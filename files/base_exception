#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
//base_exception
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
#if !defined(ELC_BASE_EXCEPTION)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
//using.hpp
#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
#if !defined(ELC_LOCALE)
	#define ELC_LOCALE
	#include <locale>
	//
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
//base_defs
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#if !defined(ELC_BASE_DEFS)
	#define __builtin_is_my_dick_still_there() true
	#include <cstddef>//nullptr_t
	#include <cstdlib>//exit、size_t
	#include <cstring>//strlen & memcpy
	#include <new>//operator delete、launder
	#include <algorithm>//max、min
	#include <type_traits>//enable_if等
	#include <typeinfo>//RTTI
	#include <cmath>//sqrt
	#include <cfenv>//rounding
	#include <ctime>//time
	#include <ranges>
	#include <initializer_list>
	#if __has_include(<stdfloat>)
		#include <stdfloat>
	#endif
	#if __has_include(<intrin.h>)
		#include <intrin.h>
	#endif
	#if defined(__clang__)||defined(__GNUC__)
		#include <cxxabi.h>
	#endif
	#define ELC_BASE_DEFS
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
//_body.hpp
//at namespace ::
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
//include default_data_type：基础数据类型定义
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
//default_data_type.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
namespace elc{
	/*ELC内部string统一采用char_t宽字符，使用setlocale(LC_ALL,"en_US.utf8")下的UTF编码。*/
	typedef char32_t char_t;
	/*c_string表示*/
	typedef char_t* string_ptr_t;
	/*c_string表示*/
	typedef const char_t* const_string_ptr_t;
	/*ELC内部钦定int_t类型*/
	typedef int64_t int_t;
	/*ELC内部钦定uint_t类型*/
	typedef uint64_t uint_t;
	/*ELC内部钦定float_t类型*/
	typedef double float_t;
	/*ELC内部钦定float_size_t类型，用以描述内存大小的浮点状况*/
	typedef long double float_size_t;
}

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/BIT_POSSIBILITY.hpp"
//float_info.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/BIT_POSSIBILITY.hpp"
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_defs.hpp"
//undefs at "_undefs.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#if !defined(ELC_WARNING_LEVEL)
	#define ELC_WARNING_LEVEL 4
#endif

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_PUBLIC_ALL)
	#define protected public
	#define private public
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#define times(...) ([[maybe_unused]]auto [loop_times,loop_end_value] : ::elc::defs::times_provider_t(__VA_ARGS__)) //for times(72)do_something;
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name,...) \
exlambda(auto&&...Args)__VA_ARGS__ lambda_force_inline{\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define exlambda [&]
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#if defined(_MSC_VER) && !defined(__clang__)
	#define lambda_inline [[msvc::forceinline]]
	#define lambda_force_inline [[msvc::forceinline]]
#elif
	#define lambda_inline [[gnu::always_inline]]
	#define lambda_force_inline [[gnu::always_inline]]
#else
	#define lambda_inline
	#define lambda_force_inline
#endif

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
	#define in_debug 1
#else
	#define not_in_debug 1
	#define in_debug 0
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_defs.hpp"

// 定义一个宏来检测是否支持GCC内置函数
#if defined(__GNUC__) || defined(__clang__)
	#define HAS_GCC_BUILTINS 1
#else
	#define HAS_GCC_BUILTINS 0
#endif

// 定义一个宏来检测是否支持MSVC内置函数
#if defined(_MSC_VER) && !defined(__clang__)
	#define HAS_MSVC_INTRINSICS 1
#else
	#define HAS_MSVC_INTRINSICS 0
#endif

// 定义一个宏来检测是否支持x86汇编
#if defined(__i386__) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)
	#define HAS_X86_ASM 1
#else
	#define HAS_X86_ASM 0
#endif

// 定义一个宏来检测是否支持x86-64汇编
#if defined(__x86_64__) || defined(_M_X64)
	#define HAS_X86_64_ASM 1
#else
	#define HAS_X86_64_ASM 0
#endif

// 定义一个宏来检测是否支持ARM汇编
#if defined(__arm__) || defined(_M_ARM)
	#define HAS_ARM_ASM 1
#else
	#define HAS_ARM_ASM 0
#endif

// 定义一个宏来检测是否支持ARM64汇编
#if defined(__aarch64__)
	#define HAS_ARM64_ASM 1
#else
	#define HAS_ARM64_ASM 0
#endif

//file_end

	#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/BIT_POSSIBILITY.hpp"

	namespace basic_environment{
		/// 每个bit（不是字节）的可能性
		/// 为什么c艹委员会不定义这个？
		constexpr size_t BIT_POSSIBILITY=1<<1;
	}
	using basic_environment::BIT_POSSIBILITY;

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_undefs.hpp"
//defs at "_defs.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_PUBLIC_ALL)
	#undef protected
	#undef private
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef times
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef exlambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS
#undef lambda_inline
#undef lambda_force_inline

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_undefs.hpp"

#undef HAS_GCC_BUILTINS
#undef HAS_MSVC_INTRINSICS
#undef HAS_X86_ASM
#undef HAS_X86_64_ASM
#undef HAS_ARM_ASM
#undef HAS_ARM64_ASM

//file_end

	#line 40 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/BIT_POSSIBILITY.hpp"
}

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
namespace elc::defs{ //在elc::defs中定义内容
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_PUBLIC_ALL)
	#define protected public
	#define private public
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#define times(...) ([[maybe_unused]]auto [loop_times,loop_end_value] : ::elc::defs::times_provider_t(__VA_ARGS__)) //for times(72)do_something;
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name,...) \
exlambda(auto&&...Args)__VA_ARGS__ lambda_force_inline{\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define exlambda [&]
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#if defined(_MSC_VER) && !defined(__clang__)
	#define lambda_inline [[msvc::forceinline]]
	#define lambda_force_inline [[msvc::forceinline]]
#elif
	#define lambda_inline [[gnu::always_inline]]
	#define lambda_force_inline [[gnu::always_inline]]
#else
	#define lambda_inline
	#define lambda_force_inline
#endif

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
	#define in_debug 1
#else
	#define not_in_debug 1
	#define in_debug 0
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"

	namespace base{}
	using namespace base;//导出内容：defs内的名称空间只起到大体名称分组的作用，不进行名称阻拦

	//内存泄露检测
	#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	namespace memory{
		inline void check_memory_lack()noexcept;
		inline struct distinctive memory_lack_checker_t{
			~memory_lack_checker_t(){
				check_memory_lack();
			}
		}memory_lack_checker{};
	}
	#endif

	namespace base{
		//恭喜你找到elc内大部分语法糖所在地
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/template_helper.hpp"
//template_helper.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/template_helper.hpp"
/*!
宏辅助,用以补全元编程错误宏template_error的内容.
*/
template<class T>
constexpr bool template_error_helper=1000-7==114514;//w.
/*!
宏辅助,用以补全元编程错误宏template_warning的内容.
*/
template<class T,class U>
[[deprecated("this was a template warning."),nodiscard]]
inline auto template_warning_helper(U&&a)noexcept{return 0;}

//file_end

		#line 54 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/using_std.hpp"
//using_std.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/using_std.hpp"
//从std中导入一些名称.
//这不比博人传燃?
using ::std::byte;
using ::std::size_t;

using ::std::forward;
using ::std::addressof;
using ::std::swap;
#line 52 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/using_std.hpp"
template<class T>
using remove_cvref= ::std::remove_cvref_t<T>;
template<class T>
using remove_cv= ::std::remove_cv_t<T>;
template<class T>
using remove_ref= ::std::remove_reference_t<T>;
template<bool B,class T,class F>
using conditional= ::std::conditional_t<B,T,F>;
template<class T,class U>
constexpr bool is_base_of= ::std::is_convertible_v<remove_cvref<U>*,remove_cvref<T>*>;
//
using ::std::partial_ordering;
using ::std::weak_ordering;
using ::std::strong_ordering;

//file_end

		#line 55 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/concept.hpp"
//concept.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/concept.hpp"
//template<typename T,template<typename>constexpr bool name>
//concept as_concept=name<T>;

//file_end

		#line 56 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/magic_number.hpp"
//magic_number.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/magic_number.hpp"
namespace magic_number{
	/*! 黄金分割比
		数理逻辑不应通过强奸感性来定义审美.
		我们应当遵从物体的自身结构,辅助线仅能在这基础上起到梳理作用,并不能以此作为创作起点来表达情感,它仅存于外部世界,无法到达内心.
		黄金分割并不万能.
	*/
	constexpr auto gold=0.61803398874989484820458683436563811772030917980576286213544862270526046281890244970720720418939113748475408807538689175212663386222353693179318006076672635443338908659593958290563832266131992829026788067520876689250171169620703222104321626954862629631361443814975870122034080588795445474924618569536486444924104432077134494704956584678850987433944221254487706647809158846074998871240076521705751797883416625624940758906970400028121042762177111777805315317141011704666599146697987317613560067087480710131795236894275219484353056783002287856997829778347845878228911097625003026961561700250464338243776486102838312683303724292675263116533924731671112115881863851331620384005222165791286675294654906811317159934323597349498509040947621322298101726107059611645629909816290555208524790352406020172799747175342777592778625619432082750513121815628551222480939471234145170223735805772786160086883829523045926478780178899219902707769038953219681986151437803149974110692608867429622675756052317277752035361393621076738937645560606059216589466759551900400555908950229530942312482355212212415444006470340565734797663972394949946584578873039623090375033993856210242369025138680414577995698122445747178034173126453220416397232134044449487302315417676893752103068737880344170093954409627955898678723209512426893557309704509595684401755519881921802064052905518934947592600734852282101088194644544222318891319294689622002301443770269923007803085261180754519288770502109684249362713592518760777884665836150238913493333122310533923213624319263728910670503399282265263556209029798642472759772565508615487543574826471814145127000602389016207773224499435308899909501680328112194320481964387675863314798571911397815397807476150772211750826945863932045652098969855567814106968372884058746103378105444390943683583581381131168993855576975484149144534150912954070050194775486163075422641729394680367319805861833918328599130396072014455950449779212076124785645916160837059498786006970189409886400764436170933417270919143365013715;//精度2000(然而只是double而已.)

	/*! 每次扩容后的空间与原空间为这样的比值可以最小化时空负担
		是的,以一种较为艺术的比值.
	*/
	constexpr auto gold_of_resize=gold+1;//精度2000——大概

	/*! 圆周率. */
	constexpr auto pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317675238467481846766940513200056812714526356082778577134275778960917363717872146844090122495343014654958537105079227968925892354201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859502445945534690830264252230825334468503526193118817101000313783875288658753320838142061717766914730359825349042875546873115956286388235378759375195778185778053217122680661300192787661119590921642019893809525720106548586327886593615338182796823030195203530185296899577362259941389124972177528347913151557485724245415069595082953311686172785588907509838175463746493931925506040092770167113900984882401285836160356370766010471018194295559619894676783744944825537977472684710404753464620804668425906949129331367702898915210475216205696602405803815019351125338243003558764024749647326391419927260426992279678235478163600934172164121992458631503028618297455570674983850549458858692699569092721079750930295532116534498720275596023648066549911988183479775356636980742654252786255181841757467289097777279380008164706001614524919217321721477235014144197356854816136115735255213347574184946843852332390739414333454776241686251898356948556209921922218427255025425688767179049460165346680498862723279178608578438382796797668145410095388378636095068006422512520511739298489608412848862694560424196528502221066118630674427862203919494504712371378696095636437191728746776465757396241389086583264599581339047802759009;//精度2000

	/*! 自然对数的底数. */
	constexpr auto e =	2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642742746639193200305992181741359662904357290033429526059563073813232862794349076323382988075319525101901157383418793070215408914993488416750924476146066808226480016847741185374234544243710753907774499206955170276183860626133138458300075204493382656029760673711320070932870912744374704723069697720931014169283681902551510865746377211125238978442505695369677078544996996794686445490598793163688923009879312773617821542499922957635148220826989519366803318252886939849646510582093923982948879332036250944311730123819706841614039701983767932068328237646480429531180232878250981945581530175671736133206981125099618188159304169035159888851934580727386673858942287922849989208680582574927961048419844436346324496848756023362482704197862320900216099023530436994184914631409343173814364054625315209618369088870701676839642437814059271456354906130310720851038375051011574770417189861068739696552126715468895703503540212340784981933432106817012100562788023519303322474501585390473041995777709350366041699732972508868769664035557071622684471625607988265178713419512466520198918006308407507245458379639351364421067750539471789004518357551541252235905906872648786357525419112888773717663748602766063496035367947026923229718683277173932361920077745221262475186983349515101986426988784717193966497690708252174233656627259284406204302141137199227852699846988477023238238400556555178890876613601304770984386116870523105531491625172837327286760072481729876375698163354150746088386636406934704372066886512756882661497307886570156850169186474885416791545965072342877306998537139043002665307839877638503238182155355973235306860430106757608389086270498418885951380910304235957824951439885901131858358406674723702971497850841458530857813391562707603563907639473114554958322669457024941398316343323789759556808568362972538679132750555425244919435891284050452269538121791319145135009938463117740179715122837854601160359554028644059;//精度2000

	constexpr auto god=72;/// 神已死,神万岁.
}

//file_end

		#line 57 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/other.hpp"
//other.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/other.hpp"
class empty_type{};

template<typename T,typename U>
inline auto&assign(T&&a,U&&b)noexcept_as(a=b){//为绕过条件内赋值时の警告而使用
	a=b;
	return a;
}

//fucking nodiscard.
constexpr struct discard_t{
	template<typename T>
	force_inline constexpr void operator=(T&&)const noexcept{}
	template<typename T>
	force_inline constexpr void operator()(T&&)const noexcept{}
}discard{};

template<typename T>
distinctive inline T const_default_value_of{};//?

enable_adl(the_destroy);
template<typename T>
static void destroy(T*a)noexcept{
	if constexpr(was_not_an_ill_form(the_destroy(a)))
		the_destroy(a);
	else
		template_error("Please overload the function the_destroy in the namespace where this type is defined.");
}

constexpr struct do_nothing_t{
	template<class...Args>
	void operator()(Args&&...)noexcept{}
	constexpr bool operator==(const do_nothing_t&)noexcept{return true;}
	template<typename T>
	constexpr bool operator==(T&)noexcept{return false;}
}do_nothing;

template<typename T>
struct times_provider_t{
	typedef times_provider_t<T> this_t;
	T loop_times=0u;
	T loop_end_value;
	struct iterator_t{
		this_t* _m;
		constexpr iterator_t& operator++()noexcept{
			++_m->loop_times;
			return*this;
		}
		constexpr this_t& operator*()noexcept{
			return*_m;
		}
		constexpr bool operator==(auto)noexcept{
			return _m->loop_times==_m->loop_end_value;
		}
	};
	constexpr iterator_t begin(){
		return {this};
	}
	constexpr auto end(){return 0;}
	constexpr times_provider_t(const T&v)noexcept:loop_end_value(v){}
};

//file_end

		#line 59 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/cast.hpp"
//cast.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/cast.hpp"
push_and_disable_msvc_warning(
	26491//down_cast警告diss
	26466//down_cast警告diss
	26492//const_cast警告diss
);
/// 对值追加const
template<typename T>
force_inline constexpr const T add_const(T a)noexcept{return a;}
/// 对引用追加const
template<typename T>
force_inline constexpr const T&add_const(T&a)noexcept{return a;}
/// 对引用移除const
template<typename T>
force_inline constexpr T&remove_const(const T&a)noexcept{return const_cast<T&>(a);}
/// 对指针追加const
template<typename T>
force_inline constexpr const T*add_const(T*a)noexcept{return a;}
/// 对指针移除const
template<typename T>
force_inline constexpr T*remove_const(const T*a)noexcept{return const_cast<T*>(a);}
/// 对指针移除const
template<typename T>
force_inline constexpr T*launder_remove_const(const T*a)noexcept{return ::std::launder(remove_const(a));}
/// 向下转型至
template<typename T,typename U>
force_inline constexpr T down_cast(U a)noexcept{return static_cast<T>(a);}
pop_msvc_warning();

//file_end

		#line 61 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/special_flags.hpp"
//special_flag.hpp
//at namespace elc::defs::base
#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/special_flags.hpp"
/// 快捷定义特殊类型的constexpr
#define defspecflag(name) \
constexpr struct name##_t{} name{}

/// 引用计数从不为0的构造
defspecflag(never_ref_num_zero);
/// 特殊构造
defspecflag(special_init);
/// 预分配内存
defspecflag(pre_alloc);

#undef defspecflag

//file_end

		#line 62 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/non_Xable.hpp"
//non_Xable.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/non_Xable.hpp"
/// 禁止复制赋值
struct non_copy_assign_able{
	constexpr non_copy_assign_able()noexcept=default;
	constexpr non_copy_assign_able(const non_copy_assign_able&)noexcept=default;
	constexpr non_copy_assign_able(non_copy_assign_able&&)noexcept=default;
	constexpr non_copy_assign_able& operator=(const non_copy_assign_able&)&noexcept=delete;
	constexpr non_copy_assign_able& operator=(non_copy_assign_able&&)&noexcept=default;
};
/// 禁止移动赋值
struct non_move_assign_able{
	constexpr non_move_assign_able()noexcept=default;
	constexpr non_move_assign_able(const non_move_assign_able&)noexcept=default;
	constexpr non_move_assign_able(non_move_assign_able&&)noexcept=default;
	constexpr non_move_assign_able& operator=(const non_move_assign_able&)&noexcept=default;
	constexpr non_move_assign_able& operator=(non_move_assign_able&&)&noexcept=delete;
};

/// 禁止默认合成的赋值
struct non_default_assign_able:non_copy_assign_able,non_move_assign_able{};


/// 禁止复制构造
struct non_copy_construct_able{
	constexpr non_copy_construct_able()=default;
	constexpr non_copy_construct_able(const non_copy_construct_able&)=delete;
	constexpr non_copy_construct_able(non_copy_construct_able&&)=default;
	constexpr non_copy_construct_able& operator=(const non_copy_construct_able&)&noexcept=default;
	constexpr non_copy_construct_able& operator=(non_copy_construct_able&&)&noexcept=default;
};
/// 禁止移动构造
struct non_move_construct_able{
	constexpr non_move_construct_able()=default;
	constexpr non_move_construct_able(const non_move_construct_able&)=default;
	constexpr non_move_construct_able(non_move_construct_able&&)=delete;
	constexpr non_move_construct_able& operator=(const non_move_construct_able&)&noexcept=default;
	constexpr non_move_construct_able& operator=(non_move_construct_able&&)&noexcept=default;
};

/// 禁止默认合成的构造
struct non_default_construct_able:non_copy_construct_able,non_move_construct_able{
	constexpr non_default_construct_able()=delete;
};

/// 禁止默认合成的复制
struct non_copyable:non_copy_assign_able,non_copy_construct_able{};
/// 禁止默认合成的移动
struct non_moveable:non_move_assign_able,non_move_construct_able{};

//file_end

		#line 63 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/attribute.hpp"
//attribute.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/attribute.hpp"
template<class T,typename attribute_name>
struct attribute{
protected:
	template<class U,special_attribute_t another_attribute_name>
	friend U*get_handle(attribute<U,another_attribute_name>*)noexcept;
	force_inline constexpr T*get_handle()noexcept{return down_cast<T*>(down_cast<attribute_name*>(this));}

	template<class U,special_attribute_t another_attribute_name>
	friend const U*get_handle(const attribute<U,another_attribute_name>*)noexcept;
	force_inline constexpr const T*get_handle()const noexcept{return down_cast<const T*>(down_cast<const attribute_name*>(this));}
};
template<class T,special_attribute_t attribute_name>
force_inline T*get_handle(attribute<T,attribute_name>*a)noexcept{return a->get_handle();}
template<class T,special_attribute_t attribute_name>
force_inline const T*get_handle(const attribute<T,attribute_name>*a)noexcept{return a->get_handle();}

template<class T,common_attribute_t attribute_name>
force_inline T* get_handle(attribute<T,attribute_name<T>>*a)noexcept{return get_handle<T,attribute_name<T>>(a);}
template<class T,common_attribute_t attribute_name>
force_inline const T* get_handle(const attribute<T,attribute_name<T>>*a)noexcept{return get_handle<T,attribute_name<T>>(a);}

template<special_attribute_t attribute_name,class T>
force_inline auto attribute_ptr_cast(T*ptr)noexcept{
	return static_cast<attribute_name*>(ptr);
}
template<special_attribute_t attribute_name,class T>
force_inline auto attribute_ptr_cast(const T* ptr)noexcept{
	return static_cast<const attribute_name*>(ptr);
}
template<common_attribute_t attribute_name,class T>
force_inline auto attribute_ptr_cast(T*ptr)noexcept{
	return attribute_ptr_cast<attribute_name<remove_cvref<T>>>(ptr);
}

template<special_attribute_t attribute_name,class T>
force_inline auto& attribute_cast(T&t)noexcept{
	return*attribute_ptr_cast<attribute_name>(&t);
}
template<common_attribute_t attribute_name,class T>
force_inline auto& attribute_cast(T&t)noexcept{
	return*attribute_ptr_cast<attribute_name>(&t);
}

template<special_attribute_t... attribute_names>
struct special_attribute_pack:virtual attribute_names...{
	/*兼容用*/
	template<class T>
	struct on_type:special_attribute_pack<attribute_names>...{};
};
template<common_attribute_t... attribute_names>
struct common_attribute_pack{
	template<class T>
	struct on_type:attribute_names<T>...{};
};

//file_end

		#line 64 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/special_attribute.hpp"
//special_attribute.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/special_attribute.hpp"
def_common_attribute_with_nothing(never_in_array);
def_special_attribute_with_nothing(build_by_get_only);

//file_end

		#line 65 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/type_info.hpp"
//type_info.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/type_info.hpp"
struct type_name_t;/// 自动重整类型名并在析构时释放重整结果，对于gcc和clang的傻逼实现
struct base_type_info_t{
private:
	struct type_id_t{
		const ::std::type_info* _m;

		constexpr type_id_t(const ::std::type_info&a)noexcept:_m(&a){}
		constexpr type_id_t(const type_id_t&a)noexcept=default;
		[[nodiscard]]type_name_t get_name()const noexcept;//定义于type_name.hpp
		[[nodiscard]]size_t get_hash()const noexcept{
			return _m->hash_code();
		}
		[[nodiscard]]bool operator==(const type_id_t&a)const noexcept{return *_m==*a._m;}
	};

	type_id_t _tid;
public:
	constexpr base_type_info_t(const ::std::type_info&a)noexcept:_tid(a){}
	constexpr base_type_info_t(const base_type_info_t&)noexcept=default;
	[[nodiscard]]type_name_t get_name()const noexcept;//定义于type_name.hpp
	[[nodiscard]]size_t get_hash()const noexcept{
		return _tid.get_hash();
	}
	[[nodiscard]]bool operator==(const base_type_info_t&a)const noexcept{return _tid==a._tid;}
	[[nodiscard]]bool operator==(const ::std::type_info&a)const noexcept{return _tid==type_id_t(a);}
};
template<class T>
struct type_info_t{
	typedef T type;

	template<class U>
	static constexpr bool same_as=::std::is_same_v<T,U>;
	template<class U>
	static constexpr bool not_same_as=!same_as<U>;
	template<class U>
	static constexpr bool base_on=::std::is_convertible_v<remove_cvref<T>*,remove_cvref<U>*>;
	template<class U>
	static constexpr bool not_base_on=!base_on<U>;

	template<class U>
	static constexpr bool can_convert_to=::std::is_convertible_v<T,U>;
	template<class U>
	static constexpr bool can_t_convert_to=!can_convert_to<U>;
	template<class U>
	static constexpr bool can_nothrow_convert_to=::std::is_nothrow_convertible_v<T,U>;
	template<class U>
	static constexpr bool can_t_nothrow_convert_to=!can_nothrow_convert_to<U>;

	#line 86 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/type_info.hpp"
	template<special_attribute_t attribute_name>
	static constexpr bool has_attribute_helper(){
		return base_on<attribute_name>;
	}
	template<common_attribute_t attribute_name>
	static constexpr bool has_attribute_helper(){
		return has_attribute_helper<attribute_name<remove_cvref<T>>>();
	}
	template<special_attribute_t attribute_name>
	static constexpr bool not_has_has_attribute_helper(){
		return!has_attribute_helper<attribute_name>();
	}
	template<common_attribute_t attribute_name>
	static constexpr bool not_has_has_attribute_helper(){
		return!has_attribute_helper<attribute_name>();
	}

	// defed at defs.
	// #define has_attribute(...) has_attribute_helper<__VA_ARGS__>()
	// #define not_has_attribute(...) not_has_has_attribute_helper<__VA_ARGS__>()

	template<common_attribute_t... common_attribute_names>
	struct with_common_attribute:common_attribute_pack<common_attribute_names...>::template_name on_type<T>{
		template<special_attribute_t... special_attribute_names>
		struct and_special_attribute:
			common_attribute_pack<common_attribute_names...>::template_name on_type<T>,
			special_attribute_pack<special_attribute_names...>::template_name on_type<T>
			{};
	};
	template<special_attribute_t... special_attribute_names>
	struct with_special_attribute:special_attribute_pack<special_attribute_names...>::template_name on_type<T>{
		template<common_attribute_t... common_attribute_names>
		struct and_common_attribute:
			special_attribute_pack<special_attribute_names...>::template_name on_type<T>,
			common_attribute_pack<common_attribute_names...>::template_name on_type<T>
			{};
	};

	constexpr type_info_t()noexcept{}
	constexpr type_info_t(const type_info_t&)noexcept=default;
	[[nodiscard]]constexpr operator base_type_info_t()const noexcept{return base_type_info_t(typeid(T));}
	[[nodiscard]]constexpr bool operator==(const ::std::type_info&a)const noexcept{return base_type_info_t(*this)==base_type_info_t(a);}
	[[nodiscard]]type_name_t get_name()const noexcept;//定义于type_name.hpp
	[[nodiscard]]size_t get_hash()const noexcept{
		return base_type_info_t(*this).get_hash();
	}
};

template<class T>
constexpr type_info_t<T>type_info{};

template<class T>
[[nodiscard]]constexpr bool operator==(const type_info_t<T>&,const type_info_t<T>&){return true;}
template<class T,class U>
[[nodiscard]]constexpr bool operator==(const type_info_t<T>&,const type_info_t<U>&){return false;}

#line 157 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/type_info.hpp"
//file_end

		#line 66 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/arithmetic_type_info_prover_decl.hpp"
//arithmetic_type_info_prover_decl.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/arithmetic_type_info_prover_decl.hpp"
namespace math{
	/// 算术类型帮助类型
	/// 任何后续定义的新算术类型都可以重载这些类型来实现数学库的泛型支持
	template<typename T>
	struct arithmetic_type_info_prover;
	
	/*! 无符号位的对应类型 */
	template<typename T>
	using to_unsigned_t = typename arithmetic_type_info_prover<remove_cvref<T>>::unsigned_type;
	/*! 有符号位的对应类型 */
	template<typename T>
	using to_signed_t = typename arithmetic_type_info_prover<remove_cvref<T>>::signed_type;
	/*! 对应的浮点数类型 */
	template<typename T>
	using float_type_of = typename arithmetic_type_info_prover<remove_cvref<T>>::float_type;

	/// 概念名称空间
	/// 基于标准库的概念，但是使用帮助类型来便于后续定义中的新算数类型重载
	inline namespace concepts{
		/// 算术类型概念
		template<typename T>
		concept arithmetic_type=arithmetic_type_info_prover<remove_cvref<T>>::is_arithmetic_type;
		template<typename T>
		concept is_arithmetic_type=arithmetic_type<T>;

		/// 基础类型概念
		template<typename T>
		concept basic_type=arithmetic_type<T> && arithmetic_type_info_prover<remove_cvref<T>>::is_basic_type;
		template<typename T>
		concept is_basic_type=basic_type<T>;

		/// 大数类型概念
		template<typename T>
		concept big_type=arithmetic_type<T> && arithmetic_type_info_prover<remove_cvref<T>>::is_big_type;
		template<typename T>
		concept is_big_type=big_type<T>;

		/// 浮点类型概念
		template<typename T>
		concept float_type=arithmetic_type<T> && arithmetic_type_info_prover<remove_cvref<T>>::is_float_type;
		template<typename T>
		concept is_float_type=float_type<T>;

		//浮点数类型：指数记录法
		template<typename T>
		concept exponent_float_type=is_float_type<T> && arithmetic_type_info_prover<remove_cvref<T>>::is_exponent_float_type;
		template<typename T>
		concept is_exponent_float_type=exponent_float_type<T>;

		//浮点数类型：分数记录法
		template<typename T>
		concept fraction_float_type=is_float_type<T> && arithmetic_type_info_prover<remove_cvref<T>>::is_fraction_float_type;
		template<typename T>
		concept is_fraction_float_type=fraction_float_type<T>;

		/// 基础浮点数类型概念
		template<typename T>
		concept basic_float_type=float_type<T> && basic_type<T>;
		template<typename T>
		concept is_basic_float_type=basic_float_type<T>;

		/// 整数类型概念
		template<typename T>
		concept integer_type=arithmetic_type<T> && arithmetic_type_info_prover<remove_cvref<T>>::is_integer_type;
		template<typename T>
		concept is_integer_type=integer_type<T>;

		/// 基础整数类型概念
		template<typename T>
		concept basic_integer_type=integer_type<T> && basic_type<T>;
		template<typename T>
		concept is_basic_integer_type=basic_integer_type<T>;

		/// 有符号类型概念
		template<typename T>
		concept signed_type=arithmetic_type<T> && arithmetic_type_info_prover<remove_cvref<T>>::is_signed;
		template<typename T>
		concept is_signed=signed_type<T>;

		/// 无符号类型概念
		template<typename T>
		concept unsigned_type=arithmetic_type<T> && !is_signed<T>;
		template<typename T>
		concept is_unsigned=unsigned_type<T>;

		/// 有符号整数类型概念
		template<typename T>
		concept signed_integer_type=integer_type<T> && is_signed<T>;
		template<typename T>
		concept is_signed_integer_type=signed_integer_type<T>;

		/// 无符号整数类型概念
		template<typename T>
		concept unsigned_integer_type=integer_type<T> && is_unsigned<T>;
		template<typename T>
		concept is_unsigned_integer_type=unsigned_integer_type<T>;

		/// 无符号浮点数类型概念
		template<typename T>
		concept unsigned_float_type=float_type<T> && is_unsigned<T>;
		template<typename T>
		concept is_unsigned_float_type=unsigned_float_type<T>;

		/// 有符号浮点数类型概念
		template<typename T>
		concept signed_float_type=float_type<T> && is_signed<T>;
		template<typename T>
		concept is_signed_float_type=signed_float_type<T>;

		/// 有符号基础整数类型概念
		template<typename T>
		concept signed_basic_integer_type=basic_integer_type<T> && is_signed<T>;
		template<typename T>
		concept is_signed_basic_integer_type=signed_basic_integer_type<T>;

		/// 无符号基础整数类型概念
		template<typename T>
		concept unsigned_basic_integer_type=basic_integer_type<T> && is_unsigned<T>;
		template<typename T>
		concept is_unsigned_basic_integer_type=unsigned_basic_integer_type<T>;

		/// 有符号基础浮点数类型概念
		template<typename T>
		concept signed_basic_float_type=basic_float_type<T> && is_signed<T>;
		template<typename T>
		concept is_signed_basic_float_type=signed_basic_float_type<T>;

		/// 无符号基础浮点数类型概念
		template<typename T>
		concept unsigned_basic_float_type=basic_float_type<T> && is_unsigned<T>;
		template<typename T>
		concept is_unsigned_basic_float_type=unsigned_basic_float_type<T>;

		/// 大整数类型概念
		template<typename T>
		concept big_integer_type=integer_type<T> && big_type<T>;
		template<typename T>
		concept is_big_integer_type=big_integer_type<T>;

		/// 大浮点数类型概念
		template<typename T>
		concept big_float_type=float_type<T> && big_type<T>;
		template<typename T>
		concept is_big_float_type=big_float_type<T>;

		/// 无符号大整数类型概念
		template<typename T>
		concept unsigned_big_integer_type=big_integer_type<T> && is_unsigned<T>;
		template<typename T>
		concept is_unsigned_big_integer_type=unsigned_big_integer_type<T>;

		/// 有符号大整数类型概念
		template<typename T>
		concept signed_big_integer_type=big_integer_type<T> && is_signed<T>;
		template<typename T>
		concept is_signed_big_integer_type=signed_big_integer_type<T>;

		/// 无符号大浮点数类型概念
		template<typename T>
		concept unsigned_big_float_type=big_float_type<T> && is_unsigned<T>;
		template<typename T>
		concept is_unsigned_big_float_type=unsigned_big_float_type<T>;

		/// 有符号大浮点数类型概念
		template<typename T>
		concept signed_big_float_type=big_float_type<T> && is_signed<T>;
		template<typename T>
		concept is_signed_big_float_type=signed_big_float_type<T>;

		/// 有NaN的类型概念
		template<typename T>
		concept has_NaN=arithmetic_type_info_prover<remove_cvref<T>>::has_NaN;

		/// 有inf的类型概念
		template<typename T>
		concept has_inf=arithmetic_type_info_prover<remove_cvref<T>>::has_inf;

		/// 有min的类型概念
		template<typename T>
		concept has_min=arithmetic_type_info_prover<remove_cvref<T>>::has_min;

		/// 有max的类型概念
		template<typename T>
		concept has_max=arithmetic_type_info_prover<remove_cvref<T>>::has_max;

		/// 有min和max的类型概念
		template<typename T>
		concept has_min_max=has_min<T> && has_max<T>;

		/// 有epsilon的类型概念
		template<typename T>
		concept has_epsilon=arithmetic_type_info_prover<remove_cvref<T>>::has_epsilon;
	}
}
using math::to_unsigned_t;
using math::to_signed_t;
using math::float_type_of;
using namespace math::concepts;

//file_end

		#line 67 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/compare.hpp"
//compare.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/compare.hpp"
//end_by_zero_t
/*!
用于标志某一数据串以0结尾
*/
inline constexpr struct end_by_zero_t{}end_by_zero;
//just_an_part_t
/*!
用于标志某一数据串并没有完结
*/
inline constexpr struct just_an_part_t{}just_an_part;
//equal：值相等.
/*!
	相等比较任意支持比较的类型或其数组——简易封装.
	用法:
	判断两值是否可比较。
	equal.able<类型1,类型2（可选，默认为类型1）>		->	bool
	判断将两者进行比较时是否会抛出异常。
	equal.nothrow<类型,类型2（可选，默认为类型1）>		->	bool

	equal(T1,T2)										->	auto

	equal(T1[N1],T2[N2])								->	bool
	equal(T1*,size1,T2*,size2)							->	bool
	equal(T1*,T2*,size)									->	bool
	equal(T1*,size1,T2*,end_by_zero)					->	bool
	equal(T1*,end_by_zero,T2*,size)						->	bool
	equal(T1*,end_by_zero,T2*,end_by_zero)				->	bool
*/
constexpr struct equal_t{
	template<class T,class U=T>
	static constexpr bool able= was_not_an_ill_form(declvalue(T)==declvalue(U));
	template<class T,class U=T>
	static constexpr bool nothrow= was_not_an_ill_form_and_noexcept(declvalue(T)==declvalue(U));

	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T&&a,U&&b)const noexcept(nothrow<T,U>){
		return a==b;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,U*b,size_t size)const noexcept(nothrow<T,U>){
		while(size--){
			if(*(a++)!=*(b++))
				return false;
		}
		return true;
	}
	template<typename T,typename U,size_t N1,size_t N2>
	[[nodiscard]]constexpr bool operator()(T(&a)[N1],U(&b)[N2])const noexcept(nothrow<T,U>){
		if constexpr(N1==N2)
			return operator()(a,b,N1);
		else{
			template_warning("N1!=N2");
			return false;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,size_t size1,U*b,size_t size2)const noexcept(nothrow<T,U>){
		if(size1==size2)
			return operator()(a,b,size1);
		else
			return false;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,size_t size1,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		while(size1--){
			if(*a!=*b || *b==U{0})
				return false;
			a++;
			b++;
		}
		return *b==U{0};
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,end_by_zero_t,U*b,size_t size2)const noexcept(nothrow<T,U>){
		return operator()(b,size2,a,end_by_zero);
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,end_by_zero_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		floop{
			if(*a!=*b)
				return false;
			if(*a==T{0})
				return true;
			a++;
			b++;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,size_t size1,just_an_part_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		while(size1--){
			if(*a!=*b || *b==U{0})
				return false;
			a++;
			b++;
		}
		return true;
	}
}equal{};

//eq：同一对象
template<typename T>
[[nodiscard]]constexpr auto is_eq(T&&a,T&&b)noexcept_as(&a==&b){
	return &a==&b;
}
template<typename T>
[[nodiscard]]constexpr auto is_not_eq(T&&a,T&&b)noexcept_as(!is_eq(a,b)){
	return!is_eq(a,b);
}

//compare：三路比较
/*!
	若大小相同则以字典序三路比较任意支持比较的类型或其数组,并在 <=> 不可用时以 < 和 == 为后备.
	用法:
	判断两者是否可真的进行三路比较。
	compare.r_able<类型1,类型2(可选，默认与1相同)>				->	bool
	判断两者是否可进行compare操作。
	compare.able<类型1,类型2(可选，默认与1相同)>				->	bool
	判断将两者进行三路比较是否会抛出异常。
	compare.nothrow<类型1,类型2（可选，默认与1相同）>			->	bool

	compare(T1,T2)
	compare(T1[N1],T2[N2])
	compare(T1*,size1,T2*,size2)
	compare(T1*,T2*,size)
	返回类型语义上是三路比较的结果类型,具体类型视情况而定.

	以字典序进行三路比较。
	compare.lexicographical(T1,T2)
	compare.lexicographical(T1[N1],T2[N2])
	compare.lexicographical(T1*,size1,T2*,size2)
	compare.lexicographical(T1*,T2*,size)
	返回类型语义上是三路比较的结果类型,具体类型视情况而定.

	翻转三路比较的结果类型。
	compare.reverse(order)
	返回对应结果类型的反义，与零相等或无法比较时则返回其本身。
*/
constexpr struct compare_t{
private:
	template<class T,class U=T>
	static constexpr bool r_able= was_not_an_ill_form(declvalue(T)<=>declvalue(U));
public:
	template<class T,class U=T>
	static constexpr bool able= r_able<T,U> ||
								was_not_an_ill_form(
														declvalue(T)==declvalue(U),
														declvalue(T)<declvalue(U),
														declvalue(U)<declvalue(T)
													);
	template<class T,class U=T>
	static constexpr bool nothrow= was_not_an_ill_form_and_noexcept(declvalue(T)<=>declvalue(U)) ||
								   was_not_an_ill_form_and_noexcept(
														declvalue(T)==declvalue(U),
														declvalue(T)<declvalue(U),
														declvalue(U)<declvalue(T)
													);

private:
	template<class T,class U>
	[[nodiscard]]static constexpr auto base_call(T&&a,U&&b)noexcept(nothrow<T,U>){
		//在 <=> 不可用时以 < 和 == 为后备，优于直接 <=>
		if constexpr(r_able<T,U>)
			return a<=>b;
		else return a == b	? partial_ordering::equivalent	:
					a < b	? partial_ordering::less		:
					b < a	? partial_ordering::greater		:
							  partial_ordering::unordered	;
	}
public:
	template<class T,class U=T>
	using type=decltype(base_call(declvalue(T),declvalue(U)));

	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T&&a,U&&b)const noexcept(nothrow<T,U>){
		return base_call(a,b);
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,U*b,size_t size)const noexcept(nothrow<T,U>){
		while(size--){
			if(auto tmp=base_call(*(a++),*(b++)); tmp!=0)
				return tmp;
		}
		return strong_ordering::equivalent;
	}
	template<typename T,typename U,size_t N1,size_t N2>
	[[nodiscard]]constexpr auto operator()(T(&a)[N1],U(&b)[N2])const noexcept(nothrow<T,U>){
		if constexpr(N1==N2)
			return operator()(a,b,N1);
		else{
			template_warning("N1!=N2");
			return N1<=>N2;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,size_t size1,U*b,size_t size2)const noexcept(nothrow<T,U>){
		type<T,U> tmp=size1<=>size2;
		if(tmp!=0)
			return tmp;
		else
			return operator()(a,b,size1);
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,size_t size1,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		type<T,U> tmp=strong_ordering::equivalent;
		while(size1--){
			if(*b==U{0})
				return strong_ordering::greater;
			if(tmp==0)
				tmp=base_call(*a,*b);
			a++;
			b++;
		}
		return *b==U{0}?tmp:strong_ordering::less;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,end_by_zero_t,U*b,size_t size2)const noexcept(nothrow<T,U>){
		type<T,U> tmp=strong_ordering::equivalent;
		while(size2--){
			if(*a==T{0})
				return strong_ordering::less;
			if(tmp==0)
				tmp=base_call(*a,*b);
			a++;
			b++;
		}
		return *b==U{0}?tmp:strong_ordering::less;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,end_by_zero_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		type<T,U> tmp=strong_ordering::equivalent;
		floop{
			if(*a==T{0})
				return *b==U{0}?tmp:strong_ordering::less;
			if(tmp==0)
				tmp=base_call(*a,*b);
			a++;
			b++;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,size_t size1,just_an_part_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		type<T,U> tmp=strong_ordering::equivalent;
		while(size1--){
			if(*b==U{0})
				return strong_ordering::greater;
			if(tmp==0)
				tmp=base_call(*a,*b);
			a++;
			b++;
		}
		return tmp;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,size_t size1,U*b,size_t size2)const noexcept(nothrow<T,U>){
		using ::std::min;//elc的min依赖compare，而compare还没有定义完全，所以这里用std的
		if(auto tmp=operator()(a,b,min(size1,size2)); tmp!=0)
			return tmp;
		else
			return size1<=>size2;
	}
	template<typename T,typename U,size_t N1,size_t N2>
	[[nodiscard]]constexpr auto lexicographical(T(&a)[N1],U(&b)[N2])const noexcept(nothrow<T,U>){
		return lexicographical(a,N1,b,N2);
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,size_t size1,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		while(size1--){
			if(*b==U{0})
				return strong_ordering::greater;
			if(auto tmp=base_call(*a,*b); tmp!=0)
				return tmp;
			a++;
			b++;
		}
		return *b==U{0}?strong_ordering::equivalent:
						strong_ordering::less;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,end_by_zero_t,U*b,size_t size2)const noexcept(nothrow<T,U>){
		while(size2--){
			if(*a==T{0})
				return strong_ordering::less;
			if(auto tmp=base_call(*a,*b); tmp!=0)
				return tmp;
			a++;
			b++;
		}
		return *b==U{0}?strong_ordering::equivalent:
						strong_ordering::less;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,end_by_zero_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		floop{
			if(*a==T{0})
				return *b==U{0}?strong_ordering::equivalent:
								strong_ordering::less;
			if(auto tmp=base_call(*a,*b); tmp!=0)
				return tmp;
			a++;
			b++;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,size_t size1,just_an_part_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		while(size1--){
			if(*b==U{0})
				return strong_ordering::greater;
			if(auto tmp=base_call(*a,*b); tmp!=0)
				return tmp;
			a++;
			b++;
		}
		return strong_ordering::equivalent;
	}
	//
	[[nodiscard]]constexpr auto reverse(partial_ordering odr)const noexcept{
		if(odr==partial_ordering::greater)
			return partial_ordering::less;
		elseif(odr==partial_ordering::less)
			return partial_ordering::greater;
		else
			return odr;
	}
	[[nodiscard]]constexpr auto reverse(weak_ordering odr)const noexcept{
		if(odr==weak_ordering::greater)
			return weak_ordering::less;
		elseif(odr==weak_ordering::less)
			return weak_ordering::greater;
		else
			return odr;
	}
	[[nodiscard]]constexpr auto reverse(strong_ordering odr)const noexcept{
		if(odr==strong_ordering::greater)
			return strong_ordering::less;
		elseif(odr==strong_ordering::less)
			return strong_ordering::greater;
		else
			return odr;
	}
}compare{};

//file_end

		#line 68 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/min_max.hpp"
//min_max.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/min_max.hpp"
/*!
获取几个参数中的最大值或某类型能表示的最大值.
用法:
	max.able<T1,T2...> -> bool T...等类型能否获得参数最大值.
	max.get_limit_able<T> -> bool 能否获得T类型能表示的最大值.
	max(v1,v2...) -> auto 获取v...的最大值.
	max(type_info<T>) -> auto 获取T能表示的最大值.
*/
constexpr struct max_t{
private:
	template<class A>
	static constexpr A type_helper()noexcept{
		return declvalue(A);
	}
	template<class A,class B>
	static constexpr auto type_helper()noexcept{
		return 1?declvalue(A):declvalue(B);
	}
	template<class A,class B,class C,class...Args>
	static constexpr auto type_helper()noexcept{
		return type_helper<A,decltype(type_helper<B,C,Args...>())>();
	}
public:
	template<class...Args>
	using type=decltype(type_helper<Args...>());
private:
	template<class A>
	static constexpr bool able_helper()noexcept{
		return true;
	}
	template<class A,class B>
	static constexpr bool able_helper()noexcept{
		return compare.able<A,B>;
	}
	template<class A,class B,class C,class...Args>
	static constexpr bool able_helper()noexcept{
		if constexpr(!able_helper<B,C,Args...>())
			return false;
		else
			return able_helper<A,type<B,C,Args...>>();
	}
public:
	template<class...Args>
	static constexpr bool able=able_helper<Args...>();
private:
	template<class A>
	static constexpr bool nothrow_helper()noexcept{
		return true;
	}
	template<class A,class B>
	static constexpr bool nothrow_helper()noexcept{
		return compare.nothrow<A,B>;
	}
	template<class A,class B,class C,class...Args>
	static constexpr bool nothrow_helper()noexcept{
		if constexpr(!nothrow_helper<B,C,Args...>())
			return false;
		else
			return nothrow_helper<A,type<B,C,Args...>>();
	}
public:
	template<class...Args>
	static constexpr bool nothrow=nothrow_helper<Args...>();

	template<typename T>
	static constexpr bool get_limit_able=math::arithmetic_type_info_prover<T>::has_max;
private:
	template<class A,class B> requires able<A,B>
	[[nodiscard]]static constexpr auto base_call(A&&a,B&&b)noexcept{
		const auto v=compare(a,b);
		return v<0?b:a;
	}
	template<class A,class B,class C,class...Args> requires able<A,B,Args...>
	[[nodiscard]]static constexpr auto base_call(A&&a,B&&b,C&&c,Args&&...rest)noexcept{
		return base_call(forward<A>(a),base_call(forward<B>(b),forward<C>(c),forward<Args>(rest)...));
	}
public:
	template<class...Args> requires able<Args...>
	[[nodiscard]]constexpr auto operator()(Args&&...rest)const noexcept{
		return base_call(forward<Args>(rest)...);
	}
	template<typename T>
	struct for_type_t{
		[[nodiscard]]constexpr auto operator()(::std::initializer_list<T>l)const noexcept requires able<const T,const T>{
			auto maxlest=l.begin();
			for(const auto&i:l){
				const auto v=compare(*maxlest,i);
				if(v<0)
					maxlest=&i;
			}
			return *maxlest;
		}
		template<class...Args>
		[[nodiscard]]constexpr auto operator()(Args&&...rest)const noexcept{
			return base_call(T(forward<Args>(rest))...);
		}
	};
	template<typename T>
	static constexpr for_type_t<T>for_type{};

	template<class T> requires able<const T,const T>
	[[nodiscard]]constexpr auto operator()(::std::initializer_list<T>l)const noexcept{
		return for_type<T>(l);
	}
	template<typename T> requires get_limit_able<T>
	[[nodiscard]]constexpr auto operator()(const type_info_t<T>&)const noexcept{
		return math::arithmetic_type_info_prover<T>::max();
	}
}max{};
/*!
获取几个参数中的最小值或某类型能表示的最小值.
用法:
	min.able<T1,T2...> -> bool T...等类型能否获得参数最小值.
	min.get_limit_able<T> -> bool 能否获得T类型能表示的最小值.
	min(v1,v2...) -> auto 获取v...的最小值.
	min(type_info<T>) -> auto 获取T能表示的最小值.
*/
constexpr struct min_t{
private:
	template<class A>
	static constexpr A type_helper()noexcept{
		return declvalue(A);
	}
	template<class A,class B>
	static constexpr auto type_helper()noexcept{
		return 1?declvalue(A):declvalue(B);
	}
	template<class A,class B,class C,class...Args>
	static constexpr auto type_helper()noexcept{
		return type_helper<A,decltype(type_helper<B,C,Args...>())>();
	}
public:
	template<class...Args>
	using type=decltype(type_helper<Args...>());
private:
	template<class A>
	static constexpr bool able_helper()noexcept{
		return true;
	}
	template<class A,class B>
	static constexpr bool able_helper()noexcept{
		return compare.able<A,B>;
	}
	template<class A,class B,class C,class...Args>
	static constexpr bool able_helper()noexcept{
		if constexpr(!able_helper<B,C,Args...>())
			return false;
		else
			return able_helper<A,type<B,C,Args...>>();
	}
public:
	template<class...Args>
	static constexpr bool able=able_helper<Args...>();
private:
	template<class A>
	static constexpr bool nothrow_helper()noexcept{
		return true;
	}
	template<class A,class B>
	static constexpr bool nothrow_helper()noexcept{
		return compare.nothrow<A,B>;
	}
	template<class A,class B,class C,class...Args>
	static constexpr bool nothrow_helper()noexcept{
		if constexpr(!nothrow_helper<B,C,Args...>())
			return false;
		else
			return nothrow_helper<A,type<B,C,Args...>>();
	}
public:
	template<class...Args>
	static constexpr bool nothrow=nothrow_helper<Args...>();

	template<typename T>
	static constexpr bool get_limit_able=math::arithmetic_type_info_prover<T>::has_min;
private:
	template<class A,class B> requires able<A,B>
	[[nodiscard]]static constexpr auto base_call(A&&a,B&&b)noexcept{
		const auto v=compare(a,b);
		return v<0?a:b;
	}
	template<class A,class B,class C,class...Args> requires able<A,B,Args...>
	[[nodiscard]]static constexpr auto base_call(A&&a,B&&b,C&&c,Args&&...rest)noexcept{
		return base_call(forward<A>(a),base_call(forward<B>(b),forward<C>(c),forward<Args>(rest)...));
	}
public:
	template<class...Args> requires able<Args...>
	[[nodiscard]]constexpr auto operator()(Args&&...rest)const noexcept{
		return base_call(forward<Args>(rest)...);
	}
	template<typename T>
	struct for_type_t{
		[[nodiscard]]constexpr auto operator()(::std::initializer_list<T>l)const noexcept requires able<const T,const T>{
			auto minlest=l.begin();
			for(const auto&i:l){
				const auto v=compare(*minlest,i);
				if(v>0)
					minlest=&i;
			}
			return *minlest;
		}
		template<class...Args>
		[[nodiscard]]constexpr auto operator()(Args&&...rest)const noexcept{
			return base_call(T(forward<Args>(rest))...);
		}
	};
	template<typename T>
	static constexpr for_type_t<T>for_type{};

	template<class T> requires able<const T,const T>
	[[nodiscard]]constexpr auto operator()(::std::initializer_list<T>l)const noexcept{
		return for_type<T>(l);
	}
	template<typename T> requires get_limit_able<T>
	[[nodiscard]]constexpr auto operator()(const type_info_t<T>&)const noexcept{
		return math::arithmetic_type_info_prover<T>::min();
	}
}min{};

//file_end

		#line 69 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/literal_support.hpp"
//literal_support.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/literal_support.hpp"
namespace literal_support{
	constexpr uint8_t hexval(char c)noexcept{
		if constexpr('a'>'A'){
			if(c>='a')
				return c+10-'a';
			elseif(c>='A')
				return c+10-'A';
		}
		else{
			if(c>='A')
				return c+10-'A';
			elseif(c>='a')
				return c+10-'a';
		}
		return c-'0';
	}
	using ::std::move;

	template<class integer_T,unsigned base>
	class integer_iterator{
		integer_T& _val;
	public:
		constexpr integer_iterator(integer_T& val)noexcept:_val(val){}
		constexpr_as_auto void operator()(char c)noexcept{
			_val*=base;
			_val+=hexval(c);
		}
	};
	template<class integer_T,unsigned base>
	class fast_integer_iterator{
		size_t _var_block=0,_scale=1;
		integer_T& _val;
	public:
		constexpr fast_integer_iterator(integer_T& val)noexcept:_val(val){}
		constexpr_as_auto void operator()(char c)noexcept{
			const size_t new_scale=_scale*base;
			if(_scale>new_scale){//溢出，建立新块
				_val=move(_val)*_scale+_var_block;
				_var_block=hexval(c);
				_scale=base;
			}
			else{
				_var_block=_var_block*base+hexval(c);
				_scale=new_scale;
			}
		}
		constexpr_as_auto ~fast_integer_iterator()noexcept{
			_val=move(_val)*_scale+_var_block;
		}
	};

	template<class integer_T,unsigned base>
	using integer_iterator_t=conditional<is_big_type<integer_T>,fast_integer_iterator<integer_T,base>,integer_iterator<integer_T,base>>;

	template<unsigned base>
	constexpr void base_checker()noexcept{
		static_assert(base==16||base==10||base==8||base==2,"base must be 16,10,8 or 2");
	}
	template<unsigned base,char c>
	constexpr void char_checker()noexcept{
		static_assert(c>='0'&&c<='9'||c>='a'&&c<='f'||c>='A'&&c<='F',"invalid char");
		static_assert(base>hexval(c),"invalid char");
	}

	template<class integer_T>
	class unsigned_integer_literal_evaler{
		template<unsigned base>
		static constexpr_as_auto void eval_impl(integer_iterator_t<integer_T,base>&)noexcept{}
		template<unsigned base,char c,char...cs>
		static constexpr_as_auto void eval_impl(integer_iterator_t<integer_T,base>&iter)noexcept{
			if constexpr(c!='\''){
				char_checker<base,c>();
				iter(c);
			}
			eval_impl<base,cs...>(iter);
		}

		template<unsigned base,char...cs>
		static constexpr_as_auto integer_T do_eval()noexcept{
			base_checker<base>();
			integer_T val{};
			{
				integer_iterator_t<integer_T,base> iter(val);
				eval_impl<base,cs...>(iter);
			}
			return move(val);
		}

		template<unsigned default_base,char...cs>
		struct eval_differ{
			static constexpr_as_auto integer_T eval()noexcept{
				return do_eval<default_base,cs...>();
			}
		};
		template<unsigned default_base,char...cs>
		struct eval_differ<default_base,'0','x',cs...>{
			static constexpr_as_auto integer_T eval()noexcept{
				return do_eval<16,cs...>();
			}
		};
		template<unsigned default_base,char...cs>
		struct eval_differ<default_base,'0','X',cs...>{
			static constexpr_as_auto integer_T eval()noexcept{
				return do_eval<16,cs...>();
			}
		};
		template<unsigned default_base,char...cs>
		struct eval_differ<default_base,'0','b',cs...>{
			static constexpr_as_auto integer_T eval()noexcept{
				return do_eval<2,cs...>();
			}
		};
		template<unsigned default_base,char...cs>
		struct eval_differ<default_base,'0','B',cs...>{
			static constexpr_as_auto integer_T eval()noexcept{
				return do_eval<2,cs...>();
			}
		};
		template<unsigned default_base,char...cs>
		struct eval_differ<default_base,'0',cs...>{
			static constexpr_as_auto integer_T eval()noexcept{
				return do_eval<8,cs...>();
			}
		};
	public:
		template<unsigned default_base,char...cs>
		static constexpr_as_auto integer_T eval_with_base()noexcept{
			return eval_differ<default_base,cs...>::eval();
		}
		template<char...cs>
		static constexpr_as_auto integer_T eval()noexcept{
			return eval_with_base<10,cs...>();
		}
	};
	template<class integer_T,class unsigned_integer_T>
	class signed_integer_literal_evaler{
		template<unsigned default_base,char...cs>
		struct eval_differ{
			static constexpr_as_auto integer_T eval()noexcept{
				return unsigned_integer_literal_evaler<unsigned_integer_T>::template eval_with_base<default_base,cs...>();
			}
		};
		template<unsigned default_base,char...cs>
		struct eval_differ<default_base,'-',cs...>{
			static constexpr_as_auto integer_T eval()noexcept{
				return -static_cast<integer_T>(unsigned_integer_literal_evaler<unsigned_integer_T>::template eval_with_base<default_base,cs...>());
			}
		};
	public:
		template<unsigned default_base,char...cs>
		static constexpr_as_auto integer_T eval_with_base()noexcept{
			return eval_differ<default_base,cs...>::eval();
		}
		template<char...cs>
		static constexpr_as_auto integer_T eval()noexcept{
			return eval_with_base<10,cs...>();
		}
	};
	template<class float_T,class base_process_T,class exp_process_integer_T,class exp_process_unsigned_integer_T>
	class unsigned_float_literal_evaler{
		template<unsigned base,char exp_char,bool pointed>
		static constexpr_as_auto void eval_impl(integer_iterator_t<base_process_T,base>&,exp_process_integer_T&)noexcept{}
		template<unsigned base,char exp_char,bool pointed,char c,char...cs>
		static constexpr_as_auto void eval_impl(integer_iterator_t<base_process_T,base>&iter,exp_process_integer_T&exp)noexcept{
			if constexpr(c=='.'){
				static_assert(!pointed,"pointed twice");
				eval_impl<base,exp_char,true,cs...>(iter,exp);
			}
			elseif constexpr(c==exp_char || c==exp_char+('A'-'a')){
				exp+=signed_integer_literal_evaler<exp_process_integer_T,exp_process_unsigned_integer_T>::template eval_with_base<base,cs...>();
				eval_impl<base,exp_char,pointed>(iter,exp);
			}
			else{
				if constexpr(c!='\''){
					if constexpr(pointed)
						--exp;
					char_checker<base,c>();
					iter(c);
				}
				eval_impl<base,exp_char,pointed,cs...>(iter,exp);
			}
		}

		template<unsigned base,char exp_char,char...cs>
		static constexpr_as_auto float_T do_eval()noexcept{
			base_checker<base>();
			base_process_T val{};exp_process_integer_T exp{};
			{
				integer_iterator_t<base_process_T,base> iter(val);
				eval_impl<base,exp_char,false,cs...>(iter,exp);
			}
			float_T aret=move(val);
			aret*=pow(base,move(exp));
			return move(aret);
		}

		template<unsigned default_base,char default_exp_char,char...cs>
		struct eval_differ{
			static constexpr_as_auto float_T eval()noexcept{
				return do_eval<default_base,default_exp_char,cs...>();
			}
		};
		template<unsigned default_base,char default_exp_char,char...cs>
		struct eval_differ<default_base,default_exp_char,'0','x',cs...>{
			static constexpr_as_auto float_T eval()noexcept{
				return do_eval<16,'p',cs...>();
			}
		};
		template<unsigned default_base,char default_exp_char,char...cs>
		struct eval_differ<default_base,default_exp_char,'0','X',cs...>{
			static constexpr_as_auto float_T eval()noexcept{
				return do_eval<16,'p',cs...>();
			}
		};
	public:
		template<unsigned default_base,char default_exp_char,char...cs>
		static constexpr_as_auto float_T eval_with_base()noexcept{
			return eval_differ<default_base,default_exp_char,cs...>::eval();
		}
		template<char...cs>
		static constexpr_as_auto float_T eval()noexcept{
			return eval_with_base<10,'e',cs...>();
		}
	};
	template<class float_T,class unsigned_float_T,class base_process_T,class exp_process_integer_T,class exp_process_unsigned_integer_T>
	class signed_float_literal_evaler{
		template<unsigned default_base,char default_exp_char,char...cs>
		struct eval_differ{
			static constexpr_as_auto float_T eval()noexcept{
				return unsigned_float_literal_evaler<unsigned_float_T,base_process_T,exp_process_integer_T,exp_process_unsigned_integer_T>::template eval_with_base<default_base,default_exp_char,cs...>();
			}
		};
		template<unsigned default_base,char default_exp_char,char...cs>
		struct eval_differ<default_base,default_exp_char,'-',cs...>{
			static constexpr_as_auto float_T eval()noexcept{
				return -static_cast<float_T>(unsigned_float_literal_evaler<unsigned_float_T,base_process_T,exp_process_integer_T,exp_process_unsigned_integer_T>::template eval_with_base<default_base,default_exp_char,cs...>());
			}
		};
	public:
		template<unsigned default_base,char default_exp_char,char...cs>
		static constexpr_as_auto float_T eval_with_base()noexcept{
			return eval_differ<default_base,default_exp_char,cs...>::eval();
		}
		template<char...cs>
		static constexpr_as_auto float_T eval()noexcept{
			return eval_with_base<10,'e',cs...>();
		}
	};
}

//file_end

		#line 70 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/math.hpp"
//math.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/math.hpp"
namespace math{
	using ::std::move;

	//isNaN
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr bool isNaN(const T&v)noexcept{
		if constexpr(has_NaN<T>)
			return v!=v;
		else
			return false;
	}
	//isInf
	template<basic_type T>
	[[nodiscard]]force_inline constexpr bool isInf(const T&v)noexcept{
		if constexpr(has_inf<T>)
			return v==arithmetic_type_info_prover<T>::Inf() || v==arithmetic_type_info_prover<T>::negative_Inf();
		else
			return false;
	}
	template<arithmetic_type T> requires(!has_inf<T>)
	[[nodiscard]]force_inline constexpr bool isInf(const T&)noexcept{
		return false;
	}
	/*! 符号位查询 */
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr bool is_negative(const T&x)noexcept{
		if constexpr(is_signed<T>){
			if constexpr(has_NaN<T>)
				if(isNaN(x))
					return false;
			return x<T{};
		}
		else
			return false;
	}
	/*! 符号位设置 */
	template<typename T=void,typename Arg_t=void>
	[[nodiscard]]force_inline constexpr auto copy_as_negative(Arg_t x,bool negative=1)noexcept{
		if constexpr(is_unsigned<T>)
			template_error("copy_as_negative:unsigned type");
		elseif constexpr(type_info<T> == type_info<void>)
			return copy_as_negative<to_signed_t<Arg_t>>(x,negative);
		elseif constexpr(is_basic_type<Arg_t>) {
			if constexpr(is_float_type<Arg_t>)
				return(T)::std::copysign(x,negative?-1:1);
			else
				return(T)negative?T{}-x:x;
		}
		else
			return(T)negative?T{}-x:x;
	}
	//copy_as_not_negative? 那不就是abs吗
	/*! 符号位反转 */
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr auto reverse_sign(const T&x)noexcept{
		return copy_as_negative(x,!is_negative(x));
	}
	/*! 任意算数类型安全转型(ub避免.). */
	template<arithmetic_type T,arithmetic_type U>
	[[nodiscard]]force_inline constexpr T safe_arithmetic_cast(U x)noexcept{
		if constexpr(basic_float_type<U> && unsigned_type<T>)
			if(is_negative(x))
				return (T)(intmax_t)x;
			else{
				push_and_disable_msvc_warning(26467);//x已非负
				return (T)(uintmax_t)x;
				pop_msvc_warning();
			}
		else
			return (T)x;
	}
	/*! 任意算数类型转size_t */
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr size_t to_size_t(T x)noexcept{
		return safe_arithmetic_cast<size_t>(x);
	}
	/*! 任意算数类型转uintmax_t */
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr uintmax_t to_uintmax_t(T x)noexcept{
		return safe_arithmetic_cast<uintmax_t>(x);
	}
	/*! 求余 */
	template<arithmetic_type T1,arithmetic_type T2>
	[[nodiscard]]force_inline constexpr auto mod(const T1&a,const T2&b){
		if constexpr(basic_float_type<T1>||basic_float_type<T2>)
			return ::std::fmod(a,b);
		else
			return a%b;
	}
	//is_odd
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr bool is_odd(const T&x)noexcept{
		if constexpr(is_integer_type<T>)
			return x&1;
		else
			return mod(x,T(2));
	}
	//is_even
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr bool is_even(const T&x)noexcept{
		return !is_odd(x);
	}
	//divmod
	template<arithmetic_type T1,arithmetic_type T2> requires(!is_big_type<T1>&&!is_big_type<T2>)
	[[nodiscard]]force_inline constexpr auto divmod(const T1&a,const T2&b){
		typedef decltype(a/b) quot_t;
		typedef decltype(a%b) mod_t;
		struct divmod_result{
			quot_t quot;
			mod_t mod;
		};
		if constexpr(basic_float_type<T1>||basic_float_type<T2>)
			return divmod_result{::std::floor(a/b),::std::fmod(a,b)};
		else
			return divmod_result{a/b,a%b};
	}
	//ceil_div
	template<arithmetic_type T,arithmetic_type U>
	[[nodiscard]]force_inline constexpr auto ceil_div(const T&a,const U&b)noexcept{
		const auto[quot,mod]=divmod(a,b);
		return quot+(mod?1u:0u);
	}

	/*! 设置浮点舍入 */
	template<typename T>
	force_inline constexpr void set_rounding(int mode){
		if constexpr(basic_float_type<T>)
			::std::fesetround(mode);
	}
	/*!获取浮点舍入 */
	template<typename T>
	[[nodiscard]]force_inline constexpr int get_rounding(){
		if constexpr(basic_float_type<T>)
			return ::std::fegetround();
		else
			return 0;
	}
	/*! 设置并自动恢复浮点舍入 */
	template<typename T>
	struct rounding_auto_setter{
		int old_rounding;
		rounding_auto_setter(int new_rounding){
			old_rounding=get_rounding<T>();
			set_rounding<T>(new_rounding);
		}
		~rounding_auto_setter(){
			set_rounding<T>(old_rounding);
		}
	};

	//abs
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr auto abs(const T&v)noexcept{
		if constexpr(is_signed<T>){
			//符号转无符号而不是num=-num避免INT_MAX这种情况下的溢出
			typedef to_unsigned_t<T> UT;
			return is_negative(v)?UT(-v):UT(v);
		}
		else
			return v;
	}
	//is_close
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr bool is_close(const T&a,const T&b)noexcept{
		if constexpr(basic_float_type<T>)
			return abs(a-b)<=arithmetic_type_info_prover<T>::epsilon();
		else
			return a==b;
	}
	//sub
	template<arithmetic_type T1,arithmetic_type T2>
	[[nodiscard]]force_inline constexpr auto sub(const T1&a,const T2&b)noexcept{
		if constexpr(is_basic_type<T1>&&is_basic_type<T2>){
			if constexpr(is_float_type<T1>||is_float_type<T2>)
				return a-b;
			else{
				using signedT = ::std::make_signed_t<::std::common_type_t<T1,T2,signed char>>;
				return static_cast<signedT>(a)-static_cast<signedT>(b);
			}
		}
		else
			return a-b;
	}
	//exp
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<float_type T>
	[[nodiscard]]force_inline constexpr T exp(const T&v)noexcept{
		if(in_consteval||!is_basic_type<T>){
			typedef decltype(lambda{
				if constexpr(is_basic_type<T>)
					return ::std::exp(T{});
				else
					return T{};
			}()) RT;
			auto exp_impl = recursive_lambda(RT x,RT sum,RT n,size_t i,RT t)noexcept -> RT{
				const auto epsilon=sum+t/n;
				if(is_close(sum,epsilon))
					return sum;
				else
					return self_recursion(x,epsilon,n*i,i+1,t*x);
			};
			auto exp_impl_caller = get_recursive_lambda_caller(exp_impl);
			return exp_impl_caller(RT{v},RT{1u},RT{1u},2,RT{v});
		}
		elseif constexpr(is_basic_type<T>)
			return ::std::exp(v);
	}
	//log
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr auto log(const T&a)noexcept{
		if(in_consteval||!is_basic_type<T>){
			typedef decltype(lambda()noexcept{
				if constexpr(is_basic_type<T>)
					return ::std::log(T{});
				else
					return T{};
			}()) RT;
			auto log_impl = recursive_lambda(const RT x,const RT y)noexcept -> RT{
				auto log_iter = lambda(RT x,RT y)noexcept{
					const auto exp_y = exp(y);
					return y + T{2u}*(x-exp_y)/(x+exp_y);
				};
				return RT(is_close(y,log_iter(x,y)) ? y : self_recursion(x,log_iter(x,y)));
			};
			auto log_impl_caller = get_recursive_lambda_caller(log_impl);
			return log_impl_caller((RT)a,RT{0u});
		}
		elseif constexpr(is_basic_type<T>)
			return ::std::log(a);
	}
	template<arithmetic_type T,arithmetic_type U>
	[[nodiscard]]force_inline constexpr auto log(const T&a,const U&b)noexcept{
		return log(a)/log(b);
	}
	//integer_log
	template<unsigned_integer_type T>
	[[nodiscard]]force_inline constexpr size_t integer_log(const T& a,const auto& b)noexcept{
		auto integer_log_impl = recursive_lambda(const T& a,T& tester,const T this_lv,const size_t num)noexcept -> size_t{
			size_t aret=0;
			{
				const auto next_lv=this_lv*this_lv;
				if(next_lv<a)
					aret=self_recursion(a,tester,next_lv,num*2);
			}
			floop
				if(auto tmp=tester*this_lv;tmp>a)return aret;
				else{
					tester=move(tmp);
					aret+=num;
				}
		};
		auto integer_log_impl_caller = get_recursive_lambda_caller(integer_log_impl,noexcept);
		T tester=1u;
		return integer_log_impl_caller(a,tester,move(b),1u);
	}

	//pow
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<arithmetic_type T,arithmetic_type U=unsigned> requires(!is_big_type<T>)
	[[nodiscard]]force_inline constexpr auto pow(const T&a,const U&b=2)noexcept{
		if(in_consteval||!is_basic_type<T>){
			typedef decltype(::std::pow(a,b)) RT;
			return RT(exp(b*log(a)));
		}
		elseif constexpr(is_basic_type<T>)
			return ::std::pow(a,b);
	}
	template<big_type T,unsigned_integer_type U=unsigned>
	[[nodiscard]]force_inline constexpr auto pow(T a,U b=2)noexcept{
		if constexpr(is_signed<T>){
			const bool isneg=is_negative(a) && is_odd(b);
			const auto abs_ret=pow(abs(a),b);
			return copy_as_negative(abs_ret,isneg);
		}
		else{
			T aret=1u;
			while(b){
				if(is_odd(b))aret*=a;
				a*=a;
				b>>=1u;
			}
			return aret;
		}
	}
	//trunc
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<float_type T> requires is_basic_type<T>
	[[nodiscard]]force_inline constexpr auto trunc(const T&v)noexcept{
		if in_consteval{
			typedef decltype(::std::trunc(v)) RT;
			return static_cast<RT>((intmax_t)v);
		}
		else
			return ::std::trunc(v);
	}
	//ceil
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<float_type T> requires is_basic_type<T>
	[[nodiscard]]force_inline constexpr auto ceil(const T&v)noexcept{
		if in_consteval{
			auto ceil_impl = lambda(T x, T y)noexcept{
				return is_close(x,y) ? y : y+T{1};
			};
			return v<0 ? -static_cast<T>(to_uintmax_t(-v)) : ceil_impl(v,static_cast<T>(to_uintmax_t(v)));
		}
		else
			return ::std::ceil(v);
	}
	//floor
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<float_type T> requires is_basic_type<T>
	[[nodiscard]]force_inline constexpr auto floor(const T&v)noexcept{
		if in_consteval{
			auto floor_impl = lambda(T x, T y)noexcept{
				return is_close(x,y) ? y : y-T{1};
			};
			return v<0 ? -static_cast<T>(to_uintmax_t(-v+T{1})) : floor_impl(v,static_cast<T>(to_uintmax_t(v)));
		}
		else
			return ::std::floor(v);
	}
	//sqrt
	template<float_type T> requires(has_epsilon<T>)
	[[nodiscard]]force_inline constexpr T sqrt(const T&v)noexcept;
	template<float_type T>
	[[nodiscard]]inline constexpr T sqrt(const T&v,const T&epsilon)noexcept{
		if constexpr(has_NaN<T> && has_inf<T>)
			if(v < 0u || v >= arithmetic_type_info_prover<T>::Inf())
				return arithmetic_type_info_prover<T>::NaN();
		T aret=exlambda()->T{
			if constexpr(BIT_POSSIBILITY==2)// evil floating point bit level hacking
				if(!in_consteval)//编译期计算不能使用union_cast，让编译器慢慢算去吧
					if constexpr(type_info<T> == type_info<float>)
						return union_cast<T>(0x5F375A86-(union_cast<const int32_t>(v)>>1));
					elseif constexpr(type_info<T> == type_info<double>)
						return union_cast<T>(0x5FE6EB50C7B537A9-(union_cast<const int64_t>(v)>>1));
					elseif constexpr(type_info<T> == type_info<long double>)
						#if defined(_MSC_VER)//msvc上long double就是double
							return union_cast<T>(0x5FE6EB50C7B537A9-(union_cast<const int64_t>(v)>>1));
						#elif defined(ELC_BASE_ENV_HAS_INT128)
							return union_cast<T>(0x5F1E45D78623ECB73CAB40BC89254389_u128-(union_cast<const int128_t>(v)>>1));
						#else
							do_nothing;//可以寄了
						#endif
					elseif constexpr(is_big_type<T>)
						return sqrt(static_cast<long double>(v));
			return v/2u;
		}();
		//newton-raphson
		floop{
			auto next_ret=(aret+v/aret)/2u;
			if(abs(next_ret-aret)<epsilon)
				return next_ret;//既然都算出来了，为什么不使用next_ret而是aret？
			else
				aret=move(next_ret);
		}
	}
	//sqrt with one parameter
	template<float_type T> requires(has_epsilon<T>)
	[[nodiscard]]force_inline constexpr T sqrt(const T&v)noexcept{
		return sqrt(v,arithmetic_type_info_prover<T>::epsilon());
	}
	template<integer_type T>
	[[nodiscard]]force_inline constexpr auto sqrt(const T&v)noexcept{
		return sqrt(static_cast<float_type_of<T>>(v));
	}
	/*! 判断某数是否是素数,无预先检查以供其他素数相关函数快速调用. */
	template<arithmetic_type T>
	[[nodiscard]]inline constexpr bool is_prime_num_no_pre_check(T a)noexcept{
		#line 405 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/math.hpp"
		T b=safe_arithmetic_cast<T>(sqrt(a));//若一个数可以分解为两因数之积,其中一个因数必定≤其开方:反指数式减少遍历范围.
		#line 417 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/math.hpp"
		for(T c=5u;c<=b;c+=6u)//遍历判断是否能被因数分解——不会有人看不懂吧?
			if((!mod(a,c))||(!mod(a,(c+2u))))
				return false;
		#line 426 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/math.hpp"
		return true;
	}
	/*! 判断某数是否是素数 */
	template<arithmetic_type T>
	[[nodiscard]]inline constexpr bool is_prime_num(T a)noexcept{
		if constexpr(is_float_type<T>)
			if(a != ceil(a))
				return false;
		auto b=abs(a);

		if(b<4)
			return true;//1和0也是prime,我不管.
		#line 448 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/math.hpp"
		if(mod(mod(b,6)-1u,4u))
			return false;
		#line 453 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/math.hpp"
		return is_prime_num_no_pre_check(b);
	}
	/// 求小于或等于某数的素数
	template<arithmetic_type T>
	[[nodiscard]]inline constexpr T get_prime_num_less_or_eq_than(T a)noexcept;
	/// 求大于或等于某数的素数
	template<arithmetic_type T>
	[[nodiscard]]inline constexpr T get_prime_num_big_or_eq_than(T a)noexcept{
		if constexpr(is_float_type<T>)
			a=ceil(a);
		if constexpr(is_signed<T>)
			if(is_negative(a)){
				auto tmp = get_prime_num_less_or_eq_than(abs(a));
				return copy_as_negative(tmp);
			}
		if(a<4u)return a;
		//将a转换为6x-1的形式.
		{
			T b=mod(a,6u);
			if(b==1u && is_prime_num_no_pre_check(a))return a;
			a+=b?5u-b:1u;
		}
		//循环判断.
		for(;;a+=6u)
			if(is_prime_num_no_pre_check(a))return a;
			elseif(is_prime_num_no_pre_check(a+2u))return a+2u;
	}
	/// 求小于或等于某数的素数
	template<arithmetic_type T>
	[[nodiscard]]inline constexpr T get_prime_num_less_or_eq_than(T a)noexcept{
		if constexpr(is_float_type<T>)
			a=floor(a);
		if constexpr(is_signed<T>)
			if(is_negative(a)){
				auto tmp = get_prime_num_big_or_eq_than(abs(a));
				return copy_as_negative(tmp);
			}
		if(a<4u)return a;
		//将a转换为6x-1的形式.
		{
			T b=mod(a,6u);
			if(b==1u && is_prime_num_no_pre_check(a))return a;
			a-=b?b-1u:5u;
		}
		//循环判断.
		for(;;a-=6u)
			if(is_prime_num_no_pre_check(a))return a;
			elseif(is_prime_num_no_pre_check(a-2u))return a-2u;
	}
	/// 求大于某数的素数
	template<arithmetic_type T>
	[[nodiscard]]inline constexpr auto get_prime_num_big_than(T a)noexcept{
		return get_prime_num_big_or_eq_than(a+1u);
	}
	push_and_disable_msvc_warning(26467);//gold_of_resize永远为正数
	/// 已知当前array的size，求下一个合适的提前分配大小
	template<unsigned_integer_type size_T>
	[[nodiscard]]inline constexpr size_T get_next_gold_size_to_resize_for_array(size_T size)noexcept{
		#line 514 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/math.hpp"
		return size_T(size*magic_number::gold_of_resize);
	}
	/// 已知当前hash table的size，求下一个合适的桶大小
	template<unsigned_integer_type size_T>
	[[nodiscard]]inline constexpr size_T get_next_gold_size_to_resize_for_hash(size_T size)noexcept{
		#line 523 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/math.hpp"
		return size_T(get_prime_num_big_or_eq_than(size*magic_number::gold_of_resize));
	}
	pop_msvc_warning();

	/// 线性插值.
	namespace linear_interpolation{
		[[nodiscard]]inline constexpr auto get_k(auto y1,auto y2,auto δx)noexcept{
			auto δy=sub(y2,y1);
			auto k=δy/δx;
			return k;
		}
		[[nodiscard]]inline constexpr auto get_k(auto y1,auto y2)noexcept{
			return get_k(y1,y2,1.0);
		}
		[[nodiscard]]inline constexpr auto get_result(auto y1,auto k,auto δx)noexcept{
			auto diff=k*δx;
			return y1+diff;
		}
		[[nodiscard]]inline constexpr auto get_reverse_result(auto k,auto δx,auto y)noexcept{
			auto diff=k*δx;
			return y-diff;
		}
	}
	//质因数分解
	//由于array在之后定义所以泛型容器
	//用法 get_prime_factorization(num).to<容器类型>(); 或 get_prime_factorization(num).unique().to<容器类型>();
	constexpr struct get_prime_factorization_t{
		template<class T>
		class result_t{
			T _m;
		public:
			template<class container_t>
			static constexpr bool able=was_not_an_ill_form(declvalue(container_t&).push_back(declvalue(T)));

			constexpr force_inline result_t(T m)noexcept:_m(m){}

			template<class container_t> requires able<container_t>
			[[nodiscard]]constexpr container_t to()const noexcept{
				container_t aret{};
				//思路：获取小于等于m的所有素数，依次除以m，若能整除则将素数加入结果，否则跳过，直到m为1.
				T i=T{2u},m=abs(_m);
				while(m!=1){
					while(!(m%i)){
						aret.push_back(i);
						m/=i;
					}
					i=get_prime_num_big_than(i);
				}
				if constexpr(signed_type<T>)
					if(is_negative(_m))
						aret.push_back(T{-1});
				return aret;
			}
			//operator container_t()
			template<class container_t>
			[[nodiscard]]constexpr force_inline operator container_t()const noexcept{
				return to<container_t>();
			}
			class unique_t{
				T _m;
			public:
				constexpr force_inline unique_t(T m)noexcept:_m(m){}

				template<class container_t> requires able<container_t>
				[[nodiscard]]constexpr container_t to()const noexcept{
					container_t aret{};
					//思路：获取小于等于m的所有素数，依次除以m，若能整除则将素数加入结果，否则跳过，直到m为1.
					T i=T{2u},m=abs(_m);
					while(m!=1){
						if(!(m%i)){
							aret.push_back(i);
							do m/=i;while(!(m%i));
						}
						i=get_prime_num_big_than(i);
					}
					if constexpr(signed_type<T>)
						if(is_negative(_m))
							aret.push_back(T{-1});
					return aret;
				}
				//operator container_t()
				template<class container_t>
				[[nodiscard]]constexpr force_inline operator container_t()const noexcept{
					return to<container_t>();
				}
			};
			[[nodiscard]]constexpr force_inline auto unique()const noexcept{
				return unique_t{_m};
			}
		};
		template<arithmetic_type T>
		[[nodiscard]]constexpr force_inline auto operator()(T m)const noexcept{
			return result_t<T>{m};
		}
	}get_prime_factorization{};
	//编译时质因数分解到质因数表
	template<unsigned_integer_type number_T,number_T number>
	struct prime_factorization_table_t{
		typedef prime_factorization_table_t<number_T,number> this_t;
		static constexpr size_t table_size=lambda{
			number_T i=2,m=number;
			size_t aret=0;
			while(m!=1){
				while(!(m%i)){
					++aret;
					m/=i;
				}
				i=get_prime_num_big_than(i);
			}
			return aret;
		}();
		number_T _table[table_size];
		constexpr force_inline prime_factorization_table_t()noexcept{
			number_T i=2,m=number;
			number_T index=0;
			while(m!=1){
				while(!(m%i)){
					_table[index++]=i;
					m/=i;
				}
				i=get_prime_num_big_than(i);
			}
		}
		[[nodiscard]]constexpr force_inline number_T operator[](size_t index)const noexcept{
			return _table[index];
		}
		//begin and end for range for
		[[nodiscard]]constexpr force_inline number_T* begin()noexcept{
			return _table;
		}
		[[nodiscard]]constexpr force_inline number_T* end()noexcept{
			return _table+table_size;
		}
		[[nodiscard]]constexpr force_inline const number_T* begin()const noexcept{
			return _table;
		}
		[[nodiscard]]constexpr force_inline const number_T* end()const noexcept{
			return _table+table_size;
		}
		//size
		[[nodiscard]]constexpr force_inline size_t size()const noexcept{
			return table_size;
		}
		//friend
		template<class T> requires(type_info<remove_cv<T>> == type_info<number_T>)
		[[nodiscard]]friend inline auto size_of_array_like(const this_t&)noexcept{
			return table_size;
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<number_T>)
		[[nodiscard]]friend inline auto begin_of_array_like(this_t&table)noexcept{
			return table.begin();
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<number_T>)
		[[nodiscard]]friend inline auto end_of_array_like(this_t&table)noexcept{
			return table.end();
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<number_T>)
		[[nodiscard]]friend inline auto begin_of_array_like(const this_t&table)noexcept{
			return table.begin();
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<number_T>)
		[[nodiscard]]friend inline auto end_of_array_like(const this_t&table)noexcept{
			return table.end();
		}
	};
	//编译时的唯一质因数分解到质因数表
	template<unsigned_integer_type number_T,number_T number>
	struct unique_prime_factorization_table_t{
		typedef unique_prime_factorization_table_t<number_T,number> this_t;
		static constexpr size_t table_size=lambda{
			number_T i=2,m=number;
			size_t aret=0;
			while(m!=1){
				if(!(m%i)){
					++aret;
					do m/=i;while(!(m%i));
				}
				i=get_prime_num_big_than(i);
			}
			return aret;
		}();
		number_T _table[table_size]={};
		constexpr force_inline unique_prime_factorization_table_t()noexcept{
			number_T i=2,m=number;
			size_t index=0;
			while(m!=1){
				if(!(m%i)){
					_table[index++]=i;
					do m/=i;while(!(m%i));
				}
				i=get_prime_num_big_than(i);
			}
		}
		[[nodiscard]]constexpr force_inline number_T operator[](size_t index)const noexcept{
			return _table[index];
		}
		//begin and end for range for
		[[nodiscard]]constexpr force_inline number_T* begin()noexcept{
			return _table;
		}
		[[nodiscard]]constexpr force_inline number_T* end()noexcept{
			return _table+table_size;
		}
		[[nodiscard]]constexpr force_inline const number_T* begin()const noexcept{
			return _table;
		}
		[[nodiscard]]constexpr force_inline const number_T* end()const noexcept{
			return _table+table_size;
		}
		//size
		[[nodiscard]]constexpr force_inline size_t size()const noexcept{
			return table_size;
		}
		//friend
		template<class T> requires(type_info<remove_cv<T>> == type_info<number_T>)
		[[nodiscard]]friend inline auto size_of_array_like(const this_t&)noexcept{
			return table_size;
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<number_T>)
		[[nodiscard]]friend inline auto begin_of_array_like(this_t&table)noexcept{
			return table.begin();
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<number_T>)
		[[nodiscard]]friend inline auto end_of_array_like(this_t&table)noexcept{
			return table.end();
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<number_T>)
		[[nodiscard]]friend inline auto begin_of_array_like(const this_t&table)noexcept{
			return table.begin();
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<number_T>)
		[[nodiscard]]friend inline auto end_of_array_like(const this_t&table)noexcept{
			return table.end();
		}
	};
	//阶乘快速计算
	template<unsigned_integer_type T>
	[[nodiscard]]constexpr inline auto factorial(unsigned n,unsigned start=1u)noexcept{
		constexpr size_t threshold=1<<4;
		if (n < threshold) {
			T s = 1u;
			unsigned end = start + n;
			while(start < end)
				s *= start++;
			return s;
		}
		unsigned m = (n+1u)/2;
		return factorial<T>(m,start)*factorial<T>(n-m,start+m);
	}
}

namespace bit{
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr size_t countl_zero(const T v)noexcept;
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr size_t countr_zero(const T v)noexcept;
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr size_t countl_one(const T v)noexcept;
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr size_t countr_one(const T v)noexcept;
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr size_t get_bitnum(const T v)noexcept;
	template<signed_basic_integer_type T>
	[[nodiscard]]force_inline constexpr size_t get_bitnum(const T v)noexcept;
}
using namespace bit;//干净的符号导出！

namespace math{
	//求出最大公约数
	template<integer_type T>
	[[nodiscard]]inline auto gcd(T x, T y)noexcept{
		size_t shift = 0;
		while(y){
			//都是偶数时，shift++并位移
			const auto x_rzero=countr_zero(x);
			const auto y_rzero=countr_zero(y);
			shift+=min(x_rzero,y_rzero);
			//一偶一奇时，只移动偶数 直到都是奇数
			x>>=x_rzero;
			y>>=y_rzero;
			//都是奇数时，大数-=小数
			if(x < y)swap(x, y);
			x-=y;
		}
		// 返回 x 左移 shift 位的结果
		return x << shift;
	}
}
using math::is_negative;
using math::copy_as_negative;
using math::reverse_sign;
using math::to_size_t;
using math::mod;
using math::is_odd;
using math::is_even;
using math::divmod;
using math::ceil_div;
using math::set_rounding;
using math::get_rounding;
using math::rounding_auto_setter;
using math::is_close;
using math::isNaN;
using math::isInf;
using math::abs;
using math::exp;
using math::log;
using math::integer_log;
using math::pow;
using math::ceil;
using math::floor;
using math::sqrt;
using math::trunc;
using math::is_prime_num;
using math::get_prime_num_big_or_eq_than;
using math::get_prime_num_big_than;
using math::get_next_gold_size_to_resize_for_array;
using math::get_next_gold_size_to_resize_for_hash;
using math::get_prime_factorization;
using math::prime_factorization_table_t;
using math::unique_prime_factorization_table_t;
using math::gcd;
using math::factorial;

//file_end

		#line 71 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
	}

	//由于vcruntime的type_info在全局定义,这里需要额外声明使用base::type_info.
	#if defined(_VCRUNTIME_H)
		using base::type_info;
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_PUBLIC_ALL)
	#undef protected
	#undef private
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef times
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef exlambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS
#undef lambda_inline
#undef lambda_force_inline

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 79 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
}
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
//_body.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_defs.hpp"
//undefs at "_undefs.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_PUBLIC_ALL)
	#define protected public
	#define private public
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#define times(...) ([[maybe_unused]]auto [loop_times,loop_end_value] : ::elc::defs::times_provider_t(__VA_ARGS__)) //for times(72)do_something;
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name,...) \
exlambda(auto&&...Args)__VA_ARGS__ lambda_force_inline{\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define exlambda [&]
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#if defined(_MSC_VER) && !defined(__clang__)
	#define lambda_inline [[msvc::forceinline]]
	#define lambda_force_inline [[msvc::forceinline]]
#elif
	#define lambda_inline [[gnu::always_inline]]
	#define lambda_force_inline [[gnu::always_inline]]
#else
	#define lambda_inline
	#define lambda_force_inline
#endif

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
	#define in_debug 1
#else
	#define not_in_debug 1
	#define in_debug 0
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_defs.hpp"

// 定义一个宏来检测是否支持GCC内置函数
#if defined(__GNUC__) || defined(__clang__)
	#define HAS_GCC_BUILTINS 1
#else
	#define HAS_GCC_BUILTINS 0
#endif

// 定义一个宏来检测是否支持MSVC内置函数
#if defined(_MSC_VER) && !defined(__clang__)
	#define HAS_MSVC_INTRINSICS 1
#else
	#define HAS_MSVC_INTRINSICS 0
#endif

// 定义一个宏来检测是否支持x86汇编
#if defined(__i386__) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)
	#define HAS_X86_ASM 1
#else
	#define HAS_X86_ASM 0
#endif

// 定义一个宏来检测是否支持x86-64汇编
#if defined(__x86_64__) || defined(_M_X64)
	#define HAS_X86_64_ASM 1
#else
	#define HAS_X86_64_ASM 0
#endif

// 定义一个宏来检测是否支持ARM汇编
#if defined(__arm__) || defined(_M_ARM)
	#define HAS_ARM_ASM 1
#else
	#define HAS_ARM_ASM 0
#endif

// 定义一个宏来检测是否支持ARM64汇编
#if defined(__aarch64__)
	#define HAS_ARM64_ASM 1
#else
	#define HAS_ARM64_ASM 0
#endif

//file_end

	#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"

	namespace basic_environment{
		typedef bool bit_type;
		[[nodiscard]]constexpr force_inline bool is_rounding_bit(bit_type v)noexcept{
			if constexpr(BIT_POSSIBILITY==2)
				return v;
			else{
				push_and_disable_msvc_warning(4804);//？
				return v>=BIT_POSSIBILITY/2;
				pop_msvc_warning();
			}
		}

		#if defined(__SIZEOF_INT128__)
			#define ELC_BASE_ENV_HAS_INT128
			typedef __uint128_t uint128_t;
			typedef __int128_t int128_t;
		#endif
		#if defined(ELC_BASE_ENV_HAS_INT128)
			typedef uint128_t uint_fast128_t;
			typedef int128_t int_fast128_t;
			template<char...cs>
			constexpr uint128_t operator ""_u128()noexcept{
				return literal_support::unsigned_integer_literal_evaler<uint128_t>::eval<cs...>();
			}
			template<char...cs>
			constexpr int128_t operator ""_i128()noexcept{
				return literal_support::signed_integer_literal_evaler<int128_t,uint128_t>::eval<cs...>();
			}
		#endif
		//基础的uintmax_t
		typedef ::std::uintmax_t basic_uintmax_t;
		typedef ::std::intmax_t basic_intmax_t;
		//更新uintmax_t和intmax_t的代指
		typedef decltype(lambda{
			#if defined(ELC_BASE_ENV_HAS_INT128)
			if constexpr(sizeof(basic_uintmax_t) < sizeof(uint128_t))
				return uint128_t{};
			else
			#endif
				return basic_uintmax_t{};
		}()) uintmax_t;
		typedef decltype(lambda{
			#if defined(ELC_BASE_ENV_HAS_INT128)
			if constexpr(sizeof(basic_intmax_t) < sizeof(int128_t))
				return int128_t{};
			else
			#endif
				return basic_intmax_t{};
		}()) intmax_t;
		//众所周知，class不能作为数组下标，所以uintmax_index_t等类型的存在是有必要的
		typedef basic_uintmax_t uintmax_index_t;
		typedef basic_intmax_t intmax_index_t;
		template<class T>
		constexpr inline bool is_elc_expansion_base_type_helper()noexcept{
			#if defined(ELC_BASE_ENV_HAS_INT128)
			if constexpr(sizeof(basic_uintmax_t) < sizeof(uint128_t) && type_info<T> == type_info<uint128_t>)
				return true;
			if constexpr(sizeof(basic_intmax_t) < sizeof(int128_t) && type_info<T> == type_info<int128_t>)
				return true;
			#endif
			return false;
		}
		template<class T>
		concept is_elc_expansion_base_type=is_elc_expansion_base_type_helper<T>();

		/*! 给定大小的无符号整数类型 */
		template<size_t size>
		using unsigned_specific_size_t=decltype(lambda{
			#define TYPE_MAPPER(type) if constexpr(size == sizeof(type))return (type)0;else
			#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
//unsigned_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
TYPE_MAPPER(uint8_t)
TYPE_MAPPER(uint16_t)
TYPE_MAPPER(uint32_t)
TYPE_MAPPER(uint64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint128_t)
#endif
TYPE_MAPPER(::std::uintmax_t)
TYPE_MAPPER(size_t)
TYPE_MAPPER(unsigned char)
TYPE_MAPPER(char8_t)
TYPE_MAPPER(char16_t)
TYPE_MAPPER(char32_t)
TYPE_MAPPER(wchar_t)
TYPE_MAPPER(unsigned short)
TYPE_MAPPER(unsigned int)
TYPE_MAPPER(unsigned long)
TYPE_MAPPER(unsigned long long)

//file_end

			#line 102 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
			#undef TYPE_MAPPER
			{}
		}());
		/*! 至少有给定大小的快速无符号整数类型 */
		template<size_t size>
		using unsigned_specific_size_fast_t=decltype(lambda{
			#define TYPE_MAPPER(type) if constexpr(size <= sizeof(type))return (type)0;else
			#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
//unsigned_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
TYPE_MAPPER(uint_fast8_t)
TYPE_MAPPER(uint_fast16_t)
TYPE_MAPPER(uint_fast32_t)
TYPE_MAPPER(uint_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint_fast128_t)
#endif

//file_end

			#line 110 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
			#undef TYPE_MAPPER
			{}
		}());
		/*! 给定大小的有符号整数类型 */
		template<size_t size>
		using signed_specific_size_t=decltype(lambda{
			#define TYPE_MAPPER(type) if constexpr(size == sizeof(type))return (type)0;else
			#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
//signed_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
TYPE_MAPPER(int8_t)
TYPE_MAPPER(int16_t)
TYPE_MAPPER(int32_t)
TYPE_MAPPER(int64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int128_t)
#endif
TYPE_MAPPER(::std::intmax_t)
TYPE_MAPPER(ptrdiff_t)
TYPE_MAPPER(signed char)
TYPE_MAPPER(short)
TYPE_MAPPER(int)
TYPE_MAPPER(long)
TYPE_MAPPER(long long)

//file_end

			#line 118 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
			#undef TYPE_MAPPER
			{}
		}());
		/*! 至少有给定大小的快速有符号整数类型 */
		template<size_t size>
		using signed_specific_size_fast_t=decltype(lambda{
			#define TYPE_MAPPER(type) if constexpr(size <= sizeof(type))return (type)0;else
			#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
//signed_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
TYPE_MAPPER(int_fast8_t)
TYPE_MAPPER(int_fast16_t)
TYPE_MAPPER(int_fast32_t)
TYPE_MAPPER(int_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int_fast128_t)
#endif

//file_end

			#line 126 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
			#undef TYPE_MAPPER
			{}
		}());
		//任意类型转算数类型
		inline constexpr class to_arithmetic_t{
			template<class T,class type>
			//由于can_convert_to的歧义性质，使用requires表达式辅助推断type是否为实际支持的类型
			//由于requires表达式的强制性质，使用can_convert_to辅助推断隐式转换是否可行
			static inline constexpr bool is_convertible = type_info<T>.can_convert_to<type> && was_not_an_ill_form(static_cast<type>(declvalue(T)));
			template<class T>
			static inline constexpr bool r_able_helper()noexcept{
				#define TYPE_MAPPER(type) if constexpr(is_convertible<T,type>)return true;else
				#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
//float_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
//float_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
TYPE_MAPPER(float)
TYPE_MAPPER(double)
TYPE_MAPPER(long double)
#if defined(__STDCPP_FLOAT16_T__)
	TYPE_MAPPER(::std::float16_t)
#endif
#if defined(__STDCPP_FLOAT32_T__)
	TYPE_MAPPER(::std::float32_t)
#endif
#if defined(__STDCPP_FLOAT64_T__)
	TYPE_MAPPER(::std::float64_t)
#endif
#if defined(__STDCPP_FLOAT128_T__)
	TYPE_MAPPER(::std::float128_t)
#endif
#if defined(__STDCPP_BFLOAT16_T__)
	TYPE_MAPPER(::std::bfloat16_t)
#endif

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
//signed_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
TYPE_MAPPER(int8_t)
TYPE_MAPPER(int16_t)
TYPE_MAPPER(int32_t)
TYPE_MAPPER(int64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int128_t)
#endif
TYPE_MAPPER(::std::intmax_t)
TYPE_MAPPER(ptrdiff_t)
TYPE_MAPPER(signed char)
TYPE_MAPPER(short)
TYPE_MAPPER(int)
TYPE_MAPPER(long)
TYPE_MAPPER(long long)

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
//unsigned_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
TYPE_MAPPER(uint8_t)
TYPE_MAPPER(uint16_t)
TYPE_MAPPER(uint32_t)
TYPE_MAPPER(uint64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint128_t)
#endif
TYPE_MAPPER(::std::uintmax_t)
TYPE_MAPPER(size_t)
TYPE_MAPPER(unsigned char)
TYPE_MAPPER(char8_t)
TYPE_MAPPER(char16_t)
TYPE_MAPPER(char32_t)
TYPE_MAPPER(wchar_t)
TYPE_MAPPER(unsigned short)
TYPE_MAPPER(unsigned int)
TYPE_MAPPER(unsigned long)
TYPE_MAPPER(unsigned long long)

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
//signed_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
TYPE_MAPPER(int_fast8_t)
TYPE_MAPPER(int_fast16_t)
TYPE_MAPPER(int_fast32_t)
TYPE_MAPPER(int_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int_fast128_t)
#endif

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
//unsigned_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
TYPE_MAPPER(uint_fast8_t)
TYPE_MAPPER(uint_fast16_t)
TYPE_MAPPER(uint_fast32_t)
TYPE_MAPPER(uint_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint_fast128_t)
#endif

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"

//file_end

				#line 139 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
				#undef TYPE_MAPPER
				return false;
			}
			template<class T>
			static force_inline constexpr auto to_arithmetic_base(T&&v)noexcept{
				#define TYPE_MAPPER(type) if constexpr(r_able_helper<T>()&&is_convertible<T,type>)return (type)v;else
				#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
//float_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
//float_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
TYPE_MAPPER(float)
TYPE_MAPPER(double)
TYPE_MAPPER(long double)
#if defined(__STDCPP_FLOAT16_T__)
	TYPE_MAPPER(::std::float16_t)
#endif
#if defined(__STDCPP_FLOAT32_T__)
	TYPE_MAPPER(::std::float32_t)
#endif
#if defined(__STDCPP_FLOAT64_T__)
	TYPE_MAPPER(::std::float64_t)
#endif
#if defined(__STDCPP_FLOAT128_T__)
	TYPE_MAPPER(::std::float128_t)
#endif
#if defined(__STDCPP_BFLOAT16_T__)
	TYPE_MAPPER(::std::bfloat16_t)
#endif

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
//signed_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
TYPE_MAPPER(int8_t)
TYPE_MAPPER(int16_t)
TYPE_MAPPER(int32_t)
TYPE_MAPPER(int64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int128_t)
#endif
TYPE_MAPPER(::std::intmax_t)
TYPE_MAPPER(ptrdiff_t)
TYPE_MAPPER(signed char)
TYPE_MAPPER(short)
TYPE_MAPPER(int)
TYPE_MAPPER(long)
TYPE_MAPPER(long long)

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
//unsigned_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
TYPE_MAPPER(uint8_t)
TYPE_MAPPER(uint16_t)
TYPE_MAPPER(uint32_t)
TYPE_MAPPER(uint64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint128_t)
#endif
TYPE_MAPPER(::std::uintmax_t)
TYPE_MAPPER(size_t)
TYPE_MAPPER(unsigned char)
TYPE_MAPPER(char8_t)
TYPE_MAPPER(char16_t)
TYPE_MAPPER(char32_t)
TYPE_MAPPER(wchar_t)
TYPE_MAPPER(unsigned short)
TYPE_MAPPER(unsigned int)
TYPE_MAPPER(unsigned long)
TYPE_MAPPER(unsigned long long)

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
//signed_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
TYPE_MAPPER(int_fast8_t)
TYPE_MAPPER(int_fast16_t)
TYPE_MAPPER(int_fast32_t)
TYPE_MAPPER(int_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int_fast128_t)
#endif

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
//unsigned_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
TYPE_MAPPER(uint_fast8_t)
TYPE_MAPPER(uint_fast16_t)
TYPE_MAPPER(uint_fast32_t)
TYPE_MAPPER(uint_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint_fast128_t)
#endif

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"

//file_end

				#line 146 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
				#undef TYPE_MAPPER
				{}
			}
			template<class T>
			static inline constexpr size_t get_arithmetic_muti_convertible_count()noexcept{
				typedef decltype(to_arithmetic_base(declvalue(T))) to_type;
				size_t muti_convertible_count=0;
				#define TYPE_MAPPER(type) \
				if constexpr(type_info<to_type>!=type_info<type> && is_convertible<T,type>)\
					muti_convertible_count++;
				#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
//float_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
//float_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
TYPE_MAPPER(float)
TYPE_MAPPER(double)
TYPE_MAPPER(long double)
#if defined(__STDCPP_FLOAT16_T__)
	TYPE_MAPPER(::std::float16_t)
#endif
#if defined(__STDCPP_FLOAT32_T__)
	TYPE_MAPPER(::std::float32_t)
#endif
#if defined(__STDCPP_FLOAT64_T__)
	TYPE_MAPPER(::std::float64_t)
#endif
#if defined(__STDCPP_FLOAT128_T__)
	TYPE_MAPPER(::std::float128_t)
#endif
#if defined(__STDCPP_BFLOAT16_T__)
	TYPE_MAPPER(::std::bfloat16_t)
#endif

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
//signed_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
TYPE_MAPPER(int8_t)
TYPE_MAPPER(int16_t)
TYPE_MAPPER(int32_t)
TYPE_MAPPER(int64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int128_t)
#endif
TYPE_MAPPER(::std::intmax_t)
TYPE_MAPPER(ptrdiff_t)
TYPE_MAPPER(signed char)
TYPE_MAPPER(short)
TYPE_MAPPER(int)
TYPE_MAPPER(long)
TYPE_MAPPER(long long)

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
//unsigned_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
TYPE_MAPPER(uint8_t)
TYPE_MAPPER(uint16_t)
TYPE_MAPPER(uint32_t)
TYPE_MAPPER(uint64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint128_t)
#endif
TYPE_MAPPER(::std::uintmax_t)
TYPE_MAPPER(size_t)
TYPE_MAPPER(unsigned char)
TYPE_MAPPER(char8_t)
TYPE_MAPPER(char16_t)
TYPE_MAPPER(char32_t)
TYPE_MAPPER(wchar_t)
TYPE_MAPPER(unsigned short)
TYPE_MAPPER(unsigned int)
TYPE_MAPPER(unsigned long)
TYPE_MAPPER(unsigned long long)

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
//signed_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
TYPE_MAPPER(int_fast8_t)
TYPE_MAPPER(int_fast16_t)
TYPE_MAPPER(int_fast32_t)
TYPE_MAPPER(int_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int_fast128_t)
#endif

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
//unsigned_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
TYPE_MAPPER(uint_fast8_t)
TYPE_MAPPER(uint_fast16_t)
TYPE_MAPPER(uint_fast32_t)
TYPE_MAPPER(uint_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint_fast128_t)
#endif

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"

//file_end

				#line 157 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
				#undef TYPE_MAPPER
				return muti_convertible_count;
			}
			template<class T>
			static inline constexpr bool convertible_unique_helper()noexcept{
				return get_arithmetic_muti_convertible_count<T>()==1;//the oly way we can save all lifes........
			}
			template<class T>
			static inline constexpr bool able_helper()noexcept{
				if constexpr(r_able_helper<T>())
					return convertible_unique_helper<T>();
				else
					return false;
			}
		public:
			template<class T>
			static inline constexpr bool able = able_helper<T>();
		private:
			//nothrow
			template<class T>
			static inline constexpr bool nothrow_helper()noexcept{
				typedef decltype(to_arithmetic_base(declvalue(T))) to_type;
				if constexpr(able<T>)
					return type_info<T>.can_nothrow_convert_to<to_type>;
				else
					return false;
			}
		public:
			template<class T>
			static inline constexpr bool nothrow = nothrow_helper<T>();
			//算数类型转任意类型
			template<class T> requires able<T>
			force_inline constexpr auto operator()(T&&v)const noexcept(nothrow<T>){
				return to_arithmetic_base(forward<T>(v));
			}
		}to_arithmetic{};
		//判断wchar_t是否和char_t相同
		inline constexpr bool wchar_t_same_as_char_t=sizeof(wchar_t)==sizeof(char_t);
		//判断wchar_t是否和char16_t相同
		inline constexpr bool wchar_t_same_as_char16_t=sizeof(wchar_t)==sizeof(char16_t);

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/add_sub_carry.hpp"
//add_sub_carry.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/add_sub_carry.hpp"
#if HAS_MSVC_INTRINSICS
	template<unsigned_basic_integer_type T>
	force_inline bool _msvc_builtin_add_carry(bool c_in, T a, T b, T*out)noexcept{
		if constexpr(sizeof(T) == 8)
			return _addcarry_u64(c_in, a, b, out);
		elseif constexpr(sizeof(T) == 4)
			return _addcarry_u32(c_in, a, b, out);
		elseif constexpr(sizeof(T) == 2)
			return _addcarry_u16(c_in, a, b, out);
		elseif constexpr(sizeof(T) == 1)
			return _addcarry_u8(c_in, a, b, out);
	}
	template<unsigned_basic_integer_type T>
	force_inline bool _msvc_builtin_sub_borrow(bool b_in, T a, T b, T*out)noexcept{
		if constexpr(sizeof(T) == 8)
			return _subborrow_u64(b_in, a, b, out);
		elseif constexpr(sizeof(T) == 4)
			return _subborrow_u32(b_in, a, b, out);
		elseif constexpr(sizeof(T) == 2)
			return _subborrow_u16(b_in, a, b, out);
		elseif constexpr(sizeof(T) == 1)
			return _subborrow_u8(b_in, a, b, out);
	}
#endif
// add carry
template<unsigned_basic_integer_type T>
constexpr force_inline bool add_carry(T a, T b, T& c)noexcept{
	if(!in_consteval){
		#if HAS_GCC_BUILTINS
			return __builtin_add_overflow(a, b, &c);
		#elif HAS_MSVC_INTRINSICS
			return _msvc_builtin_add_carry(0, a, b, &c);
		#elif HAS_X86_ASM
			//x86/x86-64
			__asm__ (
				"add %2, %1\n\t"
				"setc %0\n\t"
				: "=r"(c)
				: "r"(a), "r"(b)
			);
			return c;
		#elif HAS_ARM_ASM || HAS_ARM64_ASM
			//arm/arm64
			__asm__ (
				"adds %1, %1, %2\n\t"
				"adc %0, xzr, xzr\n\t"
				: "=r"(c)
				: "r"(a), "r"(b)
			);
			return c;
		#endif
	}
	c = a + b;
	return c < a;
}
template<unsigned_basic_integer_type T>
constexpr force_inline T add_carry(T a, T b, bool& is_overflow)noexcept{
	#if HAS_MSVC_INTRINSICS
		if(!in_consteval){
			T c;is_overflow=_msvc_builtin_add_carry(is_overflow, a, b, &c);
			return c;
		}
		else
	#endif
	{
		T c=a+is_overflow;
		if(c){
			is_overflow=add_carry(c,b,c);
			return c;
		}
		else{
			//现在我们得知a+is_overflow的结果为0:
			//若is_overflow为true，溢出确实发生了，我们需要将is_overflow设置为true，所以什么都不用管
			//若is_overflow为false，溢出没有发生，我们需要将is_overflow设置为false，我们仍然什么都不用管
			return b;
		}
	}
}
template<unsigned_basic_integer_type T>
constexpr force_inline T add_carry(T a, bool& is_overflow)noexcept{
	#if HAS_MSVC_INTRINSICS
		if(!in_consteval){
			T c;is_overflow=_msvc_builtin_add_carry(is_overflow, a, T{}, &c);
			return c;
		}
		else
	#endif
	{
		T c=a+is_overflow;
		if(c)//若c为0，保持is_overflow不变（原理见上）
			is_overflow=false;
		return c;
	}
}
// sub borrow
template<unsigned_basic_integer_type T>
constexpr force_inline bool sub_borrow(T a, T b, T& c)noexcept{
	if(!in_consteval){
		#if HAS_GCC_BUILTINS
			return __builtin_sub_overflow(a, b, &c);
		#elif HAS_MSVC_INTRINSICS
			return _msvc_builtin_sub_borrow(0, a, b, &c);
		#elif HAS_X86_ASM
			//x86/x86-64
			__asm__ (
				"sub %2, %1\n\t"
				"setc %0\n\t"
				: "=r"(c)
				: "r"(a), "r"(b)
			);
			return c;
		#elif HAS_ARM_ASM || HAS_ARM64_ASM
			//arm/arm64
			__asm__ (
				"subs %1, %1, %2\n\t"
				"sbc %0, xzr, xzr\n\t"
				: "=r"(c)
				: "r"(a), "r"(b)
			);
			return c;
		#endif
	}
	c = a - b;
	return c > a;
}
template<unsigned_basic_integer_type T>
constexpr force_inline T sub_borrow(T a, T b, bool& is_underflow)noexcept{
	#if HAS_MSVC_INTRINSICS
		if(!in_consteval){
			T c;is_underflow=_msvc_builtin_sub_borrow(is_underflow, a, b, &c);
			return c;
		}
		else
	#endif
	{
		T c=b+is_underflow;
		if(c){
			is_underflow=sub_borrow(a,c,c);
			return c;
		}
		else{
			//现在我们得知b+is_underflow的结果为0:
			//若is_underflow为true，溢出肯定该发生，我们需要将is_underflow设置为true，所以什么都不用管
			//若is_underflow为false，溢出不会发生，我们需要将is_underflow设置为false，我们仍然什么都不用管
			return a;
		}
	}
}
template<unsigned_basic_integer_type T>
constexpr force_inline T sub_borrow(T a, bool& is_underflow)noexcept{
	#if HAS_MSVC_INTRINSICS
		if(!in_consteval){
			T c;is_underflow=_msvc_builtin_sub_borrow(is_underflow, a, T{}, &c);
			return c;
		}
		else
	#endif
	{
		if(is_underflow){
			is_underflow=!a;
			return a-1;
		}
		else
			return a;
	}
}


//file_end

		#line 199 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/float_info.hpp"
//float_info.hpp
#line 46 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/float_info.hpp"
namespace float_infos{
	struct float16_float_info{
		//精确数部分的掩码
		static constexpr auto precision_mask=uint16_t(0x07FFu);
		//精确数的无符号整数类型
		typedef decltype(precision_mask) precision_type;

		//浮点数的无符号整数数据类型
		typedef uint16_t data_type;

		//自浮点数获取精确数的基（如float是2^23，double是2^52，long double是2^112）
		static constexpr auto precision_base=uint16_t(0x0800u);
		//自浮点数获取精确数的基的位数（如float是23）
		static constexpr auto precision_base_bit=11u;
		//浮点数的指数部分的diff（如float是127，double是1023，long double是16383）
		static constexpr auto exponent_diff=15;
		//浮点数的指数部分的min（如float是-126，double是-1022，long double是-16382）
		static constexpr auto exponent_min=-14;
		//浮点数的指数部分的max（如float是127，double是1023，long double是16383）
		static constexpr auto exponent_max=15;

		//浮点数的指数部分的无符号整数类型
		typedef uint8_t exponent_unsigned_type;
		//浮点数的指数部分的经过偏移后的有符号整数类型
		typedef int8_t exponent_signed_type;
		//浮点数的指数部分的掩码
		static constexpr auto exponent_mask=uint16_t(0x7FFFu);
	};
	struct float32_float_info{
		//精确数部分的掩码
		static constexpr auto precision_mask=uint32_t(0x007FFFFFu);
		//精确数的无符号整数类型
		typedef decltype(precision_mask) precision_type;

		//浮点数的无符号整数数据类型
		typedef uint32_t data_type;

		//自浮点数获取精确数的基（如float是2^23，double是2^52，long double是2^112）
		static constexpr auto precision_base=uint32_t(0x800000u);
		//自浮点数获取精确数的基的位数（如float是23）
		static constexpr auto precision_base_bit=23u;
		//浮点数的指数部分的diff（如float是127，double是1023，long double是16383）
		static constexpr auto exponent_diff=127;
		//浮点数的指数部分的min（如float是-126，double是-1022，long double是-16382）
		static constexpr auto exponent_min=-126;
		//浮点数的指数部分的max（如float是127，double是1023，long double是16383）
		static constexpr auto exponent_max=127;

		//浮点数的指数部分的无符号整数类型
		typedef uint8_t exponent_unsigned_type;
		//浮点数的指数部分的经过偏移后的有符号整数类型
		typedef int8_t exponent_signed_type;
		//浮点数的指数部分的掩码
		static constexpr auto exponent_mask=uint32_t(0x7FFFFFFFu);
	};
	struct float64_float_info{
		//精确数部分的掩码
		static constexpr auto precision_mask=uint64_t(0x000FFFFFFFFFFFFFu);
		//精确数的无符号整数类型
		typedef decltype(precision_mask) precision_type;

		//浮点数的无符号整数数据类型
		typedef uint64_t data_type;

		//自浮点数获取精确数的基（如float是2^23，double是2^52，long double是2^112）
		static constexpr auto precision_base=uint64_t(0x10000000000000u);
		//自浮点数获取精确数的基的位数（如float是23）
		static constexpr auto precision_base_bit=52u;
		//浮点数的指数部分的diff（如float是127，double是1023，long double是16383）
		static constexpr auto exponent_diff=1023;
		//浮点数的指数部分的min（如float是-126，double是-1022，long double是-16382）
		static constexpr auto exponent_min=-1022;
		//浮点数的指数部分的max（如float是127，double是1023，long double是16383）
		static constexpr auto exponent_max=1023;

		//浮点数的指数部分的无符号整数类型
		typedef uint16_t exponent_unsigned_type;
		//浮点数的指数部分的经过偏移后的有符号整数类型
		typedef int16_t exponent_signed_type;
		//浮点数的指数部分的掩码
		static constexpr auto exponent_mask=uint64_t(0x7FFFFFFFFFFFFFFFu);
	};
	#if defined(ELC_BASE_ENV_HAS_INT128)
	struct float128_float_info{
		//精确数部分的掩码
		static constexpr auto precision_mask=0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF_u128;
		//精确数的无符号整数类型
		typedef decltype(precision_mask) precision_type;

		//浮点数的无符号整数数据类型
		typedef uint128_t data_type;

		//自浮点数获取精确数的基（如float是2^23，double是2^52，long double是2^112）
		static constexpr auto precision_base=0x10000000000000000000000000000_u128;
		//自浮点数获取精确数的基的位数（如float是23）
		static constexpr auto precision_base_bit=112u;
		//浮点数的指数部分的diff（如float是127，double是1023，long double是16383）
		static constexpr auto exponent_diff=16383;
		//浮点数的指数部分的min（如float是-126，double是-1022，long double是-16382）
		static constexpr auto exponent_min=-16382;
		//浮点数的指数部分的max（如float是127，double是1023，long double是16383）
		static constexpr auto exponent_max=16383;

		//浮点数的指数部分的无符号整数类型
		typedef uint16_t exponent_unsigned_type;
		//浮点数的指数部分的经过偏移后的有符号整数类型
		typedef int16_t exponent_signed_type;
		//浮点数的指数部分的掩码
		static constexpr auto exponent_mask=0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF_u128;
	};
	#endif
	struct bfloat16_float_info{
		//精确数部分的掩码
		static constexpr auto precision_mask=uint16_t(0x00FFu);
		//精确数的无符号整数类型
		typedef decltype(precision_mask) precision_type;

		//浮点数的无符号整数数据类型
		typedef uint16_t data_type;

		//自浮点数获取精确数的基（如float是2^23，double是2^52，long double是2^112）
		static constexpr auto precision_base=uint16_t(0x0100u);
		//自浮点数获取精确数的基的位数（如float是23）
		static constexpr auto precision_base_bit=8u;
		//浮点数的指数部分的diff（如float是127，double是1023，long double是16383）
		static constexpr auto exponent_diff=127;
		//浮点数的指数部分的min（如float是-126，double是-1022，long double是-16382）
		static constexpr auto exponent_min=-126;
		//浮点数的指数部分的max（如float是127，double是1023，long double是16383）
		static constexpr auto exponent_max=127;

		//浮点数的指数部分的无符号整数类型
		typedef uint8_t exponent_unsigned_type;
		//浮点数的指数部分的经过偏移后的有符号整数类型
		typedef int8_t exponent_signed_type;
		//浮点数的指数部分的掩码
		static constexpr auto exponent_mask=uint16_t(0x7FFFu);
	};

	template<basic_float_type T>
	static constexpr auto get_float_info()noexcept{
		#if defined(__STDCPP_FLOAT16_T__)
			if constexpr(type_info<T> == type_info<::std::float16_t>)
				return float16_float_info{};
		#endif
		#if defined(__STDCPP_FLOAT32_T__)
			if constexpr(type_info<T> == type_info<::std::float32_t>)
				return float32_float_info{};
		#endif
		#if defined(__STDCPP_FLOAT64_T__)
			if constexpr(type_info<T> == type_info<::std::float64_t>)
				return float64_float_info{};
		#endif
		#if defined(__STDCPP_FLOAT128_T__)
			#if defined(ELC_BASE_ENV_HAS_INT128)
				if constexpr(type_info<T> == type_info<::std::float128_t>)
					return float128_float_info{};
			#else
				//"float128_t is not supported"
			#endif
		#endif
		#if defined(__STDCPP_BFLOAT16_T__)
			if constexpr(type_info<T> == type_info<::std::bfloat16_t>)
				return bfloat16_float_info{};
		#endif
		if constexpr(type_info<T> == type_info<float>)
			return float32_float_info{};
		elseif constexpr(type_info<T> == type_info<double>)
			return float64_float_info{};
		elseif constexpr(type_info<T> == type_info<long double>){
			#if defined(_MSC_VER)//msvc上long double就是double
				return float64_float_info{};
			#elif defined(ELC_BASE_ENV_HAS_INT128)
				return float128_float_info{};
			#else
				//"long double is not supported"
			#endif
		}
	}
	template<basic_float_type T>
	using float_info=decltype(get_float_info<T>());

	//精确数部分的掩码
	template<basic_float_type T>
	constexpr auto precision_mask=float_info<T>::precision_mask;
	//精确数的无符号整数类型
	template<basic_float_type T>
	using precision_type=typename float_info<T>::precision_type;

	//浮点数的无符号整数数据类型
	template<basic_float_type T>
	using data_type=typename float_info<T>::data_type;

	//自浮点数获取精确数的基（如float是2^23，double是2^52，long double是2^112）
	template<basic_float_type T>
	constexpr auto precision_base=float_info<T>::precision_base;

	//自浮点数获取精确数的基的位数（如float是23）
	template<basic_float_type T>
	constexpr auto precision_base_bit=float_info<T>::precision_base_bit;

	//浮点数的指数部分的diff（如float是127，double是1023，long double是16383）
	template<basic_float_type T>
	constexpr auto exponent_diff=float_info<T>::exponent_diff;
	//浮点数的指数部分的min（如float是-126，double是-1022，long double是-16382）
	template<basic_float_type T>
	constexpr auto exponent_min=float_info<T>::exponent_min;
	//浮点数的指数部分的max（如float是127，double是1023，long double是16383）
	template<basic_float_type T>
	constexpr auto exponent_max=float_info<T>::exponent_max;

	//浮点数的指数部分的无符号整数类型
	template<basic_float_type T>
	using exponent_unsigned_type=typename float_info<T>::exponent_unsigned_type;
	//浮点数的指数部分的经过偏移后的有符号整数类型
	template<basic_float_type T>
	using exponent_type=typename float_info<T>::exponent_signed_type;
	//浮点数的指数部分的掩码
	template<basic_float_type T>
	constexpr auto exponent_mask=float_info<T>::exponent_mask;
}

//file_end

		#line 201 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
		namespace float_infos{
			template<basic_float_type T>
			union float_data_union{
				T v;
				data_type<T> data;
			};
			template<basic_float_type T>
			constexpr data_type<T> get_float_data(T v)noexcept{
				float_data_union<T> tmp;
				tmp.v=v;
				return tmp.data;
			}
			template<basic_float_type T>
			constexpr T get_float_from_data(data_type<T> data)noexcept{
				float_data_union<T> tmp;
				tmp.data=data;
				return tmp.v;
			}
		}
		//自浮点数获取原生精确数部分，舍去指数和符号位
		template<basic_float_type T>
		force_inline constexpr auto get_native_precision(T v)noexcept{
			using namespace float_infos;
			auto tmp=get_float_data(v);
			tmp&=precision_mask<T>;
			return tmp;
		}
		//自浮点数获取精确数的基（如float是2^23，double是2^52，long double是2^112）
		template<basic_float_type T>
		force_inline constexpr auto get_precision_base(T=T{})noexcept{
			return float_infos::precision_base<T>;
		}
		template<basic_float_type T>
		using float_precision_base_t = decltype(get_precision_base<T>());
		template<basic_float_type T>
		using float_exponent_t = signed_specific_size_fast_t<sizeof(float_infos::exponent_type<T>)+1>;
		//（基础的）自浮点数获取指数部分，舍去基数和符号位
		template<basic_float_type T>
		force_inline constexpr auto base_get_exponent(T v)noexcept{
			using namespace float_infos;
			auto tmp=get_float_data(v);
			tmp&=exponent_mask<T>;
			tmp>>=precision_base_bit<T>;
			return exponent_unsigned_type<T>(tmp);
		}
		//自浮点数获取原生指数部分，舍去基数和符号位
		template<basic_float_type T>
		force_inline constexpr float_infos::exponent_type<T> get_native_exponent(T v)noexcept{
			const auto tmp=base_get_exponent(v);
			using namespace float_infos;
			if(tmp==0)return exponent_min<T>;
			else return exponent_type<T>(tmp)-exponent_diff<T>;
		}
		//自浮点数获取基数
		template<basic_float_type T>
		force_inline constexpr float_precision_base_t<T> get_base_num(T v)noexcept{
			//特殊情况处理（exp=0时，base=0）
			const auto tmp=base_get_exponent(v);
			return tmp?get_precision_base(v):float_precision_base_t<T>{};
		}
		//自浮点数获取基数
		template<basic_float_type T>
		force_inline constexpr float_precision_base_t<T> get_precision(T v)noexcept{
			return get_native_precision(v)+get_base_num(v);
		}
		//自浮点数获取指数
		template<basic_float_type T>
		force_inline constexpr float_exponent_t<T> get_exponent(T v)noexcept{
			using namespace float_infos;
			return float_exponent_t<T>(get_native_exponent(v)) - precision_base_bit<T>;
		}
		//自浮点数获取基数和指数
		template<basic_float_type T>
		force_inline constexpr auto get_precision_and_exponent(T v)noexcept{
			struct precision_and_exponent_t{
				float_precision_base_t<T> precision;
				float_exponent_t<T>		  exponent;
			};
			const auto precision=get_precision(v);
			const auto exponent=get_exponent(v);
			return precision_and_exponent_t{precision,exponent};
		}
		//阈值
		template<basic_float_type T>
		constexpr auto threshold_precision_bit=float_infos::precision_base_bit<T>+1;
		//自基数和指数构造浮点数
		//num=base_num*2^exponent
		template<basic_float_type T>
		force_inline constexpr T make_float(float_precision_base_t<T> base_num,float_exponent_t<T> exponent)noexcept{
			using namespace float_infos;
			//首先将基数转换为precision_base（2^precision_base_bit）为分母的分数的分子
			//并在此过程中加减指数
			//需要注意的是，这里的基数是包含1的，所以转换目标是base_num>>precision_base_bit为1
			{
				const auto tmp=countl_zero(base_num);
				constexpr auto need_shift=bitnum_of(base_num)-threshold_precision_bit<T>;
				const float_exponent_t<T> shift=float_exponent_t<T>(tmp)-need_shift;
				if(shift>0){
					base_num<<=shift;
					exponent-=shift;
				}
				elseif(shift<0){
					base_num>>=-shift;
					exponent-=shift;
				}
			}
			//适当放缩后，需要偏移指数部分，原因如下：
			//原有逻辑是num=base_num*2^exponent，这是大分数的表达逻辑
			//但是浮点数的逻辑是num=(base_num/precision_base)*2^exponent
			//将precision_base合并到exponent中，即可得到浮点数的逻辑
			exponent+=precision_base_bit<T>;
			if(exponent < exponent_min<T>){//指数过小，需要舍去
				const auto diff=exponent_min<T> - exponent;
				base_num>>=diff;
				exponent+=diff;
				if(!base_num)return 0;//基数过小，无法表示
			}
			if(exponent>exponent_max<T>)return 0;//指数过大，无法表示
			//DEN情况判断
			const bool is_den=!(base_num>>precision_base_bit<T>);//若基数最高位为0，则exponent一定为exponent_min，不用判断
			if(is_den)
				return get_float_from_data<T>(base_num);
			else{//非DEN情况下，根据浮点数表示规则去掉基数多余的1
				const auto exp=exponent_unsigned_type<T>(exponent+exponent_diff<T>);
				base_num-=get_precision_base<T>();
				data_type<T> data=base_num;
				data|=data_type<T>(exp)<<precision_base_bit<T>;
				return get_float_from_data<T>(data);
			}
		}
		//若可以，将浮点数分解为两数之商
		template<basic_float_type T,size_t max_numerator = 1u<<7,size_t max_denominator = 1u<<17>
		force_inline constexpr auto to_divide(T v)noexcept{
			struct divide_t{
				T numerator;
				size_t denominator;
			private:
				bool _success;
			public:
				constexpr divide_t(T numerator,size_t denominator)noexcept:_success(true),numerator(numerator),denominator(denominator){}
				constexpr divide_t()noexcept:_success(false),numerator(0),denominator(0){}
				[[nodiscard]]constexpr bool success()const noexcept{
					return _success;
				}
				[[nodiscard]]constexpr explicit operator bool()const noexcept{
					return success();
				}
			};
			T integer_part;
			const auto fraction_part=std::modf(v,&integer_part);
			if(fraction_part==0)return divide_t{integer_part,1u};
			//开始测试分数
			size_t numerator=1;
			while(numerator<max_numerator){
				const auto denominator = to_size_t(numerator/fraction_part);
				if(denominator<=max_denominator)//忽略分母过大的情况
				if(is_close(T(numerator)/denominator,fraction_part))//近似相等即可
				if(gcd(numerator,denominator)==1)//不进行重复检查
				{
					//补正整数部分
					const auto numerator_with_inter = integer_part*denominator+numerator;
					//检查是否能够转换回
					const auto f_test = T(numerator_with_inter)/denominator;
					if(f_test==fraction_part)
						return divide_t{numerator_with_inter,denominator};
				}
				numerator++;
			}
			return divide_t{};
		}
	}
	using basic_environment::bit_type;
	using basic_environment::is_rounding_bit;

	using basic_environment::basic_uintmax_t;
	using basic_environment::basic_intmax_t;
	using basic_environment::uintmax_index_t;
	using basic_environment::intmax_index_t;
	using basic_environment::uintmax_t;
	using basic_environment::intmax_t;
	#if defined(ELC_BASE_ENV_HAS_INT128)
	using basic_environment::uint128_t;
	using basic_environment::int128_t;
	using basic_environment::operator""_u128;
	using basic_environment::operator""_i128;
	#endif
	using basic_environment::is_elc_expansion_base_type;

	using basic_environment::unsigned_specific_size_t;
	using basic_environment::unsigned_specific_size_fast_t;
	using basic_environment::signed_specific_size_t;
	using basic_environment::signed_specific_size_fast_t;

	using basic_environment::to_arithmetic;

	using basic_environment::wchar_t_same_as_char_t;
	using basic_environment::wchar_t_same_as_char16_t;

	using basic_environment::add_carry;
	using basic_environment::sub_borrow;

	using basic_environment::get_exponent;
	using basic_environment::get_precision;
	using basic_environment::float_precision_base_t;
	using basic_environment::float_exponent_t;
	using basic_environment::get_precision_and_exponent;
	using basic_environment::make_float;
	using basic_environment::to_divide;

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_undefs.hpp"
//defs at "_defs.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_PUBLIC_ALL)
	#undef protected
	#undef private
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef times
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef exlambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS
#undef lambda_inline
#undef lambda_force_inline

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_undefs.hpp"

#undef HAS_GCC_BUILTINS
#undef HAS_MSVC_INTRINSICS
#undef HAS_X86_ASM
#undef HAS_X86_64_ASM
#undef HAS_ARM_ASM
#undef HAS_ARM64_ASM

//file_end

	#line 411 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
}

//file_end

#line 81 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
namespace elc::defs{ //在elc::defs中定义内容
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_PUBLIC_ALL)
	#define protected public
	#define private public
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#define times(...) ([[maybe_unused]]auto [loop_times,loop_end_value] : ::elc::defs::times_provider_t(__VA_ARGS__)) //for times(72)do_something;
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name,...) \
exlambda(auto&&...Args)__VA_ARGS__ lambda_force_inline{\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define exlambda [&]
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#if defined(_MSC_VER) && !defined(__clang__)
	#define lambda_inline [[msvc::forceinline]]
	#define lambda_force_inline [[msvc::forceinline]]
#elif
	#define lambda_inline [[gnu::always_inline]]
	#define lambda_force_inline [[gnu::always_inline]]
#else
	#define lambda_inline
	#define lambda_force_inline
#endif

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
	#define in_debug 1
#else
	#define not_in_debug 1
	#define in_debug 0
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 83 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"


	namespace base{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/arithmetic_type_info_prover.hpp"
//arithmetic_type_info_prover.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/arithmetic_type_info_prover.hpp"
namespace math{
	template<typename T>
	struct arithmetic_type_info_prover{
		//bool：是否是算数类型
		static constexpr bool is_arithmetic_type=::std::is_arithmetic_v<T> || is_elc_expansion_base_type<T>;
		//bool：是否是基础类型
		static constexpr bool is_basic_type=::std::is_arithmetic_v<T>;
		//bool：是否是大数类型
		static constexpr bool is_big_type=false;
		//bool：是否是浮点类型
		static constexpr bool is_float_type=::std::is_floating_point_v<T>;
		//浮点数类型：是指数记录法还是分数记录法
		static constexpr bool is_exponent_float_type=is_float_type;
		static constexpr bool is_fraction_float_type=false;
		//bool：是否是整数类型
		static constexpr bool is_integer_type=::std::is_integral_v<T>;
		//bool：是否是有符号类型
		static constexpr bool is_signed=::std::is_signed_v<T>;
		//bool：是否有NaN
	private:
		static constexpr bool has_quiet_NaN_helper()noexcept{
			if constexpr(is_arithmetic_type)
				return ::std::numeric_limits<T>::has_quiet_NaN;
			else
				return false;
		}
		static constexpr bool has_signaling_NaN_helper()noexcept{
			if constexpr(is_arithmetic_type)
				return ::std::numeric_limits<T>::has_signaling_NaN;
			else
				return false;
		}
	public:
		static constexpr bool has_quiet_NaN=has_quiet_NaN_helper();
		static constexpr bool has_signaling_NaN=has_signaling_NaN_helper();
		static constexpr bool has_NaN=has_quiet_NaN || has_signaling_NaN;

		static constexpr auto quiet_NaN()noexcept requires(has_quiet_NaN){
			return ::std::numeric_limits<T>::quiet_NaN();
		}
		static constexpr auto signaling_NaN()noexcept requires(has_signaling_NaN){
			return ::std::numeric_limits<T>::signaling_NaN();
		}
		static constexpr auto NaN()noexcept requires(has_NaN){
			if constexpr(has_quiet_NaN)
				return quiet_NaN();
			else
				return signaling_NaN();
		}
		//bool：是否有inf
	private:
		static constexpr bool has_inf_helper()noexcept{
			if constexpr(is_arithmetic_type)
				return ::std::numeric_limits<T>::has_infinity;
			else
				return false;
		}
	public:
		static constexpr bool has_inf=has_inf_helper();
		static constexpr auto Inf()noexcept requires(has_inf){
			return ::std::numeric_limits<T>::infinity();
		}
		static constexpr auto negative_Inf()noexcept requires(has_inf){
			return -Inf();
		}
	public:
		//bool：是否有最小值
		static constexpr bool has_min=is_arithmetic_type;
		//bool：是否有最大值
		static constexpr bool has_max=is_arithmetic_type;
	public:
		static constexpr auto min()noexcept requires(has_min){
			if constexpr(is_float_type)
				return ::std::numeric_limits<T>::lowest();
			else
				return ::std::numeric_limits<T>::min();
		}
		static constexpr auto max()noexcept requires(has_max){
			return ::std::numeric_limits<T>::max();
		}
	public:
		//bool：是否有默认极限值
		static constexpr bool has_epsilon=is_arithmetic_type;
	public:
		static constexpr auto epsilon()noexcept requires(has_epsilon){
			return ::std::numeric_limits<T>::epsilon();
		}
	public:
		//对应的无符号和有符号类型
		using unsigned_type=decltype(lambda{
			if constexpr(type_info<T> == type_info<bool>)
				return T();
			elseif constexpr(is_float_type)//基础浮点类型没有对应的无符号
				return T();
			elseif constexpr(is_integer_type)//考虑到charX_t，所有整数类型都应该过一遍make_unsigned_t
				return::std::make_unsigned_t<T>();
		}());
		using signed_type=decltype(lambda{
			if constexpr(type_info<T> == type_info<bool>)
				return T();
			elseif constexpr(is_float_type)
				return T();
			elseif constexpr(is_integer_type)//同上
				return::std::make_signed_t<T>();
		}());
		//对应的浮点数类型
		using float_type=decltype(lambda{
			if constexpr(is_float_type)
				return T();
			elseif constexpr(is_integer_type)
				return .0;
		}());
	};
}

//file_end

		#line 87 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/bit.hpp"
//bit.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/bit.hpp"
namespace bit{
	push_and_disable_msvc_warning(26475);//强制转换警告diss
	// npos!
	/// 用以指定不存在的位置
	template<unsigned_basic_integer_type T>
	constexpr T npos_of=T(-1);
	pop_msvc_warning();
	constexpr auto npos=npos_of<size_t>;
	/// 位操作：循环左移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr auto rotl_nomod(const T v,const auto R)noexcept;
	#define rot_base(opt,antiopt) static_cast<T>(static_cast<T>(v opt r) | static_cast<T>(v antiopt (d - r)))
	/// 位操作：循环右移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr auto rotr_nomod(const T v,const auto r)noexcept{
		constexpr auto d = ::std::numeric_limits<T>::digits;
		if constexpr(unsigned_type<decltype(r)>){
			if(r)
				return rot_base(>>,<<);
			else
				return v;
		}
		else{
			if(r>0)
				return rot_base(>>,<<);
			elseif(r==0)
				return v;
			else//r<0
				return rotl_nomod(v,0-r);
		}
	}
	/// 位操作：循环左移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr auto rotl_nomod(const T v,const auto r)noexcept{
		constexpr auto d = ::std::numeric_limits<T>::digits;
		if constexpr(unsigned_type<decltype(r)>){
			if(r)
				return rot_base(<<,>>);
			else
				return v;
		}
		else{
			if(r>0)
				return rot_base(<<,>>);
			elseif(r==0)
				return v;
			else//r<0
				return rotr_nomod(v,0-r);
		}
	}
	#undef rot_base
	/// 位操作：循环右移
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr auto rotr(const T v,const auto R)noexcept{
		constexpr auto d = ::std::numeric_limits<T>::digits;
		const auto r = mod(R,d);
		return rotr_nomod(v,r);
	}
	/// 位操作：循环左移
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr auto rotl(const T v,const auto R)noexcept{
		constexpr auto d = ::std::numeric_limits<T>::digits;
		const auto r = mod(R,d);
		return rotl_nomod(v,r);
	}
	template<unsigned_basic_integer_type T>
	class rot_iterator{
		static constexpr auto rot_offset_npos = ::std::numeric_limits<T>::digits;//d
		size_t _offset;
	public:
		force_inline constexpr rot_iterator(size_t offset)noexcept:_offset(offset%rot_offset_npos){}
		force_inline constexpr rot_iterator&operator++()noexcept{
			_offset++;
			if(_offset==rot_offset_npos)
				_offset=0;
			return*this;
		}
		force_inline constexpr rot_iterator&operator--()noexcept{
			if(_offset==0)
				_offset=rot_offset_npos;
			_offset--;
			return*this;
		}
		force_inline constexpr rot_iterator operator++(int)noexcept{
			rot_iterator tmp(*this);
			operator++();
			return tmp;
		}
		force_inline constexpr rot_iterator operator--(int)noexcept{
			rot_iterator tmp(*this);
			operator--();
			return tmp;
		}
		[[nodiscard]]force_inline constexpr size_t value()const noexcept{
			return _offset;
		}
	};
	/// 位操作：循环左移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr auto rotl_nomod(const T v,const rot_iterator<T>&r)noexcept{
		return rotl_nomod(v,r.value());
	}
	/// 位操作：循环右移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr auto rotr_nomod(const T v,const rot_iterator<T>&r)noexcept{
		return rotr_nomod(v,r.value());
	}
	/// 位操作：循环左移
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr auto rotl(const T v,const rot_iterator<T>&r)noexcept{
		return rotl_nomod(v,r);
	}
	/// 位操作：循环右移
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr auto rotr(const T v,const rot_iterator<T>&r)noexcept{
		return rotr_nomod(v,r);
	}
	/// 获取位数
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr size_t get_bitnum(const T v)noexcept{
		if constexpr(sizeof(T)!=1){//优化
			typedef unsigned_specific_size_t<sizeof(T)/2> half_t;
			constexpr size_t half_bitnum = bitnum_of(half_t);
			const half_t high = half_t(v>>half_bitnum);
			if(high)
				return half_bitnum+get_bitnum(high);
			else
				return get_bitnum(half_t(v));
		}
		else
			//默认通用实现
			return v?get_bitnum(T(v>>1))+1:0;
	}
	/// 获取位数
	template<signed_basic_integer_type T>
	[[nodiscard]]force_inline constexpr size_t get_bitnum(const T v)noexcept{
		return get_bitnum(abs(v));
	}
	/// countl_zero
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr size_t countl_zero(const T v)noexcept{
		if constexpr(sizeof(T)!=1){//优化
			typedef unsigned_specific_size_t<sizeof(T)/2> half_t;
			constexpr size_t half_bitnum = bitnum_of(half_t);
			const half_t high = half_t(v>>half_bitnum);
			if(high)
				return countl_zero(high);
			else
				return half_bitnum+countl_zero(half_t(v));
		}
		else
			//默认通用实现
			return bitnum_of(T)-get_bitnum(v);
	}
	/// countr_one
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr size_t countr_one(const T v)noexcept{
		if constexpr(sizeof(T)!=1){//优化
			typedef unsigned_specific_size_t<sizeof(T)/2> half_t;
			constexpr size_t half_bitnum = bitnum_of(half_t);
			const half_t low = half_t(v);
			if(low == half_t(-1))
				return half_bitnum+countr_one(half_t(v>>half_bitnum));
			else
				return countr_one(low);
		}
		else
			//默认通用实现
			return v&1?countr_one(T(v>>1))+1:0;
	}
	/// countl_one
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr size_t countl_one(const T v)noexcept{
		if constexpr(sizeof(T)!=1){//优化
			typedef unsigned_specific_size_t<sizeof(T)/2> half_t;
			constexpr size_t half_bitnum = bitnum_of(half_t);
			const half_t high = half_t(v>>half_bitnum);
			if(high == half_t(-1))
				return half_bitnum+countl_one(half_t(v));
			else
				return countl_one(high);
		}
		else{
			//默认通用实现
			//return countl_zero(T(~v));，或者
			constexpr T first_bit = T(1)<<(bitnum_of(T)-1);
			return v&first_bit?countl_one(T(v<<1))+1:0;
		}
	}
	/// countr_zero
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr size_t countr_zero(const T v)noexcept{
		if constexpr(sizeof(T)!=1){//优化
			typedef unsigned_specific_size_t<sizeof(T)/2> half_t;
			constexpr size_t half_bitnum = bitnum_of(half_t);
			const half_t low = half_t(v);
			if(low)
				return countr_zero(low);
			else
				return half_bitnum+countr_zero(half_t(v>>half_bitnum));
		}
		else
			//默认通用实现
			return countr_one(T(~v));
	}
	/// is_all_bit_one
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr bool all_bit_is_one(const T v)noexcept{
		return v==npos_of<T>;
	}
	/// is_all_bit_zero
	template<unsigned_basic_integer_type T>
	[[nodiscard]]force_inline constexpr bool all_bit_is_zero(const T v)noexcept{
		return v;
	}
}
using bit::npos_of;
using bit::npos;
using bit::rotl;
using bit::rotr;
using bit::rotl_nomod;
using bit::rotr_nomod;
using bit::rot_iterator;
using bit::get_bitnum;
using bit::countl_zero;
using bit::countr_zero;
using bit::countl_one;
using bit::countr_one;
using bit::all_bit_is_one;
using bit::all_bit_is_zero;

//file_end

		#line 88 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/null_ptr.hpp"
//null_ptr.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/null_ptr.hpp"
namespace null_ptr_n{
	/*!
	提醒子类定义者重载get_null_ptr.
	*/
	special_attribute_t can_t_use_default_null_ptr{};

	/*!
	可不重载get_null_ptr
	在此类ref_able或weak_ref_able时，意味着使用者**保证**所有指向此类的实例的ptr都不可为null_ptr
	否则将内存访问错误
	*/
	special_attribute_t force_use_default_null_ptr:can_t_use_default_null_ptr{};

	enable_adl(the_get_null_ptr);
	template<typename T>
	[[nodiscard]]constexpr auto get_null_ptr()noexcept{
		push_and_disable_msvc_warning(26462);//貌似msvc在这里有bug
		constexpr auto null_as_T = static_cast<T*>(nullptr);
		if constexpr(was_not_an_ill_form(the_get_null_ptr(null_as_T)))
			return the_get_null_ptr(null_as_T);
		elseif constexpr(type_info<T>.has_attribute(can_t_use_default_null_ptr)&&type_info<T>.not_has_attribute(force_use_default_null_ptr)){
			template_error("please overload the function the_get_null_ptr in the namespace where this type is defined.");
			return null_as_T;
		}
		else
			return null_as_T;
		pop_msvc_warning();
	}


	/*!
	字面量null_ptr，如同nullptr使用即可.
	*/
	constexpr struct null_ptr_t{
		template<typename T>
		[[nodiscard]]constexpr_as(get_null_ptr<remove_cvref<T>>())auto base_get()const noexcept{return get_null_ptr<remove_cvref<T>>();}
		template<typename T>
		[[nodiscard]]constexpr_as(base_get<T>())operator T*()const noexcept{return down_cast<T*>(base_get<T>());}
		//constexpr operator decltype(nullptr)()const noexcept{return nullptr;}//提醒接口设计者注意null_ptr的重载版本.
	}null_ptr{};

	template<typename T,typename U=decltype(*null_ptr.base_get<T>())>
	[[nodiscard]]auto operator==(T*a,null_ptr_t)noexcept{
		return null_ptr.base_get<T>()==static_cast<const remove_ref<U>*>(add_const(a));
	}
}
using null_ptr_n::can_t_use_default_null_ptr;
using null_ptr_n::force_use_default_null_ptr;
using null_ptr_n::null_ptr;
typedef decltype(null_ptr) null_ptr_t;
typedef decltype(nullptr) nullptr_t;

//file_end

		#line 89 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/note.hpp"
//note.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/note.hpp"
namespace note_n{
	#define def_note(name) \
	template<typename T>\
	struct name##_t{\
		T value;\
		force_inline constexpr name##_t(T a)noexcept:value(a){}\
		template<class U>\
		force_inline constexpr name##_t(name##_t<U>a)noexcept:value(a.value){}\
		force_inline constexpr operator T()noexcept{return value;}\
		force_inline constexpr T operator()()noexcept{return value;}\
	};\
	template<typename T>\
	constexpr name##_t<T>name(T v){return{v};}

	def_note(from);
	def_note(to);
	def_note(size_type);

	#undef def_note
	typedef size_type_t<::size_t> size_t;
	constexpr size_t size(::size_t v){return{v};}
	constexpr struct fail_t{}fail{};
}
namespace note=note_n;

//file_end

		#line 90 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/array_like.hpp"
//array_like.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/array_like.hpp"
namespace array_like_n{
	enable_adl(size_of_array_like);
	template<class T>
	[[nodiscard]]inline constexpr size_t size_of_array_like(T&&)noexcept{return 1;}
	template<class T,size_t N>
	[[nodiscard]]inline constexpr size_t size_of_array_like(T(&)[N])noexcept{return N;}
	template<class T>
	[[nodiscard]]inline size_t size_of_array_like(::std::initializer_list<T>&a)noexcept{return a.size();}

	enable_adl(begin_of_array_like);
	template<class T>
	[[nodiscard]]inline constexpr auto begin_of_array_like(T&&a)noexcept{return addressof(a);}
	template<class T,size_t N>
	[[nodiscard]]inline constexpr auto begin_of_array_like(T(&a)[N])noexcept{return addressof(a[0]);}
	template<class T>
	[[nodiscard]]inline const T* begin_of_array_like(::std::initializer_list<T>&a)noexcept{return a.begin();}

	enable_adl(end_of_array_like);
	template<class T>
	[[nodiscard]]inline auto end_of_array_like(T&&a)noexcept{return begin_of_array_like(a)+size_of_array_like(a);}

	template<class T>
	concept is_array_like=was_not_an_ill_form_with_parameter(
									(T v){
										begin_of_array_like(v);
										size_of_array_like(v);
									}
								);

	template<class T>
	concept is_signal_value_for_array_like=type_info<remove_cvref<decltype(*begin_of_array_like(declvalue(T)))>> == type_info<T>;
	template<class T>
	concept is_not_signal_value_for_array_like=!is_signal_value_for_array_like<T>;

	template<class T,class U>
	constexpr bool strict_is_array_like_for=was_not_an_ill_form_with_parameter(
										(U v){
											begin_of_array_like<T>(v);
											size_of_array_like<T>(v);
										}
									);
	template<class T,class U>
	constexpr bool is_array_like_for=strict_is_array_like_for<T,U>||strict_is_array_like_for<const T,U>;

	template<class T>
	struct array_like_view_t{
		typedef T* iterator;
		typedef const T* const_iterator;
		typedef array_like_view_t<T>this_t;
		struct reverse_iterator{
			T* _m;
			constexpr reverse_iterator(T*p)noexcept:_m(p){}
			constexpr reverse_iterator(const reverse_iterator&)noexcept=default;
			constexpr reverse_iterator(reverse_iterator&&)noexcept=default;
			constexpr reverse_iterator operator++()noexcept{_m--;return *this;}
			constexpr reverse_iterator operator--()noexcept{_m++;return *this;}
			constexpr reverse_iterator operator++(int)noexcept{auto tmp=*this;this->operator++();return tmp;}
			constexpr reverse_iterator operator--(int)noexcept{auto tmp=*this;this->operator--();return tmp;}
			[[nodiscard]]constexpr T& operator*()const noexcept{return*_m;}
			[[nodiscard]]constexpr T& operator[](ptrdiff_t a)const noexcept{return*(_m-a);}
			[[nodiscard]]constexpr T* operator->()const noexcept{return _m;}
			[[nodiscard]]constexpr reverse_iterator operator+(ptrdiff_t diff)const noexcept{return _m-diff;}
			[[nodiscard]]constexpr reverse_iterator operator-(ptrdiff_t diff)const noexcept{return _m+diff;}
			[[nodiscard]]constexpr operator T*()const noexcept{return _m;}
			[[nodiscard]]constexpr bool operator==(T*p)const noexcept{return _m==p;}
			[[nodiscard]]constexpr bool operator==(const reverse_iterator&a)const noexcept{return _m==a._m;}
			[[nodiscard]]constexpr auto operator<=>(T*p)noexcept{return _m<=>p;}
			[[nodiscard]]constexpr bool operator<=>(const reverse_iterator&a)const noexcept{return a._m<=>_m;}
		};
	private:
		T*_begin=nullptr;
		size_t _size=0;
	public:
		constexpr explicit array_like_view_t(T*a,size_t b)noexcept:_begin(a),_size(b){}
		template<class U> requires strict_is_array_like_for<T,U>
		explicit constexpr_as_auto array_like_view_t(U&&a)noexcept_as(begin_of_array_like<T>(a),size_of_array_like<T>(a)):array_like_view_t(begin_of_array_like<T>(a),size_of_array_like<T>(a)){}
		constexpr array_like_view_t(const this_t&)noexcept=default;

		void swap_with(this_t&b)noexcept_as(swap(_begin,b._begin),swap(_size,b._size)){
			swap(_begin,b._begin);
			swap(_size,b._size);
		}

		[[nodiscard]]constexpr const_iterator data()const noexcept{return _begin;}
		[[nodiscard]]constexpr size_t size()const noexcept{return _size;}

		[[nodiscard]]constexpr iterator begin()noexcept requires(type_info<iterator>!=type_info<const_iterator>){return _begin;}
		[[nodiscard]]constexpr iterator end()noexcept requires(type_info<iterator>!=type_info<const_iterator>){return begin()+size();}
		[[nodiscard]]constexpr const_iterator begin()const noexcept{return _begin;}
		[[nodiscard]]constexpr const_iterator end()const noexcept{return begin()+size();}

		[[nodiscard]]constexpr const_iterator cbegin()const noexcept{return remove_const(this)->begin();}
		[[nodiscard]]constexpr const_iterator cend()const noexcept{return remove_const(this)->end();}

		[[nodiscard]]constexpr reverse_iterator rbegin()noexcept{return _begin+size()-1;}
		[[nodiscard]]constexpr reverse_iterator rend()noexcept{return _begin-1;}

		[[nodiscard]]constexpr T&front()noexcept{return _begin[0];}
		[[nodiscard]]constexpr const T&front()const noexcept{return _begin[0];}
		[[nodiscard]]constexpr T&back()noexcept{return _begin[size()-1];}
		[[nodiscard]]constexpr const T&back()const noexcept{return _begin[size()-1];}

		[[nodiscard]]constexpr bool empty()const noexcept{return!size();}

		[[nodiscard]]constexpr T&operator[](size_t pos)noexcept{return begin()[pos];}
		[[nodiscard]]constexpr const T&operator[](size_t pos)const noexcept{return remove_const(*this)[pos];}

		[[nodiscard]]constexpr auto operator<=>(this_t a)const noexcept(compare.nothrow<T>){
			return compare(_begin,_size,a._begin,a._size);
		}
		[[nodiscard]]constexpr auto operator==(this_t a)const noexcept(equal.nothrow<T>){
			return equal(_begin,_size,a._begin,a._size);
		}

		[[nodiscard]]constexpr this_t subview(size_t pos,size_t end_pos)noexcept{
			if(end_pos>size())end_pos=size();
			if(pos>end_pos)pos=end_pos;
			return this_t{_begin+pos,end_pos-pos};
		}
		[[nodiscard]]constexpr this_t subview(size_t pos)noexcept{
			if(pos>size())pos=size();
			return this_t{_begin+pos,size()-pos};
		}
	};
	template<typename T>
	struct array_end_by_zero_t:array_like_view_t<T>{
		typedef array_like_view_t<T>base_t;
		using base_t::base_t;

		[[nodiscard]]static constexpr size_t get_length_of(T*ptr)noexcept{
			if(*ptr)return get_length_of(ptr+1)+1;
			else return 0;
		}

		constexpr array_end_by_zero_t(T*ptr)noexcept:base_t(ptr,get_length_of(ptr)){}
	};

	template<class T>
	[[nodiscard]]inline constexpr T* begin_of_array_like(array_like_view_t<T>&a)noexcept requires(type_info<T>!=type_info<const T>){return a.begin();}
	template<class T>
	[[nodiscard]]inline constexpr auto begin_of_array_like(const array_like_view_t<T>&a)noexcept{return a.begin();}
	template<class T>
	[[nodiscard]]inline constexpr T* begin_of_array_like(array_like_view_t<remove_cv<T>>&a)noexcept{return a.begin();}
	template<class T>
	[[nodiscard]]inline constexpr size_t size_of_array_like(const array_like_view_t<T>&a)noexcept{return a.size();}
}
using array_like_n::size_of_array_like;
using array_like_n::begin_of_array_like;
using array_like_n::end_of_array_like;
using array_like_n::is_array_like;
using array_like_n::is_signal_value_for_array_like;
using array_like_n::is_not_signal_value_for_array_like;
using array_like_n::is_array_like_for;
using array_like_n::strict_is_array_like_for;
using array_like_n::array_like_view_t;
using array_like_n::array_end_by_zero_t;

//file_end

		#line 91 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/data.hpp"
//data.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/data.hpp"
/*!
	每个T的可能性大小
*/
template<basic_integer_type T>
constexpr auto number_of_possible_values_per=uintmax_index_t(max(type_info<::std::make_unsigned_t<T>>))+1;

/*!
	功能: byte* 类型数据转换为 T&，不进行任何检查
	用法: data_cast<T>(byte*) -> T&
*/
template<class T>
[[nodiscard]]force_inline constexpr T&data_cast(byte*p)noexcept{return*reinterpret_cast<T*>(p);}
template<class T>
[[nodiscard]]force_inline constexpr T&launder_data_cast(byte*p)noexcept{return*::std::launder(data_cast<T>(p));}
/*!
	功能: byte* 类型数据转换为 T*，不进行任何检查
	用法: data_ptr_cast<T>(byte*) -> T*
*/
template<class T>
[[nodiscard]]force_inline constexpr T*data_ptr_cast(byte*p)noexcept{return reinterpret_cast<T*>(p);}
template<class T>
[[nodiscard]]force_inline constexpr T*launder_data_ptr_cast(byte*p)noexcept{return ::std::launder(data_ptr_cast<T>(p));}
/*!
	功能: T* 指针转换为 byte*，不进行任何检查
	用法: cast_to_data(T*) -> byte*
*/
template<class T>
[[nodiscard]]force_inline constexpr byte*cast_to_data(T*p)noexcept{return reinterpret_cast<byte*>(p);}
template<class T>
[[nodiscard]]force_inline constexpr byte*launder_cast_to_data(T*p)noexcept{return ::std::launder(cast_to_data(p));}
/*!
	功能: const T* 指针转换为 const byte*，不进行任何检查
	用法: cast_to_data(const T*) -> const byte*
*/
template<class T>
[[nodiscard]]force_inline constexpr const byte*cast_to_data(const T*p)noexcept{return reinterpret_cast<const byte*>(p);}
template<class T>
[[nodiscard]]force_inline constexpr const byte*launder_cast_to_data(const T*p)noexcept{return ::std::launder(cast_to_data(p));}
/*!
	功能: T& 转换为 U&，不进行任何检查
	用法: union_cast<U>(T&) -> U&
*/
template<class U,class T>
[[nodiscard]]force_inline constexpr U&union_cast(T&&t)noexcept{return*reinterpret_cast<U*>(&t);}
template<class U,class T>
[[nodiscard]]force_inline constexpr U&launder_union_cast(T&&t)noexcept{return*::std::launder(union_cast<U>(t));}

/*!
	功能: data_block辅助变量模板，接受数个类型并表现为其中的最大对齐值
*/
template<class...Ts>
inline constexpr size_t max_align_of=max({alignof(Ts)...});
/*!
	功能: data_block辅助变量模板，接受数个类型并表现为其中的最大大小值
*/
template<class...Ts>
inline constexpr size_t max_size_of=max({sizeof(Ts)...});
//byteset
template<size_t byte_num,size_t align=alignof(byte)>
struct byteset:non_copy_construct_able,non_move_construct_able{
	push_and_disable_msvc_warning(4324);
	alignas(align)byte _data[byte_num];
	pop_msvc_warning();

	push_and_disable_msvc_warning(26495);
	force_inline constexpr byteset()noexcept{
		if in_consteval
			for(size_t i=0;i<byte_num;++i)
				_data[i]=byte{};
	};
	template<class T> requires(sizeof(T)<=byte_num&&alignof(T)<=align)
	force_inline constexpr byteset(T&&t)noexcept{
		data_cast<T>(_data)=forward<T>(t);
		if constexpr(sizeof(T)<byte_num)
			if in_consteval
				for(size_t i=sizeof(T);i<byte_num;++i)
					_data[i]=byte{};
	}
	pop_msvc_warning();
	force_inline constexpr operator byte*()noexcept{return _data;}
	force_inline constexpr operator const byte*()const noexcept{return _data;}
	template<class T> requires(sizeof(T)<=byte_num&&alignof(T)<=align)
	force_inline constexpr auto&operator=(T&&t)noexcept{
		return data_cast<remove_cvref<T>>(_data)=forward<T>(t);
	}
	//begin & end
	force_inline constexpr byte*begin()noexcept{return _data;}
	force_inline constexpr byte*end()noexcept{return _data+byte_num;}
	force_inline constexpr const byte*begin()const noexcept{return _data;}
	force_inline constexpr const byte*end()const noexcept{return _data+byte_num;}
};
/*!
	功能: data_block类模板,接受多个类型参数,实例化为内含最大体积最大对齐要求的byte数组的结构体
			data_block -> byte*
	用法: data_block<T1,T2,...>value;
*/
template<class...Ts>
struct data_block:byteset<max_size_of<Ts...>,max_align_of<Ts...>>{
	static constexpr size_t size=max_size_of<Ts...>;
	static constexpr size_t align=max_align_of<Ts...>;
};
/*!
	功能: data_block辅助类模板，接受一个size_t描述对齐大小的类型模板
*/
push_and_disable_msvc_warning(4324);
template<class...Ts>
struct alignas(max_align_of<Ts...>)align_as_t{};
pop_msvc_warning();

/*!
	功能: data_view类模板,接受一个类型参数，提供对byte数组的访问和遍历
	用法: data_view<T>value{&value};
*/
template<class T>
struct data_view:array_like_view_t<byte>{
	using array_like_view_t<byte>::array_like_view_t;
	constexpr data_view(T*p)noexcept:array_like_view_t<byte>{cast_to_data(p),sizeof(T)}{}
};
template<class T>
struct data_view<const T>:array_like_view_t<const byte>{
	using array_like_view_t<const byte>::array_like_view_t;
	constexpr data_view(const T*p)noexcept:array_like_view_t<const byte>{cast_to_data(p),sizeof(T)}{}
};

/*!
	功能: 比较两个类实例在内存中的内容是否相同
	用法: full_equal_in_byte(const T&a,const T&b) -> bool
*/
template<class T>
[[nodiscard]]constexpr bool full_equal_in_byte(const T&a,const T&b)noexcept{
	return equal(cast_to_data(&a),cast_to_data(&b),sizeof(T));
}

//file_end

		#line 92 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/pointer.hpp"
//pointer.hpp
//at namespace elc::defs::base
#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/pointer.hpp"
enable_adl(the_pointer_to_bool);
/// 指针转bool的重载接口，允许类对此进行自定义
/// elc内部的指针转bool应当视情况使用默认配置或此重载接口
template<typename T>
[[nodiscard]]constexpr auto pointer_to_bool(T*a)noexcept{
	if constexpr(was_not_an_ill_form(the_pointer_to_bool(a)))
		return the_pointer_to_bool(a);
	else
		return null_ptr!=a;
}

enable_adl(the_pointer_equal);
/// 指针比较的重载接口，允许类对此进行自定义
/// elc内部的指针比较应当视情况使用默认配置或此重载接口
template<typename T>
[[nodiscard]]constexpr auto pointer_equal(T*a,T*b)noexcept{
	if constexpr(was_not_an_ill_form(the_pointer_equal(a,b)))
		return the_pointer_equal(a,b);
	else
		return a==b;
}

/// 判断类型是否为指针
template<class T>
concept is_pointer= ::std::is_pointer_v<T>;
/// 未知类型指针
typedef void*pointer;
/// 未知类型指针，不可写
typedef const void*const_pointer;

/// 获取两个指针的偏移
[[nodiscard]]constexpr ptrdiff_t get_off_set(note::from_t<const_pointer>a,note::to_t<const_pointer>b)noexcept{
	return cast_to_data(b())-cast_to_data(a());//b-a == c
}
/// 应用偏移
template<class T>
[[nodiscard]]constexpr auto apply_off_set(T*a,ptrdiff_t c)noexcept{
	return cast_to_data(a)+c;//a+c == b
}
/// 反向应用偏移
template<class T>
[[nodiscard]]constexpr auto unapply_off_set(T*b,ptrdiff_t c)noexcept{
	return cast_to_data(b)-c;//b-c == a
}

//file_end

		#line 93 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/zero.hpp"
//zero.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/zero.hpp"
/*!
没什么用的语法糖,等价于字面量0.
*/
constexpr struct zero_t{
	template<class T> requires(type_info<decltype(0)>.can_convert_to<T>)
	operator T()const noexcept(type_info<decltype(0)>.can_nothrow_convert_to<T>){return 0;}
}zero{};

/*!
Returns true if all bytes in the input are zero.

@param a The input value.

@returns True if all bytes in the input are zero.
*/
template<class T>
inline constexpr bool is_all_byte_zero(T&&a)noexcept{
	const byte*ptr=cast_to_data(addressof(a));
	const byte*end=ptr+sizeof(a);
	while(ptr!=end)
		if((unsigned char)(*ptr++))
			return false;
	return true;
}

//file_end

		#line 94 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
	}

	namespace memory{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/memory/lifetime/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/memory/lifetime/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/memory/lifetime/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/memory/lifetime/defs.hpp"
namespace lifetime_n{
	class copy_t;

	class move_t;
	//

	template<class T>
	class construct_t;
	template<class T,class...Args>
	concept construct_able=::std::is_constructible_v<T,Args...>;
	template<class T,class...Args>
	concept construct_nothrow=::std::is_nothrow_constructible_v<T,Args...>;
	template<class T,class...Args>
	concept construct_trivial=::std::is_trivially_constructible_v<T,Args...>;

	class destruct_t;
	template<class T>
	concept destruct_able=::std::is_destructible_v<T>;
	template<class T>
	concept destruct_nothrow=::std::is_nothrow_destructible_v<T>;
	template<class T>
	concept destruct_trivial=::std::is_trivially_destructible_v<T>;
	//

	class copy_construct_t;
	template<class T>
	concept copy_construct_able=::std::is_copy_constructible_v<T>;
	template<class T>
	concept copy_construct_nothrow=::std::is_nothrow_copy_constructible_v<T>;
	template<class T>
	concept copy_construct_trivial=::std::is_trivially_copy_constructible_v<T>;

	class move_construct_t;
	template<class T>
	concept move_construct_able=::std::is_move_constructible_v<T>;
	template<class T>
	concept move_construct_nothrow=::std::is_nothrow_move_constructible_v<T>;
	template<class T>
	concept move_construct_trivial=::std::is_trivially_move_constructible_v<T>;
	//

	class copy_assign_t;
	template<class T>
	concept copy_assign_able=::std::is_copy_assignable_v<T>;
	template<class T>
	concept copy_assign_nothrow=::std::is_nothrow_copy_assignable_v<T>;
	template<class T>
	concept copy_assign_trivial=::std::is_trivially_copy_assignable_v<T>;

	class move_assign_t;
	template<class T>
	concept move_assign_able=::std::is_move_assignable_v<T>;
	template<class T>
	concept move_assign_nothrow=::std::is_nothrow_move_assignable_v<T>;
	template<class T>
	concept move_assign_trivial=::std::is_trivially_move_assignable_v<T>;
	//

	template<class T> requires ::std::is_trivially_copyable_v<T>
	force_inline T* super_speed_trivial_copy_from_one(T*to,const T&value,size_t size)noexcept{
		if constexpr(sizeof(T)==sizeof(unsigned char))
			::std::memset((unsigned char*)to,(unsigned char)value,size);
		elseif constexpr(sizeof(T)==sizeof(wchar_t))
			::std::wmemset((wchar_t*)to,(wchar_t)value,size);
		else
			if(is_all_byte_zero(value))
				::std::memset(to,zero,size*sizeof(T));
			else
				::std::fill_n(to,size,value);
		return to;
	}
	template<class T> requires ::std::is_trivially_copyable_v<T>
	force_inline T* super_speed_trivial_copy_from_one(T*to,const T&value)noexcept{
		if constexpr(sizeof(T)>=sizeof(::std::max_align_t))
			if(is_all_byte_zero(value))
				::std::memset(to,zero,sizeof(T));
			else
				*to=value;
		else
			*to=value;
		return to;
	}

	/*!
	所有的construct_t实例都派生于此
	*/
	struct base_construct_t{};
	/*!
	用于构造实例
	用法详见变量模板construct
	*/
	template<typename T>
	struct construct_t:base_construct_t{
		typedef base_construct_t base_t;
		template<class...Args>
		static constexpr bool able=construct_able<T,Args...>;
		template<class...Args>
		static constexpr bool nothrow=construct_nothrow<T,Args...>;
		template<class...Args>
		static constexpr bool trivial=construct_trivial<T,Args...>;

		template<class...Args> requires able<Args...>
		[[nodiscard]]force_inline T operator()(Args&&...rest)const noexcept(nothrow<Args...>){
			return T(forward<Args>(rest)...);
		}
		struct array_construct_t{
			T*_to;
			size_t _size;
			constexpr void never_in_array_check()const noexcept{
				if constexpr(type_info<T>.has_attribute(never_in_array))
					template_error("You can\'t construct an array for never_in_array type.");
			}
			template<class...Args> requires able<Args...>
			force_inline void base_call(Args&&...rest)const noexcept(nothrow<Args...>){
				auto tmp=_size;
				while(tmp--)new(_to+tmp)T(forward<Args>(rest)...);
			}
			template<class...Args> requires able<Args...>
			force_inline T* operator()(Args&&...rest)const noexcept(nothrow<Args...>){
				never_in_array_check();
				base_call(forward<Args>(rest)...);
				return _to;
			}
			//复制构造速度优化
			force_inline T* operator()(const T&v)const noexcept(nothrow<const T&>)requires able<const T&>{
				never_in_array_check();
				if constexpr(trivial<const T&> && ::std::is_trivially_copyable_v<T>)
					super_speed_trivial_copy_from_one(_to,v,_size);
				else
					base_call(forward<const T&>(v));
				return _to;
			}
			//默认构造逻辑优化
			force_inline T* operator()()const noexcept(nothrow<>)requires able<>{
				never_in_array_check();
				if constexpr(!trivial<>)
					base_call();
				return _to;
			}
		};
		struct placement_construct_t{
			T*_to;
			template<class...Args> requires able<Args...>
			force_inline void base_call(Args&&...rest)const noexcept(nothrow<Args...>){
				new(_to)T(forward<Args>(rest)...);
			}
			template<class...Args> requires able<Args...>
			force_inline T* operator()(Args&&...rest)const noexcept(nothrow<Args...>){
				base_call(forward<Args>(rest)...);
				return _to;
			}
			//复制构造速度优化
			force_inline T* operator()(const T&v)const noexcept(nothrow<const T&>)requires able<const T&>{
				if constexpr(trivial<const T&> && ::std::is_trivially_copyable_v<T>)
					super_speed_trivial_copy_from_one(_to,v);
				else
					base_call(forward<const T&>(v));
				return _to;
			}
			//默认构造逻辑优化
			force_inline T* operator()()const noexcept(nothrow<>)requires able<>{
				if constexpr(!trivial<>)
					base_call();
				return _to;
			}
			[[nodiscard]]force_inline constexpr array_construct_t operator[](size_t size)const noexcept{return{_to,size};}
		};
		[[nodiscard]]force_inline constexpr placement_construct_t operator[](T*p)const noexcept{return{p};}
	};
	/*!
	constexpr变量模板，用于构造实例
	用法：
	construct<类型>.able<构造参数类型>		->	bool
	construct<类型>.nothrow<构造参数类型>	->	bool
	construct<T>(参数)						->	T		（以参数构建T类型实例）

	construct<T>[T*ptr](参数)				->	T*		（以参数在ptr地址处构建T类型实例，返回ptr）
	construct<T>[T*ptr][size_t size](参数)	->	T*		（以参数在ptr地址处构建size个T类型实例，返回ptr）
	*/
	template<typename T>
	constexpr construct_t<T>construct{};

	/*!
	用于销毁实例
	用法：
	destruct.able<类型>		->	bool
	destruct.nothrow<类型>	->	bool

	destruct(T*ptr)					-> void		（在ptr地址处析构T类型实例，T可为数组）
	destruct[size_t size](T*ptr)	-> void		（析构以ptr地址起始共size个T类型实例，T可为数组）
	*/
	constexpr struct destruct_t{
		template<class T>
		static constexpr bool able=destruct_able<T>;
		template<class T>
		static constexpr bool nothrow=destruct_nothrow<T>;
		template<class T>
		static constexpr bool trivial=destruct_trivial<T>;

		template<class T> requires able<T>
		static force_inline void base_call([[maybe_unused]]T*to)noexcept(nothrow<T>){
			if constexpr(!trivial<T>)
				if constexpr(::std::is_array_v<T>)
					for(auto&i : *to)
						base_call(addressof(i));
				else
					push_and_disable_msvc_warning(26457)
					to->~T();
					pop_msvc_warning()
		}

		template<class T> requires able<T>
		static void base_call([[maybe_unused]]T*begin,[[maybe_unused]]size_t size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
			if constexpr(!trivial<T>)
				while(size--)base_call(begin+size);
		}

		template<class T> requires able<T>
		force_inline void operator()(T*begin)const noexcept(nothrow<T>){
			base_call(begin);
		}

		struct array_destruct_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline void operator()(T*begin)const noexcept(nothrow<T>){
				base_call(begin,_size);
			}
		};

		[[nodiscard]]force_inline constexpr array_destruct_t operator[](size_t size)const noexcept{return{size};}

		struct not_t{};
		/*适用于unget(this,not destruct);*/
		force_inline constexpr not_t operator!()const noexcept{return not_t{};}
	}destruct{};

	/*!
	用于重新构造实例：先摧毁，再原地构建
	用法：
	re_construct.able<类型>		->	bool
	re_construct.nothrow<类型>	->	bool

	re_construct(T*ptr)						->	T*		（以无参数在ptr地址处重新构建T类型实例，返回ptr）
	re_construct[T*ptr](参数)				->	T*		（以参数在ptr地址处重新构建T类型实例，返回ptr）
	re_construct[T*ptr][size_t size](参数)	->	T*		（以参数在ptr地址处重新构建size个T类型实例，返回ptr）
	常见用法：
	re_construct(this)
	*/
	constexpr struct re_construct_t{
		template<class T,class...Args>
		static constexpr bool able=destruct.able<T>&&construct<T>.able<Args...>;
		template<class T,class...Args>
		static constexpr bool nothrow=destruct.nothrow<T>&&construct<T>.nothrow<Args...>;
		template<class T,class...Args>
		static constexpr bool trivial=destruct.trivial<T>&&construct<T>.trivial<Args...>;

		template<class T> requires able<T>
		force_inline T* operator()(T*to)const noexcept(nothrow<T>){
			destruct(to);
			construct<T>[to]();
			return to;
		}
		template<class T>
		struct array_re_construct_t{
			T*_to;
			size_t _size;
			template<class...Args> requires able<T,Args...>
			T* operator()(Args&&...rest)const noexcept(nothrow<T,Args...>){
				if constexpr(type_info<T>.has_attribute(never_in_array))
					template_error("You cannot perform array operations on never_in_array type.");
				destruct[_size](_to);
				construct<T>[_to][_size](forward<Args>(rest)...);
				return _to;
			}
		};
		template<class T>
		struct placement_re_construct_t{
			T*_to;
			template<class...Args> requires able<T,Args...>
			T* operator()(Args&&...rest)const noexcept(nothrow<T,Args...>){
				destruct(_to);
				construct<T>[_to](forward<Args>(rest)...);
				return _to;
			}
			[[nodiscard]]force_inline constexpr array_re_construct_t<T> operator[](size_t size)const noexcept{return{_to,size};}
		};
		template<class T>
		[[nodiscard]]force_inline constexpr placement_re_construct_t<T> operator[](T*p)const noexcept{return{p};}
	}re_construct;

	constexpr struct copy_construct_t{
		template<class T>
		static constexpr bool r_able=copy_construct_able<T>?
									 copy_construct_trivial<T>||!(construct<T>.trivial<>&&copy_assign_trivial<T>)
									 :false;//trivial操作优先考虑
		template<class T>
		static constexpr bool able=r_able<T>?true:(construct<T>.able<>&&copy_assign_able<T>);
		template<class T>
		static constexpr bool nothrow=r_able<T>?copy_construct_nothrow<T>:
										(construct<T>.nothrow<>&&copy_assign_nothrow<T>);
		template<class T>
		static constexpr bool trivial=r_able<T>?copy_construct_trivial<T>:
										(construct<T>.trivial<>&&copy_assign_trivial<T>);

		template<class T> requires able<T>
		static T*base_call(T*to,const T*from)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				return reinterpret_cast<T*>(::std::memcpy(to,add_const(from),sizeof(T)));
			else{
				if constexpr(r_able<T>)
					new(to)T(*from);
				else{
					construct<T>[to]();
					*to=*from;
				}
				return to;
			}
		}

		template<class T> requires able<T>
		static T*base_call(T*to,const T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				return reinterpret_cast<T*>(::std::memcpy(to,add_const(from),sizeof(T)*size));
			else{
				while(size--)
					base_call(to+size,from+size);
				return to;
			}
		}

		template<class T> requires able<T>
		force_inline T*operator()(T*to,const T*from)const noexcept(nothrow<T>)
		{return base_call(to,from);}

		template<class T> requires able<T>
		force_inline T*operator()(note::to_t<T*>to,note::from_t<const T*>from)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		template<class T> requires able<T>
		force_inline T*operator()(note::from_t<const T*>from,note::to_t<T*>to)const noexcept(nothrow<T>)
		{return base_call(to(),from());}


		template<class T> requires able<T>
		force_inline T*operator()(T*to,const T*from,size_t size)const noexcept(nothrow<T>)
		{return base_call(to,from,size);}

		template<class T> requires able<T>
		force_inline T*operator()(note::to_t<T*>to,note::from_t<const T*>from,size_t size)const noexcept(nothrow<T>)
		{return base_call(to(),from(),size);}

		template<class T> requires able<T>
		force_inline T*operator()(note::from_t<const T*>from,note::to_t<T*>to,size_t size)const noexcept(nothrow<T>)
		{return base_call(to(),from(),size);}

		template<class T> requires able<T>
		static T*base_call(T*to,const T&from)noexcept(nothrow<T>){
			if constexpr(r_able<T>)
				construct<T>[to](from);
			else{
				construct<T>[to]();
				*to=from;
			}
			return to;
		}

		template<class T> requires able<T>
		static T*base_call(T*to,const T&from,size_t size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
			if constexpr(::std::is_trivially_copyable_v<T>)
				super_speed_trivial_copy_from_one(to,from,size);
			else
				while(size--)
					base_call(to+size,from);
			return to;
		}

		template<class T> requires able<T>
		force_inline T*operator()(T*to,const T&from)const noexcept(nothrow<T>)
		{return base_call(to,from);}

		struct array_copy_construct_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,const T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(T*to,const T&from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<const T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<const T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
		};
		[[nodiscard]]force_inline constexpr array_copy_construct_t operator[](size_t a)const noexcept{return{a};}
	}copy_construct{};

	constexpr struct move_construct_t{
		template<class T>
		static constexpr bool r_able=move_construct_able<T>?
									 move_construct_trivial<T>||!copy_construct.trivial<T>
									 :false;//trivial操作优先考虑
		template<class T>
		static constexpr bool able=r_able<T>?true:copy_construct.able<T>;
		template<class T>
		static constexpr bool nothrow=r_able<T>?move_construct_nothrow<T>:
												copy_construct.nothrow<T>;
		template<class T>
		static constexpr bool trivial=r_able<T>?move_construct_trivial<T>:
												copy_construct.trivial<T>;

		template<class T> requires able<T>
		static T*base_call(T*to,T*from)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				return reinterpret_cast<T*>(::std::memcpy(to,add_const(from),sizeof(T)));
			else{
				if constexpr(r_able<T>){
					construct<T>[to](::std::move(*from));
					return to;
				}else
					return copy_construct(to,from);
			}
		}
		template<class T> requires able<T>
		static T*base_call(T*to,T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
			if constexpr(trivial<T>)
				return reinterpret_cast<T*>(::std::memcpy(to,add_const(from),sizeof(T)*size));
			else{
				if constexpr(r_able<T>){
					while(size--)
						construct<T>[to+size](::std::move(from[size]));
					return to;
				}else
					return copy_construct[size](to,from);
			}
		}

		template<class T> requires able<T>
		force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>)
		{return base_call(to,from);}

		template<class T> requires able<T>
		force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		template<class T> requires able<T>
		force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		struct array_move_construct_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
		};
		[[nodiscard]]force_inline constexpr array_move_construct_t operator[](size_t a)const noexcept{return{a};}
	}move_construct{};

	constexpr struct move_t{
		template<class T>
		static constexpr bool able=move_construct.able<T>&&destruct.able<T>;
		template<class T>
		static constexpr bool nothrow=move_construct.nothrow<T>&&destruct.nothrow<T>;
		template<class T>
		static constexpr bool trivial=move_construct.trivial<T>&&destruct.trivial<T>;

		template<class T> requires able<T>
		static T*base_call(T*to,T*from)noexcept(nothrow<T>){
			move_construct(to,from);
			destruct(from);
			return to;
		}
		template<class T> requires able<T>
		static T*base_call(T*to,T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
			move_construct[size](to,from);
			destruct[size](from);
			return to;
		}

		template<class T> requires able<T>
		force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>)
		{return base_call(to,from);}

		template<class T> requires able<T>
		force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		template<class T> requires able<T>
		force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		struct array_move_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
		};
		[[nodiscard]]force_inline constexpr array_move_t operator[](size_t a)const noexcept{return{a};}

		//特殊使用
		template<class T>
		[[nodiscard]]constexpr remove_ref<T>&& operator()(T&&a)const noexcept{
			return static_cast<remove_ref<T>&&>(a);
		}
	}move{};

	constexpr struct copy_t{
		//特殊使用
		//UF
		template<class T> requires(copy_construct.able<T>)
		[[nodiscard]]constexpr T operator()(const T&a)const noexcept{
			return copy_construct<T>(a);
		}
	}copy{};

	constexpr struct copy_assign_t{
		template<class T>
		static constexpr bool r_able=copy_assign_able<T>?
									 copy_assign_trivial<T>||!(copy_construct_trivial<T>&&destruct.trivial<T>)
									 :false;//trivial操作优先考虑
		template<class T>
		static constexpr bool able=r_able<T>?true:(copy_construct_able<T>&&destruct.able<T>);
		template<class T>
		static constexpr bool nothrow=r_able<T>?copy_assign_nothrow<T>:
											(copy_construct_nothrow<T>&&destruct.nothrow<T>);
		template<class T>
		static constexpr bool trivial=r_able<T>?copy_assign_trivial<T>:
											(copy_construct_trivial<T>&&destruct.trivial<T>);

		template<class T> requires able<T>
		static T& base_call(T&a,const T&b)noexcept(nothrow<T>){
			if constexpr(r_able<T>)
				a=b;
			else{
				destruct(&a);
				construct<T>[&a](b);
			}
			return a;
		}
		template<class T> requires able<T>
		static T* base_call(T*to,const T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				::std::memcpy(to,add_const(from),size*sizeof(T));
			else
				while(size--)
					base_call(to[size],from[size]);
			return to;
		}
		template<class T> requires able<T>
		static T* base_call(T* to,const T& from,size_t size)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				super_speed_trivial_copy_from_one(to,from,size);
			else
				while(size--)
					base_call(to[size],from);
			return to;
		}

		template<class T> requires able<T>
		force_inline T& operator()(T&a,const T&b)const noexcept(nothrow<T>){
			return base_call(a,b);
		}

		struct array_copy_assign_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,const T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(const T*from,T*to)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<const T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<const T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(const T&from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return base_call(to(),from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,const T&from)const noexcept(nothrow<T>){
				return base_call(to(),from,_size);
			}
		};
		[[nodiscard]]force_inline constexpr array_copy_assign_t operator[](size_t a)const noexcept{return{a};}
	}copy_assign{};

	constexpr struct move_assign_t{
		template<class T>
		static constexpr bool r_able=move_assign_able<T>;
		template<class T>
		static constexpr bool able=r_able<T>?true:copy_assign.able<T>;
		template<class T>
		static constexpr bool nothrow=r_able<T>?move_assign_nothrow<T>:copy_assign.nothrow<T>;
		template<class T>
		static constexpr bool trivial=r_able<T>?move_assign_trivial<T>:copy_assign.trivial<T>;

		template<class T> requires able<T>
		static T& base_call(T&a,T&&b)noexcept(nothrow<T>){
			if constexpr(r_able<T>)
				a=move(b);
			else
				copy_assign(a,b);
			return a;
		}
		template<class T> requires able<T>
		static T* base_call(T*to,T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				::std::memcpy(to,add_const(from),size*sizeof(T));
			else
				while(size--)
					base_call(to[size],from[size]);
			return to;
		}

		template<class T> requires able<T>
		force_inline T& operator()(T&a,T&b)const noexcept(nothrow<T>){
			return base_call(a,move(b));
		}

		struct array_move_assign_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
		};
		[[nodiscard]]force_inline constexpr array_move_assign_t operator[](size_t a)const noexcept{return{a};}

		static constexpr struct may_overlap_t{
			template<class T> requires able<T>
			static T* base_call(T*to,T*from,size_t size)noexcept(nothrow<T>){
				if constexpr(trivial<T>)
					::std::memmove(to,add_const(from),size*sizeof(T));
				else
					while(size--)
						base_call(to[size],from[size]);
				return to;
			}
			struct array_may_overlap_move_assign_t{
				size_t _size;
				template<class T> requires able<T>
				force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>){
					return base_call(to,from,_size);
				}
				template<class T> requires able<T>
				force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>){
					return operator()(to(),from());
				}
				template<class T> requires able<T>
				force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
					return operator()(to(),from());
				}
			};
			[[nodiscard]]force_inline constexpr array_may_overlap_move_assign_t operator[](size_t a)const noexcept{return{a};}
		}may_overlap{};
	}move_assign{};
}

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/memory/lifetime/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/memory/lifetime/_export.hpp"
//_export.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/memory/lifetime/_export.hpp"
#define export using lifetime_n::
export construct;
export destruct;
export re_construct;
export copy_assign;
export move_assign;
export move;
export copy;
export copy_construct;
export move_construct;
#undef export

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/memory/lifetime/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/memory/lifetime/_test.hpp"
//_test.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/memory/lifetime/_test.hpp"
namespace lifetime_n{
	//BLOCK:for debug
	inline void test(){
		ELC_TEST_EVENTNAME("lifetime部分测试");
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
	//BLOCK_END
}

//file_end

	#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/memory/lifetime/_body.hpp"
#endif

//file_end

		#line 98 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
	}
	using namespace memory;

	namespace base{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/iterator.hpp"
//iterator.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/iterator.hpp"
namespace iterator_n{
	//using namespace memory;//copy_assign、move_assign
	template<typename base_t_w,typename value_t>
	struct reverse_base_t{
		typedef reverse_base_t<base_t_w,value_t> this_t;
		typedef remove_cv<base_t_w> base_t_rw;
		base_t_rw _m;
		template<typename build_base_t_T> requires(construct<base_t_rw>.able<build_base_t_T>)
		constexpr reverse_base_t(build_base_t_T&& a)noexcept(construct<base_t_rw>.nothrow<build_base_t_T>):_m(a){}
		constexpr reverse_base_t(const this_t&a)noexcept(construct<base_t_rw>.nothrow<const base_t_rw&>):_m(a._m){}
		constexpr reverse_base_t(this_t&&a)noexcept(construct<base_t_rw>.nothrow<base_t_rw&&>):_m(move(a._m)){}
		constexpr this_t& operator=(const this_t&a)&noexcept{_m=a._m;return*this;}
		constexpr this_t& operator=(const this_t&&a)&noexcept{_m=move(a._m);return*this;}
		constexpr auto operator==(const this_t&a)const noexcept{return _m==a._m;}
		constexpr auto operator<=>(const this_t&a)const noexcept{return _m<=>a._m;}

		static constexpr bool is_pointer=::std::is_pointer_v<base_t_w>;

		[[nodiscard]]static constexpr bool is_get_before_noexcept()noexcept{
			if constexpr(is_pointer)
				return true;
			else return noexcept(declvalue(base_t_w).get_next());
		}
		[[nodiscard]]static constexpr bool is_get_next_noexcept()noexcept{
			if constexpr(is_pointer)
				return true;
			else return noexcept(declvalue(base_t_w).get_before());
		}
		[[nodiscard]]static constexpr bool is_able_to_get_handle()noexcept{
			if constexpr(is_pointer)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_handle()))
				return true;
		}
		[[nodiscard]]static constexpr bool is_get_handle_noexcept()noexcept{
			if constexpr(is_pointer)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_handle()))
				return noexcept(declvalue(base_t_w).get_handle());
			else
				return false;
		}
		[[nodiscard]]static constexpr bool is_able_to_get_value()noexcept{
			if constexpr(is_pointer)
				return true;
			elseif constexpr(type_info<base_t_w> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_value()))
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_value()))
				return true;
		}
		[[nodiscard]]static constexpr bool is_get_value_noexcept()noexcept{
			if constexpr(is_pointer)
				return true;
			elseif constexpr(type_info<base_t_w> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_value()))
				return noexcept(declvalue(base_t_w)->get_value());
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_value()))
				return noexcept(declvalue(base_t_w).get_value());
			else
				return false;
		}

		[[nodiscard]]auto get_before()noexcept(is_get_before_noexcept()){
			if constexpr(is_pointer)
				return _m+1;
			else return ((base_t_w&)_m).get_next();
		}
		[[nodiscard]]auto get_next()noexcept(is_get_next_noexcept()){
			if constexpr(is_pointer)
				return _m-1;
			else return ((base_t_w&)_m).get_before();
		}
		[[nodiscard]]auto get_handle()noexcept(is_get_handle_noexcept())requires(is_able_to_get_handle()){
			if constexpr(is_pointer)
				return _m;
			else return ((base_t_w&)_m).get_handle();
		}
		[[nodiscard]]decltype(auto) get_value()noexcept(is_get_value_noexcept())requires(is_able_to_get_value()){
			if constexpr(is_pointer)
				return *(base_t_w&)_m;
			elseif constexpr(type_info<base_t_w> == type_info<value_t>)
				return (base_t_w&)_m;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_value()))
				return ((base_t_w&)_m)->get_value();
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_value()))
				return ((base_t_w&)_m).get_value();
		}
	};
	template<typename base_t,typename value_t> requires(compare.able<base_t>)
	[[nodiscard]]auto operator<=>(const reverse_base_t<base_t,value_t>&a,const reverse_base_t<base_t,value_t>&b)noexcept(compare.nothrow<base_t>){
		return compare((const base_t&)b._m,(const base_t&)a._m);
	}
	template<typename base_t,typename value_t,typename T> requires(compare.able<T,base_t> && type_info<remove_cvref<T>> != type_info<reverse_base_t<base_t,value_t>::base_t_rw>)
	[[nodiscard]]auto operator<=>(const reverse_base_t<base_t,value_t>& a,T&& b)noexcept(compare.nothrow<T,base_t>){
		return compare(b,(const base_t&)a._m);
	}
	template<typename base_t,typename value_t,typename T> requires(compare.able<base_t,T> && type_info<remove_cvref<T>> != type_info<reverse_base_t<base_t,value_t>::base_t_rw>)
	[[nodiscard]]auto operator<=>(T&& a,const reverse_base_t<base_t,value_t>& b)noexcept(compare.nothrow<base_t,T>){
		return compare((const base_t&)b._m,a);
	}
	template<typename base_t,typename value_t,typename T> requires(equal.able<T,base_t> && type_info<remove_cvref<T>> != type_info<reverse_base_t<base_t,value_t>::base_t_rw>)
	[[nodiscard]]auto operator==(const reverse_base_t<base_t,value_t>& a,T&& b)noexcept(equal.nothrow<T,base_t>){
		return equal(b,(const base_t&)a._m);
	}
	template<typename base_t,typename value_t,typename T> requires(equal.able<base_t,T> && type_info<remove_cvref<T>> != type_info<reverse_base_t<base_t,value_t>::base_t_rw>)
	[[nodiscard]]auto operator==(T&& a,const reverse_base_t<base_t,value_t>& b)noexcept(equal.nothrow<base_t,T>){
		return equal((const base_t&)b._m,a);
	}
	template<typename base_t,typename value_t>
	inline void swap(reverse_base_t<base_t,value_t>&a,reverse_base_t<base_t,value_t>&b)noexcept_as(swap(a._m,b._m))
	{swap(a._m,b._m);}

	template<typename value_t,typename base_t_w>
	class same_base_t{
		template<typename,typename>
		friend class same_base_t;
	protected:
		typedef same_base_t<value_t,base_t_w>this_t;
		typedef remove_cv<base_t_w> base_t_rw;
		//
		mutable base_t_rw _m;
		//
		[[nodiscard]]static constexpr bool is_able_to_get_handle()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_handle()))
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_handle()))
				return true;
			else
				return false;
		}
		[[nodiscard]]static constexpr bool is_handle_getter_noexcept()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_handle()))
				return noexcept(declvalue(base_t_w)->get_handle());
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_handle()))
				return noexcept(declvalue(base_t_w).get_handle());
			else
				return false;
		}
		[[nodiscard]]inline value_t*handle_getter()const noexcept(is_handle_getter_noexcept()) requires(is_able_to_get_handle()){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return ((base_t_w)_m);
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_handle()))
				return ((base_t_w)_m)->get_handle();
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_handle()))
				return ((base_t_w)_m).get_handle();
		}
		//
		[[nodiscard]]static constexpr bool is_value_getter_noexcept()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_value()))
				return noexcept(declvalue(base_t_w)->get_value());
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_value()))
				return noexcept(declvalue(base_t_w).get_value());
		}

		[[nodiscard]]static constexpr auto value_type_getter()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return type_info<decltype(*((base_t_w)_m))>;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_value()))
				return type_info<decltype(((base_t_w)_m)->get_value())>;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_value()))
				return type_info<decltype(((base_t_w)_m).get_value())>;
			else
				return type_info<decltype(*declvalue(value_t*))>;
		}
		typedef decltype(value_type_getter())::template_name type value_type;

		[[nodiscard]]inline value_type value_getter()const noexcept(is_handle_getter_noexcept()){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return *((base_t_w)_m);
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_value()))
				return ((base_t_w)_m)->get_value();
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_value()))
				return ((base_t_w)_m).get_value();
			else
				return *handle_getter();
		}
		//
		[[nodiscard]]static constexpr bool is_next_getter_noexcept()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_next()))
				return noexcept(declvalue(base_t_w)->get_next());
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_next()))
				return noexcept(declvalue(base_t_w).get_next());
		}
		[[nodiscard]]inline base_t_w next_getter()const noexcept(is_next_getter_noexcept()){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return ((base_t_w)_m)+1;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_next()))
				return ((base_t_w)_m)->get_next();
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_next()))
				return ((base_t_w)_m).get_next();
		}
		//
		[[nodiscard]]static constexpr bool is_before_getter_noexcept()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_before()))
				return noexcept(declvalue(base_t_w)->get_before());
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_before()))
				return noexcept(declvalue(base_t_w).get_before());
		}
		[[nodiscard]]inline base_t_w before_getter()const noexcept(is_before_getter_noexcept()){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return ((base_t_w)_m)-1;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_before()))
				return ((base_t_w)_m)->get_before();
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_before()))
				return ((base_t_w)_m).get_before();
		}
	public:
		constexpr void swap_with(this_t&a)noexcept_as(swap(declvalue(base_t_rw&),declvalue(base_t_rw&))){swap(_m,a._m);}
		//
		constexpr same_base_t()noexcept=default;
		template<typename build_base_t_T> requires(construct<base_t_rw>.able<build_base_t_T>)
		constexpr same_base_t(build_base_t_T&&a)noexcept(construct<base_t_rw>.nothrow<build_base_t_T>):_m(a){}
		constexpr same_base_t(const this_t&a)noexcept(construct<base_t_rw>.nothrow<const base_t_rw>):_m(a._m){}
		constexpr same_base_t(this_t&&a)noexcept_as(construct<base_t_rw>.nothrow<base_t_rw&&>):_m(move(a._m)){}
		template<typename other_T,typename other_base_t> requires(construct<base_t_rw>.able<other_base_t>)
		constexpr same_base_t(const same_base_t<other_T,other_base_t>&a)noexcept(construct<base_t_rw>.nothrow<other_base_t>):_m(a._m){}
		~same_base_t()noexcept(destruct.nothrow<base_t_rw>)=default;
		[[nodiscard]]constexpr bool		  operator==(const this_t& a)const noexcept_as(declvalue(base_t_rw) == declvalue(base_t_rw)){ return _m == a._m; }
		[[nodiscard]]constexpr value_t*   operator->()noexcept(is_handle_getter_noexcept())requires(is_able_to_get_handle()){ return handle_getter(); }
		[[nodiscard]]constexpr value_type operator*()noexcept(is_value_getter_noexcept()){ return value_getter(); }
		[[nodiscard]]constexpr			  operator value_t*()noexcept_as(declvalue(this_t).operator->()){ return operator->(); }
		[[nodiscard]]constexpr bool		  operator==(value_t* a)const noexcept(is_handle_getter_noexcept()&&noexcept(pointer_equal(declvalue(value_t*),declvalue(value_t*))))requires(is_able_to_get_handle()){ return pointer_equal(handle_getter(),a); }
		template<typename other_value_t,typename other_base_t_w> requires(equal.able<base_t_rw,other_base_t_w>)
		[[nodiscard]]constexpr bool operator==(const same_base_t<other_value_t,other_base_t_w>& a)const noexcept(equal.nothrow<base_t_rw,other_base_t_w>){
			return equal(_m,a._m);
		}
		template<typename other_value_t,typename other_base_t_w>
		[[nodiscard]]constexpr auto operator<=>(const same_base_t<other_value_t,other_base_t_w>& a)const noexcept(compare.nothrow<base_t_rw,other_base_t_w>){
			if constexpr(compare.able<base_t_rw,other_base_t_w>)
				return compare(_m,a._m);
		}
		constexpr this_t& operator=(const this_t&)&noexcept=default;
		base_t_rw& get_base()noexcept{ return _m; }
		const base_t_rw& get_base()const noexcept{ return _m; }
	};
	template<typename value_t,typename base_t_w>
	inline void swap(same_base_t<value_t,base_t_w>&a,same_base_t<value_t,base_t_w>&b)noexcept_as(a.swap_with(b))
	{a.swap_with(b);}

	template<typename value_t,typename base_t_w>
	struct base_iterator_t:same_base_t<value_t,base_t_w>{
		typedef base_iterator_t<value_t,base_t_w> this_t;
		typedef same_base_t<value_t,base_t_w> base_t;
	protected:
		using base_t::is_before_getter_noexcept;
		using base_t::is_next_getter_noexcept;
		using base_t::before_getter;
		using base_t::next_getter;
		typedef remove_cv<base_t_w> base_t_rw;
	public:
		using base_t::base_t;
		constexpr this_t&operator=(const base_t_rw&a)&noexcept(copy_assign.nothrow<base_t_rw>){copy_assign(base_t::_m,a);return*this;}
		constexpr this_t&operator=(base_t_rw&&a)&noexcept(move_assign.nothrow<base_t_rw>){move_assign(base_t::_m,a);return*this;}
		constexpr this_t&operator++()&noexcept(is_next_getter_noexcept()){return*this=next_getter();}
		constexpr this_t&operator--()&noexcept(is_before_getter_noexcept()){return*this=before_getter();}
		constexpr this_t operator++(int)&noexcept_as(this_t(++declvalue(this_t&))){auto a=*this;operator++();return a;}
		constexpr this_t operator--(int)&noexcept_as(this_t(--declvalue(this_t&))){auto a=*this;operator--();return a;}
		constexpr this_t operator+(ptrdiff_t num)const noexcept_as(this_t(--declvalue(this_t&)),++declvalue(this_t&)){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return base_t::_m+num;
			else{
				auto a=*this;
				if(num>0)
					while(num--)
						++a;
				else
					while(num++)
						--a;
				return a;
			}
		}
		constexpr this_t operator-(ptrdiff_t num)const noexcept_as(declvalue(this_t&)+0){ return *this+(-num); }
	};
	template<typename value_t,typename base_t_w>
	base_iterator_t(base_iterator_t<value_t,base_t_w>) -> base_iterator_t<value_t,base_t_w>;
	template<typename value_t,typename base_t_w>
	base_iterator_t(value_t*) -> base_iterator_t<value_t,base_t_w>;

	template<typename value_t,typename base_t_w=value_t*>
	using iterator_t = base_iterator_t<remove_cvref<value_t>,base_t_w>;
	template<typename value_t,typename base_t_w=const value_t*>
	using const_iterator_t = base_iterator_t<const remove_cvref<value_t>,base_t_w>;
	template<typename value_t,typename base_t_w=value_t*>
	using reverse_iterator_t = base_iterator_t<remove_cvref<value_t>,reverse_base_t<base_t_w,value_t>>;
	template<typename value_t,typename base_t_w=const value_t*>
	using reverse_const_iterator_t = base_iterator_t<const remove_cvref<value_t>,reverse_base_t<base_t_w,value_t>>;
}
using iterator_n::base_iterator_t;
using iterator_n::iterator_t;
using iterator_n::const_iterator_t;
using iterator_n::reverse_iterator_t;
using iterator_n::reverse_const_iterator_t;

//file_end

		#line 103 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/bitset.hpp"
//data.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/bitset.hpp"
//bitset
template<size_t bit_num>
struct bitset:byteset<ceil_div(bit_num,bitnum_of(byte))>{
	static constexpr size_t data_size=ceil_div(bit_num,bitnum_of(byte));
	typedef byteset<data_size> base_t;
	typedef bitset<bit_num> this_t;
	using base_t::base_t;

	byte _data[data_size];

	class arec_t{
		this_t* _to;
		size_t _index;
		size_t _quot,_mod;
	public:
		arec_t(this_t*to,size_t index)noexcept:_to(to),_index(index){
			auto info=divmod(_index,bitnum_of(byte));
			_quot=info.quot;
			_mod=info.mod;
		}
		constexpr operator bool()const noexcept{
			return _to->_data[_quot]&(1<<_mod);
		}
		constexpr auto&operator=(bool b)noexcept{
			if(b)
				_to->_data[_quot]|=(byte)1<<_mod;
			else
				_to->_data[_quot]&=~byte(1<<_mod);
			return*this;
		}
		constexpr auto&operator&=(bool b)noexcept{
			if(!b)
				_to->_data[_quot]&=~byte(1<<_mod);
			return*this;
		}
		constexpr auto&operator|=(bool b)noexcept{
			if(b)
				_to->_data[_quot]|=(byte)1<<_mod;
			return*this;
		}
		constexpr auto&operator^=(bool b)noexcept{
			if(b)
				_to->_data[_quot]^=(byte)1<<_mod;
			return*this;
		}
	};
private:
	struct iterator_base_t{
		this_t*_to;
		ptrdiff_t _index;		//rend: -1，使用size_t也不是不可以（标准允许无符号整数溢出），但是operator<=>会出问题
		[[nodiscard]]constexpr iterator_base_t	get_before()const noexcept{ return{_to,_index-1}; }
		[[nodiscard]]constexpr iterator_base_t	get_next()const noexcept{ return{_to,_index+1}; }
		[[nodiscard]]arec_t						get_value()noexcept{ return (*_to)[_index]; }
		[[nodiscard]]const arec_t				get_value()const noexcept{ return (*add_const(_to))[_index]; }
		[[nodiscard]]constexpr bool operator==(const iterator_base_t& a)const noexcept{ return _to==a._to && _index==a._index; }
		[[nodiscard]]constexpr auto operator<=>(const iterator_base_t& a)const noexcept{ return _to==a._to ? _index<=>a._index : partial_ordering::unordered; }
	};
	[[nodiscard]]iterator_base_t get_iterator_data_at(ptrdiff_t index)const noexcept{ return iterator_base_t{(this_t*)this,index}; }
public:
	typedef iterator_t<bool,iterator_base_t>				iterator;
	typedef const_iterator_t<bool,const iterator_base_t>	const_iterator;
	constexpr iterator begin()noexcept{ return get_iterator_data_at(0); }
	constexpr iterator end()noexcept{ return get_iterator_data_at(-1); }
	constexpr const_iterator begin()const noexcept{ return get_iterator_data_at(0); }
	constexpr const_iterator end()const noexcept{ return get_iterator_data_at(-1); }
	constexpr const_iterator cbegin()const noexcept{ return get_iterator_data_at(0); }
	constexpr const_iterator cend()const noexcept{ return get_iterator_data_at(-1); }
	constexpr arec_t operator[](size_t index)noexcept{return {this,index};}
	constexpr const arec_t operator[](size_t index)const noexcept{return {remove_const(this),index};}
	constexpr auto operator~()const noexcept{
		this_t tmp;
		for(size_t i=0;i<data_size;++i)
			tmp._data[i]=~_data[i];
		return tmp;
	}
	constexpr auto&operator&=(const this_t&b)noexcept{
		for(size_t i=0;i<data_size;++i)
			_data[i]&=b._data[i];
		return*this;
	}
	constexpr auto&operator|=(const this_t&b)noexcept{
		for(size_t i=0;i<data_size;++i)
			_data[i]|=b._data[i];
		return*this;
	}
	constexpr auto&operator^=(const this_t&b)noexcept{
		for(size_t i=0;i<data_size;++i)
			_data[i]^=b._data[i];
		return*this;
	}
	template<unsigned_integer_type T>
	constexpr auto&operator=(T n)noexcept{
		typedef unsigned_specific_size_t<sizeof(byte)> arithmetic_byte_t;
		constexpr size_t mod_base=number_of_possible_values_per<arithmetic_byte_t>;
		for(size_t i=0;i<data_size;++i){
			auto result=divmod(n,mod_base);
			_data[i]=byte(arithmetic_byte_t(move(result.mod)));
			n=T(move(result.quot));
		}
		return*this;
	}
	template<unsigned_integer_type T>
	constexpr bitset(T n)noexcept{*this=n;}
	template<unsigned_integer_type T>
	explicit constexpr operator T()const noexcept{
		typedef unsigned_specific_size_t<sizeof(byte)> arithmetic_byte_t;
		constexpr size_t mod_base=number_of_possible_values_per<arithmetic_byte_t>;
		T result{};
		for(size_t i=data_size-1;i!=npos;--i){
			result*=mod_base;
			result+=arithmetic_byte_t(_data[i]);
		}
		return result;
	}
	constexpr auto&operator<<=(size_t n)noexcept{
		const auto [move_step,offset]=divmod(n,bitnum_of(byte));
		byte carry{};
		for(size_t i=data_size-move_step-1;i!=npos;--i){
			const auto tmp=_data[i];
			_data[i]=byte((tmp<<offset)|carry);
			carry=tmp>>(bitnum_of(byte)-offset);
		}
		for(size_t i=0;i<move_step;++i)
			_data[i]=byte{};
		return*this;
	}
	constexpr auto&operator>>=(size_t n)noexcept{
		const auto [move_step,offset]=divmod(n,bitnum_of(byte));
		byte carry{};
		for(size_t i=move_step;i!=data_size;++i){
			const auto tmp=_data[i];
			_data[i]=byte((tmp>>offset)|carry);
			carry=tmp<<(bitnum_of(byte)-offset);
		}
		for(size_t i=data_size-move_step;i!=data_size;++i)
			_data[i]=byte{};
		return*this;
	}
	constexpr auto operator<<(size_t n)const noexcept{return this_t(*this)<<=n;}
	constexpr auto operator>>(size_t n)const noexcept{return this_t(*this)>>=n;}
	constexpr auto operator&(const this_t&b)const noexcept{return this_t(*this)&=b;}
	constexpr auto operator|(const this_t&b)const noexcept{return this_t(*this)|=b;}
	constexpr auto operator^(const this_t&b)const noexcept{return this_t(*this)^=b;}
	constexpr auto operator==(const this_t&b)const noexcept{
		for(size_t i=0;i<data_size-1;++i)
			if(_data[i]!=b._data[i])
				return false;
		const auto mod=bit_num%bitnum_of(byte);
		return (_data[data_size-1]>>mod)==(b._data[data_size-1]>>mod);
	}
};

//file_end

		#line 104 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/hash.hpp"
//hash.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/hash.hpp"
namespace hash_n{
	typedef size_t hash_base_t;
	struct hash_value_t{
		hash_base_t _value;
		constexpr hash_base_t operator%(auto&&a)const noexcept{
			return _value%a;
		}
		constexpr bool operator==(const hash_value_t&a)const noexcept{
			return _value==a._value;
		}
	};
	struct unstable_hash_value_t:hash_value_t{
		unstable_hash_value_t(const hash_value_t&a)noexcept:hash_value_t(a){}
	};

	template<class T>
	concept is_unstable_hash = type_info<T const>.can_convert_to<unstable_hash_value_t>;
	template<class T>
	concept is_fundamental_hash = ::std::is_fundamental_v<T>;

	enable_adl(the_pointer_hash);
	/*!
	Computes the hash value of a pointer.

	@param a The pointer to hash.

	@returns The hash value of the pointer.
	*/
	template<class T>
	[[nodiscard]]inline constexpr hash_value_t pointer_hash(T*a)noexcept{
		if constexpr(was_not_an_ill_form(the_pointer_hash(a)))
			return the_pointer_hash(a);
		else
			return{hash_base_t(a)};
	}

	inline struct hash_t{
	private:
		template<class T>
		[[nodiscard]]static inline constexpr bool nothrow_helper()noexcept{
			if constexpr(is_pointer<T>)
				return noexcept(pointer_hash(declvalue(const T&)));
			elseif constexpr(is_fundamental_hash<T>)
				return noexcept(hash_value_t{hash_base_t(declvalue(const T&))});
			elseif constexpr(is_unstable_hash<T>)
				return noexcept(unstable_hash_value_t(declvalue(const T&)));
			elseif constexpr(was_not_an_ill_form(declvalue(const T&).hash()))
				return noexcept(declvalue(const T&).hash());
			elseif constexpr(was_not_an_ill_form(hash_value_t(declvalue(const T&))))
				return noexcept(hash_value_t(declvalue(const T&)));
			elseif constexpr(type_info<remove_cv<T>> == type_info<base_type_info_t>)
				return true;
			else
				return false;
		}
	public:
		template<class T>
		static constexpr bool nothrow=nothrow_helper<T>();
	private:
		template<class T>
		[[nodiscard]]static inline constexpr bool able_helper()noexcept{
			if constexpr(is_pointer<T>)
				return true;
			elseif constexpr(is_fundamental_hash<T>)
				return true;
			elseif constexpr(is_unstable_hash<T>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(const T&).hash()))
				return true;
			elseif constexpr(was_not_an_ill_form(hash_value_t(declvalue(const T&))))
				return true;
			elseif constexpr(type_info<remove_cv<T>> == type_info<base_type_info_t>)
				return true;
			else
				return false;
		}
	public:
		template<class T>
		static constexpr bool able=able_helper<T>();

		#define hash operator()

		/*!
		Computes the hash value of `nothing`.

		@returns The hash value of `nothing`.
		*/
		[[nodiscard]]inline constexpr hash_value_t hash(nothing)const noexcept{
			return{hash_base_t(nothing)};
		}
		/*!
		Computes the hash value of a base_type_info_t object.

		@param a The base_type_info_t object to hash.

		@returns The hash value of the object.
		*/
		[[nodiscard]]inline hash_value_t hash(const base_type_info_t&a)const noexcept{
			return{a.get_hash()};
		}
		/*!
		Computes the hash value of a value.

		@param a The value to hash.

		@returns The hash value of the value.
		*/
		template<class T> requires able<T>
		[[nodiscard]]constexpr_as_auto inline auto hash(const T&a)const noexcept(nothrow<T>){
			#undef hash
			if constexpr(is_pointer<T>)
				return pointer_hash(a);
			elseif constexpr(is_fundamental_hash<T>)
				return hash_value_t{hash_base_t(a)};
			elseif constexpr(is_unstable_hash<T>)
				return unstable_hash_value_t(a);
			elseif constexpr(was_not_an_ill_form(declvalue(const T&).hash()))
				return a.hash();
			elseif constexpr(was_not_an_ill_form(hash_value_t(declvalue(const T&))))
				return hash_value_t(a);
			else{
				template_error("Please overload the function hash in the namespace where this type is defined.");
				return hash_value_t{};
			}
			#define hash operator()
		}
		/*!
		Computes the hash of a value in the base type.

		@param a The value to hash.

		@returns The hash of the value in the base type.
		*/
		template<class T>
		[[nodiscard]]constexpr_as_auto inline hash_base_t get_hash_in_base_type(const T&a)const noexcept(nothrow<T>){
			return hash(a)._value;
		}
		/*!
		从某个起始点算起的hash

		@param before The hashed value before this hash.
		@param before_size The size of the hashed value before this hash.
		@param a The sequence of values.
		@param size The number of values in the sequence.

		@returns The hash value of the sequence.
		*/
		template<class T>
		[[nodiscard]]force_inline constexpr hash_value_t with_calculated_before(hash_value_t before,size_t before_size,const T*a,size_t size)const noexcept{
			hash_base_t aret=before._value;
			rot_iterator<decltype(aret)>rotl_offset = before_size+size;
			while(size--){
				aret ^= rotl(get_hash_in_base_type(a[size]),rotl_offset);
				rotl_offset--;
			}
			return{aret};
		}
		/*!
		计算此hash重复N次的数组的hash结果

		@param value The hash value to repeat.
		@param size The number of times to repeat the hash value.

		@returns The repeated hash value.
		*/
		[[nodiscard]]force_inline constexpr hash_value_t repeat_times(hash_value_t value,size_t size)const noexcept{
			hash_base_t aret=0;
			{
				//优化.
				//关於此,咱确信咱发现一种美妙的证法来保证这个优化不影响结果,但可惜凋可怜的脑容量不足以让他看懂.
				constexpr size_t bit_range_max=bitnum_of(hash_base_t);
				constexpr hash_base_t void_hash{nothing};
				push_and_disable_msvc_warning(26475)//强制转换警告diss.
				constexpr hash_base_t npos_hash{hash_base_t(-1)};
				pop_msvc_warning();
				constexpr size_t bitnumof_void=bit_range_max*BIT_POSSIBILITY;

				size=size%bitnumof_void;
				if(value._value==0 || size==0)
					return{void_hash};
				if(size >= bit_range_max){
					const bool is_npos = ::std::popcount(value._value)%BIT_POSSIBILITY;
					aret = is_npos?npos_hash:void_hash;
					size-=bit_range_max;
				}
				if(!size)
					return{aret};
			}
			rot_iterator<decltype(aret)>rotl_offset = size;
			while(size--){
				aret ^= rotl(value._value,rotl_offset);
				rotl_offset--;
			}
			return{aret};
		}
		/*!
		计算此hash重复N次的数组的hash结果

		@param value The hash value to repeat.
		@param size The number of times to repeat the hash value.

		@returns The repeated hash value.
		*/
		template<class T>
		[[nodiscard]]force_inline constexpr hash_value_t repeat_times(T&&value,size_t size)const noexcept{
			return repeat_times(hash(value),size);
		}
		/*!
		Computes the hash value of an array of elements.

		@param a The array of elements.
		@param size The size of the array.

		@returns The hash value of the array.
		*/
		template<class T>
		[[nodiscard]]inline constexpr hash_value_t hash(const T*a,size_t size)const noexcept(nothrow<const T>){
			return with_calculated_before(hash(nothing),0,a,size);
		}
		/*!
		合并两个数据段的hash结果，好似计算这两个数据段合并后的hash结果一般

		@param before The first hash value.
		@param before_size The size of the first hash value.
		@param after The second hash value.
		@param after_size The size of the second hash value.

		@returns The merged hash value.
		*/
		[[nodiscard]]force_inline hash_value_t merge_array_hash_results(
			hash_value_t before,size_t before_size,hash_value_t after,[[maybe_unused]]size_t after_size
		)const noexcept{
			return{before._value^(rotl(after._value,before_size))};
		}
		/*!
		计算一个 array_like_view_t<T> 对象的哈希值。
		@param a array_like_view_t<T> 对象。

		@returns array_like_view_t<T> 对象的哈希值。
		*/
		template<class T> requires is_not_signal_value_for_array_like<T>
		[[nodiscard]]inline constexpr hash_value_t hash(const array_like_view_t<T>a)const noexcept(nothrow<T>){
			return hash(a.begin(),a.size());
		}
		/*!
		计算一个 array_like_view_t<T> 对象的哈希值，并在哈希值之前进行计算。

		@param before 用来作为计算基础的哈希值。
		@param before_size 用来作为计算基础的哈希值的大小。
		@param a 要计算哈希值的 array_like_view_t<T> 对象。

		@returns array_like_view_t<T> 对象的哈希值。
		*/
		template<class T> requires is_not_signal_value_for_array_like<T>
		[[nodiscard]]inline constexpr hash_value_t with_calculated_before(hash_value_t before,size_t before_size,const array_like_view_t<T>a)const noexcept{
			return with_calculated_before(before,before_size,a.begin(),a.size());
		}

		#undef hash

	}hash{};
}
typedef hash_n::hash_value_t hash_t;
typedef hash_n::unstable_hash_value_t unstable_hash_t;
using hash_n::is_unstable_hash;
using hash_n::is_fundamental_hash;
using hash_n::hash;

//file_end

		#line 105 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/range.hpp"
//range.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/range.hpp"
namespace range_n{
	//  range_t
	/// 用以表示某类型的数值范围，仅可表示闭区间
	template<typename T>
	struct range_t{
		T _begin,_end;
		//_begin<=_end
		constexpr range_t(const T begin,const T end):_begin(begin),_end(end){}
		constexpr range_t(note::from_t<const T>begin,note::to_t<const T>end):_begin(begin),_end(end+1){}
		constexpr range_t(note::to_t<const T>end,note::from_t<const T>begin):_begin(begin),_end(end+1){}
		constexpr range_t(const T begin,note::size_type_t<const T>size):_begin(begin),_end(begin+size()){}
		constexpr range_t(const T begin,note::size_t size):_begin(begin),_end(begin+size()){}

		constexpr size_t size()noexcept{return _end-_begin;}
		constexpr auto end()noexcept{return _end;}
		constexpr auto begin()noexcept{return _begin;}
		constexpr auto end()const noexcept{return _end;}
		constexpr auto begin()const noexcept{return _begin;}

		template <class U> requires(type_info<T>.can_convert_to<U>)
		constexpr operator range_t<U>()const noexcept(type_info<T>.can_nothrow_convert_to<U>){
			return{_begin,_end};
		}
	};

	template<class T>
	[[nodiscard]]inline auto size_of_array_like(range_t<T*>&a)noexcept{return a.size();}
	template<class T>
	[[nodiscard]]inline auto size_of_array_like(range_t<const T*>&a)noexcept{return a.size();}

	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(range_t<T*>&a)noexcept{return a.begin();}
	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(range_t<const T*>&a)noexcept{return a.begin();}

	//  in_range
	/// 判断一个值是否在某个范围内
	template<typename T>
	[[nodiscard]]constexpr bool in_range(T pattern,const range_t<T>range)noexcept_as(bool(declvalue(T)>=declvalue(const T) && declvalue(T)<=declvalue(const T))){//算术类型或指针
		return bool(pattern>=range.begin() && pattern<range.end());
	}
	//  in_range
	/// 判断一个指针是否在某个byte指针范围内
	template<typename T>
	[[nodiscard]]constexpr bool in_range(T*pattern,const range_t<byte*>range)noexcept{
		return cast_to_data(pattern)>=range.begin() && cast_to_data(pattern)<range.end();
	}
	//  match_pattern
	/// sunday算法表头，用以实施头起始的快速子串匹配算法
	/// 大部分情况下应当编译时预构建或对运行时生成的实例进行缓存
	template<typename T>
	struct match_pattern{
		array_like_view_t<T>_pattern;
		typedef unsigned char index_type;

		size_t skip_table[number_of_possible_values_per<index_type>]{};

		static constexpr index_type get_index_of(T&ch)noexcept{
			return index_type(hash(ch) % number_of_possible_values_per<index_type>);
		}
		constexpr void build_table(const array_like_view_t<T>&pattern)noexcept{
			const size_t m=pattern.size();
			if(!m)
				return;
			for(size_t i=0;i<number_of_possible_values_per<index_type>;i++)
				skip_table[i]=m+1;
			for(size_t i=0;i<m;i++)
				skip_table[get_index_of(pattern[i])]=m-i;
		}
		constexpr match_pattern(const array_like_view_t<T>&pattern)noexcept:_pattern(pattern){
			build_table(_pattern);
		}
		[[nodiscard]]constexpr T* match(const array_like_view_t<T>&range)const noexcept{
			size_t off_set=0;
			size_t matching_off_set=1;

			floop{
				matching_off_set=1;
				while(_pattern.end()[0-matching_off_set]==range.begin()[off_set+_pattern.size()-matching_off_set])
					if(matching_off_set==_pattern.size())
						return addressof(range.begin()[off_set]);
					else
						matching_off_set++;
				if(off_set+_pattern.size() >= range.size())
					return nullptr;
				off_set+=skip_table[get_index_of(range.begin()[off_set+_pattern.size()])];
			}
		}
	};
	//  reverse_match_pattern
	/// 反向Sunday算法表头，用以实施尾起始的快速子串匹配算法
	/// 大部分情况下应当编译时预构建或对运行时生成的实例进行缓存
	template<typename T>
	struct reverse_match_pattern{
		array_like_view_t<T>_pattern;
		typedef unsigned char index_type;

		size_t skip_table[number_of_possible_values_per<index_type>]{};

		static constexpr index_type get_index_of(T&ch)noexcept{
			return index_type(hash(ch) % number_of_possible_values_per<index_type>);
		}
		constexpr void build_table(const array_like_view_t<T>&pattern)noexcept{
			const size_t m=pattern.size();
			if(!m)
				return;
			for(size_t i=0;i<number_of_possible_values_per<index_type>;i++)
				skip_table[i]=m+1;
			for(size_t i=0;i<m-1;i++)
				skip_table[get_index_of(pattern[i])]=i;
		}
		constexpr reverse_match_pattern(const array_like_view_t<T>&pattern)noexcept:_pattern(pattern){
			build_table(_pattern);
		}
		[[nodiscard]]constexpr T* match(const array_like_view_t<T>&range)const noexcept{
			size_t off_set=0;
			size_t matching_off_set=0;

			floop{
				matching_off_set=0;
				while(_pattern.begin()[matching_off_set]==range.end()[0-(off_set+_pattern.size()-matching_off_set)])
					if(matching_off_set==_pattern.size()-1)
						return addressof(range.end()[0-(off_set+_pattern.size())]);
					else
						matching_off_set++;
				if(off_set+_pattern.size() >= range.size())
					return nullptr;
				off_set+=skip_table[get_index_of(range.end()[0-(off_set+_pattern.size()+1)])];
				off_set++;
			}
		}
	};
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* in_range(const remove_cvref<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range){
			if(i==pattern)
				return addressof(i);
		}
		return nullptr;
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_size_t(const remove_cvref<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* in_range_but_reverse(const remove_cvref<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range|::std::views::reverse){
			if(i==pattern)
				return addressof(i);
		}
		return nullptr;
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_but_reverse_size_t(const remove_cvref<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range_but_reverse(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// 若成功找到匹配的数据串，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard,deprecated("cache match_pattern and don't waste it")]]
	constexpr T* in_range(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		match_pattern tmp=pattern;
		return tmp.match(range);
	}
	/// 若成功找到匹配的数据串，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	//  反向数据串匹配by steve02081504.
	/// 若成功找到匹配的数据串，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard,deprecated("cache match_pattern and don't waste it")]]
	constexpr T* in_range_but_reverse(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		reverse_match_pattern tmp = pattern;
		return tmp.match(range);
	}
	/// 若成功找到匹配的数据串，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_but_reverse_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range_but_reverse(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}

	//  bitmark_for_finds
	/// bitmark提供了一种快速进行四种泛搜索的实现，前提是构建中的pattern中的每一项的usigned表示都在一个字节（表长）内。
	/// 若bitmark构建失败，程序应当使用正在进行的泛搜索的朴素实现版本。
	template<typename T>
	struct bitmark_for_finds{
		typedef unsigned char index_type;
		bool _bitmark[number_of_possible_values_per<index_type>]{};

		bitmark_for_finds()noexcept=default;
		[[nodiscard]]constexpr bool mark(const array_like_view_t<T>&pattern)noexcept{
			if constexpr(number_of_possible_values_per<T> > number_of_possible_values_per<index_type>){
				for(auto& i: pattern){
					if(::std::make_unsigned_t<T>(i) >= number_of_possible_values_per<index_type>)
						return false;
					_bitmark[index_type(i)] = true;
				}
			}
			else{
				for(auto& i: pattern)
					_bitmark[index_type(i)] = true;
			}
			return true;
		}
		[[nodiscard]]constexpr bool operator[](T&index)const noexcept{
			if constexpr(number_of_possible_values_per<T> > number_of_possible_values_per<index_type>)
				if(::std::make_unsigned_t<T>(index) >= number_of_possible_values_per<index_type>)
					return false;
			return _bitmark[index_type(index)];
		}
	};
	/// find_first_of的bitmark实现
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_of_bitmark(const bitmark_for_finds<T>&mark,const array_like_view_t<T>&range){
		for(auto&i : range){
			if(mark[i])
				return addressof(i);
		}
		return nullptr;
	}
	/// find_first_of的朴素实现
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* base_find_first_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range){
			if(in_range(i,pattern))
				return addressof(i);
		}
		return nullptr;
	}
	//  find_first_of
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		if constexpr(basic_integer_type<T>){
			bitmark_for_finds<T> mark;
			if(mark.mark(pattern))
				return find_first_of_bitmark(mark,range);
		}
		return base_find_first_of(pattern,range);
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_first_of_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_first_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// find_last_of的bitmark实现
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_of_bitmark(const bitmark_for_finds<T>&mark,const array_like_view_t<T>&range){
		for(auto& i: range|::std::views::reverse){
			if(mark[i])
				return addressof(i);
		}
	}
	/// find_last_of的朴素实现
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* base_find_last_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range|::std::views::reverse){
			if(in_range(i,pattern))
				return addressof(i);
		}
		return nullptr;
	}
	//  find_last_of
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		if constexpr(basic_integer_type<T>){
			bitmark_for_finds<T> mark;
			if(mark.mark(pattern))
				return find_last_of_bitmark(mark,range);
		}
		return base_find_last_of(pattern,range);
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_last_of_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_last_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// find_first_not_of的bitmark实现
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_not_of_bitmark(const bitmark_for_finds<T>&mark,const array_like_view_t<T>&range){
		for(auto& i: range){
			if(!mark[i])
				return addressof(i);
		}
		return nullptr;
	}
	/// find_first_not_of的朴素实现
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* base_find_first_not_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range){
			if(!in_range(i,pattern))
				return addressof(i);
		}
		return nullptr;
	}
	//  find_first_not_of
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_not_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		if constexpr(basic_integer_type<T>){
			bitmark_for_finds<T> mark;
			if(mark.mark(pattern))
				return find_first_not_of_bitmark(mark,range);
		}
		return base_find_first_not_of(pattern,range);
	}
	/// 若成功找到不匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_first_not_of_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_first_not_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// find_last_not_of的bitmark实现
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of_bitmark(const bitmark_for_finds<T>&mark,const array_like_view_t<T>&range){
		for(auto& i: range|::std::views::reverse){
			if(!mark[i])
				return addressof(i);
		}
		return nullptr;
	}
	/// find_last_not_of的朴素实现
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* base_find_last_not_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range|::std::views::reverse){
			if(!in_range(i,pattern))
				return addressof(i);
		}
		return nullptr;
	}
	//  bitmark_for_quick_unindex
	/// bitmark提供了一种快速进行反索引的实现，前提是构建中的pattern中的每一项的usigned表示都在一个字节（表长）内。
	/// 若bitmark构建失败，程序应当使用正在进行的反索引的朴素实现版本。
	template<typename T>
	struct bitmark_for_quick_unindex{
		typedef unsigned char index_type;
		size_t _bitmark[number_of_possible_values_per<index_type>]{};

		constexpr void bitmark_data_initer(size_t init_to)noexcept{
			for(auto& i:_bitmark)
				i=init_to;
		}

		bitmark_for_quick_unindex()noexcept=default;
		[[nodiscard]]constexpr bool mark(const array_like_view_t<T>&pattern)noexcept{
			bitmark_data_initer(npos);
			#define failed bitmark_data_initer(npos),false
			if constexpr(number_of_possible_values_per<T> > number_of_possible_values_per<index_type>){
				size_t i=0;
				const size_t end=pattern.size();
				while(i<end){
					auto&ch=pattern[i];
					if(::std::make_unsigned_t<T>(ch) >= number_of_possible_values_per<index_type>)
						return failed;
					auto&index=_bitmark[index_type(ch)];
					if(index!=npos)
						return failed;
					index=i;
					i++;
				}
			}
			else{
				size_t i=0;
				const size_t end=pattern.size();
				while(i<end){
					auto&ch=pattern[i];
					auto&index=_bitmark[index_type(ch)];
					if(index!=npos)
						return failed;
					index=i;
					i++;
				}
			}
			#undef failed
			return true;
		}
		[[nodiscard]]constexpr size_t operator[](T&index)const noexcept{
			if constexpr(number_of_possible_values_per<T> > number_of_possible_values_per<index_type>)
				if(::std::make_unsigned_t<T>(index) >= number_of_possible_values_per<index_type>)
					return npos;
			return _bitmark[index_type(index)];
		}
	};
	//  find_last_not_of
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		if constexpr(basic_integer_type<T>){
			bitmark_for_finds<T> mark;
			if(mark.mark(pattern))
				return find_last_not_of_bitmark(mark,range);
		}
		return base_find_last_not_of(pattern,range);
	}
	/// 若成功找到不匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_last_not_of_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_last_not_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
}
using range_n::range_t;
using range_n::in_range;
using range_n::in_range_size_t;
using range_n::in_range_but_reverse;
using range_n::in_range_but_reverse_size_t;
using range_n::find_first_of;
using range_n::find_last_of;
using range_n::find_first_not_of;
using range_n::find_last_not_of;

//file_end

		#line 106 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/sort.hpp"
//sort.hpp
//at namespace elc::defs::base
#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/sort.hpp"
namespace sort_n{
	typedef compare_t default_compare_t;

	//heapsort
	template<typename iter_t, typename compare_t = default_compare_t>
	void heapify(iter_t begin, iter_t end, iter_t i, compare_t compare = compare_t()) {
		auto largest = i; // 初始化largest为根节点
		auto left_child = begin + 2 * (i - begin) + 1; // 左子节点
		auto right_child = left_child + 1; // 右子节点

		// 如果左子节点比根节点大，则更新largest
		if (left_child < end && compare(*left_child, *largest)==strong_ordering::greater)
			largest = left_child;

		// 如果右子节点比根节点大，则更新largest
		if (right_child < end && compare(*right_child, *largest)==strong_ordering::greater)
			largest = right_child;

		// 如果largest不是根节点，则交换根节点和largest的值，并递归地对largest子树进行heapify
		if (largest != i) {
			swap(*i,*largest);
			heapify(begin, end, largest, compare);
		}
	}

	template<typename iter_t, typename compare_t = default_compare_t>
	void build_max_heap(iter_t begin, iter_t end, compare_t compare = compare_t()) {
		auto n = end - begin;

		// 从最后一个非叶子节点开始进行heapify，直到根节点
		for (auto i = n / 2 - 1; i >= 0; i--)
			heapify(begin, end, begin + i, compare);
	}

	template<typename iter_t, typename compare_t = default_compare_t>
	void heapsort(iter_t begin, iter_t end, compare_t compare = compare_t()) {
		auto n = end - begin;

		// 构建最大堆
		build_max_heap(begin, end, compare);

		// 从最后一个元素开始，依次将其与堆顶元素交换，并对堆顶元素进行heapify
		for (auto i = n - 1; i >= 0; i--) {
			swap(*begin,begin[i]);
			heapify(begin, begin + i, begin, compare);
		}
	}

	template<typename array_t, typename compare_t = default_compare_t>
	void heapify(array_t& array, size_t i, compare_t compare = compare_t()) {
		heapify(array.begin(), array.end(), array.begin() + i, compare);
	}
	template<typename array_t, typename compare_t = default_compare_t>
	void build_max_heap(array_t& array, compare_t compare = compare_t()) {
		build_max_heap(array.begin(), array.end(), compare);
	}
	template<typename array_t, typename compare_t = default_compare_t>
	array_t&& heapsort(array_t&& array, compare_t compare = compare_t()) {
		heapsort(array.begin(), array.end(), compare);
		return forward<array_t>(array);
	}

	//insertion_sort
	template<typename iter_t, typename compare_t = default_compare_t>
	void insertion_sort(iter_t begin, iter_t end, compare_t compare = compare_t()) {
		// 从第二个元素开始，依次将其插入到前面已排序的数组中
		for (auto i = begin + 1; i < end; i++) {
			auto key = move(*i);
			auto j = i - 1;
			// 将比key大的元素向后移动
			while (j >= begin && compare(*j, key)==strong_ordering::greater) {
				*(j + 1) = move(*j);
				j--;
			}
			// 将key插入到正确的位置
			*(j + 1) = move(key);
		}
	}
	template<typename array_t, typename compare_t = default_compare_t>
	array_t&& insertion_sort(array_t&& array, compare_t compare = compare_t()) {
		insertion_sort(array.begin(), array.end(), compare);
		return forward<array_t>(array);
	}

	//quicksort
	// partition函数
	template<typename iter_t, typename compare_t = default_compare_t>
	iter_t partition(iter_t begin, iter_t end, compare_t compare = compare_t()) {
		// 选取最后一个元素作为pivot
		auto&pivot = end[-1];
		auto i = begin;
		for (auto j = begin; j < end - 1; j++) {
			// 如果当前元素小于pivot，将其交换到左边
			if (compare(*j, pivot)==strong_ordering::less) {
				swap(*i,*j);
				i++;
			}
		}
		// 将pivot放到正确的位置
		swap(*i,pivot);
		return i;
	}

	// quicksort函数
	template<typename iter_t, typename compare_t = default_compare_t>
	void quicksort(iter_t begin, iter_t end, compare_t compare = compare_t()) {
		while (end - begin > 1) {
			// 分割数组并递归排序
			const auto pivot = partition(begin, end, compare);
			quicksort(begin, pivot, compare);
			begin = pivot + 1;
		}
	}
	template<typename array_t, typename compare_t = default_compare_t>
	array_t&& quicksort(array_t&& array, compare_t compare = compare_t()) {
		quicksort(array.begin(), array.end(), compare);
		return forward<array_t>(array);
	}

	//introsort
	constexpr size_t size_threshold = 1<<4;

	// introsort循环函数
	template<typename iter_t, typename compare_t = default_compare_t>
	void introsort_loop(iter_t begin, iter_t end, size_t depth_limit, compare_t compare = compare_t()) {
		while (end - begin > size_threshold) {
			// 如果递归深度达到了限制，使用heapsort排序
			if (depth_limit == 0) {
				heapsort(begin, end, compare);
				return;
			}
			depth_limit--;

			// 分割数组并递归排序
			const auto pivot = partition(begin, end, compare);
			introsort_loop(pivot + 1, end, depth_limit, compare);
			end = pivot;
		}
		insertion_sort(begin, end, compare);
	}

	// introsort函数
	template<typename iter_t, typename compare_t = default_compare_t>
	void introsort(iter_t begin, iter_t end, compare_t compare = compare_t()) {
		const auto n = end - begin;
		// 如果数组长度小于等于size_threshold，使用插入排序
		if (n <= size_threshold)
			return insertion_sort(begin, end, compare);
		// 否则使用introsort
		const auto depth_limit = decltype(n)(2 * log(n, 2));
		introsort_loop(begin, end, depth_limit, compare);
	}
	template<typename array_t, typename compare_t = default_compare_t>
	array_t&& introsort(array_t&& array, compare_t compare = compare_t()) {
		introsort(array.begin(), array.end(), compare);
		return forward<array_t>(array);
	}

	// 默认排序函数
	template<typename iter_t, typename compare_t = default_compare_t>
	void sort(iter_t begin, iter_t end, compare_t compare = compare_t()) {
		introsort(begin, end, compare);
	}
	template<typename array_t, typename compare_t = default_compare_t>
	array_t&& sort(array_t&& array, compare_t compare = compare_t()) {
		sort(array.begin(), array.end(), compare);
		return forward<array_t>(array);
	}
}
using sort_n::sort;

//file_end

		#line 107 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/string_view.hpp"
//string_view.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/string_view.hpp"
//仅是声明
namespace constexpr_str_n{
	template<typename char_T>
	struct constexpr_str_t;
}
using constexpr_str_n::constexpr_str_t;
//重载range操作
//仅是声明以及size_t包装
namespace range_n{
	template<typename T>
	[[nodiscard]]constexpr T* in_range(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* in_range_but_reverse(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_but_reverse_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range_but_reverse(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* find_first_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_first_of_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_first_of(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* find_last_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_last_of_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_last_of(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* find_first_not_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到不匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_first_not_of_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_first_not_of(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到不匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_last_not_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
}
//开始定义
namespace string_view_n{
	/// array_like_view_t的特化类型，表明这是字符串
	template<typename char_T>
	struct string_view_t:array_like_view_t<const char_T>{
		static constexpr size_t npos=bit::npos;
		typedef array_like_view_t<const char_T> base_t;
		typedef char_T*string_ptr_t;
		typedef const char_T*const_string_ptr_t;
		//构造函数
		using base_t::base_t;
		constexpr string_view_t(const_string_ptr_t str)noexcept:string_view_t(array_end_by_zero_t<const char_T>(str)){}
		//成员函数
		[[nodiscard]]constexpr const char_T*str()const noexcept{return base_t::cbegin();}
		[[nodiscard]]constexpr const char_T*data()const noexcept{return base_t::cbegin();}
		[[nodiscard]]constexpr operator const char_T*()const noexcept{return str();}
		//substr
		[[nodiscard]]constexpr string_view_t substr(size_t pos,size_t len)const noexcept{
			return string_view_t(base_t::cbegin()+pos,len);
		}
		[[nodiscard]]constexpr string_view_t substr(size_t pos)const noexcept{
			return string_view_t(base_t::cbegin()+pos,base_t::size()-pos);
		}
		[[nodiscard]]constexpr string_view_t substr(size_t pos,const char_T*end)const noexcept{
			return string_view_t(base_t::cbegin()+pos,end-base_t::cbegin());
		}
		[[nodiscard]]constexpr string_view_t substr(const char_T*begin,size_t len)const noexcept{
			return string_view_t(begin,len);
		}
		[[nodiscard]]constexpr string_view_t substr(const char_T*begin)const noexcept{
			return string_view_t(begin,base_t::cend()-begin);
		}
		[[nodiscard]]constexpr string_view_t substr(const char_T*begin,const char_T*end)const noexcept{
			return string_view_t(begin,end-begin);
		}
		//starts_with
		[[nodiscard]]constexpr bool starts_with(const char_T ch)const noexcept{
			return base_t::size()&&base_t::cbegin()[0]==ch;
		}
		[[nodiscard]]constexpr bool starts_with(string_view_t str)const noexcept{
			if(str.size()>base_t::size())
				return false;
			return equal(base_t::cbegin(),str.cbegin(),str.size());
		}
		[[nodiscard]]constexpr bool starts_with(const char_T*str)const noexcept{
			size_t i = 0;
			const auto len = base_t::size();
			while(i<len&&str[i])
				if(base_t::cbegin()[i]!=str[i])
					return false;
				else
					++i;
			return str[i]==0;
		}
		//find
		[[nodiscard]]constexpr size_t find(const char_T ch)const{
			return in_range_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t reverse_find(const char_T ch)const{
			return in_range_but_reverse_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t find(string_view_t str)const{
			return in_range_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t reverse_find(string_view_t str)const{
			return in_range_but_reverse_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find(const constexpr_str_t<char_T>&str)const{
			return in_range_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t reverse_find(const constexpr_str_t<char_T>&str)const{
			return in_range_but_reverse_size_t(str, *this);
		}
		//others by range_n::find_last_of_size_t etc
		[[nodiscard]]constexpr size_t find_first_of(const char_T ch)const{
			return range_n::find_first_of_size_t(array_like_view_t<const char_T>(&ch, 1), *this);
		}
		[[nodiscard]]constexpr size_t find_last_of(const char_T ch)const{
			return range_n::find_last_of_size_t(array_like_view_t<const char_T>(&ch, 1), *this);
		}
		[[nodiscard]]constexpr size_t find_first_not_of(const char_T ch)const{
			return range_n::find_first_not_of_size_t(array_like_view_t<const char_T>(&ch, 1), *this);
		}
		[[nodiscard]]constexpr size_t find_last_not_of(const char_T ch)const{
			return range_n::find_last_not_of_size_t(array_like_view_t<const char_T>(&ch, 1), *this);
		}
		[[nodiscard]]constexpr size_t find_first_of(string_view_t str)const{
			return range_n::find_first_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_last_of(string_view_t str)const{
			return range_n::find_last_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_first_not_of(string_view_t str)const{
			return range_n::find_first_not_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_last_not_of(string_view_t str)const{
			return range_n::find_last_not_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_first_of(const constexpr_str_t<char_T>&str)const{
			return range_n::find_first_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_last_of(const constexpr_str_t<char_T>&str)const{
			return range_n::find_last_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_first_not_of(const constexpr_str_t<char_T>&str)const{
			return range_n::find_first_not_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_last_not_of(const constexpr_str_t<char_T>&str)const{
			return range_n::find_last_not_of_size_t(str, *this);
		}
	};
	typedef string_view_t<char_t>string_view;
}
using string_view_n::string_view_t;
using string_view_n::string_view;

//file_end

		#line 108 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/type_name.hpp"
//type_name.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/type_name.hpp"
struct demangle_name_t:string_view_t<char>{
	//对于gcc和clang，这个类型有一个malloced的char*，以便于在析构时释放
	//一切源于abi::__cxa_demangle
	//对于msvc，这个类型析构时不需要做任何事情
	typedef string_view_t<char> base_t;
	/// 重整器包装
	static base_t demangle(const char*original_name)noexcept{
		push_and_disable_msvc_warning(26494);//未初始化警告diss
		size_t len;
		const char*demangled_name;
		pop_msvc_warning();
		#if defined(__clang__)||defined(__GNUC__)
			//gcc和clang
			//使用abi::__cxa_demangle重整
			int status;
			demangled_name=::abi::__cxa_demangle(original_name,nullptr,&len,&status);
			if(status!=0){
				demangled_name=original_name;
				len=::std::strlen(original_name);
				::std::free((void*)demangled_name);
			}
		#else
			//msvc
			//不需要重整
			demangled_name=original_name;
			len=::std::strlen(original_name);
		#endif
		return base_t{demangled_name,len};
	}
	/// 复制重整结果
	static base_t copy_demangle(base_t demangled_name)noexcept{
		#if defined(__clang__)||defined(__GNUC__)
			//gcc和clang
			//需要复制重整结果（用malloced的char*）
			char*copyed_name=(char*)::std::malloc(demangled_name.size()+1);
			if(copyed_name==nullptr)
				return base_t{nullptr,0};
			::std::memcpy(copyed_name,demangled_name.data(),demangled_name.size());
			copyed_name[demangled_name.size()]='\0';
			return base_t{copyed_name,demangled_name.size()};
		#else
			//msvc
			//不需要复制重整结果
			return demangled_name;
		#endif
	}
	/// 构造函数
	demangle_name_t(const char*original_name)noexcept:base_t(demangle(original_name)){}
	/// 复制构造函数
	demangle_name_t(const demangle_name_t&other)noexcept:base_t(copy_demangle(other)){}
	/// 移动构造函数（swap）
	demangle_name_t(demangle_name_t&&other)noexcept:base_t(nullptr,0){
		swap_with(other);
	}
	/// 析构函数
	~demangle_name_t()noexcept{
		#if defined(__clang__)||defined(__GNUC__)
			//gcc和clang
			//需要释放malloced的char*
			::std::free((void*)begin());
		#endif
	}
};
struct type_name_t:demangle_name_t{
	using base_t=demangle_name_t;
	using base_t::base_t;
};
[[nodiscard]]inline type_name_t base_type_info_t::get_name()const noexcept{
	return _tid.get_name();
}
[[nodiscard]]inline type_name_t base_type_info_t::type_id_t::get_name()const noexcept{
	return _m->name();
}
template<typename T>
[[nodiscard]]inline type_name_t type_info_t<T>::get_name()const noexcept{
	return base_type_info_t(*this).get_name();
}

//file_end

		#line 109 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/constexpr_str.hpp"
//constexpr_str.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/constexpr_str.hpp"
namespace constexpr_str_n{
	/// constexpr_str_t的退化类型，表明这是常量字符串，但没有可用的额外信息
	template<typename char_T>
	struct constexpr_str_view_t:string_view_t<char_T>{
		typedef string_view_t<char_T> base_t;
		using base_t::base_t;
		using base_t::string_ptr_t;
		using base_t::const_string_ptr_t;
		constexpr_str_view_t(const_string_ptr_t str)noexcept=delete;
		//成员函数
		[[nodiscard]]constexpr const_string_ptr_t str()const noexcept{return base_t::cbegin();}
		[[nodiscard]]constexpr const_string_ptr_t data()const noexcept{return base_t::cbegin();}
		[[nodiscard]]constexpr operator const_string_ptr_t ()const noexcept{return str();}
		//substr
		[[nodiscard]]constexpr constexpr_str_view_t substr(size_t pos,size_t len)const noexcept{
			return base_t::substr(pos,len);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(size_t pos)const noexcept{
			return base_t::substr(pos);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(size_t pos,const char_T*end)const noexcept{
			return base_t::substr(pos,end);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(const char_T*begin,size_t len)const noexcept{
			return base_t::substr(begin,len);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(const char_T*begin)const noexcept{
			return base_t::substr(begin);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(const char_T*begin,const char_T*end)const noexcept{
			return base_t::substr(begin,end);
		}
	};
	/// 告知其他elc库接口这是编译时常量字符串，并提供编译时计算好的内容，包括但不限于hash、bmh头、bitmark等，用于加速库操作
	template<typename char_T>
	struct constexpr_str_t:constexpr_str_view_t<char_T>{
		typedef constexpr_str_view_t<char_T> base_t;
		typedef char_T*string_ptr_t;
		typedef const char_T*const_string_ptr_t;
		hash_t hash_result;
		range_n::match_pattern<const char_T> match_pattern;
		range_n::reverse_match_pattern<const char_T> reverse_match_pattern;
		range_n::bitmark_for_finds<const char_T> bitmark_for_finds;
		range_n::bitmark_for_quick_unindex<const char_T> bitmark_for_unindex;
		bool is_bitmark_workable;
		bool is_bitmark_for_unindex_workable=0;
		constexpr constexpr_str_t(const_string_ptr_t str, size_t size):
			base_t(str, size),
			hash_result(defs::hash(str, size)),
			match_pattern(array_like_view_t<const char_T>{str, size}),
			reverse_match_pattern(array_like_view_t<const char_T>{str, size}){
				is_bitmark_workable = bitmark_for_finds.mark(*this);
				if(is_bitmark_workable)
					is_bitmark_for_unindex_workable=bitmark_for_unindex.mark(*this);
			}
		constexpr constexpr_str_t(const_string_ptr_t str):constexpr_str_t(str,array_end_by_zero_t<char_T>::get_length_of(str)){}
		consteval constexpr_str_t(const constexpr_str_t&str)=default;
		[[nodiscard]]constexpr hash_t hash()const noexcept{return hash_result;}
	};
	using constexpr_str=constexpr_str_t<char_t>;
	template<class char_T,size_t N>
	struct constexpr_str_t_literal_helper{
		typedef char_T*string_ptr_t;
		typedef const char_T*const_string_ptr_t;
		const_string_ptr_t _array_begin;
		constexpr constexpr_str_t_literal_helper(const char_T(&str)[N])noexcept{
			_array_begin=str;
		}
		[[nodiscard]]constexpr auto get_constexpr_str_t()const noexcept{
			return constexpr_str_t{_array_begin,N-1};
		}
	};
	template<constexpr_str_t_literal_helper v>
	struct literal_result_provider{
		distinctive static constexpr auto value = v.get_constexpr_str_t();
	};
	//别问，问就是傻逼c++
	/// 告知其他elc库接口这是编译时常量字符串，并提供编译时计算好的内容，包括但不限于hash、bmh头、bitmark等，用于加速库操作
	template<constexpr_str_t_literal_helper str_helper>
	[[nodiscard]]inline consteval const auto& operator ""_constexpr_str()noexcept{
		return literal_result_provider<str_helper>::value;
	}
	/// 空字串常量且str或begin会指向一个0终止字符串（而不是nullptr），便于安全初始化
	template<class char_T>
	distinctive inline constexpr auto empty_constexpr_str_of = constexpr_str_t(&const_default_value_of<char_T>,0);
};
using constexpr_str_n::constexpr_str_view_t;
using constexpr_str_n::constexpr_str_t;
using constexpr_str_n::constexpr_str;
using constexpr_str_n::empty_constexpr_str_of;
using constexpr_str_n::operator ""_constexpr_str;

//重载range操作
namespace range_n{
	template<typename T>
	[[nodiscard]]constexpr T* in_range(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		return pattern.match_pattern.match(range);
	}
	template<typename T>
	[[nodiscard]]constexpr T* in_range_but_reverse(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		return pattern.reverse_match_pattern.match(range);
	}
	//find_first_of
	//若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		if(pattern.is_bitmark_workable)
			return find_first_of_bitmark(pattern.bitmark_for_finds,range);
		else
			return find_first_of((const constexpr_str_view_t<T>&)pattern,range);
	}
	//find_last_of
	//若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		if(pattern.is_bitmark_workable)
			return find_last_of_bitmark(pattern.bitmark_for_finds,range);
		else
			return find_last_of((const constexpr_str_view_t<T>&)pattern,range);
	}
	//find_first_not_of
	//若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_not_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		if(pattern.is_bitmark_workable)
			return find_first_not_of_bitmark(pattern.bitmark_for_finds,range);
		else
			return find_first_not_of((const constexpr_str_view_t<T>&)pattern,range);
	}
	//find_last_not_of
	//若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		if(pattern.is_bitmark_workable)
			return find_last_not_of_bitmark(pattern.bitmark_for_finds,range);
		else
			return find_last_not_of((const constexpr_str_view_t<T>&)pattern,range);
	}

	// 单字匹配相关

	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr const T* in_range(const remove_cvref<T>&pattern,const constexpr_str_t<T>&range){
		if(range.is_bitmark_for_unindex_workable){
			auto result = range.bitmark_for_unindex[pattern];
			return result==npos?nullptr:range.begin()+result;
		}
		else
			return in_range(pattern,(const constexpr_str_view_t<T>&)range);
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_size_t(const remove_cvref<T>&pattern,const constexpr_str_t<T>&range){
		if(range.is_bitmark_for_unindex_workable)
			return range.bitmark_for_unindex[pattern];
		else
			return in_range_size_t(pattern,(const constexpr_str_view_t<T>&)range);
	}
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr const T* in_range_but_reverse(const remove_cvref<T>&pattern,const constexpr_str_t<T>&range){
		if(range.is_bitmark_for_unindex_workable){
			auto result = range.bitmark_for_unindex[pattern];
			return result==npos?nullptr:range.begin()+result;
		}
		else
			return in_range_but_reverse(pattern,(const constexpr_str_view_t<T>&)range);
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_but_reverse_size_t(const remove_cvref<T>&pattern,const constexpr_str_t<T>&range){
		if(range.is_bitmark_for_unindex_workable)
			return range.bitmark_for_unindex[pattern];
		else
			return in_range_but_reverse_size_t(pattern,(const constexpr_str_view_t<T>&)range);
	}
};
using range_n::in_range;
using range_n::in_range_size_t;
using range_n::in_range_but_reverse;
using range_n::in_range_but_reverse_size_t;
using range_n::find_first_of;
using range_n::find_last_of;
using range_n::find_first_not_of;
using range_n::find_last_not_of;

//file_end

		#line 110 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/logical_bool.hpp"
//logical_bool.hpp
//at namespace elc::defs::base
#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/logical_bool.hpp"
/*! 混沌布尔值。
	允许输出介于真假之间的内容的布尔值。
	混沌布尔值会有五个可能的值，分别为true,false,neither,either。unknown视为不合法。
	用在if与while中时，true，either被判定为真，其与均为假。
	用法：
	logical_bool(bool)		输出logical_bool,将布尔值转换为混沌布尔值。
	bool(logical_bool)		输出bool，将混沌布尔值转化为布尔值。
	允许与或非运算：输出结果仍然为混沌布尔值,参与运算的值如果有unknown则均输出unknown.
	允许判定相等，输出结果为混沌布尔值,参与运算的值如果有unknown则均输出unknown，否则仅有true和false两个合法值。
*/
#line 47 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/logical_bool.hpp"
struct logical_bool{
private:
	[[no_unique_address]]bool _is_true;
	[[no_unique_address]]bool _is_false;
	[[no_unique_address]]bool _is_unknown;
public:
	constexpr logical_bool(special_init_t,bool is_true,bool is_false,bool is_unknown=0)noexcept:_is_true(is_true),_is_false(is_false),_is_unknown(is_unknown){}
	constexpr logical_bool(bool a)noexcept:_is_true(a),_is_false(!a),_is_unknown(0){}
	constexpr logical_bool(const logical_bool&)noexcept=default;
	constexpr logical_bool&operator=(const logical_bool&)&noexcept=default;
	constexpr explicit operator bool()const noexcept{return _is_true && !_is_unknown;}
	constexpr logical_bool operator!()const noexcept{
		logical_bool aret=*this;
		swap(aret._is_true,aret._is_false);
		return aret;
	}
	friend logical_bool operator&&(logical_bool a,logical_bool b)noexcept{
		return logical_bool{special_init,a._is_true && b._is_true,a._is_false || b._is_false,a._is_unknown || b._is_unknown};
	}
	friend logical_bool operator||(logical_bool a,logical_bool b)noexcept{
		return logical_bool{special_init,a._is_true || b._is_true,a._is_false && b._is_false,a._is_unknown || b._is_unknown};
	}
	friend logical_bool operator==(logical_bool a,logical_bool b)noexcept{
		logical_bool aret(a._is_true == b._is_true && a._is_false == b._is_false);
		aret._is_unknown = a._is_unknown || b._is_unknown;
		return aret;
	}
};
constexpr logical_bool neither{special_init,0,0},either{special_init,1,1},unknown{special_init,0,0,1};

//file_end

		#line 111 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/count_able.hpp"
//count_able.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/count_able.hpp"
template<class T>
[[nodiscard]]inline size_t the_number_of(type_info_t<T>)noexcept;
template<class T>
struct count_able:is_common_attribute(count_able){
private:
	friend size_t the_number_of<T>(type_info_t<T>)noexcept;
	static size_t _number;
public:
	count_able()noexcept{_number++;}
	~count_able()noexcept{_number--;}
};
template<class T>
[[nodiscard]]inline size_t the_number_of(type_info_t<T>)noexcept{
	if constexpr(type_info<T>.not_has_attribute(count_able))
		template_error("hey.");
	return count_able<T>::_number;
}

//file_end

		#line 112 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/invoke.hpp"
//invoke.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/invoke.hpp"
template<typename T>
struct invoke_t{
	/*!
	Determines if a type is invocable.

	@tparam T The type to check.
	@tparam Args The types of the arguments to the type.

	@returns True if the type is invocable, false otherwise.
	*/
	template<class...Args>
	static constexpr bool able= ::std::is_invocable_v<T,Args...>;
	/*!
	Determines if a type is invocable and nothrow.

	@tparam T The type to check.
	@tparam Args The types of the arguments to the type.

	@returns True if the type is nothrow invocable, false otherwise.
	*/
	template<class...Args>
	static constexpr bool nothrow= ::std::is_nothrow_invocable_v<T,Args...>;

	//和期待类型
	template<class Ret_t>
	struct with_return_type_t{
		template<class...Args>
		static constexpr bool able= ::std::is_invocable_r_v<Ret_t,T,Args...>;
		template<class...Args>
		static constexpr bool nothrow= ::std::is_nothrow_invocable_r_v<Ret_t,T,Args...>;

		/*!
		A function that returns a lambda that applies a function to a value.

		@param rest The arguments to the function.

		@returns A lambda that applies the function to a value.
		*/
		template<class...Args> requires able<Args...>
		decltype(auto)_as(Args&&...rest)const noexcept(nothrow<Args...>){//invoke<T>.with_return_type<Ret_t>._as(...)
			return lambda_with_catch(rest...)(const T&a)noexcept(nothrow<Args...>){return a(forward<Args>(rest)...);};
		}
	};
	template<class Ret_t>
	static constexpr with_return_type_t<Ret_t>with_return_type{};

	/*!
	A function that returns a lambda that applies a function to a value.

	@param rest The arguments to the function.

	@returns A lambda that applies the function to a value.
	*/
	template<class...Args> requires able<Args...>
	decltype(auto)_as(Args&&...rest)const noexcept(nothrow<Args...>){//invoke<T>._as(...)
		return lambda_with_catch(rest...)(const T&a)noexcept(nothrow<Args...>){return a(forward<Args>(rest)...);};
	}
};
template<typename T>
constexpr invoke_t<T>invoke{};

//file_end

		#line 113 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/maybe_fail_reference.hpp"
//maybe_fail_reference.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/maybe_fail_reference.hpp"
template<typename T>
class maybe_fail_reference{
	T*_ref_to;
public:
	constexpr maybe_fail_reference(T&a)noexcept:_ref_to(&a){}
	constexpr maybe_fail_reference(const maybe_fail_reference&)=default;
	constexpr maybe_fail_reference(note::fail_t)noexcept:_ref_to(nullptr){}

	[[nodiscard]]bool not_fail()noexcept{return _ref_to;}
	[[nodiscard]]bool fail()noexcept{return!not_fail();}
	T&get_ref()noexcept{return*_ref_to;}
};

//file_end

		#line 114 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/flag.hpp"
//flag.hpp
//at namespace elc::defs::base
#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/flag.hpp"
enum class flag_set_type:bool{seted=true,not_set=false};
using enum flag_set_type;
#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/flag.hpp"
class flag{
	bool _m;
public:
	constexpr explicit flag(flag_set_type a=not_set)noexcept:_m(bool(a)){}
	[[nodiscard]]explicit operator bool()const noexcept{return _m;}
	flag(flag&a)noexcept:_m((bool)a){}
	flag(flag&&a)noexcept:_m((bool)a){}
	inline void operator=(flag&)&noexcept=delete;
	inline void operator=(flag&&)&noexcept=delete;
	inline void set()noexcept{_m=true;}
	inline void unset()noexcept{_m=false;}
};

//file_end

		#line 115 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/mark_type.hpp"
//mark_type.hpp
//at namespace elc::defs::base
#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/mark_type.hpp"
enum class mark_type:bool{marked=true,not_mark=false};
using enum mark_type;
#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/mark_type.hpp"
template<typename T>
class mark_able:non_copyable,non_moveable{
	mutable flag _m;
public:
	constexpr explicit mark_able(mark_type a=not_mark)noexcept:_m(a==not_mark?not_set:seted){};
	inline void mark()const noexcept{_m.set();}
	inline void unmark()const noexcept{_m.unset();}
	[[nodiscard]]bool was_marked()const noexcept{return(bool)_m;}
};

//file_end

		#line 116 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/list.hpp"
//list.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/list.hpp"
//copy from old ELC
template<typename T>
class list_t;
#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/list.hpp"
template<typename T>
struct cons_t:non_copyable,non_moveable,is_common_attribute(cons_t){
	typedef cons_t<T> this_t;
private:
	friend list_t<T>;
	friend iterator_t<T,this_t*>::base_t;
	typedef attribute<T,this_t> attribute_t;

	mutable this_t*_before;//为了在析构时修改前一项的next，勿删
	mutable this_t*_next;

	[[nodiscard]]this_t*get_before()noexcept{return _before;}
	[[nodiscard]]this_t*get_next()noexcept{return _next;}

	constexpr cons_t(this_t*a,this_t*b):_before(a),_next(b){}

	constexpr void set_before(this_t*a){
		_before=a;
		a->_next=this;
	}
	constexpr void set_next(this_t*a){
		_next=a;
		a->_before=this;
	}
	constexpr void insert_to_before(this_t*a){
		set_before(a->_before);
		set_next(a);
	}
	constexpr void bind_with(this_t*a)noexcept{
		set_next(a);
		set_before(a);
	}
	constexpr void remove_from_list()noexcept{
		_before->set_next(_next);
	}
	[[nodiscard]]constexpr T*get_handle(){
		return attribute_t::get_handle();
	}
public:
	constexpr cons_t()=default;
	~cons_t(){
		remove_from_list();
	}
};
#line 90 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/list.hpp"
template<typename T>
struct list_t{
	typedef list_t<T> this_t;
	typedef cons_t<T> cons;
	typedef iterator_t<T,cons*>iterator;
private:
	cons _begin,_end;
public:
	constexpr list_t()noexcept{_begin.bind_with(&_end);}
	inline constexpr void add(cons*a)noexcept{
		a->insert_to_before(&_end);
	}
	[[nodiscard]]constexpr iterator begin()noexcept{return _begin.get_next();}//这叫头迭代器
	[[nodiscard]]constexpr iterator end()noexcept{return&_end;}//这叫超尾迭代器
	[[nodiscard]]constexpr iterator head()noexcept{return&_begin;}//。。。。这个大概就是超头迭代器了😂
	[[nodiscard]]constexpr bool empty()const noexcept{return _begin.get_next()==&_end;}
};

//file_end

		#line 118 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/function_base.hpp"
//function_base.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/function_base.hpp"
namespace function_base_n{
	#if !defined(_MSC_VER)
	template<typename>
	struct function_type_getter_helper{};

	template<typename Ret_t,typename T,typename...Args_t,bool nothrow>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)noexcept(nothrow)>
	{using type=Ret_t(Args_t...)noexcept(nothrow);};

	template<typename Ret_t,typename T,typename...Args_t,bool nothrow>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)&noexcept(nothrow)>
	{using type=Ret_t(Args_t...)noexcept(nothrow);};

	template<typename Ret_t,typename T,typename...Args_t,bool nothrow>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const noexcept(nothrow)>
	{using type=Ret_t(Args_t...)noexcept(nothrow);};

	template<typename Ret_t,typename T,typename...Args_t,bool nothrow>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const&noexcept(nothrow)>
	{using type=Ret_t(Args_t...)noexcept(nothrow);};

	template<typename T>
	[[nodiscard]]constexpr auto function_type_getter_conditional_helper()noexcept{
		if constexpr(::std::is_function_v<remove_cvref<T>>)
			return type_info<remove_cvref<T>>;
		elseif constexpr(is_pointer<T> && ::std::is_function_v<remove_cvref<::std::remove_pointer_t<T>>>)//不支持多级函数指针：懒得写（其实挺简单的），而且function_t若支持多级函数指针的推导指引会很不安全
			return function_type_getter_conditional_helper<::std::remove_pointer_t<T>>();
		else
			return type_info<type_name function_type_getter_helper<decltype(&T::operator())>::type>;
	}
	template<typename T>
	struct function_type_getter{
		typedef decltype(function_type_getter_conditional_helper<T>())::template_name type type;
	};

	#line 70 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/function_base.hpp"
	template<typename T>
	using get_function_type=function_type_getter<T>::type;

	#line 77 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/function_base.hpp"
	template<class T,class Func_t=get_function_type<T>>
	class function_data_wrapper_t;
	template<class T,bool nothrow,class Ret_t,class...Args_t>
	struct function_data_wrapper_t<T,Ret_t(Args_t...)noexcept(nothrow)>{
		static_assert(!::std::is_function_v<remove_cvref<T>>);

		T _value;

		function_data_wrapper_t(T a)noexcept(construct<T>.nothrow<T>):_value(a){}
		~function_data_wrapper_t()noexcept(destruct.nothrow<T>)=default;
		Ret_t operator()(Args_t...args)noexcept(nothrow || invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>){
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		Ret_t operator()(Args_t...args)const noexcept(nothrow || invoke<const T>.with_return_type<Ret_t>.nothrow<Args_t...>){
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		[[nodiscard]]auto&get_data()noexcept{return _value;}
	};
	#else
	//MSVC，我滴垃圾堆
	template<typename>
	struct function_type_getter_helper{};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)>
	{using type=Ret_t(Args_t...);};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)&>
	{using type=Ret_t(Args_t...);};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const>
	{using type=Ret_t(Args_t...);};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const&>
	{using type=Ret_t(Args_t...);};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)noexcept>
	{using type=Ret_t(Args_t...)noexcept;};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)&noexcept>
	{using type=Ret_t(Args_t...)noexcept;};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const noexcept>
	{using type=Ret_t(Args_t...)noexcept;};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const&noexcept>
	{using type=Ret_t(Args_t...)noexcept;};

	template<typename T>
	[[nodiscard]]constexpr auto function_type_getter_conditional_helper()noexcept{
		if constexpr(::std::is_function_v<remove_cvref<T>>)
			return type_info<remove_cvref<T>>;
		elseif constexpr(is_pointer<T> && ::std::is_function_v<remove_cvref<::std::remove_pointer_t<T>>>)//不支持多级函数指针：懒得写（其实挺简单的），而且function_t若支持多级函数指针的推导指引会很不安全
			return function_type_getter_conditional_helper<::std::remove_pointer_t<T>>();
		else
			return type_info<type_name function_type_getter_helper<decltype(&T::operator())>::type>;
	}
	template<typename T>
	struct function_type_getter{
		typedef decltype(function_type_getter_conditional_helper<T>())::template_name type type;
	};

	#line 168 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/function_base.hpp"
	template<typename T>
	using get_function_type=function_type_getter<T>::type;

	#line 175 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/function_base.hpp"
	template<class T,class Func_t=get_function_type<T>>
	class function_data_wrapper_t;
	template<class T,class Ret_t,class...Args_t>
	struct function_data_wrapper_t<T,Ret_t(Args_t...)noexcept>{
		static_assert(!::std::is_function_v<remove_cvref<T>>);

		T _value;

		function_data_wrapper_t(T a)noexcept(construct<T>.nothrow<T>):_value(a){}
		~function_data_wrapper_t()noexcept(destruct.nothrow<T>)=default;
		Ret_t operator()(Args_t...args)noexcept{
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>)
				template_warning("this T may throw an exception.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		Ret_t operator()(Args_t...args)const noexcept{
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>)
				template_warning("this T may throw an exception.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		[[nodiscard]]auto&get_data()noexcept{return _value;}
	};
	#line 219 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/function_base.hpp"
	template<class T,class Ret_t,class...Args_t>
	struct function_data_wrapper_t<T,Ret_t(Args_t...)>{
		static_assert(!::std::is_function_v<remove_cvref<T>>);

		T _value;

		function_data_wrapper_t(T a)noexcept(construct<T>.nothrow<T>):_value(a){}
		~function_data_wrapper_t()noexcept(destruct.nothrow<T>)=default;
		Ret_t operator()(Args_t...args)noexcept(invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>){
			//BLOCK:constexpr checks
			//if constexpr(!invoke<T>.able<Args_t...>)
			//workaround of https://developercommunity.visualstudio.com/t/name-lookup-problem-after-update-1740/10189035
			if constexpr(!::std::is_invocable_v<T,Args_t...>)
				template_error("this T can\'t becall as args.");
			//if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
			//workaround of https://developercommunity.visualstudio.com/t/name-lookup-problem-after-update-1740/10189035
			if constexpr(!::std::is_invocable_r_v<Ret_t,T,Args_t...>)
				template_error("the return type of T was wrong.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		Ret_t operator()(Args_t...args)const noexcept(invoke<const T>.with_return_type<Ret_t>.nothrow<Args_t...>){
			//BLOCK:constexpr checks
			//if constexpr(!invoke<const T>.able<Args_t...>)
			//workaround of https://developercommunity.visualstudio.com/t/name-lookup-problem-after-update-1740/10189035
			if constexpr(!::std::is_invocable_v<const T, Args_t...>)
				template_error("this T can\'t becall as args.");
			//if constexpr(!invoke<const T>.with_return_type<Ret_t>.able<Args_t...>)
			//workaround of https://developercommunity.visualstudio.com/t/name-lookup-problem-after-update-1740/10189035
			if constexpr(!::std::is_invocable_r_v<Ret_t,const T,Args_t...>)
				template_error("the return type of T was wrong.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		[[nodiscard]]auto&get_data()noexcept{return _value;}
		[[nodiscard]]const auto&get_data()const noexcept{return _value;}
	};
	#endif
}
using function_base_n::get_function_type;
using function_base_n::function_data_wrapper_t;

//file_end

		#line 120 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
	}

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_PUBLIC_ALL)
	#undef protected
	#undef private
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef times
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef exlambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS
#undef lambda_inline
#undef lambda_force_inline

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 123 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
}

//file_end

	#line 56 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#endif

//file_end

	#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	//
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_PUBLIC_ALL)
	#define protected public
	#define private public
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#define times(...) ([[maybe_unused]]auto [loop_times,loop_end_value] : ::elc::defs::times_provider_t(__VA_ARGS__)) //for times(72)do_something;
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name,...) \
exlambda(auto&&...Args)__VA_ARGS__ lambda_force_inline{\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define exlambda [&]
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#if defined(_MSC_VER) && !defined(__clang__)
	#define lambda_inline [[msvc::forceinline]]
	#define lambda_force_inline [[msvc::forceinline]]
#elif
	#define lambda_inline [[gnu::always_inline]]
	#define lambda_force_inline [[gnu::always_inline]]
#else
	#define lambda_inline
	#define lambda_force_inline
#endif

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
	#define in_debug 1
#else
	#define not_in_debug 1
	#define in_debug 0
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

	#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/zh_cn.hpp"
//zh_cn.hpp
#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/zh_cn.hpp"
namespace elc::defs::locale::func{

}
namespace elc::defs::locale::str{
	inline namespace gc{
		inline constexpr auto gc_fail=es"gc失败"_constexpr_str;
		inline constexpr auto empty_gc_method=es"gc方法为空时gc被调用"_constexpr_str;
	}
	inline namespace code_convert{
		inline constexpr auto setlocale_error=es"setlocale出错"_constexpr_str;
		inline constexpr auto code_convert_error=es"编码转换出错"_constexpr_str;
	}
	inline namespace lib_load{
		inline constexpr auto null_lib=es"访问null处的lib对象"_constexpr_str;
	}
	inline namespace exception{
		inline constexpr auto unknow_error=es"未知错误"_constexpr_str;
		inline constexpr auto core_runtime_internal_helper_leak=es"未知错误"_constexpr_str;
	}
	inline namespace base_read{
		inline constexpr auto ending_of_expr_beyond_expectations=es"表达式的结尾超出预期"_constexpr_str;
		inline constexpr auto expr_incomplete=es"表达式未完成"_constexpr_str;
		inline constexpr auto symbol_is_undefined=es"此符号未定义"_constexpr_str;
		inline constexpr auto expr_too_outrageous=es"表达式过于离谱"_constexpr_str;
	}
	inline namespace package_symbol_loader{
		inline constexpr auto load_failed=es"无法加载的package_symbol_loader"_constexpr_str;
		inline constexpr auto load_interface_failed=es"package_symbol_loader缺失load_interface"_constexpr_str;
	}
	inline namespace streams{
		inline constexpr auto stream_read_error=es"流读取错误"_constexpr_str;
		inline constexpr auto stream_write_error=es"流写入错误"_constexpr_str;
	}
	inline namespace die{
		//TODO
	}
}

//file_end

	#line 42 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_PUBLIC_ALL)
	#undef protected
	#undef private
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef times
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef exlambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS
#undef lambda_inline
#undef lambda_force_inline

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

	#line 43 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	//
#endif

//file_end

	#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
	#define ELC_BASE_EXCEPTION
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
//_body.hpp
//at namespace ::
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
#if defined(ELC_TEST)
	#error "this part cannot be tested."
#endif
//char_t
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
//default_data_type.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
namespace elc{
	/*ELC内部string统一采用char_t宽字符，使用setlocale(LC_ALL,"en_US.utf8")下的UTF编码。*/
	typedef char32_t char_t;
	/*c_string表示*/
	typedef char_t* string_ptr_t;
	/*c_string表示*/
	typedef const char_t* const_string_ptr_t;
	/*ELC内部钦定int_t类型*/
	typedef int64_t int_t;
	/*ELC内部钦定uint_t类型*/
	typedef uint64_t uint_t;
	/*ELC内部钦定float_t类型*/
	typedef double float_t;
	/*ELC内部钦定float_size_t类型，用以描述内存大小的浮点状况*/
	typedef long double float_size_t;
}

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_PUBLIC_ALL)
	#define protected public
	#define private public
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#define times(...) ([[maybe_unused]]auto [loop_times,loop_end_value] : ::elc::defs::times_provider_t(__VA_ARGS__)) //for times(72)do_something;
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name,...) \
exlambda(auto&&...Args)__VA_ARGS__ lambda_force_inline{\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define exlambda [&]
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#if defined(_MSC_VER) && !defined(__clang__)
	#define lambda_inline [[msvc::forceinline]]
	#define lambda_force_inline [[msvc::forceinline]]
#elif
	#define lambda_inline [[gnu::always_inline]]
	#define lambda_force_inline [[gnu::always_inline]]
#else
	#define lambda_inline
	#define lambda_force_inline
#endif

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
	#define in_debug 1
#else
	#define not_in_debug 1
	#define in_debug 0
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"

	namespace exception_n{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/exception/_body.hpp"
//_body.hpp
//at namespace elc::defs::exception_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/exception/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/exception/exception.hpp"
//_body.hpp
//at namespace elc::defs::exception_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/exception/exception.hpp"
no_vtable_class exception{
	const_string_ptr_t _constexpr_str=locale::str::exception::unknow_error;
public:
	constexpr exception()noexcept=default;
	constexpr exception(const constexpr_str&str)noexcept:_constexpr_str(str){}
	virtual constexpr ~exception()noexcept=0;
	virtual constexpr const_string_ptr_t what()noexcept{return _constexpr_str;}
};
inline constexpr exception::~exception()noexcept{}

struct runtime_exception:exception{
	using exception::exception;
};

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/exception/_body.hpp"

//file_end

		#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
	}
	namespace exceptions=exception_n;

	#if defined(ELC_TEST_ON)
	namespace base_exception_part_test{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_test.hpp"
//_test.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_test.hpp"
inline void test(){
	ELC_TEST_EVENTNAME("base_exception部分测试");
}
inline void test_log_out(){
}
inline void test_end(){
}

//file_end

		#line 45 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
	}
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_PUBLIC_ALL)
	#undef protected
	#undef private
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef times
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef exlambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS
#undef lambda_inline
#undef lambda_force_inline

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 49 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
}
namespace elc{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_export.hpp"
//_export.hpp
//at namespace elc
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_export.hpp"
#define export using defs::exception_n::
export exception;
export runtime_exception;
#undef export

//file_end

	#line 52 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
}

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
#endif

//file_end

