#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/namespace"
//namespace
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/namespace"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/namespace"
#if !defined(ELC_NAMESPACE)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/core"
//core
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/core"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/core"
#if !defined(ELC_CORE)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
//base
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
#if !defined(ELC_BASE)
	//原base的一小部分，但由于过于底层，底层到API定义都需要使用。。
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
//base_defs
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#if !defined(ELC_BASE_DEFS)
	#define __builtin_is_my_dick_still_there() true
	#include <cstddef>//nullptr_t
	#include <cstdlib>//exit、size_t
	#include <cstring>//strlen & memcpy
	#include <new>//operator delete、launder
	#include <algorithm>//max、min
	#include <type_traits>//enable_if等
	#include <typeinfo>//RTTI
	#include <cmath>//sqrt
	#include <cfenv>//rounding
	#include <ctime>//time
	#include <ranges>
	#include <initializer_list>
	#if defined(__clang__)||defined(__GNUC__)
		#include <cxxabi.h>
	#endif
	#define ELC_BASE_DEFS
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
//_body.hpp
//at namespace ::
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
//include default_data_type：基础数据类型定义
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
//default_data_type.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
namespace elc{
	/*ELC内部string统一采用char_t宽字符，使用setlocale(LC_ALL,"en_US.utf8")下的UTF编码。*/
	typedef char32_t char_t;
	/*c_string表示*/
	typedef char_t* string_ptr_t;
	/*c_string表示*/
	typedef const char_t* const_string_ptr_t;
	/*ELC内部钦定int_t类型*/
	typedef int64_t int_t;
	/*ELC内部钦定uint_t类型*/
	typedef uint64_t uint_t;
	/*ELC内部钦定float_t类型*/
	typedef double float_t;
	/*ELC内部钦定float_size_t类型，用以描述内存大小的浮点状况*/
	typedef long double float_size_t;
}

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
//_body.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
#if defined(_MSC_VER)//int128
	#include <__msvc_int128.hpp>
#endif
#include <bit>
#include <climits>
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#if !defined(ELC_WARNING_LEVEL)
	#define ELC_WARNING_LEVEL 4
#endif

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

	#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"

	namespace basic_environment{
		/// 每个bit（不是字节）的可能性
		/// 为什么c艹委员会不定义这个？
		constexpr size_t BIT_POSSIBILITY=2;

		#if defined(__SIZEOF_INT128__)
			#define ELC_BASE_ENV_HAS_INT128
			typedef __uint128_t uint128_t;
			typedef __int128_t int128_t;
		#endif
		#if defined(ELC_BASE_ENV_HAS_INT128)
			typedef uint128_t uint_fast128_t;
			typedef int128_t int_fast128_t;
			namespace int128_literal_detail{
				constexpr uint8_t hexval(char c)noexcept{
					if constexpr('a'>'A'){
						if(c>='a')
							return c+10-'a';
						elseif(c>='A')
							return c+10-'A';
					}
					else{
						if(c>='A')
							return c+10-'A';
						elseif(c>='a')
							return c+10-'a';
					}
					return c-'0';
				}
				template<int base>
				constexpr uint128_t eval_literal(uint128_t val=0)noexcept{
					return val;
				}
				template<int base, char c, char...cs>
				constexpr uint128_t eval_literal(uint128_t val=0)noexcept{
					if constexpr(c!='\''){
						static_assert(base==16||base==10||base==8||base==2,"base must be 16,10,8 or 2");
						static_assert(c>='0'&&c<='9'||c>='a'&&c<='f'||c>='A'&&c<='F',"invalid char");
						static_assert(base!=16 || sizeof...(cs)<=32-1,"literal too long");
						static_assert(base!=10 || sizeof...(cs)<=39-1,"literal too long");
						static_assert(base!=8 || sizeof...(cs)<=44-1,"literal too long");
						static_assert(base!=2 || sizeof...(cs)<=128-1,"literal too long");
						static_assert(base>hexval(c),"invalid char");
						return eval_literal<base,cs...>(val*base+hexval(c));
					}
					else
						return eval_literal<base,cs...>(val);
				}
				template<char...cs>
				struct literal_evaler{
					static constexpr uint128_t value=eval_literal<10,cs...>();
				};
				template<char...cs>
				struct literal_evaler<'0','x',cs...>{
					static constexpr uint128_t value=eval_literal<16,cs...>();
				};
				template<char...cs>
				struct literal_evaler<'0','X',cs...>{
					static constexpr uint128_t value=eval_literal<16,cs...>();
				};
				template<char...cs>
				struct literal_evaler<'0','b',cs...>{
					static constexpr uint128_t value=eval_literal<2,cs...>();
				};
				template<char...cs>
				struct literal_evaler<'0','B',cs...>{
					static constexpr uint128_t value=eval_literal<2,cs...>();
				};
				template<char...cs>
				struct literal_evaler<'0',cs...>{
					static constexpr uint128_t value=eval_literal<8,cs...>();
				};
				template<char...cs>
				constexpr uint128_t operator ""_u128()noexcept{
					return literal_evaler<cs...>::value;
				}
				template<char...cs>
				struct signed_literal_evaler{
					static constexpr int128_t value=static_cast<int128_t>(literal_evaler<cs...>::value);
				};
				template<char...cs>
				struct signed_literal_evaler<'-',cs...>{
					static constexpr int128_t value=-static_cast<int128_t>(literal_evaler<cs...>::value);
				};
				template<char...cs>
				constexpr int128_t operator ""_i128()noexcept{
					return signed_literal_evaler<cs...>::value;
				}
			}
			using int128_literal_detail::operator ""_u128;
			using int128_literal_detail::operator ""_i128;
		#endif
		//基础的uintmax_t
		typedef ::std::uintmax_t basic_uintmax_t;
		typedef ::std::intmax_t basic_intmax_t;
		//更新uintmax_t和intmax_t的代指
		typedef decltype(lambda{
			#if defined(ELC_BASE_ENV_HAS_INT128)
			if constexpr(sizeof(basic_uintmax_t) < sizeof(uint128_t))
				return uint128_t{};
			else
			#endif
				return basic_uintmax_t{};
		}()) uintmax_t;
		typedef decltype(lambda{
			#if defined(ELC_BASE_ENV_HAS_INT128)
			if constexpr(sizeof(basic_intmax_t) < sizeof(int128_t))
				return int128_t{};
			else
			#endif
				return basic_intmax_t{};
		}()) intmax_t;
		//众所周知，class不能作为数组下标，所以uintmax_index_t等类型的存在是有必要的
		typedef basic_uintmax_t uintmax_index_t;
		typedef basic_intmax_t intmax_index_t;
		template<class T>
		constexpr inline bool is_elc_expansion_base_type_helper()noexcept{
			#if defined(ELC_BASE_ENV_HAS_INT128)
			if constexpr(sizeof(basic_uintmax_t) < sizeof(uint128_t) && ::std::is_same_v<T,uint128_t>)
				return true;
			if constexpr(sizeof(basic_intmax_t) < sizeof(int128_t) && ::std::is_same_v<T,int128_t>)
				return true;
			#endif
			return false;
		}
		template<class T>
		constexpr bool inline is_elc_expansion_base_type=is_elc_expansion_base_type_helper<T>();

		/*! 给定大小的无符号整数类型 */
		template<size_t size>
		using unsigned_specific_size_t=decltype(lambda(){
			#define TYPE_MAPPER(type) if constexpr(size == sizeof(type))return (type)0;else
			#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
//unsigned_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
TYPE_MAPPER(uint8_t)
TYPE_MAPPER(uint16_t)
TYPE_MAPPER(uint32_t)
TYPE_MAPPER(uint64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint128_t)
#endif
TYPE_MAPPER(::std::uintmax_t)
TYPE_MAPPER(size_t)
TYPE_MAPPER(unsigned char)
TYPE_MAPPER(char8_t)
TYPE_MAPPER(char16_t)
TYPE_MAPPER(char32_t)
TYPE_MAPPER(wchar_t)
TYPE_MAPPER(unsigned short)
TYPE_MAPPER(unsigned int)
TYPE_MAPPER(unsigned long)
TYPE_MAPPER(unsigned long long)

//file_end

			#line 170 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
			#undef TYPE_MAPPER
			{}
		}());
		/*! 至少有给定大小的快速无符号整数类型 */
		template<size_t size>
		using unsigned_specific_size_fast_t=decltype(lambda(){
			#define TYPE_MAPPER(type) if constexpr(size <= sizeof(type))return (type)0;else
			#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
//unsigned_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
TYPE_MAPPER(uint_fast8_t)
TYPE_MAPPER(uint_fast16_t)
TYPE_MAPPER(uint_fast32_t)
TYPE_MAPPER(uint_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint_fast128_t)
#endif

//file_end

			#line 178 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
			#undef TYPE_MAPPER
			{}
		}());
		//这里的定义不能使用basedefs中的type_info，所以得重新造一个小轮子
		struct type_uniquer_t{
			constexpr bool operator==(const type_uniquer_t&other)const noexcept{return this==&other;}
		};
		template<class T>
		inline constexpr type_uniquer_t type_uniquer{};
		//任意类型转算数类型
		inline constexpr struct to_arithmetic_t{
			template<class T,class type>
			//由于::std::is_convertible_v的歧义性质，使用requires表达式辅助推断type是否为实际支持的类型
			//由于requires表达式的强制性质，使用::std::is_convertible_v辅助推断隐式转换是否可行
			static inline constexpr bool is_convertible = ::std::is_convertible_v<T, type> && was_not_an_ill_form(static_cast<type>(declvalue(T)));
			template<class T>
			static inline constexpr bool r_able_helper()noexcept{
				#define TYPE_MAPPER(type) if constexpr(is_convertible<T,type>)return true;else
				#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
//float_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
//float_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
TYPE_MAPPER(float)
TYPE_MAPPER(double)
TYPE_MAPPER(long double)

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
//signed_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
TYPE_MAPPER(int8_t)
TYPE_MAPPER(int16_t)
TYPE_MAPPER(int32_t)
TYPE_MAPPER(int64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int128_t)
#endif
TYPE_MAPPER(::std::intmax_t)
TYPE_MAPPER(ptrdiff_t)
TYPE_MAPPER(signed char)
TYPE_MAPPER(short)
TYPE_MAPPER(int)
TYPE_MAPPER(long)
TYPE_MAPPER(long long)

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
//unsigned_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
TYPE_MAPPER(uint8_t)
TYPE_MAPPER(uint16_t)
TYPE_MAPPER(uint32_t)
TYPE_MAPPER(uint64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint128_t)
#endif
TYPE_MAPPER(::std::uintmax_t)
TYPE_MAPPER(size_t)
TYPE_MAPPER(unsigned char)
TYPE_MAPPER(char8_t)
TYPE_MAPPER(char16_t)
TYPE_MAPPER(char32_t)
TYPE_MAPPER(wchar_t)
TYPE_MAPPER(unsigned short)
TYPE_MAPPER(unsigned int)
TYPE_MAPPER(unsigned long)
TYPE_MAPPER(unsigned long long)

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
//signed_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
TYPE_MAPPER(int_fast8_t)
TYPE_MAPPER(int_fast16_t)
TYPE_MAPPER(int_fast32_t)
TYPE_MAPPER(int_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int_fast128_t)
#endif

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
//unsigned_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
TYPE_MAPPER(uint_fast8_t)
TYPE_MAPPER(uint_fast16_t)
TYPE_MAPPER(uint_fast32_t)
TYPE_MAPPER(uint_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint_fast128_t)
#endif

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"

//file_end

				#line 197 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
				#undef TYPE_MAPPER
				return false;
			}
			template<class T>
			static force_inline constexpr auto to_arithmetic_base(T&&v)noexcept{
				#define TYPE_MAPPER(type) if constexpr(r_able_helper<T>()&&is_convertible<T,type>)return (type)v;else
				#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
//float_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
//float_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
TYPE_MAPPER(float)
TYPE_MAPPER(double)
TYPE_MAPPER(long double)

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
//signed_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
TYPE_MAPPER(int8_t)
TYPE_MAPPER(int16_t)
TYPE_MAPPER(int32_t)
TYPE_MAPPER(int64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int128_t)
#endif
TYPE_MAPPER(::std::intmax_t)
TYPE_MAPPER(ptrdiff_t)
TYPE_MAPPER(signed char)
TYPE_MAPPER(short)
TYPE_MAPPER(int)
TYPE_MAPPER(long)
TYPE_MAPPER(long long)

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
//unsigned_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
TYPE_MAPPER(uint8_t)
TYPE_MAPPER(uint16_t)
TYPE_MAPPER(uint32_t)
TYPE_MAPPER(uint64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint128_t)
#endif
TYPE_MAPPER(::std::uintmax_t)
TYPE_MAPPER(size_t)
TYPE_MAPPER(unsigned char)
TYPE_MAPPER(char8_t)
TYPE_MAPPER(char16_t)
TYPE_MAPPER(char32_t)
TYPE_MAPPER(wchar_t)
TYPE_MAPPER(unsigned short)
TYPE_MAPPER(unsigned int)
TYPE_MAPPER(unsigned long)
TYPE_MAPPER(unsigned long long)

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
//signed_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
TYPE_MAPPER(int_fast8_t)
TYPE_MAPPER(int_fast16_t)
TYPE_MAPPER(int_fast32_t)
TYPE_MAPPER(int_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int_fast128_t)
#endif

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
//unsigned_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
TYPE_MAPPER(uint_fast8_t)
TYPE_MAPPER(uint_fast16_t)
TYPE_MAPPER(uint_fast32_t)
TYPE_MAPPER(uint_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint_fast128_t)
#endif

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"

//file_end

				#line 204 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
				#undef TYPE_MAPPER
				{}
			}
			template<class T>
			static inline constexpr size_t get_arithmetic_muti_convertible_count()noexcept{
				typedef decltype(to_arithmetic_base(declvalue(T))) my_type;
				size_t muti_convertible_count=0;
				#define TYPE_MAPPER(type) \
				if constexpr(type_uniquer<my_type>!=type_uniquer<type> && is_convertible<T,type>)\
					muti_convertible_count++;
				#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
//float_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
//float_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
TYPE_MAPPER(float)
TYPE_MAPPER(double)
TYPE_MAPPER(long double)

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
//signed_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
TYPE_MAPPER(int8_t)
TYPE_MAPPER(int16_t)
TYPE_MAPPER(int32_t)
TYPE_MAPPER(int64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int128_t)
#endif
TYPE_MAPPER(::std::intmax_t)
TYPE_MAPPER(ptrdiff_t)
TYPE_MAPPER(signed char)
TYPE_MAPPER(short)
TYPE_MAPPER(int)
TYPE_MAPPER(long)
TYPE_MAPPER(long long)

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
//unsigned_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
TYPE_MAPPER(uint8_t)
TYPE_MAPPER(uint16_t)
TYPE_MAPPER(uint32_t)
TYPE_MAPPER(uint64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint128_t)
#endif
TYPE_MAPPER(::std::uintmax_t)
TYPE_MAPPER(size_t)
TYPE_MAPPER(unsigned char)
TYPE_MAPPER(char8_t)
TYPE_MAPPER(char16_t)
TYPE_MAPPER(char32_t)
TYPE_MAPPER(wchar_t)
TYPE_MAPPER(unsigned short)
TYPE_MAPPER(unsigned int)
TYPE_MAPPER(unsigned long)
TYPE_MAPPER(unsigned long long)

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
//signed_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_fast_mapper.hpp"
TYPE_MAPPER(int_fast8_t)
TYPE_MAPPER(int_fast16_t)
TYPE_MAPPER(int_fast32_t)
TYPE_MAPPER(int_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(int_fast128_t)
#endif

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
//unsigned_fast_mapper.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_fast_mapper.hpp"
TYPE_MAPPER(uint_fast8_t)
TYPE_MAPPER(uint_fast16_t)
TYPE_MAPPER(uint_fast32_t)
TYPE_MAPPER(uint_fast64_t)
#if defined(ELC_BASE_ENV_HAS_INT128)
	TYPE_MAPPER(uint_fast128_t)
#endif

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"

//file_end

				#line 215 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
				#undef TYPE_MAPPER
				return muti_convertible_count;
			}
			template<class T>
			static inline constexpr bool convertible_unique_helper()noexcept{
				return get_arithmetic_muti_convertible_count<T>()==1;//the oly way we can save all lifes........
			}
			template<class T>
			static inline constexpr bool able_helper()noexcept{
				if constexpr(r_able_helper<T>())
					return convertible_unique_helper<T>();
				else
					return false;
			}
			template<class T>
			static inline constexpr bool able = able_helper<T>();
			//nothrow
			template<class T>
			static inline constexpr bool nothrow_helper()noexcept{
				if constexpr(able<T>){
					typedef decltype(to_arithmetic_base(declvalue(T))) my_type;
					return ::std::is_nothrow_convertible_v<T,my_type>;
				}
				else
					return false;
			}
			template<class T>
			static inline constexpr bool nothrow = nothrow_helper<T>();
			//算数类型转任意类型
			template<class T> requires able<T>
			force_inline constexpr auto operator()(T&&v)const noexcept(nothrow<T>){
				return to_arithmetic_base(::std::forward<T>(v));
			}
		}to_arithmetic{};
		//判断wchar_t是否和char_t相同
		inline constexpr bool wchar_t_same_as_char_t=sizeof(wchar_t)==sizeof(char_t);
		//判断wchar_t是否和char16_t相同
		inline constexpr bool wchar_t_same_as_char16_t=sizeof(wchar_t)==sizeof(char16_t);
		#line 270 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
		namespace float_infos{
			//精确数部分的掩码
			template<class T>
			constexpr auto precision_mask=lambda(){
				if constexpr(::std::is_same_v<T,float>)
					return(uint32_t)0x007FFFFFu;
				elseif constexpr(::std::is_same_v<T,double>)
					return(uint64_t)0x000FFFFFFFFFFFFFu;
				elseif constexpr(::std::is_same_v<T,long double>){
					#if defined(_MSC_VER)//msvc上long double就是double
						return(uint64_t)0x000FFFFFFFFFFFFFu;
					#else
						return(uint128_t)0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF_u128;
					#endif
				}
			}();
			//精确数的无符号整数类型
			template<class T>
			using precision_type=decltype(precision_mask<T>);

			//浮点数的无符号整数数据类型
			template<class T>
			using data_type=decltype(lambda(){
				if constexpr(::std::is_same_v<T,float>)
					return uint32_t{};
				elseif constexpr(::std::is_same_v<T,double>)
					return uint64_t{};
				elseif constexpr(::std::is_same_v<T,long double>){
					#if defined(_MSC_VER)//msvc上long double就是double
						return uint64_t{};
					#else
						return uint128_t{};
					#endif
				}
			}());

			//自浮点数获取精确数的基（如float是2^23，double是2^52，long double是2^112）
			template<class T>
			constexpr auto precision_base=lambda(){
				if constexpr(::std::is_same_v<T,float>)
					return(uint32_t)0x800000u;
				elseif constexpr(::std::is_same_v<T,double>)
					return(uint64_t)0x10000000000000u;
				elseif constexpr(::std::is_same_v<T,long double>){
					#if defined(_MSC_VER)//msvc上long double就是double
						return(uint64_t)0x10000000000000u;
					#else
						return(uint128_t)0x10000000000000000000000000000_u128;
					#endif
				}
			}();

			//自浮点数获取精确数的基的位数（如float是23）
			template<class T>
			constexpr auto precision_base_bit=lambda(){
				if constexpr(::std::is_same_v<T,float>)
					return 23u;
				elseif constexpr(::std::is_same_v<T,double>)
					return 52u;
				elseif constexpr(::std::is_same_v<T,long double>){
					#if defined(_MSC_VER)//msvc上long double就是double
						return 52u;
					#else
						return 112u;
					#endif
				}
			}();

			//浮点数的指数部分的diff（如float是127，double是1023，long double是16383）
			template<class T>
			constexpr auto exponent_diff=lambda(){
				if constexpr(::std::is_same_v<T,float>)
					return 127;
				elseif constexpr(::std::is_same_v<T,double>)
					return 1023;
				elseif constexpr(::std::is_same_v<T,long double>){
					#if defined(_MSC_VER)//msvc上long double就是double
						return 1023;
					#else
						return 16383;
					#endif
				}
			}();
			//浮点数的指数部分的min（如float是-126，double是-1022，long double是-16382）
			template<class T>
			constexpr auto exponent_min=lambda(){
				if constexpr(::std::is_same_v<T,float>)
					return -126;
				elseif constexpr(::std::is_same_v<T,double>)
					return -1022;
				elseif constexpr(::std::is_same_v<T,long double>){
					#if defined(_MSC_VER)//msvc上long double就是double
						return -1022;
					#else
						return -16382;
					#endif
				}
			}();
			//浮点数的指数部分的max（如float是127，double是1023，long double是16383）
			template<class T>
			constexpr auto exponent_max=lambda(){
				if constexpr(::std::is_same_v<T,float>)
					return 127;
				elseif constexpr(::std::is_same_v<T,double>)
					return 1023;
				elseif constexpr(::std::is_same_v<T,long double>){
					#if defined(_MSC_VER)//msvc上long double就是double
						return 1023;
					#else
						return 16383;
					#endif
				}
			}();

			//浮点数的指数部分的无符号整数类型
			template<class T>
			using exponent_unsigned_type=decltype(lambda(){
				if constexpr(::std::is_same_v<T,float>)
					return uint8_t{};
				elseif constexpr(::std::is_same_v<T,double>)
					return uint16_t{};
				elseif constexpr(::std::is_same_v<T,long double>){
					#if defined(_MSC_VER)//msvc上long double就是double
						return uint16_t{};
					#else
						return uint16_t{};
					#endif
				}
			}());
			//浮点数的指数部分的经过偏移后的有符号整数类型
			template<class T>
			using exponent_type=decltype(lambda(){
				if constexpr(::std::is_same_v<T,float>)
					return int8_t{};
				elseif constexpr(::std::is_same_v<T,double>)
					return int16_t{};
				elseif constexpr(::std::is_same_v<T,long double>){
					#if defined(_MSC_VER)//msvc上long double就是double
						return int16_t{};
					#else
						return int16_t{};
					#endif
				}
			}());
			//浮点数的指数部分的掩码
			template<class T>
			constexpr auto exponent_mask=lambda(){
				if constexpr(::std::is_same_v<T,float>)
					return 0x7FFFFFFFu;
				elseif constexpr(::std::is_same_v<T,double>)
					return 0x7FFFFFFFFFFFFFFFu;
				elseif constexpr(::std::is_same_v<T,long double>){
					#if defined(_MSC_VER)//msvc上long double就是double
						return 0x7FFFFFFFFFFFFFFFu;
					#else
						return 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF_u128;
					#endif
				}
			}();
			template<class T>
			union float_data_union{
				T v;
				data_type<T> data;
			};
			template<class T>
			constexpr data_type<T> get_float_data(T v)noexcept{
				float_data_union<T> tmp;
				tmp.v=v;
				return tmp.data;
			}
			template<class T>
			constexpr T get_float_from_data(data_type<T> data)noexcept{
				float_data_union<T> tmp;
				tmp.data=data;
				return tmp.v;
			}
		}
		//自浮点数获取精确数部分，舍去指数和符号位
		template<class T> requires ::std::is_floating_point_v<T>
		force_inline constexpr auto get_precision(T v)noexcept{
			using namespace float_infos;
			auto tmp=get_float_data(v);
			tmp&=precision_mask<T>;
			return tmp;
		}
		//自浮点数获取精确数的基（如float是2^23，double是2^52，long double是2^112）
		template<class T> requires ::std::is_floating_point_v<T>
		force_inline constexpr auto get_precision_base(T=T{})noexcept{
			return float_infos::precision_base<T>;
		}
		template<class T> requires ::std::is_floating_point_v<T>
		using float_precision_base_t = decltype(get_precision_base<T>());
		//（基础的）自浮点数获取指数部分，舍去基数和符号位
		template<class T> requires ::std::is_floating_point_v<T>
		force_inline constexpr auto base_get_exponent(T v)noexcept{
			using namespace float_infos;
			auto tmp=get_float_data(v);
			tmp&=exponent_mask<T>;
			tmp>>=precision_base_bit<T>;
			return exponent_unsigned_type<T>(tmp);
		}
		//自浮点数获取指数部分，舍去基数和符号位
		template<class T> requires ::std::is_floating_point_v<T>
		force_inline constexpr auto get_exponent(T v)noexcept{
			const auto tmp=base_get_exponent(v);
			using namespace float_infos;
			if(tmp==0)return exponent_min<T>;
			else return exponent_type<T>(tmp)-exponent_diff<T>;
		}
		//自浮点数获取基数
		template<class T> requires ::std::is_floating_point_v<T>
		force_inline constexpr auto get_base_num(T v)noexcept{
			//特殊情况处理（exp=0时，base=0）
			const auto tmp=base_get_exponent(v);
			return tmp?get_precision_base(v):float_precision_base_t<T>{};
		}
		//自基数和指数构造浮点数
		//num=base_num*2^exponent
		template<class T> requires ::std::is_floating_point_v<T>
		force_inline constexpr T make_float(float_precision_base_t<T> base_num,ptrdiff_t exponent)noexcept{
			using namespace float_infos;
			//首先将基数转换为precision_base（2^precision_base_bit）为分母的分数的分子
			//并在此过程中加减指数
			//需要注意的是，这里的基数是包含1的，所以转换目标是base_num>>precision_base_bit为1
			{
				const auto tmp=::std::countl_zero(base_num);
				constexpr auto need_shift=bitnum_of(base_num)-precision_base_bit<T>-1;
				const ptrdiff_t shift=tmp-need_shift;
				if(shift>0){
					base_num<<=shift;
					exponent-=shift;
				}
				elseif(shift<0){
					base_num>>=-shift;
					exponent-=shift;
				}
			}
			//适当放缩后，需要偏移指数部分，原因如下：
			//原有逻辑是num=base_num*2^exponent，这是大分数的表达逻辑
			//但是浮点数的逻辑是num=(base_num/precision_base)*2^exponent
			//将precision_base合并到exponent中，即可得到浮点数的逻辑
			exponent+=precision_base_bit<T>;
			if(exponent < exponent_min<T>){//指数过小，需要舍去
				const auto diff=exponent_min<T> - exponent;
				base_num>>=diff;
				exponent+=diff;
				if(!base_num)return 0;//基数过小，无法表示
			}
			if(exponent>exponent_max<T>)return 0;//指数过大，无法表示
			//DEN情况判断
			const bool is_den=!(base_num>>precision_base_bit<T>);//若基数最高位为0，则exponent一定为exponent_min，不用判断
			if(is_den)
				return get_float_from_data<T>(base_num);
			else{//非DEN情况下，根据浮点数表示规则去掉基数多余的1
				const auto exp=exponent_unsigned_type<T>(exponent+exponent_diff<T>);
				base_num-=get_precision_base<T>();
				data_type<T> data=base_num;
				data|=data_type<T>(exp)<<precision_base_bit<T>;
				return get_float_from_data<T>(data);
			}
		}
	}
	using basic_environment::BIT_POSSIBILITY;

	using basic_environment::basic_uintmax_t;
	using basic_environment::basic_intmax_t;
	using basic_environment::uintmax_index_t;
	using basic_environment::intmax_index_t;
	using basic_environment::uintmax_t;
	using basic_environment::intmax_t;
	#if defined(ELC_BASE_ENV_HAS_INT128)
	using basic_environment::uint128_t;
	using basic_environment::int128_t;
	using basic_environment::operator""_u128;
	using basic_environment::operator""_i128;
	#endif
	using basic_environment::is_elc_expansion_base_type;

	using basic_environment::unsigned_specific_size_t;
	using basic_environment::unsigned_specific_size_fast_t;

	using basic_environment::to_arithmetic;

	using basic_environment::wchar_t_same_as_char_t;
	using basic_environment::wchar_t_same_as_char16_t;
	
	using basic_environment::get_exponent;
	using basic_environment::get_base_num;
	using basic_environment::get_precision;
	using basic_environment::get_precision_base;
	using basic_environment::float_precision_base_t;
	using basic_environment::make_float;

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

	#line 563 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
}

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
namespace elc::defs{ //在elc::defs中定义内容
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"

	namespace base{}
	using namespace base;//导出内容：defs内的名称空间只起到大体名称分组的作用，不进行名称阻拦

	//内存泄露检测
	#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	namespace memory{
		inline void check_memory_lack()noexcept;
		inline struct distinctive memory_lack_checker_t{
			~memory_lack_checker_t(){
				check_memory_lack();
			}
		}memory_lack_checker{};
	}
	#endif

	namespace base{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
//_body.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
//恭喜你找到elc内大部分语法糖所在地
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/template_helper.hpp"
//template_helper.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/template_helper.hpp"
/*!
宏辅助,用以补全元编程错误宏template_error的内容.
*/
template<class T>
constexpr bool template_error_helper=1000-7==114514;//w.
/*!
宏辅助,用以补全元编程错误宏template_warning的内容.
*/
template<class T,class U>
[[deprecated("this was a template warning."),nodiscard]]
inline auto template_warning_helper(U&&a)noexcept{return 0;}

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/using_std.hpp"
//using_std.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/using_std.hpp"
//从std中导入一些名称.
//这不比博人传燃?
using ::std::byte;
using ::std::size_t;

using ::std::forward;
using ::std::addressof;
using ::std::swap;
#line 52 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/using_std.hpp"
template<class T>
using remove_cvref= ::std::remove_cvref_t<T>;
template<class T>
using remove_cv= ::std::remove_cv_t<T>;
template<class T>
using remove_ref= ::std::remove_reference_t<T>;
template<bool B,class T,class F>
using conditional= ::std::conditional_t<B,T,F>;
template<class T,class U>
constexpr bool is_base_of= ::std::is_convertible_v<remove_cvref<U>*,remove_cvref<T>*>;
//
using ::std::partial_ordering;
using ::std::weak_ordering;
using ::std::strong_ordering;

using ::std::countr_zero;
using ::std::countl_zero;
using ::std::countr_one;
using ::std::countl_one;

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/concept.hpp"
//concept.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/concept.hpp"
//template<typename T,template<typename>constexpr bool name>
//concept as_concept=name<T>;

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/magic_number.hpp"
//magic_number.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/magic_number.hpp"
namespace magic_number{
	/*! 黄金分割比
		数理逻辑不应通过强奸感性来定义审美.
		我们应当遵从物体的自身结构,辅助线仅能在这基础上起到梳理作用,并不能以此作为创作起点来表达情感,它仅存于外部世界,无法到达内心.
		黄金分割并不万能.
	*/
	constexpr auto gold=0.61803398874989484820458683436563811772030917980576286213544862270526046281890244970720720418939113748475408807538689175212663386222353693179318006076672635443338908659593958290563832266131992829026788067520876689250171169620703222104321626954862629631361443814975870122034080588795445474924618569536486444924104432077134494704956584678850987433944221254487706647809158846074998871240076521705751797883416625624940758906970400028121042762177111777805315317141011704666599146697987317613560067087480710131795236894275219484353056783002287856997829778347845878228911097625003026961561700250464338243776486102838312683303724292675263116533924731671112115881863851331620384005222165791286675294654906811317159934323597349498509040947621322298101726107059611645629909816290555208524790352406020172799747175342777592778625619432082750513121815628551222480939471234145170223735805772786160086883829523045926478780178899219902707769038953219681986151437803149974110692608867429622675756052317277752035361393621076738937645560606059216589466759551900400555908950229530942312482355212212415444006470340565734797663972394949946584578873039623090375033993856210242369025138680414577995698122445747178034173126453220416397232134044449487302315417676893752103068737880344170093954409627955898678723209512426893557309704509595684401755519881921802064052905518934947592600734852282101088194644544222318891319294689622002301443770269923007803085261180754519288770502109684249362713592518760777884665836150238913493333122310533923213624319263728910670503399282265263556209029798642472759772565508615487543574826471814145127000602389016207773224499435308899909501680328112194320481964387675863314798571911397815397807476150772211750826945863932045652098969855567814106968372884058746103378105444390943683583581381131168993855576975484149144534150912954070050194775486163075422641729394680367319805861833918328599130396072014455950449779212076124785645916160837059498786006970189409886400764436170933417270919143365013715;//精度2000(然而只是double而已.)

	/*! 每次扩容后的空间与原空间为这样的比值可以最小化时空负担
		是的,以一种较为艺术的比值.
	*/
	constexpr auto gold_of_resize=gold+1;//精度2000——大概

	/*! 圆周率. */
	constexpr auto pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317675238467481846766940513200056812714526356082778577134275778960917363717872146844090122495343014654958537105079227968925892354201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859502445945534690830264252230825334468503526193118817101000313783875288658753320838142061717766914730359825349042875546873115956286388235378759375195778185778053217122680661300192787661119590921642019893809525720106548586327886593615338182796823030195203530185296899577362259941389124972177528347913151557485724245415069595082953311686172785588907509838175463746493931925506040092770167113900984882401285836160356370766010471018194295559619894676783744944825537977472684710404753464620804668425906949129331367702898915210475216205696602405803815019351125338243003558764024749647326391419927260426992279678235478163600934172164121992458631503028618297455570674983850549458858692699569092721079750930295532116534498720275596023648066549911988183479775356636980742654252786255181841757467289097777279380008164706001614524919217321721477235014144197356854816136115735255213347574184946843852332390739414333454776241686251898356948556209921922218427255025425688767179049460165346680498862723279178608578438382796797668145410095388378636095068006422512520511739298489608412848862694560424196528502221066118630674427862203919494504712371378696095636437191728746776465757396241389086583264599581339047802759009;//精度2000

	/*! 自然对数的底数. */
	constexpr auto e =	2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642742746639193200305992181741359662904357290033429526059563073813232862794349076323382988075319525101901157383418793070215408914993488416750924476146066808226480016847741185374234544243710753907774499206955170276183860626133138458300075204493382656029760673711320070932870912744374704723069697720931014169283681902551510865746377211125238978442505695369677078544996996794686445490598793163688923009879312773617821542499922957635148220826989519366803318252886939849646510582093923982948879332036250944311730123819706841614039701983767932068328237646480429531180232878250981945581530175671736133206981125099618188159304169035159888851934580727386673858942287922849989208680582574927961048419844436346324496848756023362482704197862320900216099023530436994184914631409343173814364054625315209618369088870701676839642437814059271456354906130310720851038375051011574770417189861068739696552126715468895703503540212340784981933432106817012100562788023519303322474501585390473041995777709350366041699732972508868769664035557071622684471625607988265178713419512466520198918006308407507245458379639351364421067750539471789004518357551541252235905906872648786357525419112888773717663748602766063496035367947026923229718683277173932361920077745221262475186983349515101986426988784717193966497690708252174233656627259284406204302141137199227852699846988477023238238400556555178890876613601304770984386116870523105531491625172837327286760072481729876375698163354150746088386636406934704372066886512756882661497307886570156850169186474885416791545965072342877306998537139043002665307839877638503238182155355973235306860430106757608389086270498418885951380910304235957824951439885901131858358406674723702971497850841458530857813391562707603563907639473114554958322669457024941398316343323789759556808568362972538679132750555425244919435891284050452269538121791319145135009938463117740179715122837854601160359554028644059;//精度2000

	constexpr auto god=72;/// 神已死,神万岁.
}

//file_end

#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/other.hpp"
//other.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/other.hpp"
class empty_type{};

template<typename T,typename U>
inline auto&assign(T&&a,U&&b)noexcept_as(a=b){//为绕过条件内赋值时の警告而使用
	a=b;
	return a;
}

//fucking nodiscard.
constexpr struct discard_t{
	template<typename T>
	force_inline constexpr void operator=(T&&)const noexcept{}
	template<typename T>
	force_inline constexpr void operator()(T&&)const noexcept{}
}discard{};

template<typename T>
inline void just_a_use(T&&){}

template<typename T>
distinctive inline T const_default_value_of{};//?

enable_adl(the_destroy);
template<typename T>
static void destroy(T*a)noexcept{
	if constexpr(was_not_an_ill_form(the_destroy(a)))
		the_destroy(a);
	else
		template_error("Please overload the function the_destroy in the namespace where this type is defined.");
}

//file_end

#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/cast.hpp"
//cast.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/cast.hpp"
push_and_disable_msvc_warning(
	26491//down_cast警告diss
	26466//down_cast警告diss
	26492//const_cast警告diss
);
/// 对值追加const
template<typename T>
force_inline constexpr const T add_const(T a)noexcept{return a;}
/// 对引用追加const
template<typename T>
force_inline constexpr const T&add_const(T&a)noexcept{return a;}
/// 对引用移除const
template<typename T>
force_inline constexpr T&remove_const(const T&a)noexcept{return const_cast<T&>(a);}
/// 对指针追加const
template<typename T>
force_inline constexpr const T*add_const(T*a)noexcept{return a;}
/// 对指针移除const
template<typename T>
force_inline constexpr T*remove_const(const T*a)noexcept{return const_cast<T*>(a);}
/// 对指针移除const
template<typename T>
force_inline constexpr T*launder_remove_const(const T*a)noexcept{return ::std::launder(remove_const(a));}
/// 向下转型至
template<typename T,typename U>
force_inline constexpr T down_cast(U a)noexcept{return static_cast<T>(a);}
pop_msvc_warning();

//file_end

#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/special_flags.hpp"
//special_flag.hpp
//at namespace elc::defs::base
#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/special_flags.hpp"
/// 快捷定义特殊类型的constexpr
#define defspecflag(name) \
constexpr struct name##_t{} name{}

/// 引用计数从不为0的构造
defspecflag(never_ref_num_zero);
/// 特殊构造
defspecflag(special_init);
/// 预分配内存
defspecflag(pre_alloc);

#undef defspecflag

//file_end

#line 40 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/non_Xable.hpp"
//non_Xable.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/non_Xable.hpp"
/// 禁止复制赋值
struct non_copy_assign_able{
	constexpr non_copy_assign_able()noexcept=default;
	constexpr non_copy_assign_able(const non_copy_assign_able&)noexcept=default;
	constexpr non_copy_assign_able(non_copy_assign_able&&)noexcept=default;
	constexpr non_copy_assign_able& operator=(const non_copy_assign_able&)&noexcept=delete;
	constexpr non_copy_assign_able& operator=(non_copy_assign_able&&)&noexcept=default;
};
/// 禁止移动赋值
struct non_move_assign_able{
	constexpr non_move_assign_able()noexcept=default;
	constexpr non_move_assign_able(const non_move_assign_able&)noexcept=default;
	constexpr non_move_assign_able(non_move_assign_able&&)noexcept=default;
	constexpr non_move_assign_able& operator=(const non_move_assign_able&)&noexcept=default;
	constexpr non_move_assign_able& operator=(non_move_assign_able&&)&noexcept=delete;
};

/// 禁止默认合成的赋值
struct non_default_assign_able:non_copy_assign_able,non_move_assign_able{};


/// 禁止复制构造
struct non_copy_construct_able{
	constexpr non_copy_construct_able()=default;
	constexpr non_copy_construct_able(const non_copy_construct_able&)=delete;
	constexpr non_copy_construct_able(non_copy_construct_able&&)=default;
	constexpr non_copy_construct_able& operator=(const non_copy_construct_able&)&noexcept=default;
	constexpr non_copy_construct_able& operator=(non_copy_construct_able&&)&noexcept=default;
};
/// 禁止移动构造
struct non_move_construct_able{
	constexpr non_move_construct_able()=default;
	constexpr non_move_construct_able(const non_move_construct_able&)=default;
	constexpr non_move_construct_able(non_move_construct_able&&)=delete;
	constexpr non_move_construct_able& operator=(const non_move_construct_able&)&noexcept=default;
	constexpr non_move_construct_able& operator=(non_move_construct_able&&)&noexcept=default;
};

/// 禁止默认合成的构造
struct non_default_construct_able:non_copy_construct_able,non_move_construct_able{
	constexpr non_default_construct_able()=delete;
};

/// 禁止默认合成的复制
struct non_copyable:non_copy_assign_able,non_copy_construct_able{};
/// 禁止默认合成的移动
struct non_moveable:non_move_assign_able,non_move_construct_able{};

//file_end

#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/attribute.hpp"
//attribute.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/attribute.hpp"
template<class T,typename attribute_name>
struct attribute{
protected:
	template<class U,special_attribute_t another_attribute_name>
	friend U*get_handle(attribute<U,another_attribute_name>*)noexcept;
	force_inline constexpr T*get_handle()noexcept{return down_cast<T*>(down_cast<attribute_name*>(this));}

	template<class U,special_attribute_t another_attribute_name>
	friend const U*get_handle(const attribute<U,another_attribute_name>*)noexcept;
	force_inline constexpr const T*get_handle()const noexcept{return down_cast<const T*>(down_cast<const attribute_name*>(this));}
};
template<class T,special_attribute_t attribute_name>
force_inline T*get_handle(attribute<T,attribute_name>*a)noexcept{return a->get_handle();}
template<class T,special_attribute_t attribute_name>
force_inline const T*get_handle(const attribute<T,attribute_name>*a)noexcept{return a->get_handle();}

template<class T,common_attribute_t attribute_name>
force_inline T* get_handle(attribute<T,attribute_name<T>>*a)noexcept{return get_handle<T,attribute_name<T>>(a);}
template<class T,common_attribute_t attribute_name>
force_inline const T* get_handle(const attribute<T,attribute_name<T>>*a)noexcept{return get_handle<T,attribute_name<T>>(a);}

template<special_attribute_t attribute_name,class T>
force_inline auto attribute_ptr_cast(T*ptr)noexcept{
	return static_cast<attribute_name*>(ptr);
}
template<special_attribute_t attribute_name,class T>
force_inline auto attribute_ptr_cast(const T* ptr)noexcept{
	return static_cast<const attribute_name*>(ptr);
}
template<common_attribute_t attribute_name,class T>
force_inline auto attribute_ptr_cast(T*ptr)noexcept{
	return attribute_ptr_cast<attribute_name<remove_cvref<T>>>(ptr);
}

template<special_attribute_t attribute_name,class T>
force_inline auto& attribute_cast(T&t)noexcept{
	return*attribute_ptr_cast<attribute_name>(&t);
}
template<common_attribute_t attribute_name,class T>
force_inline auto& attribute_cast(T&t)noexcept{
	return*attribute_ptr_cast<attribute_name>(&t);
}

template<special_attribute_t... attribute_names>
struct special_attribute_pack:virtual attribute_names...{
	/*兼容用*/
	template<class T>
	struct on_type:special_attribute_pack<attribute_names>...{};
};
template<common_attribute_t... attribute_names>
struct common_attribute_pack{
	template<class T>
	struct on_type:attribute_names<T>...{};
};

//file_end

#line 42 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/special_attribute.hpp"
//special_attribute.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/special_attribute.hpp"
def_common_attribute_with_nothing(never_in_array);
def_special_attribute_with_nothing(build_by_get_only);

//file_end

#line 43 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/type_info.hpp"
//type_info.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/type_info.hpp"
struct type_name_t;/// 自动重整类型名并在析构时释放重整结果，对于gcc和clang的傻逼实现
struct base_type_info_t{
private:
	struct type_id_t{
		const ::std::type_info* _m;

		constexpr type_id_t(const ::std::type_info&a)noexcept:_m(&a){}
		constexpr type_id_t(const type_id_t&a)noexcept=default;
		[[nodiscard]]type_name_t get_name()const noexcept;//定义于type_name.hpp
		[[nodiscard]]size_t get_hash()const noexcept{
			return _m->hash_code();
		}
		[[nodiscard]]bool operator==(const type_id_t&a)const noexcept{return *_m==*a._m;}
	};

	type_id_t _tid;
public:
	constexpr base_type_info_t(const ::std::type_info&a)noexcept:_tid(a){}
	constexpr base_type_info_t(const base_type_info_t&)noexcept=default;
	[[nodiscard]]type_name_t get_name()const noexcept;//定义于type_name.hpp
	[[nodiscard]]size_t get_hash()const noexcept{
		return _tid.get_hash();
	}
	[[nodiscard]]bool operator==(const base_type_info_t&a)const noexcept{return _tid==a._tid;}
	[[nodiscard]]bool operator==(const ::std::type_info&a)const noexcept{return _tid==type_id_t(a);}
};
template<class T>
struct type_info_t{
	typedef T type;

	template<class U>
	static constexpr bool same_as=::std::is_same_v<T,U>;
	template<class U>
	static constexpr bool not_same_as=!same_as<U>;
	template<class U>
	static constexpr bool base_on=::std::is_convertible_v<remove_cvref<T>*,remove_cvref<U>*>;
	template<class U>
	static constexpr bool not_base_on=!base_on<U>;

	template<class U>
	static constexpr bool can_convert_to=::std::is_convertible_v<T,U>;
	template<class U>
	static constexpr bool can_t_convert_to=!can_convert_to<U>;
	template<class U>
	static constexpr bool can_nothrow_convert_to=::std::is_nothrow_convertible_v<T,U>;
	template<class U>
	static constexpr bool can_t_nothrow_convert_to=!can_nothrow_convert_to<U>;

	#line 86 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/type_info.hpp"
	template<special_attribute_t attribute_name>
	static constexpr bool has_attribute_helper(){
		return base_on<attribute_name>;
	}
	template<common_attribute_t attribute_name>
	static constexpr bool has_attribute_helper(){
		return has_attribute_helper<attribute_name<remove_cvref<T>>>();
	}
	template<special_attribute_t attribute_name>
	static constexpr bool not_has_has_attribute_helper(){
		return!has_attribute_helper<attribute_name>();
	}
	template<common_attribute_t attribute_name>
	static constexpr bool not_has_has_attribute_helper(){
		return!has_attribute_helper<attribute_name>();
	}

	// defed at defs.
	// #define has_attribute(...) has_attribute_helper<__VA_ARGS__>()
	// #define not_has_attribute(...) not_has_has_attribute_helper<__VA_ARGS__>()

	template<common_attribute_t... common_attribute_names>
	struct with_common_attribute:common_attribute_pack<common_attribute_names...>::template_name on_type<T>{
		template<special_attribute_t... special_attribute_names>
		struct and_special_attribute:
			common_attribute_pack<common_attribute_names...>::template_name on_type<T>,
			special_attribute_pack<special_attribute_names...>::template_name on_type<T>
			{};
	};
	template<special_attribute_t... special_attribute_names>
	struct with_special_attribute:special_attribute_pack<special_attribute_names...>::template_name on_type<T>{
		template<common_attribute_t... common_attribute_names>
		struct and_common_attribute:
			special_attribute_pack<special_attribute_names...>::template_name on_type<T>,
			common_attribute_pack<common_attribute_names...>::template_name on_type<T>
			{};
	};

	constexpr type_info_t()noexcept{}
	constexpr type_info_t(const type_info_t&)noexcept=default;
	[[nodiscard]]constexpr operator base_type_info_t()const noexcept{return base_type_info_t(typeid(T));}
	[[nodiscard]]constexpr bool operator==(const ::std::type_info&a)const noexcept{return base_type_info_t(*this)==base_type_info_t(a);}
	[[nodiscard]]type_name_t get_name()const noexcept;//定义于type_name.hpp
	[[nodiscard]]size_t get_hash()const noexcept{
		return base_type_info_t(*this).get_hash();
	}
};

template<class T>
constexpr type_info_t<T>type_info{};

template<class T>
[[nodiscard]]constexpr bool operator==(const type_info_t<T>&,const type_info_t<T>&){return true;}
template<class T,class U>
[[nodiscard]]constexpr bool operator==(const type_info_t<T>&,const type_info_t<U>&){return false;}

#line 157 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/type_info.hpp"
//file_end

#line 44 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/min_max.hpp"
//min_max.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/min_max.hpp"
/*!
获取几个参数中的最小值或某类型能表示的最小值.
用法:
	min.able<T1,T2...> -> bool T...等类型能否获得参数最小值.
	min.get_limit_able<T> -> bool 能否获得T类型能表示的最小值.
	min(v1,v2...) -> auto 获取v...的最小值.
	min(type_info<T>) -> auto 获取T能表示的最小值.
*/
constexpr struct min_t{
	template<class...Args>
	static constexpr bool able=was_not_an_ill_form(::std::min(declvalue(Args)...));

	template<typename T>
	static constexpr bool get_limit_able=was_not_an_ill_form(::std::numeric_limits<T>::min());

	template<class...Args> requires able<Args...>
	[[nodiscard]]constexpr auto operator()(Args&&...rest)const noexcept{
		return ::std::min(forward<Args>(rest)...);
	}
	template<class T,class...Args> requires able<::std::initializer_list<T>>
	[[nodiscard]]constexpr auto operator()(T a,Args&&...rest)const noexcept{
		return ::std::min(a,T(rest)...);
	}
	template<typename T>
	struct for_type_t{
		[[nodiscard]]constexpr auto operator()(::std::initializer_list<T>l)const noexcept requires able<::std::initializer_list<T>>{
			return ::std::min(l);
		}
		template<class...Args>
		[[nodiscard]]constexpr auto operator()(Args&&...rest)const noexcept{
			return ::std::min(T(rest)...);
		}
	};
	template<typename T>
	static constexpr for_type_t<T>for_type{};

	template<class T> requires able<::std::initializer_list<T>>
	[[nodiscard]]constexpr auto operator()(::std::initializer_list<T>l)const noexcept{
		return ::std::min(l);
	}
	template<typename T> requires get_limit_able<T>
	[[nodiscard]]constexpr auto operator()(type_info_t<T>)const noexcept{
		return ::std::numeric_limits<T>::min();
	}
}min{};
/*!
获取几个参数中的最大值或某类型能表示的最大值.
用法:
	max.able<T1,T2...> -> bool T...等类型能否获得参数最大值.
	max.get_limit_able<T> -> bool 能否获得T类型能表示的最大值.
	max(v1,v2...) -> auto 获取v...的最大值.
	max(type_info<T>) -> auto 获取T能表示的最大值.
*/
constexpr struct max_t{
	template<class...Args>
	static constexpr bool able=was_not_an_ill_form(::std::max(declvalue(Args)...));

	template<typename T>
	static constexpr bool get_limit_able=was_not_an_ill_form(::std::numeric_limits<T>::max());

	template<class...Args> requires able<Args...>
	[[nodiscard]]constexpr auto operator()(Args&&...rest)const noexcept{
		return ::std::max(forward<Args>(rest)...);
	}
	template<class T,class...Args> requires able<::std::initializer_list<T>>
	[[nodiscard]]constexpr auto operator()(T a,Args&&...rest)const noexcept{
		return ::std::max(a,T(rest)...);
	}
	template<typename T>
	struct for_type_t{
		[[nodiscard]]constexpr auto operator()(::std::initializer_list<T>l)const noexcept requires able<::std::initializer_list<T>>{
			return ::std::max(l);
		}
		template<class...Args>
		[[nodiscard]]constexpr auto operator()(Args&&...rest)const noexcept{
			return ::std::max(T(rest)...);
		}
	};
	template<typename T>
	static constexpr for_type_t<T>for_type{};

	template<class T> requires able<::std::initializer_list<T>>
	[[nodiscard]]constexpr auto operator()(::std::initializer_list<T>l)const noexcept{
		return ::std::max(l);
	}
	template<typename T> requires get_limit_able<T>
	[[nodiscard]]constexpr auto operator()(type_info_t<T>)const noexcept{
		return ::std::numeric_limits<T>::max();
	}
}max{};

//file_end

#line 45 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/math.hpp"
//math.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/math.hpp"
namespace math{
	/// 算术类型帮助类型
	/// 任何后续定义的新算术类型都可以重载这些类型来实现数学库的泛型支持
	template<typename T>
	struct arithmetic_type_info_prover{
		//bool：是否是算数类型
		static constexpr bool is_arithmetic_type=::std::is_arithmetic_v<T> || is_elc_expansion_base_type<T>;
		//bool：是否是基础类型
		static constexpr bool is_basic_type=::std::is_arithmetic_v<T>;
		//bool：是否是大数类型
		static constexpr bool is_big_type=false;
		//bool：是否是浮点类型
		static constexpr bool is_float_type=::std::is_floating_point_v<T>;
		//bool：是否是有符号类型
		static constexpr bool is_signed=::std::is_signed_v<T>;
		//bool：是否有NaN
	private:
		static constexpr bool has_NaN_helper()noexcept{
			if constexpr(is_arithmetic_type)
				return ::std::numeric_limits<T>::has_quiet_NaN || ::std::numeric_limits<T>::has_signaling_NaN;
			else
				return false;
		}
	public:
		static constexpr bool has_NaN=has_NaN_helper();
		//bool：是否有inf
	private:
		static constexpr bool has_inf_helper()noexcept{
			if constexpr(is_arithmetic_type)
				return ::std::numeric_limits<T>::has_infinity;
			else
				return false;
		}
	public:
		static constexpr bool has_inf=has_inf_helper();
		//对应的无符号和有符号类型
		using unsigned_type=decltype(lambda{
			if constexpr(::std::is_unsigned_v<T>||::std::is_floating_point_v<T>)
				return T();
			elseif constexpr(::std::is_signed_v<T>)
				return::std::make_unsigned_t<T>();
		}());
		using signed_type=decltype(lambda{
			if constexpr(::std::is_signed_v<T>||::std::is_floating_point_v<T>)
				return T();
			elseif constexpr(::std::is_unsigned_v<T> && (type_info<T>!=type_info<bool>))
				return::std::make_signed_t<T>();
		}());
	};
	/*! 无符号位的对应类型 */
	template<typename T>
	using to_unsigned_t = typename arithmetic_type_info_prover<remove_cvref<T>>::unsigned_type;
	/*! 有符号位的对应类型 */
	template<typename T>
	using to_signed_t = typename arithmetic_type_info_prover<remove_cvref<T>>::signed_type;

	/// 概念名称空间
	/// 基于标准库的概念，但是使用帮助类型来便于后续定义中的新算数类型重载
	inline namespace concepts{
		/// 算术类型概念
		template<typename T>
		constexpr bool is_arithmetic_type=arithmetic_type_info_prover<remove_cvref<T>>::is_arithmetic_type;
		template<typename T>
		concept arithmetic_type=is_arithmetic_type<T>;

		/// 基础类型概念
		template<typename T>
		constexpr bool is_basic_type=arithmetic_type_info_prover<remove_cvref<T>>::is_basic_type;
		template<typename T>
		concept basic_type=is_basic_type<T>;

		/// 大数类型概念
		template<typename T>
		constexpr bool is_big_type=arithmetic_type_info_prover<remove_cvref<T>>::is_big_type;
		template<typename T>
		concept big_type=is_big_type<T>;

		/// 浮点类型概念
		template<typename T>
		constexpr bool is_float_type=arithmetic_type_info_prover<remove_cvref<T>>::is_float_type;
		template<typename T>
		concept float_type=is_float_type<T>;

		/// 整数类型概念
		template<typename T>
		constexpr bool is_integer_type=!is_float_type<T>;
		template<typename T>
		concept integer_type=is_integer_type<T>;

		/// 有符号类型概念
		template<typename T>
		constexpr bool is_signed=arithmetic_type_info_prover<remove_cvref<T>>::is_signed;
		template<typename T>
		concept signed_type=is_signed<T>;

		/// 无符号类型概念
		template<typename T>
		constexpr bool is_unsigned=!is_signed<T>;
		template<typename T>
		concept unsigned_type=is_unsigned<T>;

		/// 有符号整数类型概念
		template<typename T>
		constexpr bool is_signed_integer_type=is_integer_type<T>&&is_signed<T>;
		template<typename T>
		concept signed_integer_type=is_signed_integer_type<T>;

		/// 无符号整数类型概念
		template<typename T>
		constexpr bool is_unsigned_integer_type=is_integer_type<T>&&is_unsigned<T>;
		template<typename T>
		concept unsigned_integer_type=is_unsigned_integer_type<T>;

		/// 有NaN的类型概念
		template<typename T>
		concept has_NaN=arithmetic_type_info_prover<remove_cvref<T>>::has_NaN;

		/// 有inf的类型概念
		template<typename T>
		concept has_inf=arithmetic_type_info_prover<remove_cvref<T>>::has_inf;
	}

	//isNaN
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr bool isNaN(const T&v)noexcept{
		if constexpr(has_NaN<T>)
			return v!=v;
		else
			return false;
	}
	/*! 符号位查询 */
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr bool is_negative(const T&x)noexcept{
		if constexpr(is_signed<T>){
			if constexpr(has_NaN<T>)
				if(isNaN(x))
					return false;
			return x<T{};
		}
		else
			return false;
	}
	/*! 符号位设置 */
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr T copy_as_negative(auto x,bool negative=1)noexcept{
		if constexpr(is_unsigned<T>)
			template_error("copy_as_negative:unsigned type");
		if constexpr(is_basic_type<decltype(x)>){
			if constexpr(is_float_type<decltype(x)>)
				return(T)::std::copysign(x,negative?-1:1);
			else
				return(T)negative?T{}-x:x;
		}
		else
			return copy_as_negative<T>((T)x,negative);
	}
	[[nodiscard]]force_inline constexpr auto copy_as_negative(auto x,bool negative=1)noexcept{
		return copy_as_negative<to_signed_t<decltype(x)>>(x,negative);
	}
	[[nodiscard]]force_inline constexpr auto copy_as_not_negative(auto x)noexcept{
		return copy_as_negative(x,false);
	}
	/*! 任意算数类型安全转型(ub避免.). */
	template<arithmetic_type T,arithmetic_type U>
	[[nodiscard]]force_inline constexpr T safe_arithmetic_cast(U x)noexcept{
		if constexpr(::std::is_floating_point_v<U> && ::std::is_unsigned_v<T>)
			return (T)(intmax_t)x;
		else
			return (T)x;
	}
	/*! 任意算数类型转size_t */
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr size_t to_size_t(T x)noexcept{
		return safe_arithmetic_cast<size_t>(x);
	}
	/*! 任意算数类型转uintmax_t */
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr uintmax_t to_uintmax_t(T x)noexcept{
		return safe_arithmetic_cast<uintmax_t>(x);
	}
	/*! 求余 */
	template<arithmetic_type T1,arithmetic_type T2>
	[[nodiscard]]force_inline constexpr auto mod(const T1&a,const T2&b){
		if constexpr(::std::is_floating_point_v<T1>||::std::is_floating_point_v<T2>)
			return ::std::fmod(a,b);
		else
			return a%b;
	}
	//divmod
	template<arithmetic_type T1,arithmetic_type T2> requires(!is_big_type<T1>&&!is_big_type<T2>)
	[[nodiscard]]force_inline constexpr auto divmod(const T1&a,const T2&b){
		typedef decltype(a/b) quot_t;
		typedef decltype(a%b) mod_t;
		struct divmod_result{
			quot_t quot;
			mod_t mod;
		};
		if constexpr(::std::is_floating_point_v<T1>||::std::is_floating_point_v<T2>)
			return divmod_result{::std::floor(a/b),::std::fmod(a,b)};
		else
			return divmod_result{a/b,a%b};
	}

	/*! 设置浮点舍入 */
	template<typename T>
	force_inline constexpr void set_rounding(int mode){
		if constexpr(::std::is_floating_point_v<T>)
			::std::fesetround(mode);
	}
	/*!获取浮点舍入 */
	template<typename T>
	[[nodiscard]]force_inline constexpr int get_rounding(){
		if constexpr(::std::is_floating_point_v<T>)
			return ::std::fegetround();
		else
			return 0;
	}
	/*! 设置并自动恢复浮点舍入 */
	template<typename T>
	struct rounding_auto_setter{
		int old_rounding;
		rounding_auto_setter(int new_rounding){
			old_rounding=get_rounding<T>();
			set_rounding<T>(new_rounding);
		}
		~rounding_auto_setter(){
			set_rounding<T>(old_rounding);
		}
	};

	//abs
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr auto abs(const T&v)noexcept{
		if constexpr(is_signed<T>){
			//符号转无符号而不是num=-num避免INT_MAX这种情况下的溢出
			typedef to_unsigned_t<T> UT;
			return is_negative(v)?UT(-v):UT(v);
		}
		else
			return v;
	}
	//is_close
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr bool is_close(const T&a,const T&b)noexcept{
		if constexpr(is_float_type<T> && is_basic_type<T>)
			return abs(a-b)<=::std::numeric_limits<T>::epsilon();
		else
			return a==b;
	}
	//sub
	template<arithmetic_type T1,arithmetic_type T2>
	[[nodiscard]]force_inline constexpr auto sub(const T1&a,const T2&b)noexcept{
		if constexpr(is_basic_type<T1>&&is_basic_type<T2>){
			if constexpr(is_float_type<T1>||is_float_type<T2>)
				return a-b;
			else{
				using signedT = ::std::make_signed_t<::std::common_type_t<T1,T2,signed char>>;
				return static_cast<signedT>(a)-static_cast<signedT>(b);
			}
		}
		else
			return a-b;
	}
	//exp
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<float_type T>
	[[nodiscard]]force_inline constexpr T exp(const T&v)noexcept{
		if(in_consteval||!is_basic_type<T>){
			typedef decltype(lambda{
				if constexpr(is_basic_type<T>)
					return ::std::exp(T{});
				else
					return T{};
			}()) RT;
			auto exp_impl = recursive_lambda(RT x,RT sum,RT n,size_t i,RT t)noexcept -> RT{
				const auto epsilon=sum+t/n;
				if(is_close(sum,epsilon))
					return sum;
				else
					return self_recursion(x,epsilon,n*i,i+1,t*x);
			};
			auto exp_impl_caller = get_recursive_lambda_caller(exp_impl);
			return exp_impl_caller(RT{v},RT{1u},RT{1u},2,RT{v});
		}
		elseif constexpr(is_basic_type<T>)
			return ::std::exp(v);
	}
	//log
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr auto log(const T&a)noexcept{
		if(in_consteval||!is_basic_type<T>){
			typedef decltype(lambda()noexcept{
				if constexpr(is_basic_type<T>)
					return ::std::log(T{});
				else
					return T{};
			}()) RT;
			auto log_impl = recursive_lambda(const RT x,const RT y)noexcept -> RT{
				auto log_iter = lambda(RT x,RT y)noexcept{
					const auto exp_y = exp(y);
					return y + T{2u}*(x-exp_y)/(x+exp_y);
				};
				return RT(is_close(y,log_iter(x,y)) ? y : self_recursion(x,log_iter(x,y)));
			};
			auto log_impl_caller = get_recursive_lambda_caller(log_impl);
			return log_impl_caller((RT)a,RT{0u});
		}
		elseif constexpr(is_basic_type<T>)
			return ::std::log(a);
	}
	template<arithmetic_type T,arithmetic_type U>
	[[nodiscard]]force_inline constexpr auto log(const T&a,const U&b)noexcept{
		return log(a)/log(b);
	}
	//pow
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<arithmetic_type T,arithmetic_type U>
	[[nodiscard]]force_inline constexpr auto pow(const T&a,const U&b)noexcept{
		if(in_consteval||!is_basic_type<T>){
			typedef decltype(::std::pow(a,b)) RT;
			return RT(exp(b*log(a)));
		}
		elseif constexpr(is_basic_type<T>)
			return ::std::pow(a,b);
	}
	//trunc
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<float_type T> requires is_basic_type<T>
	[[nodiscard]]force_inline constexpr auto trunc(const T&v)noexcept{
		if in_consteval{
			typedef decltype(::std::trunc(v)) RT;
			return static_cast<RT>((intmax_t)v);
		}
		else
			return ::std::trunc(v);
	}
	//ceil
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<float_type T> requires is_basic_type<T>
	[[nodiscard]]force_inline constexpr auto ceil(const T&v)noexcept{
		if in_consteval{
			auto ceil_impl = lambda(T x, T y)noexcept{
				return is_close(x,y) ? y : y+T{1};
			};
			return v<0 ? -static_cast<T>(to_uintmax_t(-v)) : ceil_impl(v,static_cast<T>(to_uintmax_t(v)));
		}
		else
			return ::std::ceil(v);
	}
	//floor
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<float_type T> requires is_basic_type<T>
	[[nodiscard]]force_inline constexpr auto floor(const T&v)noexcept{
		if in_consteval{
			auto floor_impl = lambda(T x, T y)noexcept{
				return is_close(x,y) ? y : y-T{1};
			};
			return v<0 ? -static_cast<T>(to_uintmax_t(-v+T{1})) : floor_impl(v,static_cast<T>(to_uintmax_t(v)));
		}
		else
			return ::std::floor(v);
	}
	//sqrt
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<arithmetic_type T>
	[[nodiscard]]force_inline constexpr auto sqrt(const T&v)noexcept{
		if(in_consteval||!is_basic_type<T>){
			typedef decltype(lambda()noexcept{
				if constexpr(is_basic_type<T>)
					return ::std::sqrt(T{});
				else
					return T{};
			}()) RT;
			auto sqrt_impl = recursive_lambda(const RT x,const RT curr,const RT prev)noexcept -> RT{
				return is_close(curr,prev) ? curr : self_recursion(x,(curr+x/curr)/RT{2u},curr);
			};
			auto sqrt_impl_caller = get_recursive_lambda_caller(sqrt_impl);
			if(v >= 0u && v < ::std::numeric_limits<RT>::infinity())
				return sqrt_impl_caller((RT)v,(RT)v,(RT)0u);
			else
				return ::std::numeric_limits<RT>::quiet_NaN();
		}
		elseif constexpr(is_basic_type<T>)
			return ::std::sqrt(v);
	}

	/*! 判断某数是否是素数,无预先检查以供其他素数相关函数快速调用. */
	template<arithmetic_type T>
	[[nodiscard]]inline constexpr bool is_prime_num_no_pre_check(T a)noexcept{
		#line 425 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/math.hpp"
		T b=safe_arithmetic_cast<T>(sqrt(a));//若一个数可以分解为两因数之积,其中一个因数必定≤其开方:反指数式减少遍历范围.
		#line 437 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/math.hpp"
		for(T c=5u;c<=b;c+=6u)//遍历判断是否能被因数分解——不会有人看不懂吧?
			if((!mod(a,c))||(!mod(a,(c+2u))))
				return false;
		#line 446 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/math.hpp"
		return true;
	}
	/*! 判断某数是否是素数 */
	template<arithmetic_type T>
	[[nodiscard]]inline constexpr bool is_prime_num(T a)noexcept{
		if constexpr(is_float_type<T>)
			if(a != ceil(a))
				return false;
		auto b=abs(a);

		if(b<4)
			return true;//1和0也是prime,我不管.
		#line 468 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/math.hpp"
		if(mod(mod(b,6)-1u,4u))
			return false;
		#line 473 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/math.hpp"
		return is_prime_num_no_pre_check(b);
	}
	/// 求小于或等于某数的素数
	template<arithmetic_type T>
	[[nodiscard]]inline constexpr T get_prime_num_less_or_eq_than(T a)noexcept;
	/// 求大于或等于某数的素数
	template<arithmetic_type T>
	[[nodiscard]]inline constexpr T get_prime_num_big_or_eq_than(T a)noexcept{
		if constexpr(is_float_type<T>)
			a=ceil(a);
		if constexpr(is_signed<T>)
			if(is_negative(a)){
				auto tmp = get_prime_num_less_or_eq_than(abs(a));
				return copy_as_negative(tmp);
			}
		if(a<4u)return a;
		//将a转换为6x-1的形式.
		{
			T b=mod(a,6u);
			if(b==1u && is_prime_num_no_pre_check(a))return a;
			a+=b?5u-b:1u;
		}
		//循环判断.
		for(;;a+=6u)
			if(is_prime_num_no_pre_check(a))return a;
			elseif(is_prime_num_no_pre_check(a+2u))return a+2u;
	}
	/// 求小于或等于某数的素数
	template<arithmetic_type T>
	[[nodiscard]]inline constexpr T get_prime_num_less_or_eq_than(T a)noexcept{
		if constexpr(is_float_type<T>)
			a=floor(a);
		if constexpr(is_signed<T>)
			if(is_negative(a)){
				auto tmp = get_prime_num_big_or_eq_than(abs(a));
				return copy_as_negative(tmp);
			}
		if(a<4u)return a;
		//将a转换为6x-1的形式.
		{
			T b=mod(a,6u);
			if(b==1u && is_prime_num_no_pre_check(a))return a;
			a-=b?b-1u:5u;
		}
		//循环判断.
		for(;;a-=6u)
			if(is_prime_num_no_pre_check(a))return a;
			elseif(is_prime_num_no_pre_check(a-2u))return a-2u;
	}
	/// 求大于某数的素数
	template<arithmetic_type T>
	[[nodiscard]]inline constexpr auto get_prime_num_big_than(T a)noexcept{
		return get_prime_num_big_or_eq_than(a+1u);
	}
	push_and_disable_msvc_warning(26467);//gold_of_resize永远为正数
	/// 已知当前array的size，求下一个合适的提前分配大小
	[[nodiscard]]inline constexpr size_t get_next_gold_size_to_resize_for_array(size_t size)noexcept{
		#line 533 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/math.hpp"
		return size_t(size*magic_number::gold_of_resize);
	}
	/// 已知当前hash table的size，求下一个合适的桶大小
	[[nodiscard]]inline constexpr size_t get_next_gold_size_to_resize_for_hash(size_t size)noexcept{
		#line 541 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/math.hpp"
		return size_t(get_prime_num_big_or_eq_than(size*magic_number::gold_of_resize));
	}
	pop_msvc_warning();

	/// 线性插值.
	namespace linear_interpolation{
		[[nodiscard]]inline constexpr auto get_k(auto y1,auto y2,auto δx)noexcept{
			auto δy=sub(y2,y1);
			auto k=δy/δx;
			return k;
		}
		[[nodiscard]]inline constexpr auto get_k(auto y1,auto y2)noexcept{
			return get_k(y1,y2,1.0);
		}
		[[nodiscard]]inline constexpr auto get_result(auto y1,auto k,auto δx)noexcept{
			auto diff=k*δx;
			return y1+diff;
		}
		[[nodiscard]]inline constexpr auto get_reverse_result(auto k,auto δx,auto y)noexcept{
			auto diff=k*δx;
			return y-diff;
		}
	}
	//质因数分解
	//由于array在之后定义所以泛型容器
	//用法 get_prime_factorization(num).to<容器类型>(); 或 get_prime_factorization(num).unique().to<容器类型>();
	constexpr struct get_prime_factorization_t{
		template<class T>
		class result_t{
			T _m;
		public:
			template<class container_t>
			static constexpr bool able=was_not_an_ill_form(declvalue(container_t&).push_back(declvalue(T)));

			constexpr force_inline result_t(T m)noexcept:_m(m){}

			template<class container_t> requires able<container_t>
			[[nodiscard]]constexpr container_t to()const noexcept{
				container_t aret;
				//思路：获取小于等于m的所有素数，依次除以m，若能整除则将素数加入结果，否则跳过，直到m为1.
				T i=T{2},m=abs(_m);
				while(m!=1){
					while(!(m%i)){
						aret.push_back(i);
						m/=i;
					}
					i=get_prime_num_big_than(i);
				}
				if constexpr(::std::is_signed_v<T> || ::std::is_floating_point_v<T>)
					if(is_negative(_m))
						aret.push_back(T{-1});
				return aret;
			}
			//operator container_t()
			template<class container_t>
			[[nodiscard]]constexpr force_inline operator container_t()const noexcept{
				return to<container_t>();
			}
			class unique_t{
				T _m;
			public:
				constexpr force_inline unique_t(T m)noexcept:_m(m){}

				template<class container_t> requires able<container_t>
				[[nodiscard]]constexpr container_t to()const noexcept{
					container_t aret;
					//思路：获取小于等于m的所有素数，依次除以m，若能整除则将素数加入结果，否则跳过，直到m为1.
					T i=T{2},m=abs(_m);
					while(m!=1){
						if(!(m%i)){
							aret.push_back(i);
							do m/=i;while(!(m%i));
						}
						i=get_prime_num_big_than(i);
					}
					if constexpr(::std::is_signed_v<T> || ::std::is_floating_point_v<T>)
						if(is_negative(_m))
							aret.push_back(T{-1});
					return aret;
				}
				//operator container_t()
				template<class container_t>
				[[nodiscard]]constexpr force_inline operator container_t()const noexcept{
					return to<container_t>();
				}
			};
			[[nodiscard]]constexpr force_inline auto unique()const noexcept{
				return unique_t{_m};
			}
		};
		template<class T> requires ::std::is_arithmetic_v<T>
		[[nodiscard]]constexpr force_inline auto operator()(T m)const noexcept{
			return result_t<T>{m};
		}
	}get_prime_factorization{};
	//编译时质因数分解到质因数表
	template<size_t number>
	struct prime_factorization_table_t{
		static constexpr size_t table_size=lambda{
			size_t i=2,m=number;
			size_t ret=0;
			while(m!=1){
				while(!(m%i)){
					++ret;
					m/=i;
				}
				i=get_prime_num_big_than(i);
			}
			return ret;
		}();
		size_t _table[table_size];
		constexpr force_inline prime_factorization_table_t()noexcept{
			size_t i=2,m=number;
			size_t index=0;
			while(m!=1){
				while(!(m%i)){
					_table[index++]=i;
					m/=i;
				}
				i=get_prime_num_big_than(i);
			}
		}
		[[nodiscard]]constexpr force_inline size_t operator[](size_t index)const noexcept{
			return _table[index];
		}
		//begin and end for range for
		[[nodiscard]]constexpr force_inline size_t* begin()noexcept{
			return _table;
		}
		[[nodiscard]]constexpr force_inline size_t* end()noexcept{
			return _table+table_size;
		}
		[[nodiscard]]constexpr force_inline const size_t* begin()const noexcept{
			return _table;
		}
		[[nodiscard]]constexpr force_inline const size_t* end()const noexcept{
			return _table+table_size;
		}
		//size
		[[nodiscard]]constexpr force_inline size_t size()const noexcept{
			return table_size;
		}
		//friend
		template<class T> requires(type_info<remove_cv<T>> == type_info<size_t>)
		[[nodiscard]]friend inline auto size_of_array_like(const prime_factorization_table_t<number>&)noexcept{
			return table_size;
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<size_t>)
		[[nodiscard]]friend inline auto begin_of_array_like(prime_factorization_table_t<number>&table)noexcept{
			return table.begin();
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<size_t>)
		[[nodiscard]]friend inline auto end_of_array_like(prime_factorization_table_t<number>&table)noexcept{
			return table.end();
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<size_t>)
		[[nodiscard]]friend inline auto begin_of_array_like(const prime_factorization_table_t<number>&table)noexcept{
			return table.begin();
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<size_t>)
		[[nodiscard]]friend inline auto end_of_array_like(const prime_factorization_table_t<number>&table)noexcept{
			return table.end();
		}
	};
	//编译时的唯一质因数分解到质因数表
	template<size_t number>
	struct unique_prime_factorization_table_t{
		static constexpr size_t table_size=lambda{
			size_t i=2,m=number;
			size_t ret=0;
			while(m!=1){
				if(!(m%i)){
					++ret;
					do m/=i;while(!(m%i));
				}
				i=get_prime_num_big_than(i);
			}
			return ret;
		}();
		size_t _table[table_size]={};
		constexpr force_inline unique_prime_factorization_table_t()noexcept{
			size_t i=2,m=number;
			size_t index=0;
			while(m!=1){
				if(!(m%i)){
					_table[index++]=i;
					do m/=i;while(!(m%i));
				}
				i=get_prime_num_big_than(i);
			}
		}
		[[nodiscard]]constexpr force_inline size_t operator[](size_t index)const noexcept{
			return _table[index];
		}
		//begin and end for range for
		[[nodiscard]]constexpr force_inline size_t* begin()noexcept{
			return _table;
		}
		[[nodiscard]]constexpr force_inline size_t* end()noexcept{
			return _table+table_size;
		}
		[[nodiscard]]constexpr force_inline const size_t* begin()const noexcept{
			return _table;
		}
		[[nodiscard]]constexpr force_inline const size_t* end()const noexcept{
			return _table+table_size;
		}
		//size
		[[nodiscard]]constexpr force_inline size_t size()const noexcept{
			return table_size;
		}
		//friend
		template<class T> requires(type_info<remove_cv<T>> == type_info<size_t>)
		[[nodiscard]]friend inline auto size_of_array_like(const unique_prime_factorization_table_t<number>&)noexcept{
			return table_size;
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<size_t>)
		[[nodiscard]]friend inline auto begin_of_array_like(unique_prime_factorization_table_t<number>&table)noexcept{
			return table.begin();
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<size_t>)
		[[nodiscard]]friend inline auto end_of_array_like(unique_prime_factorization_table_t<number>&table)noexcept{
			return table.end();
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<size_t>)
		[[nodiscard]]friend inline auto begin_of_array_like(const unique_prime_factorization_table_t<number>&table)noexcept{
			return table.begin();
		}
		template<class T> requires(type_info<remove_cv<T>> == type_info<size_t>)
		[[nodiscard]]friend inline auto end_of_array_like(const unique_prime_factorization_table_t<number>&table)noexcept{
			return table.end();
		}
	};
	//求出最大公约数
	template<integer_type T>
	[[nodiscard]]inline auto gcd(T x, T y)noexcept{
		size_t shift = 0;
		while(y){
			//都是偶数时，shift++并位移
			const auto x_rzero=countr_zero(x);
			const auto y_rzero=countr_zero(y);
			shift+=min(x_rzero,y_rzero);
			//一偶一奇时，只移动偶数 直到都是奇数
			x>>=x_rzero;
			y>>=y_rzero;
			//都是奇数时，大数-=小数
			if(x < y)swap(x, y);
			x-=y;
		}
		// 返回 x 左移 shift 位的结果
		return x << shift;
	}
}
using namespace math::concepts;
using math::to_unsigned_t;
using math::is_negative;
using math::copy_as_negative;
using math::copy_as_not_negative;
using math::to_size_t;
using math::mod;
using math::divmod;
using math::set_rounding;
using math::get_rounding;
using math::rounding_auto_setter;
using math::is_close;
using math::isNaN;
using math::abs;
using math::exp;
using math::log;
using math::pow;
using math::ceil;
using math::floor;
using math::sqrt;
using math::trunc;
using math::is_prime_num;
using math::get_prime_num_big_or_eq_than;
using math::get_prime_num_big_than;
using math::get_next_gold_size_to_resize_for_array;
using math::get_next_gold_size_to_resize_for_hash;
using math::get_prime_factorization;
using math::prime_factorization_table_t;
using math::unique_prime_factorization_table_t;
using math::gcd;

//file_end

#line 46 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/bit.hpp"
//bit.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/bit.hpp"
namespace bit{
	/// 位操作：循环左移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotl_nomod(const T v,const auto R)noexcept;
	#define rot_base(opt,antiopt) static_cast<T>(static_cast<T>(v opt r) | static_cast<T>(v antiopt (d - r)))
	/// 位操作：循环右移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotr_nomod(const T v,const auto r)noexcept{
		constexpr auto d = ::std::numeric_limits<T>::digits;
		if constexpr(::std::is_unsigned_v<decltype(r)>){
			if(r)
				return rot_base(>>,<<);
			else
				return v;
		}
		else{
			if(r>0)
				return rot_base(>>,<<);
			elseif(r==0)
				return v;
			else//r<0
				return rotl_nomod(v,0-r);
		}
	}
	/// 位操作：循环左移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotl_nomod(const T v,const auto r)noexcept{
		constexpr auto d = ::std::numeric_limits<T>::digits;
		if constexpr(::std::is_unsigned_v<decltype(r)>){
			if(r)
				return rot_base(<<,>>);
			else
				return v;
		}
		else{
			if(r>0)
				return rot_base(<<,>>);
			elseif(r==0)
				return v;
			else//r<0
				return rotr_nomod(v,0-r);
		}
	}
	#undef rot_base
	/// 位操作：循环右移
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotr(const T v,const auto R)noexcept{
		constexpr auto d = ::std::numeric_limits<T>::digits;
		const auto r = mod(R,d);
		return rotr_nomod(v,r);
	}
	/// 位操作：循环左移
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotl(const T v,const auto R)noexcept{
		constexpr auto d = ::std::numeric_limits<T>::digits;
		const auto r = mod(R,d);
		return rotl_nomod(v,r);
	}
	template<class T> requires ::std::is_arithmetic_v<T>
	class rot_iterator{
		static constexpr auto rot_offset_npos = ::std::numeric_limits<T>::digits;//d
		size_t _offset;
	public:
		force_inline constexpr rot_iterator(size_t offset)noexcept:_offset(offset%rot_offset_npos){}
		force_inline constexpr rot_iterator&operator++()noexcept{
			_offset++;
			if(_offset==rot_offset_npos)
				_offset=0;
			return*this;
		}
		force_inline constexpr rot_iterator&operator--()noexcept{
			if(_offset==0)
				_offset=rot_offset_npos;
			_offset--;
			return*this;
		}
		force_inline constexpr rot_iterator operator++(int)noexcept{
			rot_iterator tmp(*this);
			operator++();
			return tmp;
		}
		force_inline constexpr rot_iterator operator--(int)noexcept{
			rot_iterator tmp(*this);
			operator--();
			return tmp;
		}
		[[nodiscard]]force_inline constexpr size_t value()const noexcept{
			return _offset;
		}
	};
	/// 位操作：循环左移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotl_nomod(const T v,const rot_iterator<T>&r)noexcept{
		return rotl_nomod(v,r.value());
	}
	/// 位操作：循环右移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotr_nomod(const T v,const rot_iterator<T>&r)noexcept{
		return rotr_nomod(v,r.value());
	}
	/// 位操作：循环左移
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotl(const T v,const rot_iterator<T>&r)noexcept{
		return rotl_nomod(v,r);
	}
	/// 位操作：循环右移
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotr(const T v,const rot_iterator<T>&r)noexcept{
		return rotr_nomod(v,r);
	}
}
using bit::rotl;
using bit::rotr;
using bit::rotl_nomod;
using bit::rotr_nomod;
using bit::rot_iterator;

//file_end

#line 47 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/null_ptr.hpp"
//null_ptr.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/null_ptr.hpp"
namespace null_ptr_n{
	/*!
	提醒子类定义者重载get_null_ptr.
	*/
	special_attribute_t can_t_use_default_null_ptr{};

	/*!
	可不重载get_null_ptr
	在此类ref_able或weak_ref_able时，意味着使用者**保证**所有指向此类的实例的ptr都不可为null_ptr
	否则将内存访问错误
	*/
	special_attribute_t force_use_default_null_ptr:can_t_use_default_null_ptr{};

	enable_adl(the_get_null_ptr);
	template<typename T>
	[[nodiscard]]constexpr auto get_null_ptr()noexcept{
		push_and_disable_msvc_warning(26462);//貌似msvc在这里有bug
		constexpr auto null_as_T = static_cast<T*>(nullptr);
		if constexpr(was_not_an_ill_form(the_get_null_ptr(null_as_T)))
			return the_get_null_ptr(null_as_T);
		elseif constexpr(type_info<T>.has_attribute(can_t_use_default_null_ptr)&&type_info<T>.not_has_attribute(force_use_default_null_ptr)){
			template_error("please overload the function the_get_null_ptr in the namespace where this type is defined.");
			return null_as_T;
		}
		else
			return null_as_T;
		pop_msvc_warning();
	}


	/*!
	字面量null_ptr，如同nullptr使用即可.
	*/
	constexpr struct null_ptr_t{
		template<typename T>
		[[nodiscard]]constexpr_as(get_null_ptr<remove_cvref<T>>())auto base_get()const noexcept{return get_null_ptr<remove_cvref<T>>();}
		template<typename T>
		[[nodiscard]]constexpr_as(base_get<T>())operator T*()const noexcept{return down_cast<T*>(base_get<T>());}
		//constexpr operator decltype(nullptr)()const noexcept{return nullptr;}//提醒接口设计者注意null_ptr的重载版本.
	}null_ptr{};

	template<typename T,typename U=decltype(*null_ptr.base_get<T>())>
	[[nodiscard]]auto operator==(T*a,null_ptr_t)noexcept{
		return null_ptr.base_get<T>()==static_cast<const remove_ref<U>*>(add_const(a));
	}
}
using null_ptr_n::can_t_use_default_null_ptr;
using null_ptr_n::force_use_default_null_ptr;
using null_ptr_n::null_ptr;
typedef decltype(null_ptr) null_ptr_t;
typedef decltype(nullptr) nullptr_t;

//file_end

#line 48 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/compare.hpp"
//compare.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/compare.hpp"
//end_by_zero_t
/*!
用于标志某一数据串以0结尾
*/
inline constexpr struct end_by_zero_t{}end_by_zero;
//just_an_part_t
/*!
用于标志某一数据串并没有完结
*/
inline constexpr struct just_an_part_t{}just_an_part;
//equal：值相等.
/*!
	相等比较任意支持比较的类型或其数组——简易封装.
	用法:
	判断两值是否可比较。
	equal.able<类型1,类型2（可选，默认为类型1）>		->	bool
	判断将两者进行比较时是否会抛出异常。
	equal.nothrow<类型,类型2（可选，默认为类型1）>		->	bool

	equal(T1,T2)										->	auto

	equal(T1[N1],T2[N2])								->	bool
	equal(T1*,size1,T2*,size2)							->	bool
	equal(T1*,T2*,size)									->	bool
	equal(T1*,size1,T2*,end_by_zero)					->	bool
	equal(T1*,end_by_zero,T2*,size)						->	bool
	equal(T1*,end_by_zero,T2*,end_by_zero)				->	bool
*/
constexpr struct equal_t{
	template<class T,class U=T>
	static constexpr bool able= was_not_an_ill_form(declvalue(T)==declvalue(U));
	template<class T,class U=T>
	static constexpr bool nothrow= was_not_an_ill_form_and_noexcept(declvalue(T)==declvalue(U));

	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T&&a,U&&b)const noexcept(nothrow<T,U>){
		return a==b;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,U*b,size_t size)const noexcept(nothrow<T,U>){
		while(size--){
			if(*(a++)!=*(b++))
				return false;
		}
		return true;
	}
	template<typename T,typename U,size_t N1,size_t N2>
	[[nodiscard]]constexpr bool operator()(T(&a)[N1],U(&b)[N2])const noexcept(nothrow<T,U>){
		if constexpr(N1==N2)
			return operator()(a,b,N1);
		else{
			template_warning("N1!=N2");
			return false;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,size_t size1,U*b,size_t size2)const noexcept(nothrow<T,U>){
		if(size1==size2)
			return operator()(a,b,size1);
		else
			return false;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,size_t size1,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		while(size1--){
			if(*a!=*b || *b==U{0})
				return false;
			a++;
			b++;
		}
		return *b==U{0};
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,end_by_zero_t,U*b,size_t size2)const noexcept(nothrow<T,U>){
		return operator()(b,size2,a,end_by_zero);
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,end_by_zero_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		floop{
			if(*a!=*b)
				return false;
			if(*a==T{0})
				return true;
			a++;
			b++;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,size_t size1,just_an_part_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		while(size1--){
			if(*a!=*b || *b==U{0})
				return false;
			a++;
			b++;
		}
		return true;
	}
}equal{};

//eq：同一对象
template<typename T>
[[nodiscard]]constexpr auto is_eq(T&&a,T&&b)noexcept_as(&a==&b){
	return &a==&b;
}
template<typename T>
[[nodiscard]]constexpr auto is_not_eq(T&&a,T&&b)noexcept_as(!is_eq(a,b)){
	return!is_eq(a,b);
}

//compare：三路比较
/*!
	若大小相同则以字典序三路比较任意支持比较的类型或其数组,并在 <=> 不可用时以 < 和 == 为后备.
	用法:
	判断两者是否可真的进行三路比较。
	compare.r_able<类型1,类型2(可选，默认与1相同)>				->	bool
	判断两者是否可进行compare操作。
	compare.able<类型1,类型2(可选，默认与1相同)>				->	bool
	判断将两者进行三路比较是否会抛出异常。
	compare.nothrow<类型1,类型2（可选，默认与1相同）>			->	bool

	compare(T1,T2)
	compare(T1[N1],T2[N2])
	compare(T1*,size1,T2*,size2)
	compare(T1*,T2*,size)
	返回类型语义上是三路比较的结果类型,具体类型视情况而定.

	以字典序进行三路比较。
	compare.lexicographical(T1,T2)
	compare.lexicographical(T1[N1],T2[N2])
	compare.lexicographical(T1*,size1,T2*,size2)
	compare.lexicographical(T1*,T2*,size)
	返回类型语义上是三路比较的结果类型,具体类型视情况而定.

	翻转三路比较的结果类型。
	compare.reverse(order)
	返回对应结果类型的反义，与零相等或无法比较时则返回其本身。
*/
constexpr struct compare_t{
	template<class T,class U=T>
	static constexpr bool r_able= was_not_an_ill_form(declvalue(T)<=>declvalue(U));

	template<class T,class U=T>
	static constexpr bool able= r_able<T,U> ||
								was_not_an_ill_form(
														declvalue(T)==declvalue(U),
														declvalue(T)<declvalue(U),
														declvalue(U)<declvalue(T)
													);
	template<class T,class U=T>
	static constexpr bool nothrow= was_not_an_ill_form_and_noexcept(declvalue(T)<=>declvalue(U)) ||
								   was_not_an_ill_form_and_noexcept(
														declvalue(T)==declvalue(U),
														declvalue(T)<declvalue(U),
														declvalue(U)<declvalue(T)
													);


	template<class T,class U>
	[[nodiscard]]static constexpr auto base_call(T&&a,U&&b)noexcept(nothrow<T,U>){
		//在 <=> 不可用时以 < 和 == 为后备，优于直接 <=>
		if constexpr(r_able<T,U>)
			return a<=>b;
		else return a == b	? partial_ordering::equivalent	:
					a < b	? partial_ordering::less		:
					b < a	? partial_ordering::greater		:
							  partial_ordering::unordered	;
	}

	template<class T,class U=T>
	using type=decltype(base_call(declvalue(T),declvalue(U)));

	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T&&a,U&&b)const noexcept(nothrow<T,U>){
		return base_call(a,b);
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,U*b,size_t size)const noexcept(nothrow<T,U>){
		while(size--){
			if(auto tmp=base_call(*(a++),*(b++)); tmp!=0)
				return tmp;
		}
		return strong_ordering::equivalent;
	}
	template<typename T,typename U,size_t N1,size_t N2>
	[[nodiscard]]constexpr auto operator()(T(&a)[N1],U(&b)[N2])const noexcept(nothrow<T,U>){
		if constexpr(N1==N2)
			return operator()(a,b,N1);
		else{
			template_warning("N1!=N2");
			return N1<=>N2;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,size_t size1,U*b,size_t size2)const noexcept(nothrow<T,U>){
		type<T,U> tmp=size1<=>size2;
		if(tmp!=0)
			return tmp;
		else
			return operator()(a,b,size1);
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,size_t size1,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		type<T,U> tmp=strong_ordering::equivalent;
		while(size1--){
			if(*b==U{0})
				return strong_ordering::greater;
			if(tmp==0)
				tmp=base_call(*a,*b);
			a++;
			b++;
		}
		return *b==U{0}?tmp:strong_ordering::less;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,end_by_zero_t,U*b,size_t size2)const noexcept(nothrow<T,U>){
		type<T,U> tmp=strong_ordering::equivalent;
		while(size2--){
			if(*a==T{0})
				return strong_ordering::less;
			if(tmp==0)
				tmp=base_call(*a,*b);
			a++;
			b++;
		}
		return *b==U{0}?tmp:strong_ordering::less;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,end_by_zero_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		type<T,U> tmp=strong_ordering::equivalent;
		floop{
			if(*a==T{0})
				return *b==U{0}?tmp:strong_ordering::less;
			if(tmp==0)
				tmp=base_call(*a,*b);
			a++;
			b++;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,size_t size1,just_an_part_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		type<T,U> tmp=strong_ordering::equivalent;
		while(size1--){
			if(*b==U{0})
				return strong_ordering::greater;
			if(tmp==0)
				tmp=base_call(*a,*b);
			a++;
			b++;
		}
		return tmp;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,size_t size1,U*b,size_t size2)const noexcept(nothrow<T,U>){
		if(auto tmp=operator()(a,b,min(size1,size2)); tmp!=0)
			return tmp;
		else
			return size1<=>size2;
	}
	template<typename T,typename U,size_t N1,size_t N2>
	[[nodiscard]]constexpr auto lexicographical(T(&a)[N1],U(&b)[N2])const noexcept(nothrow<T,U>){
		return lexicographical(a,N1,b,N2);
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,size_t size1,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		while(size1--){
			if(*b==U{0})
				return strong_ordering::greater;
			if(auto tmp=base_call(*a,*b); tmp!=0)
				return tmp;
			a++;
			b++;
		}
		return *b==U{0}?strong_ordering::equivalent:
						strong_ordering::less;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,end_by_zero_t,U*b,size_t size2)const noexcept(nothrow<T,U>){
		while(size2--){
			if(*a==T{0})
				return strong_ordering::less;
			if(auto tmp=base_call(*a,*b); tmp!=0)
				return tmp;
			a++;
			b++;
		}
		return *b==U{0}?strong_ordering::equivalent:
						strong_ordering::less;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,end_by_zero_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		floop{
			if(*a==T{0})
				return *b==U{0}?strong_ordering::equivalent:
								strong_ordering::less;
			if(auto tmp=base_call(*a,*b); tmp!=0)
				return tmp;
			a++;
			b++;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,size_t size1,just_an_part_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		while(size1--){
			if(*b==U{0})
				return strong_ordering::greater;
			if(auto tmp=base_call(*a,*b); tmp!=0)
				return tmp;
			a++;
			b++;
		}
		return strong_ordering::equivalent;
	}
	//
	[[nodiscard]]constexpr auto reverse(partial_ordering odr)const noexcept{
		if(odr==partial_ordering::greater)
			return partial_ordering::less;
		elseif(odr==partial_ordering::less)
			return partial_ordering::greater;
		else
			return odr;
	}
	[[nodiscard]]constexpr auto reverse(weak_ordering odr)const noexcept{
		if(odr==weak_ordering::greater)
			return weak_ordering::less;
		elseif(odr==weak_ordering::less)
			return weak_ordering::greater;
		else
			return odr;
	}
	[[nodiscard]]constexpr auto reverse(strong_ordering odr)const noexcept{
		if(odr==strong_ordering::greater)
			return strong_ordering::less;
		elseif(odr==strong_ordering::less)
			return strong_ordering::greater;
		else
			return odr;
	}
}compare{};

//file_end

#line 49 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/note.hpp"
//note.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/note.hpp"
namespace note_n{
	#define def_note(name) \
	template<typename T>\
	struct name##_t{\
		T value;\
		force_inline constexpr name##_t(T a)noexcept:value(a){}\
		template<class U>\
		force_inline constexpr name##_t(name##_t<U>a)noexcept:value(a.value){}\
		force_inline constexpr operator T()noexcept{return value;}\
		force_inline constexpr T operator()()noexcept{return value;}\
	};\
	template<typename T>\
	constexpr name##_t<T>name(T v){return{v};}

	def_note(from);
	def_note(to);
	def_note(size);

	#undef def_note
	constexpr struct fail_t{}fail{};
}
namespace note=note_n;

//file_end

#line 50 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/array_like.hpp"
//array_like.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/array_like.hpp"
namespace array_like_n{
	enable_adl(size_of_array_like);
	template<class T>
	[[nodiscard]]inline constexpr size_t size_of_array_like(T&&)noexcept{return 1;}
	template<class T,size_t N>
	[[nodiscard]]inline constexpr size_t size_of_array_like(T(&)[N])noexcept{return N;}
	template<class T>
	[[nodiscard]]inline size_t size_of_array_like(::std::initializer_list<T>&a)noexcept{return a.size();}

	enable_adl(begin_of_array_like);
	template<class T>
	[[nodiscard]]inline constexpr auto begin_of_array_like(T&&a)noexcept{return addressof(a);}
	template<class T,size_t N>
	[[nodiscard]]inline constexpr auto begin_of_array_like(T(&a)[N])noexcept{return addressof(a[0]);}
	template<class T>
	[[nodiscard]]inline const T* begin_of_array_like(::std::initializer_list<T>&a)noexcept{return a.begin();}

	enable_adl(end_of_array_like);
	template<class T>
	[[nodiscard]]inline auto end_of_array_like(T&&a)noexcept{return begin_of_array_like(a)+size_of_array_like(a);}

	template<class T>
	constexpr bool is_array_like=was_not_an_ill_form_with_parameter(
									(T v){
										begin_of_array_like(v);
										size_of_array_like(v);
									}
								);

	template<class T>
	constexpr bool is_signal_value_for_array_like=type_info<remove_cvref<decltype(*begin_of_array_like(declvalue(T)))>> == type_info<T>;
	template<class T>
	constexpr bool is_not_signal_value_for_array_like=!is_signal_value_for_array_like<T>;

	template<class T,class U>
	constexpr bool strict_is_array_like_for=was_not_an_ill_form_with_parameter(
										(U v){
											begin_of_array_like<T>(v);
											size_of_array_like<T>(v);
										}
									);
	template<class T,class U>
	constexpr bool is_array_like_for=strict_is_array_like_for<T,U>||strict_is_array_like_for<const T,U>;

	template<class T>
	struct array_like_view_t{
		typedef T* iterator;
		typedef const T* const_iterator;
		typedef array_like_view_t<T>this_t;
		struct reverse_iterator{
			T* _m;
			constexpr reverse_iterator(T*p)noexcept:_m(p){}
			constexpr reverse_iterator(const reverse_iterator&)noexcept=default;
			constexpr reverse_iterator(reverse_iterator&&)noexcept=default;
			constexpr reverse_iterator operator++()noexcept{_m--;return *this;}
			constexpr reverse_iterator operator--()noexcept{_m++;return *this;}
			constexpr reverse_iterator operator++(int)noexcept{auto tmp=*this;this->operator++();return tmp;}
			constexpr reverse_iterator operator--(int)noexcept{auto tmp=*this;this->operator--();return tmp;}
			[[nodiscard]]constexpr T& operator*()const noexcept{return*_m;}
			[[nodiscard]]constexpr T& operator[](ptrdiff_t a)const noexcept{return*(_m-a);}
			[[nodiscard]]constexpr T* operator->()const noexcept{return _m;}
			[[nodiscard]]constexpr reverse_iterator operator+(ptrdiff_t diff)const noexcept{return _m-diff;}
			[[nodiscard]]constexpr reverse_iterator operator-(ptrdiff_t diff)const noexcept{return _m+diff;}
			[[nodiscard]]constexpr operator T*()const noexcept{return _m;}
			[[nodiscard]]constexpr bool operator==(T*p)const noexcept{return _m==p;}
			[[nodiscard]]constexpr bool operator==(const reverse_iterator&a)const noexcept{return _m==a._m;}
			[[nodiscard]]constexpr auto operator<=>(T*p)noexcept{return _m<=>p;}
			[[nodiscard]]constexpr bool operator<=>(const reverse_iterator&a)const noexcept{return a._m<=>_m;}
		};
	private:
		T*_begin=nullptr;
		size_t _size=0;
	public:
		constexpr explicit array_like_view_t(T*a,size_t b)noexcept:_begin(a),_size(b){}
		template<class U> requires strict_is_array_like_for<T,U>
		explicit constexpr_as_auto array_like_view_t(U&&a)noexcept_as(begin_of_array_like<T>(a),size_of_array_like<T>(a)):array_like_view_t(begin_of_array_like<T>(a),size_of_array_like<T>(a)){}
		constexpr array_like_view_t(const this_t&)noexcept=default;

		void swap_with(this_t&b)noexcept_as(swap(_begin,b._begin),swap(_size,b._size)){
			swap(_begin,b._begin);
			swap(_size,b._size);
		}

		[[nodiscard]]constexpr const_iterator data()const noexcept{return _begin;}
		[[nodiscard]]constexpr size_t size()const noexcept{return _size;}

		[[nodiscard]]constexpr iterator begin()noexcept requires(type_info<iterator>!=type_info<const_iterator>){return _begin;}
		[[nodiscard]]constexpr iterator end()noexcept requires(type_info<iterator>!=type_info<const_iterator>){return begin()+size();}
		[[nodiscard]]constexpr const_iterator begin()const noexcept{return _begin;}
		[[nodiscard]]constexpr const_iterator end()const noexcept{return begin()+size();}

		[[nodiscard]]constexpr const_iterator cbegin()const noexcept{return remove_const(this)->begin();}
		[[nodiscard]]constexpr const_iterator cend()const noexcept{return remove_const(this)->end();}

		[[nodiscard]]constexpr reverse_iterator rbegin()noexcept{return _begin+size()-1;}
		[[nodiscard]]constexpr reverse_iterator rend()noexcept{return _begin-1;}

		[[nodiscard]]constexpr T&front()noexcept{return _begin[0];}
		[[nodiscard]]constexpr const T&front()const noexcept{return _begin[0];}
		[[nodiscard]]constexpr T&back()noexcept{return _begin[size()-1];}
		[[nodiscard]]constexpr const T&back()const noexcept{return _begin[size()-1];}

		[[nodiscard]]constexpr bool empty()const noexcept{return!size();}

		[[nodiscard]]constexpr T&operator[](size_t pos)noexcept{return begin()[pos];}
		[[nodiscard]]constexpr const T&operator[](size_t pos)const noexcept{return remove_const(*this)[pos];}

		[[nodiscard]]constexpr auto operator<=>(this_t a)noexcept(compare.nothrow<T>){
			return compare(_begin,_size,a._begin,a._size);
		}
		[[nodiscard]]constexpr auto operator==(this_t a)noexcept(equal.nothrow<T>){
			return equal(_begin,_size,a._begin,a._size);
		}
	};
	template<typename T>
	struct array_end_by_zero_t:array_like_view_t<T>{
		typedef array_like_view_t<T>base_t;
		using base_t::base_t;

		[[nodiscard]]constexpr static size_t get_length_of(T*ptr)noexcept{
			if(*ptr)return get_length_of(ptr+1)+1;
			else return 0;
		}

		constexpr array_end_by_zero_t(T*ptr)noexcept:base_t(ptr,get_length_of(ptr)){}
	};

	template<class T>
	[[nodiscard]]inline constexpr T* begin_of_array_like(array_like_view_t<T>&a)noexcept requires(type_info<T>!=type_info<const T>){return a.begin();}
	template<class T>
	[[nodiscard]]inline constexpr auto begin_of_array_like(const array_like_view_t<T>&a)noexcept{return a.begin();}
	template<class T>
	[[nodiscard]]inline constexpr T* begin_of_array_like(array_like_view_t<remove_cv<T>>&a)noexcept{return a.begin();}
	template<class T>
	[[nodiscard]]inline constexpr size_t size_of_array_like(const array_like_view_t<T>&a)noexcept{return a.size();}
}
using array_like_n::size_of_array_like;
using array_like_n::begin_of_array_like;
using array_like_n::end_of_array_like;
using array_like_n::is_array_like;
using array_like_n::is_signal_value_for_array_like;
using array_like_n::is_not_signal_value_for_array_like;
using array_like_n::is_array_like_for;
using array_like_n::strict_is_array_like_for;
using array_like_n::array_like_view_t;
using array_like_n::array_end_by_zero_t;

//file_end

#line 51 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/data.hpp"
//data.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/data.hpp"
/*!
	每个T的可能性大小
*/
template<class T> requires ::std::is_integral_v<T>
constexpr auto number_of_possible_values_per=uintmax_index_t(max(type_info<::std::make_unsigned_t<T>>))+1;

/*!
	功能: byte* 类型数据转换为 T&，不进行任何检查
	用法: data_cast<T>(byte*) -> T&
*/
template<class T>
[[nodiscard]]force_inline constexpr T&data_cast(byte*p)noexcept{return*reinterpret_cast<T*>(p);}
template<class T>
[[nodiscard]]force_inline constexpr T&launder_data_cast(byte*p)noexcept{return*::std::launder(data_cast<T>(p));}
/*!
	功能: byte* 类型数据转换为 T*，不进行任何检查
	用法: data_ptr_cast<T>(byte*) -> T*
*/
template<class T>
[[nodiscard]]force_inline constexpr T*data_ptr_cast(byte*p)noexcept{return reinterpret_cast<T*>(p);}
template<class T>
[[nodiscard]]force_inline constexpr T*launder_data_ptr_cast(byte*p)noexcept{return ::std::launder(data_ptr_cast<T>(p));}
/*!
	功能: T* 指针转换为 byte*，不进行任何检查
	用法: cast_to_data(T*) -> byte*
*/
template<class T>
[[nodiscard]]force_inline constexpr byte*cast_to_data(T*p)noexcept{return reinterpret_cast<byte*>(p);}
template<class T>
[[nodiscard]]force_inline constexpr byte*launder_cast_to_data(T*p)noexcept{return ::std::launder(cast_to_data(p));}
/*!
	功能: const T* 指针转换为 const byte*，不进行任何检查
	用法: cast_to_data(const T*) -> const byte*
*/
template<class T>
[[nodiscard]]force_inline constexpr const byte*cast_to_data(const T*p)noexcept{return reinterpret_cast<const byte*>(p);}
template<class T>
[[nodiscard]]force_inline constexpr const byte*launder_cast_to_data(const T*p)noexcept{return ::std::launder(cast_to_data(p));}
/*!
	功能: T& 转换为 U&，不进行任何检查
	用法: union_cast<U>(T&) -> U&
*/
template<class U,class T>
[[nodiscard]]force_inline constexpr U&union_cast(T&&t)noexcept{return*reinterpret_cast<U*>(&t);}
template<class U,class T>
[[nodiscard]]force_inline constexpr U&launder_union_cast(T&&t)noexcept{return*::std::launder(union_cast<U>(t));}

/*!
	功能: data_block辅助变量模板，接受数个类型并表现为其中的最大对齐值
*/
template<class...Ts>
inline constexpr size_t max_align_of=max({alignof(Ts)...});
/*!
	功能: data_block辅助变量模板，接受数个类型并表现为其中的最大大小值
*/
template<class...Ts>
inline constexpr size_t max_size_of=max({sizeof(Ts)...});
/*!
	功能: data_block类模板,接受多个类型参数,实例化为内含最大体积最大对齐要求的byte数组的结构体
			data_block -> byte*
	用法: data_block<T1,T2,...>value;
*/
template<class...Ts>
struct data_block:non_copy_construct_able,non_move_construct_able{
	static constexpr size_t size=max_size_of<Ts...>;
	static constexpr size_t align=max_align_of<Ts...>;
	push_and_disable_msvc_warning(4324);
	alignas(align)byte _data[size];
	pop_msvc_warning();

	push_and_disable_msvc_warning(26495);
	force_inline constexpr data_block()noexcept{
		if in_consteval
			for(size_t i=0;i<size;++i)
				_data[i]=byte{};
	};
	template<class T> requires(sizeof(T)<=size&&alignof(T)<=align)
	force_inline constexpr data_block(T&&t)noexcept{
		data_cast<T>(_data)=forward<T>(t);
		if constexpr(sizeof(T)<size)
			if in_consteval
				for(size_t i=sizeof(T);i<size;++i)
					_data[i]=byte{};
	}
	pop_msvc_warning();
	force_inline constexpr operator byte*()noexcept{return _data;}
	force_inline constexpr operator const byte*()const noexcept{return _data;}
	template<class T> requires(sizeof(T)<=size&&alignof(T)<=align)
	force_inline constexpr auto&operator=(T&&t)noexcept{
		return data_cast<remove_cvref<T>>(_data)=forward<T>(t);
	}
	//begin & end
	force_inline constexpr byte*begin()noexcept{return _data;}
	force_inline constexpr byte*end()noexcept{return _data+size;}
	force_inline constexpr const byte*begin()const noexcept{return _data;}
	force_inline constexpr const byte*end()const noexcept{return _data+size;}
};
/*!
	功能: data_block辅助类模板，接受一个size_t描述对齐大小的类型模板
*/
push_and_disable_msvc_warning(4324);
template<class...Ts>
struct alignas(max_align_of<Ts...>)align_as_t{};
pop_msvc_warning();

/*!
	功能: data_view类模板,接受一个类型参数，提供对byte数组的访问和遍历
	用法: data_view<T>value{&value};
*/
template<class T>
struct data_view:array_like_view_t<byte>{
	using array_like_view_t<byte>::array_like_view_t;
	constexpr data_view(T*p)noexcept:array_like_view_t<byte>{cast_to_data(p),sizeof(T)}{}
};
template<class T>
struct data_view<const T>:array_like_view_t<const byte>{
	using array_like_view_t<const byte>::array_like_view_t;
	constexpr data_view(const T*p)noexcept:array_like_view_t<const byte>{cast_to_data(p),sizeof(T)}{}
};

/*!
	功能: 比较两个类实例在内存中的内容是否相同
	用法: full_equal_in_byte(const T&a,const T&b) -> bool
*/
template<class T>
[[nodiscard]]constexpr bool full_equal_in_byte(const T&a,const T&b)noexcept{
	return equal(cast_to_data(&a),cast_to_data(&b),sizeof(T));
}

//file_end

#line 52 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/pointer.hpp"
//pointer.hpp
//at namespace elc::defs::base
#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/pointer.hpp"
enable_adl(the_pointer_to_bool);
/// 指针转bool的重载接口，允许类对此进行自定义
/// elc内部的指针转bool应当视情况使用默认配置或此重载接口
template<typename T>
[[nodiscard]]constexpr auto pointer_to_bool(T*a)noexcept{
	if constexpr(was_not_an_ill_form(the_pointer_to_bool(a)))
		return the_pointer_to_bool(a);
	else
		return null_ptr!=a;
}

enable_adl(the_pointer_equal);
/// 指针比较的重载接口，允许类对此进行自定义
/// elc内部的指针比较应当视情况使用默认配置或此重载接口
template<typename T>
[[nodiscard]]constexpr auto pointer_equal(T*a,T*b)noexcept{
	if constexpr(was_not_an_ill_form(the_pointer_equal(a,b)))
		return the_pointer_equal(a,b);
	else
		return a==b;
}

/// 判断类型是否为指针
template<class T>
inline constexpr bool is_pointer= ::std::is_pointer_v<T>;
/// 未知类型指针
typedef void*pointer;
/// 未知类型指针，不可写
typedef const void*const_pointer;

/// 获取两个指针的偏移
[[nodiscard]]constexpr ptrdiff_t get_off_set(note::from_t<const_pointer>a,note::to_t<const_pointer>b)noexcept{
	return cast_to_data(b())-cast_to_data(a());//b-a == c
}
/// 应用偏移
template<class T>
[[nodiscard]]constexpr auto apply_off_set(T*a,ptrdiff_t c)noexcept{
	return cast_to_data(a)+c;//a+c == b
}
/// 反向应用偏移
template<class T>
[[nodiscard]]constexpr auto unapply_off_set(T*b,ptrdiff_t c)noexcept{
	return cast_to_data(b)-c;//b-c == a
}

//file_end

#line 53 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/hash.hpp"
//hash.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/hash.hpp"
namespace hash_n{
	typedef size_t hash_base_t;
	struct hash_value_t{
		hash_base_t _value;
		constexpr hash_base_t operator%(auto&&a)const noexcept{
			return _value%a;
		}
		constexpr bool operator==(const hash_value_t&a)const noexcept{
			return _value==a._value;
		}
	};
	struct unstable_hash_value_t:hash_value_t{
		unstable_hash_value_t(const hash_value_t&a)noexcept:hash_value_t(a){}
	};

	template<class T>
	inline constexpr bool is_unstable_hash = type_info<T const>.can_convert_to<unstable_hash_value_t>;
	template<class T>
	inline constexpr bool is_fundamental_hash = ::std::is_fundamental_v<T>;

	enable_adl(the_pointer_hash);
	/*!
	Computes the hash value of a pointer.

	@param a The pointer to hash.

	@returns The hash value of the pointer.
	*/
	template<class T>
	[[nodiscard]]inline constexpr hash_value_t pointer_hash(T*a)noexcept{
		if constexpr(was_not_an_ill_form(the_pointer_hash(a)))
			return the_pointer_hash(a);
		else
			return{hash_base_t(a)};
	}

	inline struct hash_t{
	private:
		template<class T>
		[[nodiscard]]static inline constexpr bool nothrow_helper()noexcept{
			if constexpr(is_pointer<T>)
				return noexcept(pointer_hash(declvalue(const T&)));
			elseif constexpr(is_fundamental_hash<T>)
				return noexcept(hash_value_t{hash_base_t(declvalue(const T&))});
			elseif constexpr(is_unstable_hash<T>)
				return noexcept(unstable_hash_value_t(declvalue(const T&)));
			elseif constexpr(was_not_an_ill_form(declvalue(const T&).hash()))
				return noexcept(declvalue(const T&).hash());
			elseif constexpr(was_not_an_ill_form(hash_value_t(declvalue(const T&))))
				return noexcept(hash_value_t(declvalue(const T&)));
			elseif constexpr(type_info<remove_cv<T>> == type_info<base_type_info_t>)
				return true;
			else
				return false;
		}
	public:
		template<class T>
		static constexpr bool nothrow=nothrow_helper<T>();
	private:
		template<class T>
		[[nodiscard]]static inline constexpr bool able_helper()noexcept{
			if constexpr(is_pointer<T>)
				return true;
			elseif constexpr(is_fundamental_hash<T>)
				return true;
			elseif constexpr(is_unstable_hash<T>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(const T&).hash()))
				return true;
			elseif constexpr(was_not_an_ill_form(hash_value_t(declvalue(const T&))))
				return true;
			elseif constexpr(type_info<remove_cv<T>> == type_info<base_type_info_t>)
				return true;
			else
				return false;
		}
	public:
		template<class T>
		static constexpr bool able=able_helper<T>();

		#define hash operator()

		/*!
		Computes the hash value of `nothing`.

		@returns The hash value of `nothing`.
		*/
		[[nodiscard]]inline constexpr hash_value_t hash(nothing)const noexcept{
			return{hash_base_t(nothing)};
		}
		/*!
		Computes the hash value of a base_type_info_t object.

		@param a The base_type_info_t object to hash.

		@returns The hash value of the object.
		*/
		[[nodiscard]]inline hash_value_t hash(const base_type_info_t&a)const noexcept{
			return{a.get_hash()};
		}
		/*!
		Computes the hash value of a value.

		@param a The value to hash.

		@returns The hash value of the value.
		*/
		template<class T> requires able<T>
		[[nodiscard]]constexpr_as_auto inline auto hash(const T&a)const noexcept(nothrow<T>){
			#undef hash
			if constexpr(is_pointer<T>)
				return pointer_hash(a);
			elseif constexpr(is_fundamental_hash<T>)
				return hash_value_t{hash_base_t(a)};
			elseif constexpr(is_unstable_hash<T>)
				return unstable_hash_value_t(a);
			elseif constexpr(was_not_an_ill_form(declvalue(const T&).hash()))
				return a.hash();
			elseif constexpr(was_not_an_ill_form(hash_value_t(declvalue(const T&))))
				return hash_value_t(a);
			else{
				template_error("Please overload the function hash in the namespace where this type is defined.");
				return hash_value_t{};
			}
			#define hash operator()
		}
		/*!
		Computes the hash of a value in the base type.

		@param a The value to hash.

		@returns The hash of the value in the base type.
		*/
		template<class T>
		[[nodiscard]]constexpr_as_auto inline hash_base_t get_hash_in_base_type(const T&a)const noexcept(nothrow<T>){
			return hash(a)._value;
		}
		/*!
		从某个起始点算起的hash

		@param before The hashed value before this hash.
		@param before_size The size of the hashed value before this hash.
		@param a The sequence of values.
		@param size The number of values in the sequence.

		@returns The hash value of the sequence.
		*/
		template<class T>
		[[nodiscard]]force_inline constexpr hash_value_t with_calculated_before(hash_value_t before,size_t before_size,const T*a,size_t size)const noexcept{
			hash_base_t aret=before._value;
			rot_iterator<decltype(aret)>rotl_offset = before_size+size;
			while(size--){
				aret ^= rotl(get_hash_in_base_type(a[size]),rotl_offset);
				rotl_offset--;
			}
			return{aret};
		}
		/*!
		计算此hash重复N次的数组的hash结果

		@param value The hash value to repeat.
		@param size The number of times to repeat the hash value.

		@returns The repeated hash value.
		*/
		[[nodiscard]]force_inline constexpr hash_value_t repeat_times(hash_value_t value,size_t size)const noexcept{
			hash_base_t aret=0;
			{
				//优化.
				//关於此,咱确信咱发现一种美妙的证法来保证这个优化不影响结果,但可惜凋可怜的脑容量不足以让他看懂.
				constexpr size_t bit_range_max=bitnum_of(hash_base_t);
				constexpr hash_base_t void_hash{nothing};
				push_and_disable_msvc_warning(26475)//强制转换警告diss.
				constexpr hash_base_t npos_hash{hash_base_t(-1)};
				pop_msvc_warning();
				constexpr size_t bitnumof_void=bit_range_max*BIT_POSSIBILITY;

				size=size%bitnumof_void;
				if(value._value==0 || size==0)
					return{void_hash};
				if(size >= bit_range_max){
					const bool is_npos = ::std::popcount(value._value)%BIT_POSSIBILITY;
					aret = is_npos?npos_hash:void_hash;
					size-=bit_range_max;
				}
				if(!size)
					return{aret};
			}
			rot_iterator<decltype(aret)>rotl_offset = size;
			while(size--){
				aret ^= rotl(value._value,rotl_offset);
				rotl_offset--;
			}
			return{aret};
		}
		/*!
		计算此hash重复N次的数组的hash结果

		@param value The hash value to repeat.
		@param size The number of times to repeat the hash value.

		@returns The repeated hash value.
		*/
		template<class T>
		[[nodiscard]]force_inline constexpr hash_value_t repeat_times(T&&value,size_t size)const noexcept{
			return repeat_times(hash(value),size);
		}
		/*!
		Computes the hash value of an array of elements.

		@param a The array of elements.
		@param size The size of the array.

		@returns The hash value of the array.
		*/
		template<class T>
		[[nodiscard]]inline constexpr hash_value_t hash(const T*a,size_t size)const noexcept(nothrow<const T>){
			return with_calculated_before(hash(nothing),0,a,size);
		}
		/*!
		合并两个数据段的hash结果，好似计算这两个数据段合并后的hash结果一般

		@param before The first hash value.
		@param before_size The size of the first hash value.
		@param after The second hash value.
		@param after_size The size of the second hash value.

		@returns The merged hash value.
		*/
		[[nodiscard]]force_inline hash_value_t merge_array_hash_results(
			hash_value_t before,size_t before_size,hash_value_t after,[[maybe_unused]]size_t after_size
		)const noexcept{
			return{before._value^(rotl(after._value,before_size))};
		}
		/*!
		计算一个 array_like_view_t<T> 对象的哈希值。
		@param a array_like_view_t<T> 对象。

		@returns array_like_view_t<T> 对象的哈希值。
		*/
		template<class T> requires is_not_signal_value_for_array_like<T>
		[[nodiscard]]inline constexpr hash_value_t hash(const array_like_view_t<T>a)const noexcept(nothrow<T>){
			return hash(a.begin(),a.size());
		}
		/*!
		计算一个 array_like_view_t<T> 对象的哈希值，并在哈希值之前进行计算。

		@param before 用来作为计算基础的哈希值。
		@param before_size 用来作为计算基础的哈希值的大小。
		@param a 要计算哈希值的 array_like_view_t<T> 对象。

		@returns array_like_view_t<T> 对象的哈希值。
		*/
		template<class T> requires is_not_signal_value_for_array_like<T>
		[[nodiscard]]inline constexpr hash_value_t with_calculated_before(hash_value_t before,size_t before_size,const array_like_view_t<T>a)const noexcept{
			return with_calculated_before(before,before_size,a.begin(),a.size());
		}

		#undef hash

	}hash{};
}
typedef hash_n::hash_value_t hash_t;
typedef hash_n::unstable_hash_value_t unstable_hash_t;
using hash_n::is_unstable_hash;
using hash_n::is_fundamental_hash;
using hash_n::hash;

//file_end

#line 54 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/range.hpp"
//range.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/range.hpp"
namespace range_n{
	//  range_t
	/// 用以表示某类型的数值范围，仅可表示闭区间
	template<typename T>
	struct range_t{
		T _begin,_end;
		//_begin<=_end
		constexpr range_t(const T begin,const T end):_begin(begin),_end(end){}
		constexpr range_t(note::from_t<const T>begin,note::to_t<const T>end):_begin(begin),_end(end+1){}
		constexpr range_t(note::to_t<const T>end,note::from_t<const T>begin):_begin(begin),_end(end+1){}
		constexpr range_t(const T begin,note::size_t<const T>size):_begin(begin),_end(begin+size()){}
		constexpr range_t(const T begin,note::size_t<size_t>size):_begin(begin),_end(begin+size()){}

		constexpr size_t size()noexcept{return _end-_begin;}
		constexpr auto end()noexcept{return _end;}
		constexpr auto begin()noexcept{return _begin;}
		constexpr auto end()const noexcept{return _end;}
		constexpr auto begin()const noexcept{return _begin;}

		template <class U> requires(type_info<T>.can_convert_to<U>)
		constexpr operator range_t<U>()const noexcept(type_info<T>.can_nothrow_convert_to<U>){
			return{_begin,_end};
		}
	};

	template<class T>
	[[nodiscard]]inline auto size_of_array_like(range_t<T*>&a)noexcept{return a.size();}
	template<class T>
	[[nodiscard]]inline auto size_of_array_like(range_t<const T*>&a)noexcept{return a.size();}

	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(range_t<T*>&a)noexcept{return a.begin();}
	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(range_t<const T*>&a)noexcept{return a.begin();}

	//  in_range
	/// 判断一个值是否在某个范围内
	template<typename T>
	[[nodiscard]]constexpr bool in_range(T pattern,const range_t<T>range)noexcept_as(bool(declvalue(T)>=declvalue(const T) && declvalue(T)<=declvalue(const T))){//算术类型或指针
		return bool(pattern>=range.begin() && pattern<range.end());
	}
	//  in_range
	/// 判断一个指针是否在某个byte指针范围内
	template<typename T>
	[[nodiscard]]constexpr bool in_range(T*pattern,const range_t<byte*>range)noexcept{
		return cast_to_data(pattern)>=range.begin() && cast_to_data(pattern)<range.end();
	}
	//  match_pattern
	/// sunday算法表头，用以实施头起始的快速子串匹配算法
	/// 大部分情况下应当编译时预构建或对运行时生成的实例进行缓存
	template<typename T>
	struct match_pattern{
		array_like_view_t<T>_pattern;
		typedef unsigned char index_type;

		size_t skip_table[number_of_possible_values_per<index_type>]{};

		static constexpr index_type get_index_of(T&ch)noexcept{
			return index_type(hash(ch) % number_of_possible_values_per<index_type>);
		}
		constexpr void build_table(const array_like_view_t<T>&pattern)noexcept{
			const size_t m=pattern.size();
			if(!m)
				return;
			for(size_t i=0;i<number_of_possible_values_per<index_type>;i++)
				skip_table[i]=m+1;
			for(size_t i=0;i<m;i++)
				skip_table[get_index_of(pattern[i])]=m-i;
		}
		constexpr match_pattern(const array_like_view_t<T>&pattern)noexcept:_pattern(pattern){
			build_table(_pattern);
		}
		[[nodiscard]]constexpr T* match(const array_like_view_t<T>&range)const noexcept{
			size_t off_set=0;
			size_t matching_off_set=1;

			floop{
				matching_off_set=1;
				while(_pattern.end()[0-matching_off_set]==range.begin()[off_set+_pattern.size()-matching_off_set])
					if(matching_off_set==_pattern.size())
						return addressof(range.begin()[off_set]);
					else
						matching_off_set++;
				if(off_set+_pattern.size() >= range.size())
					return nullptr;
				off_set+=skip_table[get_index_of(range.begin()[off_set+_pattern.size()])];
			}
		}
	};
	//  reverse_match_pattern
	/// 反向Sunday算法表头，用以实施尾起始的快速子串匹配算法
	/// 大部分情况下应当编译时预构建或对运行时生成的实例进行缓存
	template<typename T>
	struct reverse_match_pattern{
		array_like_view_t<T>_pattern;
		typedef unsigned char index_type;

		size_t skip_table[number_of_possible_values_per<index_type>]{};

		static constexpr index_type get_index_of(T&ch)noexcept{
			return index_type(hash(ch) % number_of_possible_values_per<index_type>);
		}
		constexpr void build_table(const array_like_view_t<T>&pattern)noexcept{
			const size_t m=pattern.size();
			if(!m)
				return;
			for(size_t i=0;i<number_of_possible_values_per<index_type>;i++)
				skip_table[i]=m+1;
			for(size_t i=0;i<m-1;i++)
				skip_table[get_index_of(pattern[i])]=i;
		}
		constexpr reverse_match_pattern(const array_like_view_t<T>&pattern)noexcept:_pattern(pattern){
			build_table(_pattern);
		}
		[[nodiscard]]constexpr T* match(const array_like_view_t<T>&range)const noexcept{
			size_t off_set=0;
			size_t matching_off_set=0;

			floop{
				matching_off_set=0;
				while(_pattern.begin()[matching_off_set]==range.end()[0-(off_set+_pattern.size()-matching_off_set)])
					if(matching_off_set==_pattern.size()-1)
						return addressof(range.end()[0-(off_set+_pattern.size())]);
					else
						matching_off_set++;
				if(off_set+_pattern.size() >= range.size())
					return nullptr;
				off_set+=skip_table[get_index_of(range.end()[0-(off_set+_pattern.size()+1)])];
				off_set++;
			}
		}
	};
	push_and_disable_msvc_warning(26475);//强制转换警告diss
	//  npos
	/// 用以指定不存在的位置
	static constexpr size_t npos = size_t(-1);
	pop_msvc_warning();
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* in_range(const remove_cvref<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range){
			if(i==pattern)
				return addressof(i);
		}
		return nullptr;
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_size_t(const remove_cvref<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* in_range_but_reverse(const remove_cvref<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range|::std::views::reverse){
			if(i==pattern)
				return addressof(i);
		}
		return nullptr;
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_but_reverse_size_t(const remove_cvref<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range_but_reverse(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// 若成功找到匹配的数据串，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard,deprecated("cache match_pattern and don't waste it")]]
	constexpr T* in_range(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		match_pattern tmp=pattern;
		return tmp.match(range);
	}
	/// 若成功找到匹配的数据串，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	//  反向数据串匹配by steve02081504.
	/// 若成功找到匹配的数据串，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard,deprecated("cache match_pattern and don't waste it")]]
	constexpr T* in_range_but_reverse(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		reverse_match_pattern tmp = pattern;
		return tmp.match(range);
	}
	/// 若成功找到匹配的数据串，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_but_reverse_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range_but_reverse(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}

	//  bitmark_for_finds
	/// bitmark提供了一种快速进行四种泛搜索的实现，前提是构建中的pattern中的每一项的usigned表示都在一个字节（表长）内。
	/// 若bitmark构建失败，程序应当使用正在进行的泛搜索的朴素实现版本。
	template<typename T>
	struct bitmark_for_finds {
		typedef unsigned char index_type;
		bool _bitmark[number_of_possible_values_per<index_type>]{};

		bitmark_for_finds()noexcept=default;
		[[nodiscard]]constexpr bool mark(const array_like_view_t<T>&pattern)noexcept{
			if constexpr(number_of_possible_values_per<T> > number_of_possible_values_per<index_type>){
				for(auto& i: pattern){
					if(::std::make_unsigned_t<T>(i) >= number_of_possible_values_per<index_type>)
						return false;
					_bitmark[index_type(i)] = true;
				}
			}
			else{
				for(auto& i: pattern)
					_bitmark[index_type(i)] = true;
			}
			return true;
		}
		[[nodiscard]]constexpr bool operator[](T&index)const noexcept{
			if constexpr(number_of_possible_values_per<T> > number_of_possible_values_per<index_type>)
				if(::std::make_unsigned_t<T>(index) >= number_of_possible_values_per<index_type>)
					return false;
			return _bitmark[index_type(index)];
		}
	};
	/// find_first_of的bitmark实现
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_of_bitmark(const bitmark_for_finds<T>&mark,const array_like_view_t<T>&range){
		for(auto&i : range){
			if(mark[i])
				return addressof(i);
		}
		return nullptr;
	}
	/// find_first_of的朴素实现
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* base_find_first_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range){
			if(in_range(i,pattern))
				return addressof(i);
		}
		return nullptr;
	}
	//  find_first_of
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		if constexpr(::std::is_integral_v<T>){
			bitmark_for_finds<T> mark;
			if(mark.mark(pattern))
				return find_first_of_bitmark(mark,range);
		}
		return base_find_first_of(pattern,range);
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_first_of_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_first_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// find_last_of的bitmark实现
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_of_bitmark(const bitmark_for_finds<T>&mark,const array_like_view_t<T>&range){
		for(auto& i: range|::std::views::reverse){
			if(mark[i])
				return addressof(i);
		}
	}
	/// find_last_of的朴素实现
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* base_find_last_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range|::std::views::reverse){
			if(in_range(i,pattern))
				return addressof(i);
		}
		return nullptr;
	}
	//  find_last_of
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		if constexpr(::std::is_integral_v<T>){
			bitmark_for_finds<T> mark;
			if(mark.mark(pattern))
				return find_last_of_bitmark(mark,range);
		}
		return base_find_last_of(pattern,range);
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_last_of_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_last_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// find_first_not_of的bitmark实现
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_not_of_bitmark(const bitmark_for_finds<T>&mark,const array_like_view_t<T>&range){
		for(auto& i: range){
			if(!mark[i])
				return addressof(i);
		}
		return nullptr;
	}
	/// find_first_not_of的朴素实现
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* base_find_first_not_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range){
			if(!in_range(i,pattern))
				return addressof(i);
		}
		return nullptr;
	}
	//  find_first_not_of
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_not_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		if constexpr(::std::is_integral_v<T>){
			bitmark_for_finds<T> mark;
			if(mark.mark(pattern))
				return find_first_not_of_bitmark(mark,range);
		}
		return base_find_first_not_of(pattern,range);
	}
	/// 若成功找到不匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_first_not_of_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_first_not_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// find_last_not_of的bitmark实现
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of_bitmark(const bitmark_for_finds<T>&mark,const array_like_view_t<T>&range){
		for(auto& i: range|::std::views::reverse){
			if(!mark[i])
				return addressof(i);
		}
		return nullptr;
	}
	/// find_last_not_of的朴素实现
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* base_find_last_not_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range|::std::views::reverse){
			if(!in_range(i,pattern))
				return addressof(i);
		}
		return nullptr;
	}
	//  bitmark_for_quick_unindex
	/// bitmark提供了一种快速进行反索引的实现，前提是构建中的pattern中的每一项的usigned表示都在一个字节（表长）内。
	/// 若bitmark构建失败，程序应当使用正在进行的反索引的朴素实现版本。
	template<typename T>
	struct bitmark_for_quick_unindex {
		typedef unsigned char index_type;
		size_t _bitmark[number_of_possible_values_per<index_type>]{};

		constexpr void bitmark_data_initer(size_t init_to)noexcept{
			for(auto& i:_bitmark)
				i=init_to;
		}

		bitmark_for_quick_unindex()noexcept=default;
		[[nodiscard]]constexpr bool mark(const array_like_view_t<T>&pattern)noexcept{
			bitmark_data_initer(npos);
			#define failed bitmark_data_initer(npos),false
			if constexpr(number_of_possible_values_per<T> > number_of_possible_values_per<index_type>){
				size_t i=0;
				const size_t end=pattern.size();
				while(i<end){
					auto&ch=pattern[i];
					if(::std::make_unsigned_t<T>(ch) >= number_of_possible_values_per<index_type>)
						return failed;
					auto&index=_bitmark[index_type(ch)];
					if(index!=npos)
						return failed;
					index=i;
					i++;
				}
			}
			else{
				size_t i=0;
				const size_t end=pattern.size();
				while(i<end){
					auto&ch=pattern[i];
					auto&index=_bitmark[index_type(ch)];
					if(index!=npos)
						return failed;
					index=i;
					i++;
				}
			}
			#undef failed
			return true;
		}
		[[nodiscard]]constexpr size_t operator[](T&index)const noexcept{
			if constexpr(number_of_possible_values_per<T> > number_of_possible_values_per<index_type>)
				if(::std::make_unsigned_t<T>(index) >= number_of_possible_values_per<index_type>)
					return npos;
			return _bitmark[index_type(index)];
		}
	};
	//  find_last_not_of
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		if constexpr(::std::is_integral_v<T>){
			bitmark_for_finds<T> mark;
			if(mark.mark(pattern))
				return find_last_not_of_bitmark(mark,range);
		}
		return base_find_last_not_of(pattern,range);
	}
	/// 若成功找到不匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_last_not_of_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_last_not_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
}
using range_n::range_t;
using range_n::in_range;
using range_n::in_range_size_t;
using range_n::in_range_but_reverse;
using range_n::in_range_but_reverse_size_t;
using range_n::find_first_of;
using range_n::find_last_of;
using range_n::find_first_not_of;
using range_n::find_last_not_of;

//file_end

#line 55 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/string_view.hpp"
//string_view.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/string_view.hpp"
//仅是声明
namespace constexpr_str_n {
	template<typename char_T>
	struct constexpr_str_t;
}
using constexpr_str_n::constexpr_str_t;
//重载range操作
//仅是声明以及size_t包装
namespace range_n {
	template<typename T>
	[[nodiscard]]constexpr T* in_range(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* in_range_but_reverse(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_but_reverse_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range_but_reverse(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* find_first_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_first_of_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_first_of(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* find_last_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_last_of_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_last_of(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* find_first_not_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到不匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_first_not_of_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_first_not_of(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到不匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_last_not_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
}
//开始定义
namespace string_view_n{
	/// array_like_view_t的特化类型，表明这是字符串
	template<typename char_T>
	struct string_view_t:array_like_view_t<const char_T>{
		static constexpr size_t npos=range_n::npos;
		typedef array_like_view_t<const char_T> base_t;
		typedef char_T*string_ptr_t;
		typedef const char_T*const_string_ptr_t;
		//构造函数
		using base_t::base_t;
		constexpr string_view_t(const_string_ptr_t str)noexcept:string_view_t(array_end_by_zero_t<const char_T>(str)){}
		//成员函数
		[[nodiscard]]constexpr const char_T*str()const noexcept{return base_t::cbegin();}
		[[nodiscard]]constexpr const char_T*data()const noexcept{return base_t::cbegin();}
		[[nodiscard]]constexpr operator const char_T*()const noexcept{return str();}
		//substr
		[[nodiscard]]constexpr string_view_t substr(size_t pos,size_t len)const noexcept{
			return string_view_t(base_t::cbegin()+pos,len);
		}
		[[nodiscard]]constexpr string_view_t substr(size_t pos)const noexcept{
			return string_view_t(base_t::cbegin()+pos,base_t::size()-pos);
		}
		[[nodiscard]]constexpr string_view_t substr(size_t pos,const char_T*end)const noexcept{
			return string_view_t(base_t::cbegin()+pos,end-base_t::cbegin());
		}
		[[nodiscard]]constexpr string_view_t substr(const char_T*begin,size_t len)const noexcept{
			return string_view_t(begin,len);
		}
		[[nodiscard]]constexpr string_view_t substr(const char_T*begin)const noexcept{
			return string_view_t(begin,base_t::cend()-begin);
		}
		[[nodiscard]]constexpr string_view_t substr(const char_T*begin,const char_T*end)const noexcept{
			return string_view_t(begin,end-begin);
		}
		//find
		[[nodiscard]]constexpr size_t find(const char_T ch)const{
			return in_range_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t reverse_find(const char_T ch)const{
			return in_range_but_reverse_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t find(string_view_t str)const{
			return in_range_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t reverse_find(string_view_t str)const{
			return in_range_but_reverse_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find(const constexpr_str_t<char_T>&str)const{
			return in_range_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t reverse_find(const constexpr_str_t<char_T>&str)const{
			return in_range_but_reverse_size_t(str, *this);
		}
		//others by range_n::find_last_of_size_t etc
		[[nodiscard]]constexpr size_t find_first_of(const char_T ch)const{
			return range_n::find_first_of_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t find_last_of(const char_T ch)const{
			return range_n::find_last_of_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t find_first_not_of(const char_T ch)const{
			return range_n::find_first_not_of_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t find_last_not_of(const char_T ch)const{
			return range_n::find_last_not_of_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t find_first_of(string_view_t str)const{
			return range_n::find_first_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_last_of(string_view_t str)const{
			return range_n::find_last_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_first_not_of(string_view_t str)const{
			return range_n::find_first_not_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_last_not_of(string_view_t str)const{
			return range_n::find_last_not_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_first_of(const constexpr_str_t<char_T>&str)const{
			return range_n::find_first_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_last_of(const constexpr_str_t<char_T>&str)const{
			return range_n::find_last_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_first_not_of(const constexpr_str_t<char_T>&str)const{
			return range_n::find_first_not_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_last_not_of(const constexpr_str_t<char_T>&str)const{
			return range_n::find_last_not_of_size_t(str, *this);
		}
	};
	typedef string_view_t<char_t>string_view;
}
using string_view_n::string_view_t;
using string_view_n::string_view;

//file_end

#line 56 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/type_name.hpp"
//type_name.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/type_name.hpp"
struct type_name_t:string_view_t<char>{
	//对于gcc和clang，这个类型有一个malloced的char*，以便于在析构时释放
	//一切源于abi::__cxa_demangle
	//对于msvc，这个类型析构时不需要做任何事情
	typedef string_view_t<char> base_t;
	/// 重整器包装
	static base_t demangle(const char*original_name)noexcept{
		push_and_disable_msvc_warning(26494);//未初始化警告diss
		size_t len;
		const char*demangled_name;
		pop_msvc_warning();
		#if defined(__clang__)||defined(__GNUC__)
			//gcc和clang
			//使用abi::__cxa_demangle重整
			int status;
			demangled_name=::abi::__cxa_demangle(original_name,nullptr,&len,&status);
			if(status!=0){
				demangled_name=original_name;
				len=::std::strlen(original_name);
				::std::free((void*)demangled_name);
			}
		#else
			//msvc
			//不需要重整
			demangled_name=original_name;
			len=::std::strlen(original_name);
		#endif
		return base_t{demangled_name,len};
	}
	/// 复制重整结果
	static base_t copy_demangle(base_t demangled_name)noexcept{
		#if defined(__clang__)||defined(__GNUC__)
			//gcc和clang
			//需要复制重整结果（用malloced的char*）
			char*copyed_name=(char*)::std::malloc(demangled_name.size()+1);
			if(copyed_name==nullptr)
				return base_t{nullptr,0};
			::std::memcpy(copyed_name,demangled_name.data(),demangled_name.size());
			copyed_name[demangled_name.size()]='\0';
			return base_t{copyed_name,demangled_name.size()};
		#else
			//msvc
			//不需要复制重整结果
			return demangled_name;
		#endif
	}
	/// 构造函数
	type_name_t(const char*original_name)noexcept:base_t(demangle(original_name)){}
	/// 复制构造函数
	type_name_t(const type_name_t&other)noexcept:base_t(copy_demangle(other)){}
	/// 移动构造函数（swap）
	type_name_t(type_name_t&&other)noexcept:base_t(nullptr,0){
		swap_with(other);
	}
	/// 析构函数
	~type_name_t()noexcept{
		#if defined(__clang__)||defined(__GNUC__)
			//gcc和clang
			//需要释放malloced的char*
			::std::free((void*)begin());
		#endif
	}
};
[[nodiscard]]inline type_name_t base_type_info_t::get_name()const noexcept{
	return _tid.get_name();
}
[[nodiscard]]inline type_name_t base_type_info_t::type_id_t::get_name()const noexcept{
	return _m->name();
}
template<typename T>
[[nodiscard]]inline type_name_t type_info_t<T>::get_name()const noexcept{
	return base_type_info_t(*this).get_name();
}

//file_end

#line 57 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/constexpr_str.hpp"
//constexpr_str.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/constexpr_str.hpp"
namespace constexpr_str_n{
	/// constexpr_str_t的退化类型，表明这是常量字符串，但没有可用的额外信息
	template<typename char_T>
	struct constexpr_str_view_t:string_view_t<char_T>{
		typedef string_view_t<char_T> base_t;
		using base_t::base_t;
		using base_t::string_ptr_t;
		using base_t::const_string_ptr_t;
		constexpr_str_view_t(const_string_ptr_t str)noexcept=delete;
		//成员函数
		[[nodiscard]]constexpr const_string_ptr_t str()const noexcept{return base_t::cbegin();}
		[[nodiscard]]constexpr const_string_ptr_t data()const noexcept{return base_t::cbegin();}
		[[nodiscard]]constexpr operator const_string_ptr_t ()const noexcept{return str();}
		//substr
		[[nodiscard]]constexpr constexpr_str_view_t substr(size_t pos,size_t len)const noexcept{
			return base_t::substr(pos,len);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(size_t pos)const noexcept{
			return base_t::substr(pos);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(size_t pos,const char_T*end)const noexcept{
			return base_t::substr(pos,end);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(const char_T*begin,size_t len)const noexcept{
			return base_t::substr(begin,len);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(const char_T*begin)const noexcept{
			return base_t::substr(begin);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(const char_T*begin,const char_T*end)const noexcept{
			return base_t::substr(begin,end);
		}
	};
	/// 告知其他elc库接口这是编译时常量字符串，并提供编译时计算好的内容，包括但不限于hash、bmh头、bitmark等，用于加速库操作
	template<typename char_T>
	struct constexpr_str_t:constexpr_str_view_t<char_T>{
		typedef constexpr_str_view_t<char_T> base_t;
		typedef char_T*string_ptr_t;
		typedef const char_T*const_string_ptr_t;
		hash_t hash_result;
		range_n::match_pattern<const char_T> match_pattern;
		range_n::reverse_match_pattern<const char_T> reverse_match_pattern;
		range_n::bitmark_for_finds<const char_T> bitmark_for_finds;
		range_n::bitmark_for_quick_unindex<const char_T> bitmark_for_unindex;
		bool is_bitmark_workable;
		bool is_bitmark_for_unindex_workable=0;
		constexpr constexpr_str_t(const_string_ptr_t str, size_t size):
			base_t(str, size),
			hash_result(defs::hash(str, size)),
			match_pattern(array_like_view_t<const char_T>{str, size}),
			reverse_match_pattern(array_like_view_t<const char_T>{str, size}){
				is_bitmark_workable = bitmark_for_finds.mark(*this);
				if(is_bitmark_workable)
					is_bitmark_for_unindex_workable=bitmark_for_unindex.mark(*this);
			}
		constexpr constexpr_str_t(const_string_ptr_t str):constexpr_str_t(str,array_end_by_zero_t<char_T>::get_length_of(str)){}
		consteval constexpr_str_t(const constexpr_str_t&str)=default;
		[[nodiscard]]constexpr hash_t hash()const noexcept{return hash_result;}
	};
	using constexpr_str=constexpr_str_t<char_t>;
	template<class char_T,size_t N>
	struct constexpr_str_t_literal_helper{
		typedef char_T*string_ptr_t;
		typedef const char_T*const_string_ptr_t;
		const_string_ptr_t _array_begin;
		constexpr constexpr_str_t_literal_helper(const char_T(&str)[N])noexcept{
			_array_begin=str;
		}
		[[nodiscard]]constexpr auto get_constexpr_str_t()const noexcept{
			return constexpr_str_t{_array_begin,N-1};
		}
	};
	template<constexpr_str_t_literal_helper v>
	struct literal_result_provider {
		distinctive static constexpr auto value = v.get_constexpr_str_t();
	};
	//别问，问就是傻逼c++
	/// 告知其他elc库接口这是编译时常量字符串，并提供编译时计算好的内容，包括但不限于hash、bmh头、bitmark等，用于加速库操作
	template<constexpr_str_t_literal_helper str_helper>
	[[nodiscard]]inline consteval const auto& operator ""_constexpr_str()noexcept{
		return literal_result_provider<str_helper>::value;
	}
	/// 空字串常量且str或begin会指向一个0终止字符串（而不是nullptr），便于安全初始化
	template<class char_T>
	distinctive inline constexpr auto empty_constexpr_str_of = constexpr_str_t(&const_default_value_of<char_T>,0);
};
using constexpr_str_n::constexpr_str_view_t;
using constexpr_str_n::constexpr_str_t;
using constexpr_str_n::constexpr_str;
using constexpr_str_n::empty_constexpr_str_of;
using constexpr_str_n::operator ""_constexpr_str;

//重载range操作
namespace range_n {
	template<typename T>
	[[nodiscard]]constexpr T* in_range(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		return pattern.match_pattern.match(range);
	}
	template<typename T>
	[[nodiscard]]constexpr T* in_range_but_reverse(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		return pattern.reverse_match_pattern.match(range);
	}
	//find_first_of
	//若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		if(pattern.is_bitmark_workable)
			return find_first_of_bitmark(pattern.bitmark_for_finds,range);
		else
			return find_first_of((const constexpr_str_view_t<T>&)pattern,range);
	}
	//find_last_of
	//若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		if(pattern.is_bitmark_workable)
			return find_last_of_bitmark(pattern.bitmark_for_finds,range);
		else
			return find_last_of((const constexpr_str_view_t<T>&)pattern,range);
	}
	//find_first_not_of
	//若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_not_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		if(pattern.is_bitmark_workable)
			return find_first_not_of_bitmark(pattern.bitmark_for_finds,range);
		else
			return find_first_not_of((const constexpr_str_view_t<T>&)pattern,range);
	}
	//find_last_not_of
	//若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		if(pattern.is_bitmark_workable)
			return find_last_not_of_bitmark(pattern.bitmark_for_finds,range);
		else
			return find_last_not_of((const constexpr_str_view_t<T>&)pattern,range);
	}

	// 单字匹配相关

	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr const T* in_range(const remove_cvref<T>&pattern,const constexpr_str_t<T>&range){
		if(range.is_bitmark_for_unindex_workable){
			auto result = range.bitmark_for_unindex[pattern];
			return result==range_n::npos?nullptr:range.begin()+result;
		}
		else
			return in_range(pattern,(const constexpr_str_view_t<T>&)range);
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_size_t(const remove_cvref<T>&pattern,const constexpr_str_t<T>&range){
		if(range.is_bitmark_for_unindex_workable)
			return range.bitmark_for_unindex[pattern];
		else
			return in_range_size_t(pattern,(const constexpr_str_view_t<T>&)range);
	}
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr const T* in_range_but_reverse(const remove_cvref<T>&pattern,const constexpr_str_t<T>&range){
		if(range.is_bitmark_for_unindex_workable){
			auto result = range.bitmark_for_unindex[pattern];
			return result==range_n::npos?nullptr:range.begin()+result;
		}
		else
			return in_range_but_reverse(pattern,(const constexpr_str_view_t<T>&)range);
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_but_reverse_size_t(const remove_cvref<T>&pattern,const constexpr_str_t<T>&range){
		if(range.is_bitmark_for_unindex_workable)
			return range.bitmark_for_unindex[pattern];
		else
			return in_range_but_reverse_size_t(pattern,(const constexpr_str_view_t<T>&)range);
	}
};
using range_n::in_range;
using range_n::in_range_size_t;
using range_n::in_range_but_reverse;
using range_n::in_range_but_reverse_size_t;
using range_n::find_first_of;
using range_n::find_last_of;
using range_n::find_first_not_of;
using range_n::find_last_not_of;

//file_end

#line 58 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/logical_bool.hpp"
//logic.hpp
//at namespace elc::defs::base
#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/logical_bool.hpp"
/*! 混沌布尔值。
	允许输出介于真假之间的内容的布尔值。
	混沌布尔值会有五个可能的值，分别为true,false,neither,either。unknown视为不合法。
	用在if与while中时，true，either被判定为真，其与均为假。
	用法：
	logical_bool(bool)		输出logical_bool,将布尔值转换为混沌布尔值。
	bool(logical_bool)		输出bool，将混沌布尔值转化为布尔值。
	允许与或非运算：输出结果仍然为混沌布尔值,参与运算的值如果有unknown则均输出unknown.
	允许判定相等，输出结果为混沌布尔值,参与运算的值如果有unknown则均输出unknown，否则仅有true和false两个合法值。
*/
#line 47 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/logical_bool.hpp"
struct logical_bool{
private:
	[[no_unique_address]]bool _is_true;
	[[no_unique_address]]bool _is_false;
	[[no_unique_address]]bool _is_unknown;
public:
	constexpr logical_bool(special_init_t,bool is_true,bool is_false,bool is_unknown=0)noexcept:_is_true(is_true),_is_false(is_false),_is_unknown(is_unknown){}
	constexpr logical_bool(bool a)noexcept:_is_true(a),_is_false(!a),_is_unknown(0){}
	constexpr logical_bool(const logical_bool&)noexcept=default;
	constexpr logical_bool&operator=(const logical_bool&)&noexcept=default;
	constexpr explicit operator bool()const noexcept{return _is_true && !_is_unknown;}
	constexpr logical_bool operator!()const noexcept{
		logical_bool aret=*this;
		swap(aret._is_true,aret._is_false);
		return aret;
	}
	friend logical_bool operator&&(logical_bool a,logical_bool b)noexcept{
		return logical_bool{special_init,a._is_true && b._is_true,a._is_false || b._is_false,a._is_unknown || b._is_unknown};
	}
	friend logical_bool operator||(logical_bool a,logical_bool b)noexcept{
		return logical_bool{special_init,a._is_true || b._is_true,a._is_false && b._is_false,a._is_unknown || b._is_unknown};
	}
	friend logical_bool operator==(logical_bool a,logical_bool b)noexcept{
		logical_bool aret(a._is_true == b._is_true && a._is_false == b._is_false);
		aret._is_unknown = a._is_unknown || b._is_unknown;
		return aret;
	}
};
constexpr logical_bool neither{special_init,0,0},either{special_init,1,1},unknown{special_init,0,0,1};

//file_end

#line 59 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/zero.hpp"
//zero.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/zero.hpp"
/*!
没什么用的语法糖,等价于字面量0.
*/
constexpr struct zero_t{
	template<class T> requires(type_info<decltype(0)>.can_convert_to<T>)
	operator T()const noexcept(type_info<decltype(0)>.can_nothrow_convert_to<T>){return 0;}
}zero{};

/*!
Returns true if all bytes in the input are zero.

@param a The input value.

@returns True if all bytes in the input are zero.
*/
template<class T>
inline constexpr bool is_all_byte_zero(T&&a)noexcept{
	const byte*ptr=cast_to_data(addressof(a));
	const byte*end=ptr+sizeof(a);
	while(ptr!=end)
		if((unsigned char)(*ptr++))
			return false;
	return true;
}

//file_end

#line 60 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/count_able.hpp"
//count_able.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/count_able.hpp"
template<class T>
[[nodiscard]]inline size_t the_number_of(type_info_t<T>)noexcept;
template<class T>
struct count_able:is_common_attribute(count_able){
private:
	friend size_t the_number_of<T>(type_info_t<T>)noexcept;
	static size_t _number;
public:
	count_able()noexcept{_number++;}
	~count_able()noexcept{_number--;}
};
template<class T>
[[nodiscard]]inline size_t the_number_of(type_info_t<T>)noexcept{
	if constexpr(type_info<T>.not_has_attribute(count_able))
		template_error("hey.");
	return count_able<T>::_number;
}

//file_end

#line 61 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/invoke.hpp"
//invoke.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/invoke.hpp"
template<typename T>
struct invoke_t{
	/*!
	Determines if a type is invocable.

	@tparam T The type to check.
	@tparam Args The types of the arguments to the type.

	@returns True if the type is invocable, false otherwise.
	*/
	template<class...Args>
	static constexpr bool able= ::std::is_invocable_v<T,Args...>;
	/*!
	Determines if a type is invocable and nothrow.

	@tparam T The type to check.
	@tparam Args The types of the arguments to the type.

	@returns True if the type is nothrow invocable, false otherwise.
	*/
	template<class...Args>
	static constexpr bool nothrow= ::std::is_nothrow_invocable_v<T,Args...>;

	//和期待类型
	template<class Ret_t>
	struct with_return_type_t{
		template<class...Args>
		static constexpr bool able= ::std::is_invocable_r_v<Ret_t,T,Args...>;
		template<class...Args>
		static constexpr bool nothrow= ::std::is_nothrow_invocable_r_v<Ret_t,T,Args...>;

		/*!
		A function that returns a lambda that applies a function to a value.

		@param rest The arguments to the function.

		@returns A lambda that applies the function to a value.
		*/
		template<class...Args> requires able<Args...>
		decltype(auto)_as(Args&&...rest)const noexcept(nothrow<Args...>){//invoke<T>.with_return_type<Ret_t>._as(...)
			return lambda_with_catch(rest...)(const T&a)noexcept(nothrow<Args...>){return a(forward<Args>(rest)...);};
		}
	};
	template<class Ret_t>
	static constexpr with_return_type_t<Ret_t>with_return_type{};

	/*!
	A function that returns a lambda that applies a function to a value.

	@param rest The arguments to the function.

	@returns A lambda that applies the function to a value.
	*/
	template<class...Args> requires able<Args...>
	decltype(auto)_as(Args&&...rest)const noexcept(nothrow<Args...>){//invoke<T>._as(...)
		return lambda_with_catch(rest...)(const T&a)noexcept(nothrow<Args...>){return a(forward<Args>(rest)...);};
	}
};
template<typename T>
constexpr invoke_t<T>invoke{};

//file_end

#line 62 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/maybe_fail_reference.hpp"
//maybe_fail_reference.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/maybe_fail_reference.hpp"
template<typename T>
class maybe_fail_reference{
	T*_ref_to;
public:
	constexpr maybe_fail_reference(T&a)noexcept:_ref_to(&a){}
	constexpr maybe_fail_reference(const maybe_fail_reference&)=default;
	constexpr maybe_fail_reference(note::fail_t)noexcept:_ref_to(nullptr){}

	[[nodiscard]]bool not_fail()noexcept{return _ref_to;}
	[[nodiscard]]bool fail()noexcept{return!not_fail();}
	T&get_ref()noexcept{return*_ref_to;}
};

//file_end

#line 63 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"

//file_end

		#line 53 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
	}

	//由于vcruntime的type_info在全局定义,这里需要额外声明使用base::type_info.
	#if defined(_VCRUNTIME_H)
		using base::type_info;
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 61 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
}

//file_end

	#line 50 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#endif

//file_end

	#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
	#include <cstring>//memcpy、memmove
	#include <atomic>//atomic
	#if defined(ELC_TEST_ON)
		#include <ctime>//time
	#endif
	#define ELC_BASE
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
//_body.hpp
//at namespace ::
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
#if defined(ELC_TEST)//若已包含elc/test则报错：其应在此文件后被包含
	#error "this part cannot be tested."
#endif

//include APIs：elc中可能根据编译环境而修改的底层函数
//using at memory/alloc
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"
//alloc.hpp
#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"
#if !defined(ELC_APIS_alloc)
	#define ELC_APIS_alloc
	#if defined(ELC_MEMORY_ALLOC_LOCATION_RECORD)
		#include <stacktrace>//for operate_source_location
	#endif
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/decl_system_type.hpp"
//decl_system_type.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/decl_system_type.hpp"
//copy&rewrite from steve02081504/steve.h
#define linux 2
#define windows 3
#define other 4
#if defined(__linux)||defined(__linux__)||defined(__gnu_linux__)
	#define SYSTEM_TYPE linux
#elif defined(_WIN32)||defined(__MINGW32__)||defined(__CYGWIN__)
	#define SYSTEM_TYPE windows
#else
	#define SYSTEM_TYPE other
#endif
#define ERROR_MSG_UNABLE_OS "Unable OS,edit this file on your own or contact ELC's producers."

//file_end

	#line 40 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"
	#if SYSTEM_TYPE == windows
		#if defined(_DEBUG)
			#include <crtdbg.h>
		#else
			#include <malloc.h>
		#endif
	#else
		#include <cstdlib>
	#endif
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
//base_defs
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#line 51 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"

//file_end

	#line 50 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"
	/// @brief alloc相关基础函数
	namespace elc::APIs::alloc{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

		#line 53 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"

		using namespace ::elc::defs;//remove_const||byte
		#if SYSTEM_TYPE != windows
			//overhead
			#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc/default_method/overhead.hpp"
//overhead.hpp
//at namespace elc::APIs::alloc
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc/default_method/overhead.hpp"
namespace overhead_n{
	using namespace ::elc::defs;
	constexpr size_t overhead_get_align(size_t align)noexcept{
		return max(align,alignof(size_t));//保证最高对齐需求
	}
	constexpr size_t overhead_get_offset_value(size_t align)noexcept{
		align=overhead_get_align(align);
		return (size_t(sizeof(size_t)/align)+bool(sizeof(size_t)%align))*align;//等同于sizeof(size_t)-sizeof(size_t)%align+(sizeof(size_t)%align?align:0)
		//暨，偏移量既要大于sizeof(size_t)以装下overhead，又要是align的整数倍以保证T实例的对齐被满足
	}
	constexpr size_t correct_size(size_t size,size_t align)noexcept{
		return size+overhead_get_offset_value(align);
	}
	constexpr size_t correct_align(size_t align)noexcept{
		return overhead_get_align(align);
	}
	inline pointer correct_pointer(pointer a,size_t align){
		return apply_off_set(a,overhead_get_offset_value(align));
	}
	inline pointer recorrect_pointer(pointer a,size_t align){
		return unapply_off_set(a,overhead_get_offset_value(align));
	}
	inline const_pointer recorrect_pointer(const_pointer a, size_t align){
		return unapply_off_set(a,overhead_get_offset_value(align));
	}
	inline void set_overhead(pointer a,size_t size){
		*reinterpret_cast<size_t*>(a)=size;
	}
	inline size_t get_overhead(const_pointer a){
		return*reinterpret_cast<const size_t*>(a);
	}
}

//file_end

			#line 57 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"
		#endif
		//operate_source_location & source_location_guard
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc/debug_info/source_location_guard.hpp"
//source_location_guard.hpp
//at namespace elc::APIs::alloc
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc/debug_info/source_location_guard.hpp"
#if defined(_MSC_VER)
	#if defined(ELC_MEMORY_ALLOC_LOCATION_RECORD)
		#pragma detect_mismatch("ELC_MEMORY_ALLOC_LOCATION_RECORD","true")
	#else
		#pragma detect_mismatch("ELC_MEMORY_ALLOC_LOCATION_RECORD","false")
	#endif
#endif
#if defined(ELC_MEMORY_ALLOC_LOCATION_RECORD)
	distinctive inline ::std::stacktrace_entry operate_source_frame;
	distinctive inline struct source_location_info_t{
		const char*_file=nullptr;
		uint_least32_t _line=0;
		const char*file()noexcept{
			if(!_file){
				try{
					static ::std::string file_cache;
					file_cache=operate_source_frame.source_file();
					_file=file_cache.c_str();
				}
				catch(...){
				}
			}
			return _file;
		}
		uint_least32_t line()noexcept{
			if(!_line){
				try{
					_line=operate_source_frame.source_line();
				}
				catch(...){
				}
			}
			return _line;
		}
		void clear()noexcept{
			_file=nullptr;
			_line=0;
		}
	}operate_source_location;
	struct source_location_guard{
		bool _is_set=false;
		source_location_guard(size_t lookup=0)noexcept{
			if(!operate_source_frame){
				::std::stacktrace stack = ::std::stacktrace::current(/*skip*/lookup+2,/*max_depth*/1);
				if(stack.size()){
					operate_source_frame = stack[0];
					_is_set				 = true;
				}
			}
		}
		~source_location_guard()noexcept{
			if(_is_set){
				operate_source_frame = ::std::stacktrace_entry{};
				operate_source_location.clear();
			}
		}
	};
#else
	struct source_location_guard{
		constexpr source_location_guard([[maybe_unused]]size_t lookup=0)noexcept{}
	};
	distinctive inline struct source_location_info_t{
		constexpr const char*file()noexcept{return nullptr;}
		constexpr uint_least32_t line()noexcept{return 0;}
	}operate_source_location;
#endif

//file_end

		#line 59 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"

		//BLOCK: Counting memory allocations
		#if defined(_MSC_VER)
			#if defined(ELC_TEST_COUNT_MEMORY_ALLOC)
				#pragma detect_mismatch("ELC_TEST_COUNT_MEMORY_ALLOC","true")
			#else
				#pragma detect_mismatch("ELC_TEST_COUNT_MEMORY_ALLOC","false")
			#endif
		#endif

		#if defined(ELC_TEST_COUNT_MEMORY_ALLOC)
			[[nodiscard]]inline size_t get_size_of_alloc(const byte*p,size_t align)noexcept;
			namespace count_info{
				distinctive inline size_t alloc_count=0;
				distinctive inline size_t free_count=0;
				distinctive inline size_t alloc_size=0;
				distinctive inline size_t free_size=0;
				distinctive inline size_t memory_using=0;
				distinctive inline size_t memory_using_max=0;
				inline void update_memory_using(ptrdiff_t diff)noexcept{
					memory_using+=diff;
					if(memory_using>memory_using_max)
						memory_using_max=memory_using;
				}
				inline void clear()noexcept{
					alloc_count=0;
					free_count=0;
					alloc_size=0;
					free_size=0;
					memory_using=0;
					memory_using_max=0;
				}
			}
		#endif
		//BLOCK_END

		#if defined(ELC_MEMORY_ALLOC_LOCATION_RECORD) && defined(ELC_SPEED_TEST)
			#error "ELC_MEMORY_ALLOC_LOCATION_RECORD and ELC_SPEED_TEST can't be defined at the same time."
		#endif

		inline constexpr bool use_debug_alloc_lib=
			#if defined(_DEBUG) && !defined(ELC_SPEED_TEST)
				true
			#else
				false
			#endif
		;

		/*!
		aligned_alloc 内存分配函数，需提供对齐需求
		return空指针被允许
		size被保证不为0
		*/
		[[nodiscard]]inline byte*aligned_alloc(size_t align,size_t size)noexcept{
			push_and_disable_msvc_warning(26494);//未初始化警告diss
			void* aret;//返回值放这里
			pop_msvc_warning();

			#if SYSTEM_TYPE == windows
				if constexpr(use_debug_alloc_lib)
					aret = _aligned_malloc_dbg(size,align,operate_source_location.file(),operate_source_location.line());
				else
					aret = _aligned_malloc(size,align);
			#else
				using namespace overhead_n;
				void*tmp=::std::aligned_alloc(correct_align(align),correct_size(size,align));
				if(tmp){
					set_overhead(tmp,size);
					aret = correct_pointer(tmp,align);
				}
				else
					aret = nullptr;
			#endif

			#if defined(ELC_TEST_COUNT_MEMORY_ALLOC)
				if(aret){
					count_info::alloc_count++;
					count_info::alloc_size+=size;
					count_info::update_memory_using(size);
				}
			#endif

			return(byte*)aret;
		}
		/*!
		realloc 重新规划分配的大小
		return空指针被允许，但ptr值必须保持有效以保证gc后再次realloc有效
		new_size被保证不为0
		align维持不变
		但只允许在扩大数据块时可选的移动数据块
		*/
		[[nodiscard]]inline byte*realloc(byte*ptr,size_t nsize,[[maybe_unused]]size_t align)noexcept{
			#if defined(ELC_TEST_COUNT_MEMORY_ALLOC)
				const auto osize=get_size_of_alloc(ptr,align);
			#endif
			push_and_disable_msvc_warning(26494);//未初始化警告diss
			void* aret;//返回值放这里
			pop_msvc_warning();

			#if SYSTEM_TYPE == windows
				if constexpr(use_debug_alloc_lib)
					aret = _aligned_realloc_dbg(ptr,nsize,align,operate_source_location.file(),operate_source_location.line());
				else
					aret = _aligned_realloc(ptr,nsize,align);
			#else
				using namespace overhead_n;
				void*tmp=::std::realloc(recorrect_pointer(ptr,align),correct_size(nsize,align));
				if(tmp){
					set_overhead(tmp,nsize);
					aret = correct_pointer(tmp,align);
				}
				else
					aret = nullptr;
			#endif

			#if defined(ELC_TEST_COUNT_MEMORY_ALLOC)
				if(aret){
					count_info::alloc_size+=nsize-osize;
					count_info::update_memory_using(nsize-osize);
				}
			#endif

			return(byte*)aret;
		}
		/*!
		free 释放所分配的内存
		传入需获取大小的数据块起始点与对齐
		*/
		inline void free(byte*p,[[maybe_unused]]size_t align)noexcept{
			#if defined(ELC_TEST_COUNT_MEMORY_ALLOC)
				const auto size=get_size_of_alloc(p,align);
				count_info::free_count++;
				count_info::free_size+=size;
				count_info::update_memory_using(-ptrdiff_t(size));
			#endif

			#if SYSTEM_TYPE == windows
				if constexpr(use_debug_alloc_lib)
					_aligned_free_dbg(p);
				else
					_aligned_free(p);
			#else
				using namespace overhead_n;
				::std::free(recorrect_pointer(p,align));
			#endif
		}
		/*!
		get_size_of_alloc 获取数据块的大小
		传入需获取大小的数据块起始点与对齐
		*/
		[[nodiscard]]inline size_t get_size_of_alloc(const byte*p,[[maybe_unused]]size_t align)noexcept{
			#if SYSTEM_TYPE == windows
				if constexpr(use_debug_alloc_lib)
					return _aligned_msize_dbg(remove_const(p),align,0);
				else
					return _aligned_msize(remove_const(p),align,0);
			#else
				using namespace overhead_n;
				return get_overhead(recorrect_pointer(p,align));
			#endif
		}

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

		#line 222 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"
	}
	//
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/undef_decl_system_type.hpp"
//undef_decl_system_type.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/undef_decl_system_type.hpp"
//copy&rewrite from steve02081504/evest.h
#undef linux
#undef windows
#undef other
#undef SYSTEM_TYPE
#undef ERROR_MSG_UNABLE_OS

//file_end

	#line 225 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"
#endif

//file_end

#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
//using at memory/gc
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"
//die.hpp
#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"
#if !defined(ELC_APIS_die)
	#define ELC_APIS_die
	#include <cuchar>
	#include <clocale>
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
//default_data_type.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
namespace elc{
	/*ELC内部string统一采用char_t宽字符，使用setlocale(LC_ALL,"en_US.utf8")下的UTF编码。*/
	typedef char32_t char_t;
	/*c_string表示*/
	typedef char_t* string_ptr_t;
	/*c_string表示*/
	typedef const char_t* const_string_ptr_t;
	/*ELC内部钦定int_t类型*/
	typedef int64_t int_t;
	/*ELC内部钦定uint_t类型*/
	typedef uint64_t uint_t;
	/*ELC内部钦定float_t类型*/
	typedef double float_t;
	/*ELC内部钦定float_size_t类型，用以描述内存大小的浮点状况*/
	typedef long double float_size_t;
}

//file_end

	#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/_body.hpp"
//_body.hpp
#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/_body.hpp"
#if !defined(ELC_APIS_char_set)
	#define ELC_APIS_char_set
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
//base_defs
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#line 51 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"

//file_end

	#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/_body.hpp"
	/// @brief 文字编码相关函数
	namespace elc::char_set{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

		#line 40 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/_body.hpp"

		using namespace ::elc::defs;//string_view_t

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/marcos/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/marcos/_defs.hpp"
#define U_MASK(x) ((uint32_t)1<<(x))

#define GET_CATEGORY(props) ((props)&0x1f)

#define CAT_MASK(props) U_MASK(GET_CATEGORY(props))

#define _UTRIE_INDEX_FROM_SUPP(trieIndex, c) \
	(((int32_t)((trieIndex)[\
		(trieIndex)[(UTRIE_INDEX_1_OFFSET-UTRIE_OMITTED_BMP_INDEX_1_LENGTH)+\
					((c)>>UTRIE_SHIFT_1)]+\
		(((c)>>UTRIE_SHIFT_2)&UTRIE_INDEX_2_MASK)])\
	<<UTRIE_INDEX_SHIFT)+\
	((c)&UTRIE_DATA_MASK))

#define _UTRIE_INDEX_RAW(offset, trieIndex, c) \
	(((int32_t)((trieIndex)[(offset)+((c)>>UTRIE_SHIFT_2)])\
	<<UTRIE_INDEX_SHIFT)+\
	((c)&UTRIE_DATA_MASK))

#define _UTRIE_INDEX_FROM_CP(trie, asciiOffset, c) \
	((uint32_t)(c)<0xd800 ?\
		_UTRIE_INDEX_RAW(0, (trie)->index, c) :\
		(uint32_t)(c)<=0xffff ?\
			_UTRIE_INDEX_RAW(\
				(c)<=0xdbff ? UTRIE_LSCP_INDEX_2_OFFSET-(0xd800>>UTRIE_SHIFT_2) : 0,\
				(trie)->index, c) :\
			(uint32_t)(c)>0x10ffff ?\
				(asciiOffset)+UTRIE_BAD_UTF8_DATA_OFFSET :\
				(c)>=(trie)->highStart ?\
					(trie)->highValueIndex :\
					_UTRIE_INDEX_FROM_SUPP((trie)->index, c))

#define _UTRIE_GET(trie, data, asciiOffset, c) (trie)->data[_UTRIE_INDEX_FROM_CP(trie, asciiOffset, c)]

#define UTRIE_GET16(trie, c) _UTRIE_GET((trie), index, (trie)->indexLength, (c))

#define GET_PROPS(c) (UTRIE_GET16(&propstrie, c))

//file_end

		#line 44 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/constexprs.hpp"
//constexprs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/constexprs.hpp"
inline namespace constexprs{
	inline namespace offsets{
		/** Shift size for getting the index-1 table offset. */
		inline constexpr auto UTRIE_SHIFT_1=6+5;

		/** Shift size for getting the index-2 table offset. */
		inline constexpr auto UTRIE_SHIFT_2=5;

		/**
		 * Difference between the two shift sizes,
		 * for getting an index-1 offset from an index-2 offset. 6=11-5
		 */
		inline constexpr auto UTRIE_SHIFT_1_2=UTRIE_SHIFT_1-UTRIE_SHIFT_2;

		/**
		 * Number of index-1 entries for the BMP. 32=0x20
		 * This part of the index-1 table is omitted from the serialized form.
		 */
		inline constexpr auto UTRIE_OMITTED_BMP_INDEX_1_LENGTH=0x10000>>UTRIE_SHIFT_1;

		/** Number of code points per index-1 table entry. 2048=0x800 */
		inline constexpr auto UTRIE_CP_PER_INDEX_1_ENTRY=1<<UTRIE_SHIFT_1;

		/** Number of entries in an index-2 block. 64=0x40 */
		inline constexpr auto UTRIE_INDEX_2_BLOCK_LENGTH=1<<UTRIE_SHIFT_1_2;

		/** Mask for getting the lower bits for the in-index-2-block offset. */
		inline constexpr auto UTRIE_INDEX_2_MASK=UTRIE_INDEX_2_BLOCK_LENGTH-1;

		/** Number of entries in a data block. 32=0x20 */
		inline constexpr auto UTRIE_DATA_BLOCK_LENGTH=1<<UTRIE_SHIFT_2;

		/** Mask for getting the lower bits for the in-data-block offset. */
		inline constexpr auto UTRIE_DATA_MASK=UTRIE_DATA_BLOCK_LENGTH-1;

		/**
		 * Shift size for shifting left the index array values.
		 * Increases possible data size with 16-bit index values at the cost
		 * of compactability.
		 * This requires data blocks to be aligned by UTRIE_DATA_GRANULARITY.
		 */
		inline constexpr auto UTRIE_INDEX_SHIFT=2;

		/** The alignment size of a data block. Also the granularity for compaction. */
		inline constexpr auto UTRIE_DATA_GRANULARITY=1<<UTRIE_INDEX_SHIFT;

		/* Fixed layout of the first part of the index array. ------------------- */

		/**
		 * The BMP part of the index-2 table is fixed and linear and starts at offset 0.
		 * Length=2048=0x800=0x10000>>UTRIE_SHIFT_2.
		 */
		inline constexpr auto UTRIE_INDEX_2_OFFSET=0;

		/**
		 * The part of the index-2 table for U+D800..U+DBFF stores values for
		 * lead surrogate code _units_ not code _points_.
		 * Values for lead surrogate code _points_ are indexed with this portion of the table.
		 * Length=32=0x20=0x400>>UTRIE_SHIFT_2. (There are 1024=0x400 lead surrogates.)
		 */
		inline constexpr auto UTRIE_LSCP_INDEX_2_OFFSET=0x10000>>UTRIE_SHIFT_2;
		inline constexpr auto UTRIE_LSCP_INDEX_2_LENGTH=0x400>>UTRIE_SHIFT_2;

		/** Count the lengths of both BMP pieces. 2080=0x820 */
		inline constexpr auto UTRIE_INDEX_2_BMP_LENGTH=UTRIE_LSCP_INDEX_2_OFFSET+UTRIE_LSCP_INDEX_2_LENGTH;

		/**
		 * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
		 * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE_SHIFT_2.
		 */
		inline constexpr auto UTRIE_UTF8_2B_INDEX_2_OFFSET=UTRIE_INDEX_2_BMP_LENGTH;
		inline constexpr auto UTRIE_UTF8_2B_INDEX_2_LENGTH=0x800>>6;  /* U+0800 is the first code point after 2-byte UTF-8 */

		/**
		 * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
		 * Variable length, for code points up to highStart, where the last single-value range starts.
		 * Maximum length 512=0x200=0x100000>>UTRIE_SHIFT_1.
		 * (For 0x100000 supplementary code points U+10000..U+10ffff.)
		 *
		 * The part of the index-2 table for supplementary code points starts
		 * after this index-1 table.
		 *
		 * Both the index-1 table and the following part of the index-2 table
		 * are omitted completely if there is only BMP data.
		 */
		inline constexpr auto UTRIE_INDEX_1_OFFSET=UTRIE_UTF8_2B_INDEX_2_OFFSET+UTRIE_UTF8_2B_INDEX_2_LENGTH;
		inline constexpr auto UTRIE_MAX_INDEX_1_LENGTH=0x100000>>UTRIE_SHIFT_1;

		#line 123 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/constexprs.hpp"
		/**
		 * The illegal-UTF-8 data block follows the ASCII block, at offset 128=0x80.
		 * Used with linear access for single bytes 0..0xbf for simple error handling.
		 * Length 64=0x40, not UTRIE_DATA_BLOCK_LENGTH.
		 */
		inline constexpr auto UTRIE_BAD_UTF8_DATA_OFFSET=0x80;

		/** The start of non-linear-ASCII data blocks, at offset 192=0xc0. */
		inline constexpr auto UTRIE_DATA_START_OFFSET=0xc0;
	}
	inline namespace categorys{
		/** Non-category for unassigned and non-character code points. @stable ICU 2.0 */
		inline constexpr auto U_UNASSIGNED = 0;
		/** Cn "Other, Not Assigned (no characters in [UnicodeData.txt] have this property)" (same as U_UNASSIGNED!) @stable ICU 2.0 */
		inline constexpr auto U_GENERAL_OTHER_TYPES = 0;
		/** Lu @stable ICU 2.0 */
		inline constexpr auto U_UPPERCASE_LETTER = 1;
		/** Ll @stable ICU 2.0 */
		inline constexpr auto U_LOWERCASE_LETTER = 2;
		/** Lt @stable ICU 2.0 */
		inline constexpr auto U_TITLECASE_LETTER = 3;
		/** Lm @stable ICU 2.0 */
		inline constexpr auto U_MODIFIER_LETTER = 4;
		/** Lo @stable ICU 2.0 */
		inline constexpr auto U_OTHER_LETTER = 5;
		/** Mn @stable ICU 2.0 */
		inline constexpr auto U_NON_SPACING_MARK = 6;
		/** Me @stable ICU 2.0 */
		inline constexpr auto U_ENCLOSING_MARK = 7;
		/** Mc @stable ICU 2.0 */
		inline constexpr auto U_COMBINING_SPACING_MARK = 8;
		/** Nd @stable ICU 2.0 */
		inline constexpr auto U_DECIMAL_DIGIT_NUMBER = 9;
		/** Nl @stable ICU 2.0 */
		inline constexpr auto U_LETTER_NUMBER = 10;
		/** No @stable ICU 2.0 */
		inline constexpr auto U_OTHER_NUMBER = 11;
		/** Zs @stable ICU 2.0 */
		inline constexpr auto U_SPACE_SEPARATOR = 12;
		/** Zl @stable ICU 2.0 */
		inline constexpr auto U_LINE_SEPARATOR = 13;
		/** Zp @stable ICU 2.0 */
		inline constexpr auto U_PARAGRAPH_SEPARATOR = 14;
		/** Cc @stable ICU 2.0 */
		inline constexpr auto U_CONTROL_CHAR = 15;
		/** Cf @stable ICU 2.0 */
		inline constexpr auto U_FORMAT_CHAR = 16;
		/** Co @stable ICU 2.0 */
		inline constexpr auto U_PRIVATE_USE_CHAR = 17;
		/** Cs @stable ICU 2.0 */
		inline constexpr auto U_SURROGATE = 18;
		/** Pd @stable ICU 2.0 */
		inline constexpr auto U_DASH_PUNCTUATION = 19;
		/** Ps @stable ICU 2.0 */
		inline constexpr auto U_START_PUNCTUATION = 20;
		/** Pe @stable ICU 2.0 */
		inline constexpr auto U_END_PUNCTUATION = 21;
		/** Pc @stable ICU 2.0 */
		inline constexpr auto U_CONNECTOR_PUNCTUATION = 22;
		/** Po @stable ICU 2.0 */
		inline constexpr auto U_OTHER_PUNCTUATION = 23;
		/** Sm @stable ICU 2.0 */
		inline constexpr auto U_MATH_SYMBOL = 24;
		/** Sc @stable ICU 2.0 */
		inline constexpr auto U_CURRENCY_SYMBOL = 25;
		/** Sk @stable ICU 2.0 */
		inline constexpr auto U_MODIFIER_SYMBOL = 26;
		/** So @stable ICU 2.0 */
		inline constexpr auto U_OTHER_SYMBOL = 27;
		/** Pi @stable ICU 2.0 */
		inline constexpr auto U_INITIAL_PUNCTUATION = 28;
		/** Pf @stable ICU 2.0 */
		inline constexpr auto U_FINAL_PUNCTUATION = 29;
	}
	inline namespace masks{
		inline constexpr auto U_GC_CN_MASK = U_MASK(U_GENERAL_OTHER_TYPES);

		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_LU_MASK = U_MASK(U_UPPERCASE_LETTER);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_LL_MASK = U_MASK(U_LOWERCASE_LETTER);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_LT_MASK = U_MASK(U_TITLECASE_LETTER);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_LM_MASK = U_MASK(U_MODIFIER_LETTER);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_LO_MASK = U_MASK(U_OTHER_LETTER);

		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_MN_MASK = U_MASK(U_NON_SPACING_MARK);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_ME_MASK = U_MASK(U_ENCLOSING_MARK);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_MC_MASK = U_MASK(U_COMBINING_SPACING_MARK);

		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_ND_MASK = U_MASK(U_DECIMAL_DIGIT_NUMBER);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_NL_MASK = U_MASK(U_LETTER_NUMBER);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_NO_MASK = U_MASK(U_OTHER_NUMBER);

		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_ZS_MASK = U_MASK(U_SPACE_SEPARATOR);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_ZL_MASK = U_MASK(U_LINE_SEPARATOR);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_ZP_MASK = U_MASK(U_PARAGRAPH_SEPARATOR);

		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_CC_MASK = U_MASK(U_CONTROL_CHAR);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_CF_MASK = U_MASK(U_FORMAT_CHAR);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_CO_MASK = U_MASK(U_PRIVATE_USE_CHAR);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_CS_MASK = U_MASK(U_SURROGATE);

		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_PD_MASK = U_MASK(U_DASH_PUNCTUATION);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_PS_MASK = U_MASK(U_START_PUNCTUATION);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_PE_MASK = U_MASK(U_END_PUNCTUATION);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_PC_MASK = U_MASK(U_CONNECTOR_PUNCTUATION);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_PO_MASK = U_MASK(U_OTHER_PUNCTUATION);

		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_SM_MASK = U_MASK(U_MATH_SYMBOL);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_SC_MASK = U_MASK(U_CURRENCY_SYMBOL);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_SK_MASK = U_MASK(U_MODIFIER_SYMBOL);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_SO_MASK = U_MASK(U_OTHER_SYMBOL);

		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_PI_MASK = U_MASK(U_INITIAL_PUNCTUATION);
		/** Mask constant for a UCharCategory. @stable ICU 2.1 */
		inline constexpr auto U_GC_PF_MASK = U_MASK(U_FINAL_PUNCTUATION);


		/** Mask constant for multiple UCharCategory bits (L Letters). @stable ICU 2.1 */
		inline constexpr auto U_GC_L_MASK = (U_GC_LU_MASK|U_GC_LL_MASK|U_GC_LT_MASK|U_GC_LM_MASK|U_GC_LO_MASK);

		/** Mask constant for multiple UCharCategory bits (LC Cased Letters). @stable ICU 2.1 */
		inline constexpr auto U_GC_LC_MASK = (U_GC_LU_MASK|U_GC_LL_MASK|U_GC_LT_MASK);

		/** Mask constant for multiple UCharCategory bits (M Marks). @stable ICU 2.1 */
		inline constexpr auto U_GC_M_MASK = (U_GC_MN_MASK|U_GC_ME_MASK|U_GC_MC_MASK);

		/** Mask constant for multiple UCharCategory bits (N Numbers). @stable ICU 2.1 */
		inline constexpr auto U_GC_N_MASK = (U_GC_ND_MASK|U_GC_NL_MASK|U_GC_NO_MASK);

		/** Mask constant for multiple UCharCategory bits (Z Separators). @stable ICU 2.1 */
		inline constexpr auto U_GC_Z_MASK = (U_GC_ZS_MASK|U_GC_ZL_MASK|U_GC_ZP_MASK);

		/** Mask constant for multiple UCharCategory bits (C Others). @stable ICU 2.1 */
		inline constexpr auto U_GC_C_MASK = (U_GC_CN_MASK|U_GC_CC_MASK|U_GC_CF_MASK|U_GC_CO_MASK|U_GC_CS_MASK);

		/** Mask constant for multiple UCharCategory bits (P Punctuation). @stable ICU 2.1 */
		inline constexpr auto U_GC_P_MASK = (U_GC_PD_MASK|U_GC_PS_MASK|U_GC_PE_MASK|U_GC_PC_MASK|U_GC_PO_MASK|U_GC_PI_MASK|U_GC_PF_MASK);

		/** Mask constant for multiple UCharCategory bits (S Symbols). @stable ICU 2.1 */
		inline constexpr auto U_GC_S_MASK = (U_GC_SM_MASK|U_GC_SC_MASK|U_GC_SK_MASK|U_GC_SO_MASK);
	}
	inline namespace chars{
		inline constexpr auto TAB =0x0009;
		inline constexpr auto LF =0x000a;
		inline constexpr auto FF =0x000c;
		inline constexpr auto CR =0x000d;
		inline constexpr auto NBSP =0x00a0;
		inline constexpr auto CGJ =0x034f;
		inline constexpr auto FIGURESP=0x2007;
		inline constexpr auto HAIRSP =0x200a;
		inline constexpr auto ZWNJ =0x200c;
		inline constexpr auto ZWJ =0x200d;
		inline constexpr auto RLM =0x200f;
		inline constexpr auto NNBSP =0x202f;
		inline constexpr auto ZWNBSP =0xfeff;
	}
}

//file_end

		#line 45 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/props_data.hpp"
//props_data.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/props_data.hpp"
inline constexpr uint16_t props_index[23016]={
0x495,0x49d,0x4a5,0x4ad,0x4c5,0x4cd,0x4d5,0x4dd,0x4e5,0x4ed,0x4f3,0x4fb,0x503,0x50b,0x513,0x51b,
0x521,0x529,0x531,0x539,0x53c,0x544,0x54c,0x554,0x55c,0x564,0x560,0x568,0x570,0x578,0x57d,0x585,
0x58d,0x595,0x599,0x5a1,0x5a9,0x5b1,0x5b9,0x5c1,0x5bd,0x5c5,0x5ca,0x5d2,0x5d8,0x5e0,0x5e8,0x5f0,
0x5f8,0x600,0x608,0x610,0x615,0x61d,0x620,0x628,0x630,0x638,0x63e,0x646,0x645,0x64d,0x655,0x65d,
0x66d,0x665,0x675,0x67d,0x683,0x600,0x693,0x68b,0x6a3,0x6a5,0x6ad,0x69b,0x6bd,0x6c3,0x6cb,0x6b5,
0x6db,0x6e1,0x6e9,0x6d3,0x6f9,0x6ff,0x707,0x6f1,0x717,0x71d,0x725,0x70f,0x735,0x73d,0x745,0x72d,
0x755,0x75b,0x763,0x74d,0x773,0x779,0x781,0x76b,0x791,0x796,0x79e,0x789,0x7ae,0x7b5,0x7bd,0x7a6,
0x641,0x7c5,0x7cd,0x4b5,0x7d5,0x7dc,0x7e4,0x4b5,0x7ec,0x7f4,0x7fc,0x801,0x809,0x810,0x818,0x4b5,
0x600,0x820,0x828,0x830,0x838,0x58d,0x848,0x840,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x850,0x600,0x858,0x85c,0x864,0x600,0x86a,0x600,0x870,0x878,0x880,0x58d,0x58d,0x888,
0x890,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x895,0x89d,0x600,0x600,0x8a5,0x8ad,0x8b5,0x8bd,0x8c5,0x600,0x8cd,0x8d5,0x8dd,
0x8ed,0x600,0x8f5,0x8f7,0x8ff,0x8e5,0x600,0x902,0x916,0x90a,0x912,0x91e,0x600,0x926,0x92c,0x934,
0x93c,0x600,0x94c,0x954,0x95c,0x944,0x96c,0x4b5,0x974,0x977,0x97f,0x964,0x98f,0x987,0x600,0x996,
0x600,0x9a5,0x99e,0x9ad,0x9b5,0x9b9,0x9c1,0x9c9,0x535,0x9d1,0x9d4,0x9da,0x9e1,0x9d4,0x55c,0x55c,
0x4e5,0x4e5,0x4e5,0x4e5,0x9e9,0x4e5,0x4e5,0x4e5,0x9f9,0xa01,0xa09,0xa11,0xa19,0xa1d,0xa25,0x9f1,
0xa3d,0xa45,0xa2d,0xa35,0xa4d,0xa55,0xa5d,0xa65,0xa7d,0xa6d,0xa75,0xa85,0xa8d,0xa9c,0xaa1,0xa94,
0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xab1,0xab9,0x934,0xabc,0xac4,0xacb,0xad0,0xad8,
0x934,0xadf,0xade,0xaef,0xaf2,0x934,0x934,0xae7,0x934,0x934,0x934,0x934,0x934,0xb01,0xb09,0xaf9,
0x934,0x934,0x934,0xb0e,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0xb14,0xb1c,0x934,0xb24,0xb2b,
0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0xaa9,0xaa9,0xaa9,0xaa9,0xb33,0xaa9,0xb3a,0xb41,
0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0xaa9,0x934,0xb49,0xb50,0xb54,0xb5a,0x934,0x934,0x934,
0x58d,0x595,0x535,0xb62,0x4e5,0x4e5,0x4e5,0xb6a,0x535,0xb72,0x600,0xb78,0xb88,0xb80,0xb80,0x55c,
0xb90,0xb98,0xba0,0x4b5,0xba8,0x934,0x934,0xbaf,0x934,0x934,0x934,0x934,0x934,0x934,0xbb7,0xbbd,
0xbcd,0xbc5,0x641,0x600,0xbd5,0x890,0x600,0xbdd,0xbe5,0xbe9,0x600,0x600,0xbee,0x600,0x934,0xbf5,
0xad9,0xbfd,0xc03,0x934,0xbfd,0xc0b,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,
0xc13,0x600,0x600,0x600,0xc1b,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0xc21,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xc26,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x934,0x934,
0xc2e,0x600,0xc31,0x600,0xc39,0xc3f,0xc47,0xc4f,0xc54,0x600,0x600,0xc58,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xc5f,0x600,0xc66,0xc6c,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xc74,0x600,0x600,0x600,0xc7c,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0xc7e,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xc85,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0xc8c,0x600,0x600,0x600,0xc93,0xc9b,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xca0,0x600,0x600,0xca8,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xcac,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xcaf,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xcb2,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0xcb8,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0xcc0,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0xcc5,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0xcca,0x600,0x600,0x600,0xccf,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0xcd7,0xcde,0xce2,0x600,0x600,0x600,0xce9,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0xcf7,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0xcef,0x934,0xcff,0x9ad,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0xd04,0xd0c,0x4e5,0xd1c,0xd14,0x600,0x600,0xd24,0xd2c,0xd3c,0x4e5,0xd41,0xd49,0xd4f,0xd56,0xd34,
0xd5e,0xd66,0x600,0xd6e,0xd7e,0xd81,0xd76,0xd89,0x655,0xd91,0xd98,0x8f6,0x6a3,0xda8,0xda0,0xdb0,
0x600,0xdb8,0xdc0,0xdc8,0x600,0xdd0,0xdd8,0xde0,0xde8,0xdf0,0xdf4,0xdfc,0x535,0x535,0x600,0xe04,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xe0c,0xe18,0xe10,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,
0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0x600,0x600,0x600,0xe30,0x600,0xcea,0xe37,0xe3c,
0x600,0x600,0x600,0xe44,0x600,0x600,0x901,0x4b5,0xe5a,0xe4a,0xe52,0x600,0x600,0xe62,0xe6a,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xe6f,0x938,0x600,0xe77,0x600,0xe7d,0xe81,
0xe89,0xe91,0xe98,0xea0,0x600,0x600,0x600,0xea6,0xebe,0x4a5,0xec6,0xece,0xed3,0x916,0xeae,0xeb6,
0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,
0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,0xe20,
0x12d4,0x12d4,0x1314,0x1354,0x1394,0x13cc,0x140c,0x144c,0x1484,0x14c4,0x14f0,0x1530,0x1570,0x1580,0x15c0,0x15f4,
0x1634,0x1664,0x16a4,0x16e4,0x16f4,0x1728,0x1760,0x17a0,0x17e0,0x1820,0x1854,0x1880,0x18c0,0x18f8,0x1914,0x1954,
0xa80,0xac0,0xb00,0xb40,0xb80,0xbab,0xbeb,0xa40,0xc0e,0xa40,0xa40,0xa40,0xa40,0xc4e,0x1db,0x1db,
0xc8e,0xcce,0xa40,0xa40,0xa40,0xcf7,0xd37,0xd57,0xa40,0xd7d,0xdbd,0xdfd,0xe3d,0xe7d,0xebd,0xefd,
0xf3d,0xf74,0x1db,0x1db,0xf98,0xfcc,0x1db,0xff4,0x1db,0x1db,0x1db,0x1db,0x1021,0x1db,0x1db,0x1db,
0x1db,0x1db,0x1db,0x1db,0x1035,0x1db,0x106d,0x10ad,0x1db,0x10b8,0x1db,0x1db,0x1db,0x10ee,0xa40,0x112e,
0x1db,0x1db,0x116e,0x1db,0x1191,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0x11d1,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,
0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x1211,
0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,
0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x1211,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0xedb,0xee2,0xeea,0x4b5,0x600,0x600,0x600,0xef2,0xf02,0xefa,0xf19,0xf0a,0xf11,0xf21,0xf25,0xf29,
0x4b5,0x4b5,0x4b5,0x4b5,0x8f6,0x600,0xf31,0xf39,0x600,0xf41,0xf49,0xf4d,0xf55,0x600,0xf5d,0x4b5,
0x58d,0x597,0xf65,0x600,0xf69,0xf71,0xf81,0xf79,0x600,0xf89,0x600,0xf90,0xfa0,0xf98,0x4b5,0x4b5,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xb88,0x902,0xfa8,0xfb8,0xfb0,0x4b5,0x4b5,
0xfc8,0xfc0,0xfcb,0xfd3,0x916,0xfdb,0x4b5,0xfe3,0xfeb,0xff3,0x4b5,0x4b5,0x600,0x1003,0x100b,0xffb,
0x101b,0x1022,0x1013,0x102a,0x1032,0x4b5,0x1042,0x103a,0x600,0x1045,0x104d,0x1055,0x105d,0x1065,0x4b5,0x4b5,
0x600,0x600,0x106d,0x4b5,0x58d,0x1075,0x535,0x107d,0x600,0x1085,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x108d,0x600,0x1095,0x4b5,0x109a,0x10a2,0x10aa,0x10b1,0xfdf,0x10b9,0xfdf,0x10c1,0xb88,
0x10d1,0x636,0x10d9,0x10c9,0x98f,0x10e1,0x10e9,0x10ef,0x1107,0x10f7,0x10ff,0x110b,0x98f,0x111b,0x1113,0x1123,
0x113b,0x112b,0x1133,0x4b5,0x1142,0x114a,0x658,0x1152,0x1162,0x1168,0x1170,0x115a,0x4b5,0x4b5,0x4b5,0x4b5,
0x600,0x1178,0x1180,0x1099,0x600,0x1188,0x1190,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x600,0x1198,0x11a0,0x4b5,
0x600,0x11a8,0x11b0,0x11b8,0x600,0x11c8,0x11c0,0x4b5,0x870,0x11d0,0x11d8,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x600,0x11e0,0x4b5,0x4b5,0x4b5,0x58d,0x535,0x11e8,0x11f8,0x11fe,0x11f0,0x4b5,0x4b5,0x120e,0x1212,0x1206,
0x122a,0x121a,0x1222,0x600,0x1238,0x1232,0x600,0x8f7,0x1248,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x1256,0x125b,0x1240,0x1250,0x126b,0x1263,0x4b5,0x4b5,0x127a,0x127e,0x1272,0x128e,0x1286,0x11c0,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x1292,0x12a2,0x12a7,0x129a,0x4b5,0x4b5,0x12af,0x12bf,0x12b7,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x901,0x4b5,0x4b5,0x4b5,
0x12cf,0x12d7,0x12df,0x12c7,0x600,0x600,0x600,0x600,0x600,0x600,0x12e7,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0xfdf,0x600,0x600,0x12ef,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x12f7,0x12ff,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x11d8,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x8f7,
0x916,0xda4,0x600,0x916,0x1307,0x130c,0x600,0x131c,0x1324,0x132c,0x1314,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x58d,0x535,0x1334,0x4b5,0x4b5,0x4b5,0x600,0x600,0x133c,0x1341,0x1347,0x4b5,0x4b5,0x134f,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x1357,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x902,0x4b5,0x106d,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x135d,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x1365,0x136a,0x1371,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xe10,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x600,0x600,0x600,0x1377,0x137c,0x1384,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x55c,0x1394,0x139b,0x934,0x934,0x934,0x138c,0x4b5,0x934,0x934,0x934,
0x934,0x934,0x934,0x934,0xbb7,0x934,0x13a2,0x934,0x13a9,0x13b1,0x13b7,0x934,0xade,0x934,0x934,0x13bf,
0x4b5,0x4b5,0x4b5,0x13c7,0x13c7,0x934,0x934,0xadb,0x13cf,0x4b5,0x4b5,0x4b5,0x4b5,0x13df,0x13e6,0x13eb,
0x13f1,0x13f9,0x1401,0x1409,0x13e3,0x1411,0x1419,0x1421,0x1426,0x13f8,0x13df,0x13e6,0x13e2,0x13f1,0x142e,0x13e0,
0x1431,0x13e3,0x1439,0x1441,0x1449,0x1450,0x143c,0x1444,0x144c,0x1453,0x143f,0x145b,0x13d7,0x934,0x934,0x934,
0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x55c,0x146b,0x55c,
0x1472,0x1479,0x1463,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x1488,0x1490,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x1480,0x1498,0x9d4,
0x14a8,0x14a0,0x4b5,0x4b5,0x4b5,0x600,0x14b8,0x14b0,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0xfdf,0x14c0,0x600,0x14c8,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0xfdf,0x14d0,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x14d8,0x600,0x600,0x600,
0x600,0x600,0x600,0x14e0,0x4b5,0x58d,0x14f0,0x14e8,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x14f8,0x1508,0x1500,0x4b5,0x4b5,0x1518,0x1510,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x1528,0x1530,0x1538,
0x1540,0x1548,0x1550,0x4b5,0x1520,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x934,0x1558,0x934,
0x934,0xbaf,0x13a0,0x1560,0xbb7,0x1568,0x934,0x934,0x934,0x934,0xbb9,0x4b5,0x1570,0x1578,0x157c,0x1584,
0x158c,0x4b5,0x4b5,0x4b5,0x4b5,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x1594,0x934,0x934,0x934,
0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,
0x934,0x934,0x934,0x157d,0x159c,0x934,0x934,0x934,0x15a4,0x934,0x934,0x15ab,0x15b3,0x1558,0x934,0x15bb,
0x934,0x15c3,0x15c8,0x4b5,0x4b5,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0x934,0xbaf,
0x15d0,0x15d9,0x15dd,0x15e5,0x15d5,0x934,0x934,0x934,0x934,0x15ed,0x934,0xade,0x11bc,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x15f5,0x600,0x600,
0x15fc,0x600,0x600,0x600,0x1604,0x600,0x160c,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xc90,0x600,0x600,
0x1614,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x161c,0x1624,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0xccf,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x162b,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x1632,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x1639,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x4b5,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x901,0x600,0x600,0x600,0x600,0x600,0x600,0xf69,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x1641,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x1649,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x600,0x600,
0x600,0x600,0x1651,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0xf69,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x67d,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,
0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x600,0x1314,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x1661,0x1659,0x1659,0x1659,0x4b5,0x4b5,0x4b5,0x4b5,0x55c,0x55c,0x55c,0x55c,0x55c,0x55c,0x55c,
0x1669,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,0x4b5,
0x4b5,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,0xe28,
0x1671,0x494,0x494,0x494,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xc,0x17,0x17,0x17,0x19,0x17,0x17,0x17,0x14,0x15,0x17,0x18,
0x17,0x13,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,
0x18,0x18,0x18,0x17,0x17,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x14,
0x17,0x15,0x1a,0x16,0x1a,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0x14,
0x18,0x15,0x18,0xf,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xc,0x17,0x19,0x19,0x19,0x19,0x1b,0x17,0x1a,0x1b,5,0x1c,
0x18,0x10,0x1b,0x1a,0x1b,0x18,0x34b,0x38b,0x1a,2,0x17,0x17,0x1a,0x30b,5,0x1d,
0x34cb,0x344b,0x3ccb,0x17,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,0x18,1,1,1,1,
1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,0x18,2,2,2,2,
2,2,2,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,2,1,2,1,
2,1,2,1,2,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,1,2,1,2,1,2,2,2,1,1,2,
1,2,1,1,2,1,1,1,2,2,1,1,1,1,2,1,
1,2,1,1,1,2,2,2,1,1,2,1,1,2,1,2,
1,2,1,1,2,1,2,2,1,2,1,1,2,1,1,1,
2,1,2,1,1,2,2,5,1,2,2,2,5,5,5,5,
1,3,2,1,3,2,1,3,2,1,2,1,2,1,2,1,
2,1,2,1,2,1,2,1,2,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,2,1,3,2,
1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,2,2,2,2,2,2,1,1,
2,1,1,2,2,1,2,1,1,1,1,2,1,2,1,2,
1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,5,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,0x1a,0x1a,0x1a,0x1a,4,4,4,4,4,4,4,4,4,4,
4,4,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
4,4,4,4,4,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,4,0x1a,4,0x1a,
0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
1,2,1,2,4,0x1a,1,2,0,0,4,2,2,2,0x17,1,
0,0,0,0,0x1a,0x1a,1,0x17,1,1,1,0,1,0,1,1,
2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,0,1,1,1,1,1,1,1,1,1,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,1,2,2,1,1,1,2,2,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,2,2,2,2,1,2,0x18,1,2,1,1,2,
2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,0x1b,6,6,6,6,6,7,7,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,1,2,1,2,1,2,1,2,1,2,1,
2,1,2,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,0,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
0,4,0x17,0x17,0x17,0x17,0x17,0x17,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,0x17,0x13,0,0,0x1b,0x1b,0x19,
0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,0x13,6,
0x17,6,6,0x17,6,6,0x17,6,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,5,
5,5,5,0x17,0x17,0,0,0,0,0,0,0,0,0,0,0,
0x10,0x10,0x10,0x10,0x10,0x10,0x18,0x18,0x18,0x17,0x17,0x19,0x17,0x17,0x1b,0x1b,
6,6,6,6,6,6,6,6,6,6,6,0x17,0x10,0x17,0x17,0x17,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
4,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0x17,0x17,5,5,
6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0x17,5,6,6,6,6,6,6,6,0x10,0x1b,6,
6,6,6,6,6,4,4,6,6,0x1b,6,6,6,6,5,5,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,0x1b,0x1b,5,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0x10,
5,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,0,0,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,
6,6,6,6,6,5,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,
6,6,6,6,6,6,6,6,4,4,0x1b,0x17,0x17,0x17,4,0,
0,6,0x19,0x19,6,6,6,6,4,6,6,6,4,6,6,6,
6,6,0,0,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,6,6,6,6,4,6,
6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,
0,0,0x17,0,5,5,5,5,5,5,5,5,5,5,5,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0x1a,5,5,5,5,5,5,0,0x10,0x10,0,0,
0,0,0,0,6,6,6,6,6,6,6,6,6,6,0x10,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,5,5,5,5,
5,5,5,5,5,4,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,5,5,6,6,
0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,4,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,8,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,8,
6,5,8,8,8,6,6,6,6,6,6,6,6,8,8,8,
8,6,8,8,5,6,6,6,6,6,6,6,5,5,5,5,
5,5,5,5,5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
0x1c9,0x209,0x249,0x289,5,5,0x19,0x19,0x37cb,0x35cb,0x3fcb,0x34cb,0x3ccb,0x94b,0x1b,0x19,
5,0x17,6,0,5,6,8,8,0,5,5,5,5,5,5,5,
5,0,0,5,5,0,0,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0,5,5,5,5,5,5,5,0,5,0,
0,0,5,5,5,5,0,0,6,5,8,8,8,6,6,6,
6,0,0,8,8,0,0,8,8,6,5,0,0,0,0,0,
0,0,0,8,0,0,0,0,5,5,0,5,0,0,0,0,
0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,6,6,5,5,
5,6,0x17,0,0,0,0,0,0,0,0,0,0,6,6,8,
0,5,5,5,5,5,5,0,0,0,0,5,5,0,0,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
5,5,5,5,5,0,5,5,0,5,5,0,5,5,0,0,
6,0,8,8,8,6,6,0,0,0,0,6,6,0,0,6,
6,6,0,0,0,6,0,0,0,0,0,0,0,5,5,5,
5,0,5,0,5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
0x1c9,0x209,0x249,0x289,0x17,0x19,0,0,0,0,0,0,0,5,6,6,
6,6,6,6,0,6,6,8,0,5,5,5,5,5,5,5,
5,5,0,5,5,5,0,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0,5,5,5,5,5,5,5,0,5,5,
0,5,5,5,5,5,0,0,6,5,8,8,8,6,6,6,
6,6,0,6,6,8,0,8,8,6,0,0,5,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,6,6,
0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x1b,5,0x34cb,0x344b,
0x3ccb,0x37cb,0x35cb,0x3fcb,0,0,0,0,0,0,0,0,0,6,8,8,
0,5,5,5,5,5,5,5,5,0,0,5,5,0,0,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
5,5,5,5,5,0,5,5,0,5,5,5,5,5,0,0,
6,5,8,6,8,6,6,6,6,0,0,8,8,0,0,8,
8,6,0,0,0,0,0,0,0,6,6,8,0,0,0,0,
5,5,0,5,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
0x1c9,0x209,0x249,0x289,0x7cb,0x1e4b,0x784b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x19,0x1b,0,
0,0,0,0,0,0,6,5,0,5,5,5,5,5,5,0,
0,0,5,5,5,0,5,5,5,5,0,0,0,5,5,0,
5,0,5,5,0,0,0,5,5,0,0,0,5,5,5,0,
0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
0,0,8,8,6,8,8,0,0,0,8,8,8,0,8,8,
8,6,0,0,5,0,0,0,0,0,0,8,0,0,0,0,
0,0,0,0,5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,0,0x17,0x54b,0x58b,0x5cb,0x60b,
0x58b,0x5cb,0x60b,0x1b,6,8,8,8,6,5,5,5,5,5,5,5,
5,0,5,5,5,0,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0,0,6,5,6,6,6,8,8,8,
8,0,6,6,6,0,6,6,6,6,0,0,0,0,0,0,
0,6,6,0,5,5,5,0,0,5,0,0,5,5,6,6,
0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,5,5,8,
0,0,0,0,0,0,0,0,0,0,0,0,5,6,8,8,
0x17,5,5,5,5,5,5,5,5,0,5,5,5,0,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
5,5,5,5,5,5,5,5,0,5,5,5,5,5,0,0,
6,5,8,6,8,8,8,8,8,0,6,8,8,0,8,8,
6,6,0,0,0,0,0,0,0,8,8,0,0,0,0,0,
0,5,5,0,5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
0x1c9,0x209,0x249,0x289,0x7cb,0x1e4b,0x784b,0x34cb,0x344b,0x3ccb,0x37cb,0x35cb,0x3fcb,0x1b,5,5,
5,5,5,5,6,6,8,8,5,5,5,5,5,5,5,5,
5,0,5,5,5,0,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,6,6,5,8,8,8,6,6,6,6,0,8,8,
8,0,8,8,8,6,5,0x1b,0,0,0,0,5,5,5,8,
0xcc0b,0xca0b,0xcb4b,0xc90b,0x364b,0xc94b,0x350b,5,0,0,0,0,0,0,0x49,0x89,
0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,8,8,0x17,0,0,0,
0,0,0,0,0,0,0,0,0,6,8,8,0,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,
0,5,0,0,5,5,5,5,5,5,5,0,0,0,6,0,
0,0,0,8,8,8,6,6,6,0,6,0,8,8,8,8,
8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,6,5,5,6,6,6,6,6,6,6,0,
0,0,0,0x19,5,5,5,5,5,5,4,6,6,6,6,6,
6,6,6,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,
0,0,0,0,0,5,5,0,5,0,5,5,5,5,5,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0,5,0,5,5,5,5,5,5,5,5,5,
5,6,5,5,6,6,6,6,6,6,6,6,6,5,0,0,
5,5,5,5,5,0,4,0,6,6,6,6,6,6,6,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,5,5,5,5,
5,0x1b,0x1b,0x1b,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0x1b,0x17,0x1b,0x1b,0x1b,6,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x344b,0x3c4b,0x444b,0x4c4b,0x544b,0x5c4b,
0x644b,0x6c4b,0x744b,0x2c4b,0x1b,6,0x1b,6,0x1b,6,0x14,0x15,0x14,0x15,8,8,
5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,8,6,6,6,6,6,0x17,6,6,5,5,5,5,
5,6,6,6,6,6,6,6,6,6,6,6,0,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,0,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,0x1b,
0x17,0x17,0x17,0x17,0x17,0x1b,0x1b,0x1b,0x1b,0x17,0x17,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,8,8,6,6,6,
6,8,6,6,6,6,6,6,8,6,6,8,8,6,6,5,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0x17,0x17,0x17,0x17,
5,5,5,5,5,5,8,8,6,6,5,5,5,5,6,6,
6,5,8,8,8,5,5,8,8,8,8,8,8,8,5,5,
5,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,
5,5,6,8,8,6,6,8,8,8,8,8,8,6,5,8,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,8,8,8,6,0x1b,0x1b,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,0x17,4,2,2,2,
1,1,1,1,1,1,0,1,0,0,0,0,0,1,0,0,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
5,5,5,5,5,5,5,5,5,0,5,5,5,5,0,0,
5,5,5,5,5,5,5,0,5,0,5,5,5,5,0,0,
5,5,5,5,5,5,5,5,5,0,5,5,5,5,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0,5,5,5,5,0,0,5,5,5,5,5,5,5,0,
5,0,5,5,5,5,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0,5,5,5,5,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,0,0,6,6,6,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,
0x4cb,0x50b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x788b,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,0,0,2,2,2,2,2,2,0,0,
0x13,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0x1b,0x17,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0xc,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x14,
0x15,0,0,0,5,5,5,5,5,5,5,5,5,5,5,0x17,
0x17,0x17,0x98a,0x9ca,0xa0a,5,5,5,5,5,5,5,5,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,6,6,6,8,0,0,0,0,0,0,
0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,6,6,8,0x17,0x17,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,6,6,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,0,5,5,5,0,6,6,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,6,6,8,6,6,6,6,6,
6,6,8,8,8,8,8,8,8,8,6,8,8,6,6,6,
6,6,6,6,6,6,6,6,0x17,0x17,0x17,4,0x17,0x17,0x17,0x19,
5,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0,0x54b,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,6,5,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0x17,0x17,0x17,0x17,0x17,0x17,0x13,0x17,0x17,0x17,0x17,6,
6,6,0x10,6,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0,5,5,5,4,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0,0,0,0,0,0,0,5,5,5,5,
5,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
0,0,0,0,0,0,0,0,6,6,6,8,8,8,8,6,
6,8,8,8,0,0,0,0,8,8,6,8,8,8,8,8,
8,6,6,6,0,0,0,0,0x1b,0,0,0,0x17,0x17,0x49,0x89,
0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0,0,5,5,5,5,5,0,0,0,
0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,0,0,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x30b,0,0,0,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,6,6,8,8,6,0,0,0x17,0x17,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,4,0x17,0x17,0x17,0x17,0x17,0x17,0,0,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,6,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,8,6,8,6,6,6,6,6,6,6,0,
6,8,6,8,8,6,6,6,6,6,6,6,6,8,8,8,
8,8,8,6,6,6,6,6,6,6,6,6,6,0,0,6,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
0x17,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,6,6,6,6,
6,6,6,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x17,0x17,0,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
6,6,6,6,8,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
6,8,6,6,6,6,6,8,6,8,8,8,8,8,6,8,
8,5,5,5,5,5,5,5,5,0,0,0,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0x17,0x17,0x17,0x17,5,8,6,6,
6,6,8,8,6,6,8,6,6,6,5,5,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,5,5,5,6,6,8,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,8,
6,6,8,8,8,6,8,6,6,6,8,8,0,0,0,0,
0,0,0,0,0x17,0x17,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0,0,0,5,5,5,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,5,5,5,5,5,5,8,8,8,8,8,8,8,8,
6,6,6,6,6,6,6,6,8,8,6,6,0,0,0,0x17,
0x17,0x17,0x17,0x17,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,
4,4,0x17,0x17,2,2,2,2,2,2,2,2,2,0,0,0,
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
0,1,1,1,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,0,
0,0,0,0,6,6,6,0x17,6,6,6,6,6,6,6,6,
6,6,6,6,6,8,6,6,6,6,6,6,6,5,5,5,
5,6,5,5,5,5,5,5,6,5,5,8,6,6,5,0,
0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,
4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,
4,4,4,4,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,2,2,2,2,2,2,
2,2,1,2,2,2,2,2,2,2,2,2,1,1,1,1,
1,0x1a,0x1a,0x1a,0,0,2,2,2,0,2,2,1,1,1,1,
3,0x1a,0x1a,0,2,2,2,2,2,2,2,2,1,1,1,1,
1,1,1,1,2,2,2,2,2,2,0,0,1,1,1,1,
1,1,0,0,2,2,2,2,2,2,2,2,1,1,1,1,
1,1,1,1,2,2,2,2,2,2,2,2,1,1,1,1,
1,1,1,1,2,2,2,2,2,2,0,0,1,1,1,1,
1,1,0,0,2,2,2,2,2,2,2,2,0,1,0,1,
0,1,0,1,2,2,2,2,2,2,2,2,1,1,1,1,
1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,0,0,2,2,2,2,2,2,2,2,3,3,3,3,
3,3,3,3,2,2,2,2,2,2,2,2,3,3,3,3,
3,3,3,3,2,2,2,2,2,0,2,2,1,1,1,1,
3,0x1a,2,0x1a,0x1a,0x1a,2,2,2,0,2,2,1,1,1,1,
3,0x1a,0x1a,0x1a,2,2,2,2,0,0,2,2,1,1,1,1,
0,0x1a,0x1a,0x1a,0x16,0x17,0x17,0x17,0x18,0x14,0x15,0x17,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,0x17,0x17,0x18,0x17,0x16,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0xc,0x10,0x10,0x10,0x10,0x10,0,0x10,0x10,0x10,0x10,0x10,0x10,
0x10,0x10,0x10,0x10,0x2cb,4,0,0,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x18,0x18,
0x18,0x14,0x15,4,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x10,
0x10,0x10,0x10,0x10,0x13,0x13,0x13,0x13,0x13,0x13,0x17,0x17,0x1c,0x1d,0x14,0x1c,
0x1c,0x1d,0x14,0x1c,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0xd,0xe,0x10,0x10,
0x10,0x10,0x10,0xc,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x1c,0x1d,0x17,
0x17,0x17,0x17,0x16,0x2cb,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x18,0x18,
0x18,0x14,0x15,0,4,4,4,4,4,4,4,4,4,4,4,4,
4,0,0,0,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
0x19,0x19,0x19,0x19,0x19,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,
6,7,7,7,7,6,7,7,7,6,6,6,6,6,6,6,
6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,1,0x1b,1,0x1b,1,0x1b,1,1,
1,1,0x1b,2,1,1,1,1,2,5,5,5,5,2,0x1b,0x1b,
2,2,1,1,0x18,0x18,0x18,0x18,0x18,1,2,2,2,2,0x1b,0x18,
0x1b,0x1b,2,0x1b,0x358b,0x360b,0x364b,0x348b,0x388b,0x350b,0x390b,0x3d0b,0x410b,0x354b,0x454b,0x35cb,
0x3dcb,0x45cb,0x4dcb,0x58b,0x1b,0x1b,1,0x1b,0x1b,0x1b,0x1b,1,0x1b,0x1b,2,1,
1,1,2,2,1,1,1,2,0x1b,1,0x1b,0x1b,0x18,1,1,1,
1,1,0x1b,0x1b,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x7ca,0x80a,0x84a,
0x11ca,0x1e4a,0x980a,0x784a,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x7ca,0x80a,0x84a,
0x11ca,0x1e4a,0x980a,0x784a,0x784a,0x984a,0x788a,1,2,0x6ca,0x11ca,0x988a,0x78ca,0x54b,0x1b,0x1b,
0,0,0,0,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x1b,0x1b,0x18,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x18,0x18,0x1b,0x1b,0x18,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x14,0x15,0x14,0x15,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x14,0x15,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,
0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x2cb,0x80b,0x84b,0x88b,0x8cb,0x90b,0x94b,0x98b,0x9cb,0xa0b,
0xa4b,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x2cb,0x30b,0x34b,0x38b,0x3cb,
0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x80b,0x84b,0x88b,0x8cb,0x90b,0x94b,0x98b,0x9cb,0xa0b,0xa4b,
0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x80b,0x84b,0x88b,0x8cb,0x90b,0x94b,
0x98b,0x9cb,0xa0b,0xa4b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,
0x14,0x15,0x14,0x15,0x14,0x15,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,
0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,
0x48b,0x4cb,0x50b,0x7cb,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x18,0x18,0x18,0x18,0x18,0x14,0x15,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x14,
0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,
0x15,0x14,0x15,0x14,0x15,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x14,0x15,0x14,0x15,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x14,0x15,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,1,2,1,1,1,2,2,1,
2,1,2,1,2,1,1,1,1,2,1,2,2,1,2,2,
2,2,2,2,4,4,1,1,1,2,1,2,2,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,1,2,1,2,6,6,6,1,2,0,0,0,0,
0,0x17,0x17,0x17,0x17,0x344b,0x17,0x17,2,2,2,2,2,2,0,2,
0,0,0,0,0,2,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,4,
0x17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,0,
5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,
0x17,0x17,0x1c,0x1d,0x1c,0x1d,0x17,0x17,0x17,0x1c,0x1d,0x17,0x1c,0x1d,0x17,0x17,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x13,0x17,0x17,0x13,0x17,0x1c,0x1d,0x17,0x17,
0x1c,0x1d,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x17,0x17,0x17,0x17,0x17,4,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x13,0x13,0x17,0x17,0x17,0x17,
0x13,0x17,0x14,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
0x1b,0x1b,0x17,0x17,0x17,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x13,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0,0,0,0,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0,0,0,0,0x1b,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,6,6,
6,6,8,8,0x13,4,4,4,4,4,0x1b,0x1b,0x7ca,0xa4a,0xcca,4,
5,0x17,0x1b,0x1b,0xc,0x17,0x17,0x17,0x1b,4,5,0x54a,0x14,0x15,0x14,0x15,
0x14,0x15,0x14,0x15,0x14,0x15,0x1b,0x1b,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,
0x13,0x14,0x15,0x15,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,0,0,6,6,0x1a,
0x1a,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x17,
4,4,4,5,0,0,0,0,0,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,0,0x1b,0x1b,0x58b,0x5cb,0x60b,0x64b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1b,0xa8b,0xacb,0xb0b,
0xb4b,0xb8b,0xbcb,0xc0b,0xc4b,0xc8b,0xccb,0xd0b,0xd4b,0xd8b,0xdcb,0xe0b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0xe4b,0xe8b,0xecb,
0xf0b,0xf4b,0xf8b,0xfcb,0x100b,0x104b,0x108b,0x10cb,0x110b,0x114b,0x118b,0x11cb,5,5,5,5,
5,0x685,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x5c5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x685,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0x705,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0x585,5,5,0x705,5,5,5,0x7885,
5,0x605,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0x785,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x5c5,5,5,5,5,5,5,5,0x685,5,0x645,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,0x7985,0x7c5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,0x7845,5,5,5,5,
5,5,5,5,0x605,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0x685,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x1e45,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x7985,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x7a85,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0x5c5,5,0x745,5,0x6c5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0x7c5,5,0x7845,0xa45,0xcc5,5,5,5,5,5,5,0xf45,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0x605,0x605,0x605,0x605,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,0x645,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0x585,5,5,5,5,5,5,5,0x585,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0x585,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0x785,0xa45,5,5,5,5,
5,5,5,5,5,5,5,5,0x585,0x5c5,0x605,5,0x5c5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x7c5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0x745,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0x705,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x785,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x1e45,5,
5,5,5,5,5,5,0x645,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x7885,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0x5c5,5,5,5,5,0x5c5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0x5c5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0x7845,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x6c5,5,
5,5,5,5,0x1e45,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x6c5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0x545,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0,0,0,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,4,5,5,5,5,5,5,5,5,5,5,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,4,0x17,0x17,0x17,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,4,4,6,6,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,5,6,
7,7,7,0x17,6,6,6,6,6,6,6,6,6,6,0x17,4,
5,5,5,5,5,5,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x54a,
6,6,0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,0,
0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,4,4,4,4,4,4,4,4,4,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,4,4,4,1,2,5,4,4,2,5,5,5,5,5,
0x1a,0x1a,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
2,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,4,2,2,2,2,2,2,2,2,1,2,1,
2,1,1,2,1,2,1,2,1,2,1,2,4,0x1a,0x1a,1,
2,1,2,5,1,2,1,2,2,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,1,1,1,1,2,1,1,1,1,
1,2,1,2,1,2,1,2,1,2,1,2,1,1,1,1,
2,1,2,0,0,0,0,0,1,2,0,2,0,2,1,2,
1,2,0,0,0,0,0,0,5,5,6,5,5,5,6,5,
5,5,5,6,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,8,8,6,6,8,
0x1b,0x1b,0x1b,0x1b,6,0,0,0,0x34cb,0x344b,0x3ccb,0x37cb,0x35cb,0x3fcb,0x1b,0x1b,
0x19,0x1b,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0x17,0x17,0x17,0x17,
0,0,0,0,0,0,0,0,8,8,8,8,6,6,0,0,
0,0,0,0,0,0,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0,0,0,0,0,0,8,8,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,8,8,8,8,8,8,8,8,
8,8,8,8,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,5,5,5,5,5,5,0x17,0x17,0x17,5,
0x17,5,5,6,5,5,5,5,5,5,6,6,6,6,6,6,
6,6,0x17,0x17,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,
6,6,8,8,0,0,0,0,0,0,0,0,0,0,0,0x17,
8,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,4,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0x17,0x17,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,6,8,8,6,6,6,6,8,8,6,6,8,8,
5,5,5,5,5,6,4,5,5,5,5,5,5,5,5,5,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,5,5,0,
5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,8,
8,6,6,8,8,6,6,0,0,0,0,0,0,0,0,0,
5,5,5,6,5,5,5,5,5,5,5,5,6,8,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0x17,0x17,0x17,0x17,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
4,5,5,5,5,5,5,0x1b,0x1b,0x1b,5,8,6,8,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
6,5,6,6,6,5,5,6,6,5,5,5,5,5,6,6,
5,6,5,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,5,5,4,0x17,0x17,
5,5,5,5,5,5,5,5,5,5,5,8,6,6,8,8,
0x17,0x17,5,4,4,8,6,0,0,0,0,0,0,0,0,0,
0,5,5,5,5,5,5,0,0,5,5,5,5,5,5,0,
0,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,0,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,0x1a,4,4,4,4,
2,2,2,2,2,2,2,2,2,4,0x1a,0x1a,0,0,0,0,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
5,5,5,8,8,6,8,8,6,8,8,0x17,8,6,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,
5,5,5,5,5,5,5,0,0,0,0,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
5,5,5,5,5,5,5,5,5,5,5,0x605,5,5,5,5,
5,5,5,0x7c5,5,5,5,5,0x5c5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0x6c5,5,0x6c5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0x7c5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0x18,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
5,5,5,5,5,0,5,0,5,5,0,5,5,0,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,2,2,2,2,2,2,2,0,
0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,
0,0,0,0,0,5,6,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0x15,0x14,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0,0,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,
0,0,0,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
0x19,0x1b,0x1b,0x1b,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x14,0x15,0x17,0,0,
0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,0x17,0x13,0x13,0x16,0x16,0x14,0x15,0x14,0x15,0x14,0x15,0x14,
0x15,0x14,0x15,0x14,0x15,0x17,0x17,0x14,0x15,0x17,0x17,0x17,0x17,0x16,0x16,0x16,
0x17,0x17,0x17,0,0x17,0x17,0x17,0x17,0x13,0x14,0x15,0x14,0x15,0x14,0x15,0x17,
0x17,0x17,0x18,0x13,0x18,0x18,0x18,0,0x17,0x19,0x17,0x17,0,0,0,0,
5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0,0,0x10,0,0,5,5,5,5,5,5,
0,0,5,5,5,5,5,5,0,0,5,5,5,5,5,5,
0,0,5,5,5,0,0,0,0x19,0x19,0x18,0x1a,0x1b,0x19,0x19,0,
0x1b,0x18,0x18,0x18,0x18,0x1b,0x1b,0,0,0,0,0,0,0,0,0,
0,0x10,0x10,0x10,0x1b,0x1b,0,0,0,0x17,0x17,0x17,0x19,0x17,0x17,0x17,
0x14,0x15,0x17,0x18,0x17,0x13,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0x17,0x17,0x18,0x18,0x18,0x17,0x1a,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,0x14,0x18,0x15,0x18,0x14,0x15,0x17,0x14,0x15,0x17,0x17,5,5,
5,5,5,5,5,5,5,5,4,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,4,4,5,5,5,5,
5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,0,5,5,0,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,0,0,0,0,0,0xb00b,0xb80b,0x784b,0x804b,0x884b,0x904b,0x984b,0xa04b,
0xa84b,0xb04b,0xb84b,0x788b,0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,0xb08b,0xb88b,0,0,0,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x17,0x17,0x17,0,0,0,0,0x58b,
0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,
0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0xcca,0x11ca,0x11ca,
0x11ca,0x11ca,0x1e4a,0x880a,0x980a,0x980a,0x980a,0x980a,0x980a,0x784a,0x984a,0x68a,0x11ca,0x344b,0x344b,0x388b,
0x3ccb,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x54b,0x34cb,
0x1b,0x1b,0x1b,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0,0,0,0x34ca,0x344a,0x58a,0x68a,0x11ca,0x980a,0x984a,0x988a,0x68a,0x7ca,0x11ca,0x1e4a,
0x980a,0x784a,0x984a,0x68a,0x7ca,0x11ca,0x1e4a,0x980a,0x784a,0x788a,0x988a,0x7ca,0x58a,0x58a,0x58a,0x5ca,
0x5ca,0x5ca,0x5ca,0x68a,0x1b,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,6,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,6,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,
0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,
0,0,0,0,0x58b,0x68b,0x7cb,0x11cb,0,0,0,0,0,0,0,0,
0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0x1bca,5,5,5,5,5,5,5,5,0xb80a,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0,0x17,5,5,5,5,0,0,0,0,5,5,5,5,
5,5,5,5,0x17,0x58a,0x5ca,0x7ca,0xa4a,0x1e4a,0,0,0,0,0,0,
0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,0,0,0,0,2,2,2,2,
2,2,2,2,5,5,5,5,5,5,5,5,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0x17,
1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,
2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,0,2,2,2,2,2,2,2,0,2,2,0,0,0,
1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,
1,1,1,0,1,1,0,2,2,2,2,2,2,2,2,2,
5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
4,0,4,4,4,4,4,4,4,4,4,0,0,0,0,0,
4,4,4,4,4,4,0,4,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0,5,5,0,0,0,5,0,0,5,
5,5,5,5,5,5,0,0,5,0,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0,0x17,0x58b,0x5cb,0x60b,0x7cb,0xa4b,0x1e4b,0x784b,0x788b,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,0x1b,0x1b,0x58b,0x5cb,0x60b,0x64b,0x68b,0x7cb,0xa4b,0,0,0,0,
0,0,0,0x58b,0x5cb,0x60b,0x64b,0x64b,0x68b,0x7cb,0xa4b,0x1e4b,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
5,5,0,0,0,0,0,0x58b,0x68b,0x7cb,0xa4b,0x1e4b,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0x58b,0x7cb,0xa4b,0x1e4b,0x5cb,0x60b,0,0,0,0x17,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0,0,0,0,0,0x17,0xa04b,0xa84b,0xb04b,0xb84b,
0x788b,0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,0xb08b,0xb88b,0x78cb,0x80cb,0x88cb,0x90cb,0x98cb,0xa0cb,0xa8cb,
0xb0cb,0xb8cb,0x36cb,0x354b,0x34cb,0x348b,0x46cb,0x344b,0x4ecb,0x388b,0x3ccb,0x454b,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0,0,0,0,0x5ecb,0x344b,5,5,0x58b,0x5cb,0x60b,0x64b,
0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0,0,0x1e4b,0x800b,
0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0x784b,0x804b,0x884b,0x904b,0x984b,0x30b,0x34b,0x38b,0x3cb,
0x7cb,0xa4b,0x1e4b,0x784b,0x344b,0,0,0,0,0,0,0,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,5,6,6,6,
0,6,6,0,0,0,0,0,6,6,6,6,5,5,5,5,
0,5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
6,6,6,0,0,0,0,6,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0x58b,0x11cb,0x17,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0x58b,0x7cb,0xa4b,5,5,5,5,5,6,6,0,
0,0,0,0x58b,0x68b,0x7cb,0xa4b,0x1e4b,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,
0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
0x1b,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0,0,0,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0,0,0x58b,0x5cb,0x60b,0x64b,
0x7cb,0xa4b,0x1e4b,0x784b,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,0,0,0,0,0,0x58b,0x5cb,0x60b,0x64b,
0x7cb,0xa4b,0x1e4b,0x784b,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0,0,0,0,0,0,0,0x17,0x17,0x17,
0x17,0,0,0,0,0,0,0,0,0,0,0,0,0x58b,0x5cb,0x60b,
0x64b,0x7cb,0xa4b,0x1e4b,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,0,0,0,0,0,0,0,0x58b,0x68b,
0x7cb,0x11cb,0x1e4b,0x784b,5,5,5,5,6,6,6,6,0,0,0,0,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0xa4b,0xccb,
0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0x344b,
0x34cb,0x348b,0x388b,0,5,5,5,5,5,5,5,5,5,5,0,6,
6,0x13,0,0,5,5,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,6,6,6,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0x58b,0x5cb,0x60b,0x64b,0x68b,0x7cb,0xa4b,0xccb,0x1e4b,0x344b,5,
0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,
6,6,6,6,6,0x58b,0x7cb,0xa4b,0x1e4b,0x17,0x17,0x17,0x17,0x17,0,0,
0,0,0,0,5,5,6,6,6,6,0x17,0x17,0x17,0x17,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,0x58b,0x5cb,0x60b,0x64b,0x7cb,0xa4b,0x1e4b,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x784b,0x49,0x89,0xc9,0x109,0x149,0x189,
0x1c9,0x209,0x249,0x289,6,5,5,6,6,5,0,0,0,0,0,0,
0,0,0,6,8,6,8,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,6,6,6,6,6,6,6,0x17,0x17,0x17,0x17,0x17,
0x17,0x17,0,0,0,0,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,
0xa4b,0xccb,0xf4b,0x11cb,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,8,8,8,6,6,6,6,8,8,6,6,0x17,
0x17,0x10,0x17,0x17,0x17,0x17,6,0,0,0,0,0,0,0,0,0,
0,0x10,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,5,5,5,5,
5,5,5,6,6,6,6,6,8,6,6,6,6,6,6,6,
6,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0x17,0x17,
5,8,8,5,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,
0x17,0x17,5,0,0,0,0,0,0,0,0,0,8,5,5,5,
5,0x17,0x17,0x17,0x17,6,6,6,6,0x17,8,6,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,5,0x17,5,0x17,0x17,0x17,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,
8,8,6,6,6,6,6,6,6,6,6,8,0,0x58b,0x5cb,0x60b,
0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,
0x784b,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,8,8,8,6,6,6,8,8,
6,8,6,6,0x17,0x17,0x17,0x17,0x17,0x17,6,5,5,6,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
5,0,5,5,5,5,0,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,
5,0x17,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,8,8,8,6,6,6,6,6,
6,6,6,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0,0,0,0,0,0,5,5,8,8,0,0,6,6,
6,6,6,6,6,0,0,0,6,6,6,6,6,0,0,0,
0,0,0,0,0,0,0,0,6,6,8,8,0,5,5,5,
5,5,5,5,5,0,0,5,5,0,0,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,
5,0,5,5,0,5,5,5,5,5,0,6,6,5,8,8,
6,8,8,8,8,0,0,8,8,0,0,8,8,8,0,0,
5,0,0,0,0,0,0,8,0,0,0,0,0,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,8,8,8,6,6,6,6,6,6,6,6,
8,8,6,6,6,8,6,5,5,5,5,0x17,0x17,0x17,0x17,0x17,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0,0x17,6,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
8,8,8,6,6,6,6,6,6,8,6,8,8,8,8,6,
6,8,6,6,5,5,0x17,5,0,0,0,0,0,0,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,
8,8,6,6,6,6,0,0,8,8,8,8,6,6,8,6,
6,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,5,5,5,5,6,6,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
8,8,8,6,6,6,6,6,6,6,6,8,8,6,8,6,
6,0x17,0x17,0x17,5,0,0,0,0,0,0,0,0,0,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,6,8,6,8,8,
6,6,6,6,6,6,8,6,5,0x17,0,0,0,0,0,0,
8,8,6,6,6,6,8,6,6,6,6,6,0,0,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x7cb,0xa4b,0x17,0x17,0x17,0x1b,
5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,6,
6,6,6,6,6,6,6,6,8,6,6,0x17,0,0,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,
0x16cb,0x194b,0x1bcb,0,0,0,0,0,0,0,0,0,0,0,0,5,
8,5,8,6,0x17,0x17,0x17,0,0,0,0,0,0,0,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
5,5,5,5,5,5,5,0,0,5,0,0,5,5,5,5,
5,5,5,5,0,5,5,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,8,8,8,8,8,8,0,8,
8,0,0,6,6,8,6,5,6,5,0x17,5,8,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,8,8,8,6,6,6,6,
0,0,6,6,8,8,8,8,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,
6,8,5,6,6,6,6,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,6,
0,0,0,0,0,0,0,0,5,6,6,6,6,6,6,8,
8,6,6,6,5,5,5,5,5,6,6,6,6,6,6,6,
6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0x17,0x17,0x17,0,0,0,0,0,
0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,
6,6,6,6,6,6,6,8,6,6,0x17,0x17,0x17,5,0x17,0x17,
5,0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,0,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0,0,0,
0x17,0x17,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,8,6,6,6,6,
6,6,6,0,6,6,6,6,6,6,8,6,6,6,6,6,
6,6,6,6,0,8,6,6,6,6,6,6,6,8,6,6,
8,6,6,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0,0,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,6,
0,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0,0,0,0,0,0,5,5,5,5,5,5,5,0,
5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,0,
0,0,6,0,6,6,0,6,5,5,5,5,5,5,5,5,
5,5,8,8,8,8,8,0,6,6,0,8,8,6,8,6,
5,0,0,0,0,0,0,0,5,5,5,5,5,5,0,5,
5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,6,6,8,8,0x17,
0x17,0,0,0,0,0,0,0,6,8,6,0x17,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0,0,0,0,0,0,6,6,5,8,5,5,5,5,
5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
8,8,6,6,6,6,6,0,0,0,8,8,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x19,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,
0,0,0,0,0,0,0,0,0,0,0,0x17,0xcd0b,0xcc0b,0xcb0b,0xd00b,
0xca0b,0xcf0b,0xcb4b,0xd04b,0xc90b,0x37cb,0x37cb,0x364b,0x35cb,0xc94b,0x3fcb,0x350b,0x34cb,0x344b,0x344b,0x3ccb,
0xcd0b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x19,0x19,0x19,0x34ca,0x354a,0x34ca,0x34ca,
0x344a,0x348a,0x388a,0xf4a,0x11ca,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0,0x17,0x17,0x17,0x17,
0x17,0,0,0,0,0,0,0,0,0,0,0,0x5ca,0x60a,0x64a,0x68a,
0x6ca,0x70a,0x74a,0x78a,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x64a,0x68a,0x6ca,0x70a,0x74a,
0x78a,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x58a,0x5ca,0x60a,0x64a,0x68a,0x5ca,
0x60a,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x58a,0x5ca,0x60a,0x60a,0x64a,0x68a,0xc08a,0xc18a,
0x58a,0x5ca,0x60a,0x60a,0x64a,0x68a,0x60a,0x60a,0x64a,0x64a,0x64a,0x64a,0x6ca,0x70a,0x70a,0x70a,
0x74a,0x74a,0x78a,0x78a,0x78a,0x78a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x58a,0x5ca,0x60a,0x64a,0x64a,
0x68a,0x68a,0x5ca,0x60a,0x58a,0x5ca,0x348a,0x388a,0x454a,0x348a,0x388a,0x35ca,5,5,5,5,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0x17,0x17,0,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0x10,0x10,0x10,0x10,
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,6,5,5,5,
5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,0,0,0,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
6,6,6,6,6,0x17,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
6,6,6,6,6,6,6,0x17,0x17,0x17,0x17,0x17,0x1b,0x1b,0x1b,0x1b,
4,4,4,4,0x17,0x1b,0,0,0,0,0,0,0,0,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0x7cb,0x1e4b,0x788b,0x790b,0x798b,
0x7a0b,0x7a8b,0,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0,0,0,0,0,5,5,5,
0x54b,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0x80b,0x84b,0x88b,0x8cb,0x90b,
0x94b,0x98b,0x9cb,0xa0b,0x58b,0x5cb,0x60b,0x17,0x17,0x17,0x17,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,6,
5,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,0,0,0,0,0,0,0,6,6,6,6,4,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,0x17,4,
6,0,0,0,0,0,0,0,0,0,0,0,8,8,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,4,4,4,4,0,4,4,4,4,4,4,4,
0,4,4,0,5,5,5,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,5,5,5,0,0,5,0,0,
0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,0,0,0x1b,6,6,0x17,
0x10,0x10,0x10,0x10,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,0,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,
0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,8,8,6,6,6,0x1b,0x1b,
0x1b,8,8,8,8,8,8,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,6,
6,6,6,6,6,6,6,0x1b,0x1b,6,6,6,6,6,6,6,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,6,6,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,6,
6,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x54b,0x58b,0x5cb,0x60b,
0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0x80b,0x84b,0x88b,0x8cb,0x90b,0x94b,0x98b,0x9cb,0xa0b,
0,0,0,0,0,0,0,0,0,0,0,0,0x58b,0x5cb,0x60b,0x64b,
0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x58b,0x5cb,
0x60b,0x64b,0x68b,0x58b,0x68b,0,0,0,0,0,0,0,0x249,0x289,0x49,0x89,
0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,0,2,2,2,2,2,2,2,2,2,2,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
1,0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,
1,0,1,1,1,1,1,1,1,1,2,2,2,2,0,2,
0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,
2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,2,2,2,2,1,1,0,1,1,1,1,0,
0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,
1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,1,
1,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,
1,1,1,1,1,0,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,2,2,2,2,2,2,0,0,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,0x18,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0x18,
2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x18,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,0x18,2,2,2,2,2,2,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,0x18,
2,2,2,2,2,2,1,2,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
0x1c9,0x209,0x249,0x289,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,0x1b,0x1b,0x1b,0x1b,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,0x1b,0x1b,0x17,0x17,0x17,0x17,0x17,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,6,6,6,6,6,6,0,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,0,0,6,6,6,6,6,
2,2,2,2,2,2,2,2,2,2,5,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,
0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
6,6,0,6,6,0,6,6,6,6,6,0,0,0,0,0,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,5,0x1b,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,
6,6,6,6,6,6,6,4,4,4,4,4,4,4,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0x19,
5,5,5,5,5,5,5,5,5,5,5,4,6,6,6,6,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
5,5,5,5,5,5,5,0,5,5,5,5,0,5,5,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
5,5,5,5,5,0,0,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,
6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,
2,2,2,2,6,6,6,6,6,6,6,4,0,0,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0x17,0x17,
1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,
0x78cb,0x794b,0x814b,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x1b,0x34cb,0x344b,0x3ccb,
0x19,0x58b,0x5cb,0x788b,0x78cb,0,0,0,0,0,0,0,0,0,0,0,
0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0x784b,0x804b,0x884b,0x904b,
0x984b,0xa04b,0xa84b,0xb04b,0xb84b,0x788b,0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,0xb08b,0xb88b,0x78cb,0x80cb,
0x984b,0xa04b,0xa84b,0xb04b,0xb84b,0x788b,0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,0xb08b,0xb88b,0x1b,0x5cb,
0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0x900b,0xa00b,0x804b,0x788b,0x344b,0x354b,0,0,
0,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,
0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0x784b,0x804b,0x884b,0x904b,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x18,0x18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0,5,5,0,5,0,0,5,0,5,5,5,5,5,5,5,
5,5,5,0,5,5,5,5,0,5,0,5,0,0,0,0,
0,0,5,0,0,0,0,5,0,5,0,5,0,5,5,5,
0,5,5,0,5,0,0,5,0,5,0,5,0,5,0,5,
0,5,5,0,5,0,0,5,5,5,5,0,5,5,5,5,
5,5,5,0,5,5,5,5,0,5,5,5,5,0,5,0,
5,5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,
0,5,5,5,0,5,5,5,5,5,0,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x2cb,0x2cb,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x54b,0x54b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,
0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1a,0x1a,0x1a,0x1a,0x1a,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0x1b,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,
0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,
0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,5,0x705,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0x645,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0x645,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0x685,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,0xcc5,5,5,5,5,5,5,5,5,0xf45,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0xf45,5,5,5,
5,5,5,5,5,5,5,5,5,5,0x6c5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0x605,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0x605,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0x605,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,0x605,5,5,5,5,5,5,5,5,5,5,5,5,
5,0x645,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0x785,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
0x10,0x10,0x10,0x10,0,0x10,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
0x11,0x11,0,0,0,0,0,0
};

inline constexpr struct propstrie_t{
	/* protected: used by macros and functions for reading values */
	const uint16_t *index;
	int32_t indexLength;

	/* Start of the last range which ends at U+10ffff, and its value. */
	char32_t highStart;
	int32_t highValueIndex;
}propstrie{
	props_index,
	4692,
	0x110000,
	0x59e4
};

//file_end

		#line 46 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/convert.hpp"
//convert.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/convert.hpp"
typedef string_view_t<char8_t>string_view_u8_t;
typedef string_view_t<char16_t>string_view_u16_t;
typedef string_view_t<char32_t>string_view_u32_t;

inline constexpr size_t utf16_to_utf8_code_size  = 2;
inline constexpr size_t utf32_to_utf8_code_size  = 4;
inline constexpr size_t utf32_to_utf16_code_size = 2;

template<class char_T>
inline constexpr size_t to_u32_code_size=sizeof(char32_t)/sizeof(char_T);

using range_n::npos;
inline namespace convert_impl{
	inline constexpr size_t decode_utf8(char32_t *out, const char8_t *in, size_t in_size_max)noexcept{
		push_and_disable_msvc_warning(26494);//未初始化警告diss
		char8_t code1, code2, code3, code4;
		pop_msvc_warning();
		code1 = *in++;
		if(code1 < 0x80){ /* 1-byte sequence */
			*out = code1;
			return 1;
		}
		elseif(code1 < 0xC2)
			return npos;
		elseif(code1 < 0xE0){ /* 2-byte sequence */
			if(in_size_max < 2)
				return npos;
			code2 = *in++;
			if((code2 & 0xC0) != 0x80)
				return npos;
			*out = (code1 << 6) + code2 - 0x3080;
			return 2;
		}
		elseif(code1 < 0xF0){ /* 3-byte sequence */
			if(in_size_max < 3)
				return npos;
			code2 = *in++;
			if((code2 & 0xC0) != 0x80)
				return npos;
			if(code1 == 0xE0 && code2 < 0xA0)
				return npos;
			code3 = *in++;
			if((code3 & 0xC0) != 0x80)
				return npos;
			*out = (code1 << 12) + (code2 << 6) + code3 - 0xE2080;
			return 3;
		}
		elseif(code1 < 0xF5){ /* 4-byte sequence */
			if(in_size_max < 4)
				return npos;
			code2 = *in++;
			if((code2 & 0xC0) != 0x80)
				return npos;
			if(code1 == 0xF0 && code2 < 0x90)
				return npos;
			if(code1 == 0xF4 && code2 >= 0x90)
				return npos;
			code3 = *in++;
			if((code3 & 0xC0) != 0x80)
				return npos;
			code4 = *in++;
			if((code4 & 0xC0) != 0x80)
				return npos;
			*out = (code1 << 18) + (code2 << 12) + (code3 << 6) + code4 - 0x3C82080;
			return 4;
		}
		else
			return npos;
	}
	inline constexpr size_t get_decode_utf8_size(const char8_t* in)noexcept{
		if(*in < 0x80) /* 1-byte sequence */
			return 1;
		elseif(*in < 0xC2)
			return npos;
		elseif(*in < 0xE0) /* 2-byte sequence */
			return 2;
		elseif(*in < 0xF0) /* 3-byte sequence */
			return 3;
		elseif(*in < 0xF5) /* 4-byte sequence */
			return 4;
		else
			return npos;
	}
	inline constexpr size_t decode_utf16(char32_t *out, const char16_t *in, size_t in_size_max)noexcept{
		const char16_t code1 = *in++;
		if(code1 >= 0xD800 && code1 < 0xDC00){ /* surrogate pair */
			if(in_size_max < 2)
				return npos;
			const char16_t code2 = *in++;
			if(code2 >= 0xDC00 && code2 < 0xE000){
				*out = (code1 << 10) + code2 - 0x35FDC00;
				return 2;
			}
			return npos;
		}
		*out = code1;
		return 1;
	}
	inline constexpr size_t get_decode_utf16_size(const char16_t* in)noexcept{
		if(*in >= 0xD800 && *in < 0xDC00) /* surrogate pair */
			return 2;
		else
			return 1;
	}
	inline constexpr size_t encode_utf8(char8_t *out, char32_t in)noexcept{
		if(in < 0x80){
			*out++ = (char8_t)in;
			return 1;
		}
		elseif(in < 0x800){
			*out++ = char8_t((in >> 6) + 0xC0);
			*out++ = char8_t((in & 0x3F) + 0x80);
			return 2;
		}
		elseif(in < 0x10000){
			*out++ = char8_t((in >> 12) + 0xE0);
			*out++ = ((in >> 6) & 0x3F) + 0x80;
			*out++ = (in & 0x3F) + 0x80;
			return 3;
		}
		elseif(in < 0x110000){
			*out++ = char8_t((in >> 18) + 0xF0);
			*out++ = ((in >> 12) & 0x3F) + 0x80;
			*out++ = ((in >> 6) & 0x3F) + 0x80;
			*out++ = (in & 0x3F) + 0x80;
			return 4;
		}
		return npos;
	}
	inline constexpr size_t get_encode_utf8_size(char32_t in)noexcept{
		if(in < 0x80)
			return 1;
		elseif(in < 0x800)
			return 2;
		elseif(in < 0x10000)
			return 3;
		elseif(in < 0x110000)
			return 4;
		else
			return npos;
	}
	inline constexpr size_t encode_utf16(char16_t *out, char32_t in)noexcept{
		if(in < 0x10000){
			*out++ = char16_t(in);
			return 1;
		}
		elseif(in < 0x110000){
			*out++ = char16_t((in >> 10) + 0xD7C0);
			*out++ = (in & 0x3FF) + 0xDC00;
			return 2;
		}
		return npos;
	}
	inline constexpr size_t get_encode_utf16_size(char32_t in)noexcept{
		if(in < 0x10000)
			return 1;
		elseif(in < 0x110000)
			return 2;
		else
			return npos;
	}
}
template<typename in_char_t, typename out_char_t>
struct code_convert_result {
	bool _success;
	string_view_t<in_char_t> _processed_input;
	string_view_t<out_char_t> _processed_output;
public:
	inline constexpr code_convert_result(bool success, string_view_t<in_char_t> processed_input, string_view_t<out_char_t> processed_output)noexcept:_success(success),_processed_input(processed_input),_processed_output(processed_output){}
	inline constexpr bool success()const noexcept{ return _success; }
	inline constexpr string_view_t<in_char_t> processed_input()const noexcept{ return _processed_input; }
	inline constexpr string_view_t<out_char_t> processed_output()const noexcept{ return _processed_output; }
	inline constexpr explicit operator bool()const noexcept{ return success(); }
};
inline constexpr auto get_utf8_to_utf16_size(const char8_t *in, size_t len)noexcept{
	size_t out_size = 0;
	const auto end = in + len;
	while(in < end){
		char32_t code;
		const auto size = decode_utf8(&code, in, end - in);
		if(size == npos)
			return npos;
		const auto tmp = get_encode_utf16_size(code);
		if(tmp == npos)
			return npos;
		out_size += tmp;
		in += size;
	}
}
inline constexpr auto get_utf8_to_utf16_size(string_view_u8_t in)noexcept{
	return get_utf8_to_utf16_size(in.data(), in.size());
}
inline constexpr auto utf8_to_utf16(char16_t *out, const char8_t *in, size_t len)noexcept{
	const auto end = in + len;
	push_and_disable_msvc_warning(26494);//未初始化警告diss
	char32_t code;
	pop_msvc_warning();
	//for return
	const auto out_start = out;
	const auto in_start = in;
	auto result_builder = [&](bool success)noexcept{
		return code_convert_result<char8_t, char16_t>(success, string_view_t<char8_t>(in_start, in - in_start), string_view_t<char16_t>(out_start, out - out_start));
	};
	while(in < end){
		const auto size = decode_utf8(&code, in, end - in);
		if(size == npos)
			return result_builder(false);
		auto tmp = encode_utf16(out, code);
		if(tmp == npos)
			return result_builder(false);
		out += tmp;
		in += size;
	}
	return result_builder(true);
}
inline constexpr auto utf8_to_utf16(char16_t *out, string_view_u8_t in)noexcept{
	return utf8_to_utf16(out, in.data(), in.size());
}
inline constexpr auto get_utf8_to_utf32_size(const char8_t *in, size_t len)noexcept{
	size_t out_size = 0;
	const auto end = in + len;
	while(in < end){
		const auto tmp = get_decode_utf8_size(in);
		if(tmp == npos)
			return npos;
		in += tmp;
		out_size++;
	}
	return out_size;
}
inline constexpr auto get_utf8_to_utf32_size(string_view_u8_t in)noexcept{
	return get_utf8_to_utf32_size(in.data(), in.size());
}
inline constexpr auto utf8_to_utf32(char32_t *out, const char8_t *in, size_t len)noexcept{
	const auto end = in + len;
	push_and_disable_msvc_warning(26494);//未初始化警告diss
	char32_t code;
	pop_msvc_warning();
	//for return
	const auto out_start = out;
	const auto in_start = in;
	auto result_builder = [&](bool success)noexcept{
		return code_convert_result<char8_t, char32_t>(success, string_view_t<char8_t>(in_start, in - in_start), string_view_t<char32_t>(out_start, out - out_start));
	};
	while(in < end){
		const auto size = decode_utf8(&code, in, end - in);
		if(size == npos)
			return result_builder(false);
		*out++ = code;
		in += size;
	}
	return result_builder(true);
}
inline constexpr auto utf8_to_utf32(char32_t *out, string_view_u8_t in)noexcept{
	return utf8_to_utf32(out, in.data(), in.size());
}
inline constexpr auto get_utf16_to_utf8_size(const char16_t *in, size_t len)noexcept{
	size_t out_size = 0;
	const auto end = in + len;
	while(in < end){
		char32_t code;
		const auto size = decode_utf16(&code, in, end - in);
		if(size == npos)
			return npos;
		const auto tmp = get_encode_utf8_size(code);
		if(tmp == npos)
			return npos;
		out_size += tmp;
		in += size;
	}
	return out_size;
}
inline constexpr auto get_utf16_to_utf8_size(string_view_u16_t in)noexcept{
	return get_utf16_to_utf8_size(in.data(), in.size());
}
inline constexpr auto utf16_to_utf8(char8_t *out, const char16_t *in, size_t len)noexcept{
	const auto end = in + len;
	push_and_disable_msvc_warning(26494);//未初始化警告diss
	char32_t code;
	pop_msvc_warning();
	//for return
	const auto out_start = out;
	const auto in_start = in;
	auto result_builder = [&](bool success)noexcept{
		return code_convert_result<char16_t, char8_t>(success, string_view_t<char16_t>(in_start, in - in_start), string_view_t<char8_t>(out_start, out - out_start));
	};
	while(in < end){
		const auto size = decode_utf16(&code, in, end - in);
		if(size == npos)
			return result_builder(false);
		auto tmp = encode_utf8(out, code);
		if(tmp == npos)
			return result_builder(false);
		out += tmp;
		in += size;
	}
	return result_builder(true);
}
inline constexpr auto utf16_to_utf8(char8_t *out, string_view_u16_t in)noexcept{
	return utf16_to_utf8(out, in.data(), in.size());
}
inline constexpr auto get_utf16_to_utf32_size(const char16_t *in, size_t len)noexcept{
	size_t out_size = 0;
	const auto end = in + len;
	while(in < end){
		char32_t code;
		const auto size = decode_utf16(&code, in, end - in);
		if(size == npos)
			return npos;
		in += size;
		out_size++;
	}
	return out_size;
}
inline constexpr auto get_utf16_to_utf32_size(string_view_u16_t in)noexcept{
	return get_utf16_to_utf32_size(in.data(), in.size());
}
inline constexpr auto utf16_to_utf32(char32_t *out, const char16_t *in, size_t len)noexcept{
	const auto end = in + len;
	//for return
	const auto out_start = out;
	const auto in_start = in;
	auto result_builder = [&](bool success)noexcept{
		return code_convert_result<char16_t, char32_t>(success, string_view_t<char16_t>(in_start, in - in_start), string_view_t<char32_t>(out_start, out - out_start));
	};
	while(in < end){
		char32_t code;
		const auto size = decode_utf16(&code, in, end - in);
		if(size == npos)
			return result_builder(false);
		*out++ = code;
		in += size;
	}
	return result_builder(true);
}
inline constexpr auto utf16_to_utf32(char32_t *out, string_view_u16_t in)noexcept{
	return utf16_to_utf32(out, in.data(), in.size());
}
inline constexpr auto get_utf32_to_utf8_size(const char32_t *in, size_t len)noexcept{
	size_t out_size = 0;
	const auto end = in + len;
	while(in < end){
		const auto tmp = get_encode_utf8_size(*in);
		if(tmp == npos)
			return npos;
		out_size += tmp;
		++in;
	}
	return out_size;
}
inline constexpr auto get_utf32_to_utf8_size(string_view_u32_t in)noexcept{
	return get_utf32_to_utf8_size(in.data(), in.size());
}
inline constexpr auto utf32_to_utf8(char8_t *out, const char32_t *in, size_t len)noexcept{
	const auto end = in + len;
	//for return
	const auto out_start = out;
	const auto in_start = in;
	auto result_builder = [&](bool success)noexcept{
		return code_convert_result<char32_t, char8_t>(success, string_view_t<char32_t>(in_start, in - in_start), string_view_t<char8_t>(out_start, out - out_start));
	};
	while(in < end){
		auto tmp = encode_utf8(out, *in);
		if(tmp == npos)
			return result_builder(false);
		out += tmp;
		++in;
	}
	return result_builder(true);
}
inline constexpr auto utf32_to_utf8(char8_t *out, string_view_u32_t in)noexcept{
	return utf32_to_utf8(out, in.data(), in.size());
}
inline constexpr auto get_utf32_to_utf16_size(const char32_t *in, size_t len)noexcept{
	size_t out_size = 0;
	const auto end = in + len;
	while(in < end){
		const auto tmp = get_encode_utf16_size(*in);
		if(tmp == npos)
			return npos;
		out_size += tmp;
		++in;
	}
	return out_size;
}
inline constexpr auto get_utf32_to_utf16_size(string_view_u32_t in)noexcept{
	return get_utf32_to_utf16_size(in.data(), in.size());
}
inline constexpr auto utf32_to_utf16(char16_t *out, const char32_t *in, size_t len)noexcept{
	const auto end = in + len;
	//for return
	const auto out_start = out;
	const auto in_start = in;
	auto result_builder = [&](bool success)noexcept{
		return code_convert_result<char32_t, char16_t>(success, string_view_t<char32_t>(in_start, in - in_start), string_view_t<char16_t>(out_start, out - out_start));
	};
	while(in < end){
		auto tmp = encode_utf16(out, *in);
		if(tmp == npos)
			return result_builder(false);
		out += tmp;
		++in;
	}
	return result_builder(true);
}
inline constexpr auto utf32_to_utf16(char16_t *out, string_view_u32_t in)noexcept{
	return utf32_to_utf16(out, in.data(), in.size());
}
inline constexpr auto utf32_to_utf8(char32_t ch, char8_t *out)noexcept{
	return utf32_to_utf8(out, &ch, 1);
}
inline constexpr auto utf32_to_utf16(char32_t ch, char16_t *out)noexcept{
	return utf32_to_utf16(out, &ch, 1);
}
inline constexpr auto utf16_to_utf8(char16_t ch, char8_t *out)noexcept{
	return utf16_to_utf8(out, &ch, 1);
}
inline constexpr void utf16_to_utf32(char32_t *out, char16_t in)noexcept=delete;
inline constexpr void utf8_to_utf16(char16_t *out, char8_t in)noexcept=delete;

//

//utf32 to utf32 for compatible
inline constexpr auto utf32_to_utf32(char32_t *out, const char32_t *in, size_t len)noexcept{
	const auto end = in + len;
	//for return
	const auto out_start = out;
	const auto in_start = in;
	auto result_builder = [&](bool success)noexcept{
		return code_convert_result<char32_t, char32_t>(success, string_view_t<char32_t>(in_start, in - in_start), string_view_t<char32_t>(out_start, out - out_start));
	};
	while(in < end){
		*out++ = *in++;
	}
	return result_builder(true);
}
inline constexpr auto utf32_to_utf32(char32_t *out, string_view_u32_t in)noexcept{
	return utf32_to_utf32(out, in.data(), in.size());
}
inline constexpr auto utf32_to_utf32(char32_t ch, char32_t *out)noexcept{
	return utf32_to_utf32(out, &ch, 1);
}

//utf32 to auto
force_inline constexpr auto utf32_to_auto(char32_t *out, const char32_t *in, size_t len)noexcept{
	return utf32_to_utf32(out, in, len);
}
force_inline constexpr auto utf32_to_auto(char16_t *out, const char32_t *in, size_t len)noexcept{
	return utf32_to_utf16(out, in, len);
}
force_inline constexpr auto utf32_to_auto(char8_t *out, const char32_t *in, size_t len)noexcept{
	return utf32_to_utf8(out, in, len);
}
force_inline constexpr auto utf32_to_auto(char32_t *out, string_view_u32_t in)noexcept{
	return utf32_to_utf32(out, in.data(), in.size());
}
force_inline constexpr auto utf32_to_auto(char16_t *out, string_view_u32_t in)noexcept{
	return utf32_to_utf16(out, in.data(), in.size());
}
force_inline constexpr auto utf32_to_auto(char8_t *out, string_view_u32_t in)noexcept{
	return utf32_to_utf8(out, in.data(), in.size());
}
force_inline constexpr auto utf32_to_auto(char32_t ch, char32_t *out)noexcept{
	return utf32_to_utf32(out, &ch, 1);
}
force_inline constexpr auto utf32_to_auto(char32_t ch, char16_t *out)noexcept{
	return utf32_to_utf16(out, &ch, 1);
}
force_inline constexpr auto utf32_to_auto(char32_t ch, char8_t *out)noexcept{
	return utf32_to_utf8(out, &ch, 1);
}

//auto to utf32
force_inline constexpr auto auto_to_utf32(char32_t *out, const char32_t *in, size_t len)noexcept{
	return utf32_to_utf32(out, in, len);
}
force_inline constexpr auto auto_to_utf32(char32_t *out, const char16_t *in, size_t len)noexcept{
	return utf16_to_utf32(out, in, len);
}
force_inline constexpr auto auto_to_utf32(char32_t *out, const char8_t *in, size_t len)noexcept{
	return utf8_to_utf32(out, in, len);
}
force_inline constexpr auto auto_to_utf32(char32_t *out, string_view_u32_t in)noexcept{
	return utf32_to_utf32(out, in.data(), in.size());
}
force_inline constexpr auto auto_to_utf32(char32_t *out, string_view_u16_t in)noexcept{
	return utf16_to_utf32(out, in.data(), in.size());
}
force_inline constexpr auto auto_to_utf32(char32_t *out, string_view_u8_t in)noexcept{
	return utf8_to_utf32(out, in.data(), in.size());
}
force_inline constexpr auto auto_to_utf32(char32_t ch, char32_t *out)noexcept{
	return utf32_to_utf32(out, &ch, 1);
}
force_inline constexpr auto auto_to_utf32(char16_t ch, char32_t *out)noexcept{
	return utf16_to_utf32(out, &ch, 1);
}
force_inline constexpr auto auto_to_utf32(char8_t ch, char32_t *out)noexcept{
	return utf8_to_utf32(out, &ch, 1);
}

//file_end

		#line 47 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/isX.hpp"
//isX.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/isX.hpp"
/* Checks if ch is a lower case letter.*/
inline constexpr bool islower(char_t c)noexcept{
	const uint32_t props=GET_PROPS(c);
	return(GET_CATEGORY(props)==U_LOWERCASE_LETTER);
}

/* Checks if ch is an upper case letter.*/
inline constexpr bool isupper(char_t c)noexcept{
	const uint32_t props=GET_PROPS(c);
	return(GET_CATEGORY(props)==U_UPPERCASE_LETTER);
}

/* Checks if ch is a title case letter; usually upper case letters.*/
inline constexpr bool istitle(char_t c)noexcept{
	const uint32_t props=GET_PROPS(c);
	return(GET_CATEGORY(props)==U_TITLECASE_LETTER);
}

/* Checks if ch is a decimal digit. */
inline constexpr bool isdigit(char_t c)noexcept{
	const uint32_t props=GET_PROPS(c);
	return(GET_CATEGORY(props)==U_DECIMAL_DIGIT_NUMBER);
}

inline constexpr bool isxdigit(char_t c)noexcept{
	/* check ASCII and Fullwidth ASCII a-fA-F */
	if(
		(c<=0x66 && c>=0x41 && (c<=0x46 || c>=0x61)) ||
		(c>=0xff21 && c<=0xff46 && (c<=0xff26 || c>=0xff41))
	){
		return true;
	}

	const uint32_t props=GET_PROPS(c);
	return(GET_CATEGORY(props)==U_DECIMAL_DIGIT_NUMBER);
}

/* Checks if the Unicode character is a letter.*/
inline constexpr bool isalpha(char_t c)noexcept{
	const uint32_t props=GET_PROPS(c);
	return((CAT_MASK(props)&U_GC_L_MASK)!=0);
}

/* Checks if c is a letter or a decimal digit */
inline constexpr bool isalnum(char_t c)noexcept{
	const uint32_t props=GET_PROPS(c);
	return((CAT_MASK(props)&(U_GC_L_MASK|U_GC_ND_MASK))!=0);
}

/* Checks if ch is a unicode character with assigned character type.*/
inline constexpr bool isdefined(char_t c)noexcept{
	const uint32_t props=GET_PROPS(c);
	return(GET_CATEGORY(props)!=0);
}

/* Checks if the Unicode character is a base form character that can take a diacritic.*/
inline constexpr bool isbase(char_t c)noexcept{
	const uint32_t props=GET_PROPS(c);
	return((CAT_MASK(props)&(U_GC_L_MASK|U_GC_N_MASK|U_GC_MC_MASK|U_GC_ME_MASK))!=0);
}

/* Checks if the Unicode character is a control character.*/
inline constexpr bool iscntrl(char_t c)noexcept{
	const uint32_t props=GET_PROPS(c);
	return((CAT_MASK(props)&(U_GC_CC_MASK|U_GC_CF_MASK|U_GC_ZL_MASK|U_GC_ZP_MASK))!=0);
}

inline constexpr bool isISOControl(char_t c)noexcept{
	return (uint32_t)c<=0x9f && (c<=0x1f || c>=0x7f);
}

/* Some control characters that are used as space. */
#define IS_THAT_CONTROL_SPACE(c) \
	(c<=0x9f && ((c>=TAB && c<=CR) || (c>=0x1c && c <=0x1f) || c==0x85))

/* Checks if the Unicode character is a space character.*/
inline constexpr bool isspace(char_t c)noexcept{
	const uint32_t props=GET_PROPS(c);
	return((CAT_MASK(props)&U_GC_Z_MASK)!=0 || IS_THAT_CONTROL_SPACE(c));
}

#undef IS_THAT_CONTROL_SPACE

inline constexpr bool isblank(char_t c)noexcept{
	if((uint32_t)c<=0x9f){
		return c==9 || c==0x20; /* TAB or SPACE */
	}else{
		/* Zs */
		const uint32_t props=GET_PROPS(c);
		return(GET_CATEGORY(props)==U_SPACE_SEPARATOR);
	}
}

/* Checks if the Unicode character is printable.*/
inline constexpr bool isprint(char_t c)noexcept{
	const uint32_t props=GET_PROPS(c);
	/* comparing ==0 returns false for the categories mentioned */
	return((CAT_MASK(props)&U_GC_C_MASK)==0);
}

inline constexpr bool isgraph(char_t c)noexcept{
	const uint32_t props=GET_PROPS(c);
	/* comparing ==0 returns false for the categories mentioned */
	return((CAT_MASK(props)&
					(U_GC_CC_MASK|U_GC_CF_MASK|U_GC_CS_MASK|U_GC_CN_MASK|U_GC_Z_MASK))
				   ==0);
}

inline constexpr bool ispunct(char_t c)noexcept{
	const uint32_t props=GET_PROPS(c);
	return((CAT_MASK(props)&U_GC_P_MASK)!=0);
}

//file_end

		#line 48 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/marcos/_undefs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/marcos/_undefs.hpp"
#undef U_MASK

#undef GET_CATEGORY

#undef CAT_MASK

#undef _UTRIE_INDEX_FROM_SUPP

#undef _UTRIE_INDEX_RAW

#undef _UTRIE_INDEX_FROM_CP

#undef _UTRIE_GET

#undef UTRIE_GET16

#undef GET_PROPS

//file_end

		#line 49 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/_body.hpp"

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

		#line 51 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/char_set/_body.hpp"
	}
#endif

//file_end

	#line 40 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/decl_system_type.hpp"
//decl_system_type.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/decl_system_type.hpp"
//copy&rewrite from steve02081504/steve.h
#define linux 2
#define windows 3
#define other 4
#if defined(__linux)||defined(__linux__)||defined(__gnu_linux__)
	#define SYSTEM_TYPE linux
#elif defined(_WIN32)||defined(__MINGW32__)||defined(__CYGWIN__)
	#define SYSTEM_TYPE windows
#else
	#define SYSTEM_TYPE other
#endif
#define ERROR_MSG_UNABLE_OS "Unable OS,edit this file on your own or contact ELC's producers."

//file_end

	#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"
	#if SYSTEM_TYPE == windows
		#define NOMINMAX
		#include <Windows.h>
		#include <debugapi.h>
	#endif
	/// @brief 终止报错相关基础函数
	namespace elc::APIs::die{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

		#line 49 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"

		using namespace elc::defs;

		struct die_state{
			#if SYSTEM_TYPE == windows
				HANDLE hConsole;
				//text_color
				WORD text_color;
			#elif SYSTEM_TYPE == linux
				//nothing
			#endif
		};

		inline void Init_die_state(die_state&state)noexcept{
			#if SYSTEM_TYPE == windows
				state.hConsole=GetStdHandle(STD_ERROR_HANDLE);
				//chenge color to red
				CONSOLE_SCREEN_BUFFER_INFO csbi;
				GetConsoleScreenBufferInfo(state.hConsole,&csbi);
				state.text_color=csbi.wAttributes;
				SetConsoleTextAttribute(state.hConsole,FOREGROUND_RED);
			#elif SYSTEM_TYPE == linux
				//chenge color to red
				fputs("\033[31m",stderr);
			#endif
		}

		inline void ConsoleLog(const die_state&state,string_view_t<char> str)noexcept{
			#if SYSTEM_TYPE == windows
				WriteConsoleA(state.hConsole,str.data(),(DWORD)str.size(),nullptr,nullptr);
			#elif SYSTEM_TYPE == linux
				fputs(str.data(),stderr);
			#endif
		}
		inline void ConsoleLog(const die_state&state,string_view_t<wchar_t> str)noexcept{
			#if SYSTEM_TYPE == windows
				WriteConsoleW(state.hConsole,str.data(),(DWORD)str.size(),nullptr,nullptr);
			#elif SYSTEM_TYPE == linux
				fputws(str.data(),stderr);
			#endif
		}
		inline void ConsoleLogEnd(const die_state&state)noexcept{
			#if SYSTEM_TYPE == windows
				FlushFileBuffers(state.hConsole);
				//chenge color back
				SetConsoleTextAttribute(state.hConsole,state.text_color);
			#elif SYSTEM_TYPE == linux
				fflush(stderr);
				//chenge color back
				fputs("\033[0m",stderr);
			#endif
		}

		/// @brief 终止整个程序并可能的触发断点或输出错误信息
		[[noreturn]]inline void die()noexcept{
			#if SYSTEM_TYPE == windows
				if(IsDebuggerPresent())
					__debugbreak();
			#endif
			#if defined(_WINMAIN_)
				::MessageBoxW(NULL,L"elc died.",NULL,MB_ICONERROR);
			#endif
			die_state state;
			Init_die_state(state);
			ConsoleLog(state,"elc died.\n");
			ConsoleLogEnd(state);
			::std::abort();
		}
		/// @brief 同 die() ，但是有详细的错误信息
		/// @param err_msg 错误信息
		[[noreturn]]inline void die_with(string_view err_msg)noexcept{
			#if SYSTEM_TYPE == windows
				if(IsDebuggerPresent())
					__debugbreak();
			#endif
			if(err_msg){
				if constexpr(wchar_t_same_as_char16_t){
					push_and_disable_msvc_warning(26494);//未初始化警告diss
					wchar_t err_msg_in_wchar[2048];
					pop_msvc_warning();
					const auto size=char_set::utf32_to_utf16((char16_t*)err_msg_in_wchar,err_msg).processed_output().size();
					err_msg_in_wchar[size]=L'\0';
					#if defined(_WINMAIN_)
						::MessageBoxW(NULL,err_msg_in_wchar,NULL,MB_ICONERROR);
					#endif
					die_state state;
					Init_die_state(state);
					ConsoleLog(state,L"elc died because:\n");
					ConsoleLog(state,err_msg_in_wchar);
					ConsoleLog(state,L"\n");
					ConsoleLogEnd(state);
				}
				elseif constexpr(wchar_t_same_as_char_t){
					const string_view_t<wchar_t> err_msg_in_wchar{(const wchar_t*)err_msg.data(),err_msg.size()};
					#if defined(_WINMAIN_)
						::MessageBoxW(NULL,err_msg_in_wchar.data(),NULL,MB_ICONERROR);
					#endif
					die_state state;
					Init_die_state(state);
					ConsoleLog(state,L"elc died because:\n");
					ConsoleLog(state,err_msg_in_wchar);
					ConsoleLog(state,L"\n");
					ConsoleLogEnd(state);
				}
				else{
					::std::mbstate_t stat{};
					push_and_disable_msvc_warning(26494);//未初始化警告diss
					char err_msg_in_char[2048];
					char* err_msg_write = err_msg_in_char;
					size_t s;
					pop_msvc_warning();
					for(auto c:err_msg){
						s = ::std::c32rtomb(err_msg_write, c, &stat);
						push_and_disable_msvc_warning(26475)//强转警告diss
						if(s == range_n::npos)
							die();
						pop_msvc_warning();
						err_msg_write += s;
					}
					*err_msg_write = '\0';
					#if defined(_WINMAIN_)
						::MessageBoxA(NULL,err_msg_in_char,NULL,MB_ICONERROR);
					#endif
					die_state state;
					Init_die_state(state);
					ConsoleLog(state,"elc died because:\n");
					ConsoleLog(state,err_msg_in_char);
					ConsoleLog(state,"\n");
					ConsoleLogEnd(state);
				}
			}
			else
				die();
			::std::abort();
		}

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

		#line 186 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"
	}
	//
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/undef_decl_system_type.hpp"
//undef_decl_system_type.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/undef_decl_system_type.hpp"
//copy&rewrite from steve02081504/evest.h
#undef linux
#undef windows
#undef other
#undef SYSTEM_TYPE
#undef ERROR_MSG_UNABLE_OS

//file_end

	#line 189 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"

	namespace elc::defs{
		using elc::APIs::die::die;
		using elc::APIs::die::die_with;
	}
#endif

//file_end

#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
//include locale：自然语言相关的字符串
//strings
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
//using.hpp
#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
#if !defined(ELC_LOCALE)
	#define ELC_LOCALE
	#include <locale>
	//
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
//base_defs
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#line 51 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"

//file_end

	#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	//
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

	#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/zh_cn.hpp"
//zh_cn.hpp
#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/zh_cn.hpp"
namespace elc::defs::locale::func{

}
namespace elc::defs::locale::str{
	inline namespace gc{
		inline constexpr auto gc_fail=es"gc失败"_constexpr_str;
		inline constexpr auto empty_gc_method=es"gc方法为空时gc被调用"_constexpr_str;
	}
	inline namespace code_convert{
		inline constexpr auto setlocale_error=es"setlocale出错"_constexpr_str;
		inline constexpr auto code_convert_error=es"编码转换出错"_constexpr_str;
	}
	inline namespace lib_load{
		inline constexpr auto null_lib=es"访问null处的lib对象"_constexpr_str;
	}
	inline namespace exception{
		inline constexpr auto unknow_error=es"未知错误"_constexpr_str;
		inline constexpr auto core_runtime_internal_helper_leak=es"未知错误"_constexpr_str;
	}
	inline namespace base_read{
		inline constexpr auto ending_of_expr_beyond_expectations=es"表达式的结尾超出预期"_constexpr_str;
		inline constexpr auto expr_incomplete=es"表达式未完成"_constexpr_str;
		inline constexpr auto symbol_is_undefined=es"此符号未定义"_constexpr_str;
		inline constexpr auto expr_too_outrageous=es"表达式过于离谱"_constexpr_str;
	}
	inline namespace package_symbol_loader{
		inline constexpr auto load_failed=es"无法加载的package_symbol_loader"_constexpr_str;
		inline constexpr auto load_interface_failed=es"package_symbol_loader缺失load_interface"_constexpr_str;
	}
	inline namespace streams{
		inline constexpr auto stream_read_error=es"流读取错误"_constexpr_str;
		inline constexpr auto stream_write_error=es"流写入错误"_constexpr_str;
	}
	inline namespace die{
		//TODO
	}
}

//file_end

	#line 42 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

	#line 43 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	//
#endif

//file_end

#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"

namespace elc::defs{ //在elc::defs中定义内容
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 42 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"

	namespace memory{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/defs.hpp"
namespace lifetime_n{
	class copy_t;

	class move_t;
	//

	template<class T>
	class construct_t;
	template<class T,class...Args>
	constexpr bool construct_able=::std::is_constructible_v<T,Args...>;
	template<class T,class...Args>
	constexpr bool construct_nothrow=::std::is_nothrow_constructible_v<T,Args...>;
	template<class T,class...Args>
	constexpr bool construct_trivial=::std::is_trivially_constructible_v<T,Args...>;

	class destruct_t;
	template<class T>
	constexpr bool destruct_able=::std::is_destructible_v<T>;
	template<class T>
	constexpr bool destruct_nothrow=::std::is_nothrow_destructible_v<T>;
	template<class T>
	constexpr bool destruct_trivial=::std::is_trivially_destructible_v<T>;
	//

	class copy_construct_t;
	template<class T>
	constexpr bool copy_construct_able=::std::is_copy_constructible_v<T>;
	template<class T>
	constexpr bool copy_construct_nothrow=::std::is_nothrow_copy_constructible_v<T>;
	template<class T>
	constexpr bool copy_construct_trivial=::std::is_trivially_copy_constructible_v<T>;

	class move_construct_t;
	template<class T>
	constexpr bool move_construct_able=::std::is_move_constructible_v<T>;
	template<class T>
	constexpr bool move_construct_nothrow=::std::is_nothrow_move_constructible_v<T>;
	template<class T>
	constexpr bool move_construct_trivial=::std::is_trivially_move_constructible_v<T>;
	//

	class copy_assign_t;
	template<class T>
	constexpr bool copy_assign_able=::std::is_copy_assignable_v<T>;
	template<class T>
	constexpr bool copy_assign_nothrow=::std::is_nothrow_copy_assignable_v<T>;
	template<class T>
	constexpr bool copy_assign_trivial=::std::is_trivially_copy_assignable_v<T>;

	class move_assign_t;
	template<class T>
	constexpr bool move_assign_able=::std::is_move_assignable_v<T>;
	template<class T>
	constexpr bool move_assign_nothrow=::std::is_nothrow_move_assignable_v<T>;
	template<class T>
	constexpr bool move_assign_trivial=::std::is_trivially_move_assignable_v<T>;
	//

	template<class T> requires ::std::is_trivially_copyable_v<T>
	force_inline T* super_speed_trivial_copy_from_one(T*to,const T&value,size_t size)noexcept{
		if constexpr(sizeof(T)==sizeof(unsigned char))
			::std::memset((unsigned char*)to,(unsigned char)value,size);
		elseif constexpr(sizeof(T)==sizeof(wchar_t))
			::std::wmemset((wchar_t*)to,(wchar_t)value,size);
		else
			if(is_all_byte_zero(value))
				::std::memset(to,zero,size*sizeof(T));
			else
				::std::fill_n(to,size,value);
		return to;
	}
	template<class T> requires ::std::is_trivially_copyable_v<T>
	force_inline T* super_speed_trivial_copy_from_one(T*to,const T&value)noexcept{
		if constexpr(sizeof(T)>=sizeof(::std::max_align_t))
			if(is_all_byte_zero(value))
				::std::memset(to,zero,sizeof(T));
			else
				*to=value;
		else
			*to=value;
		return to;
	}

	/*!
	所有的construct_t实例都派生于此
	*/
	struct base_construct_t{};
	/*!
	用于构造实例
	用法详见变量模板construct
	*/
	template<typename T>
	struct construct_t:base_construct_t{
		typedef base_construct_t base_t;
		template<class...Args>
		static constexpr bool able=construct_able<T,Args...>;
		template<class...Args>
		static constexpr bool nothrow=construct_nothrow<T,Args...>;
		template<class...Args>
		static constexpr bool trivial=construct_trivial<T,Args...>;

		template<class...Args> requires able<Args...>
		[[nodiscard]]force_inline T operator()(Args&&...rest)const noexcept(nothrow<Args...>){
			return T(forward<Args>(rest)...);
		}
		struct array_construct_t{
			T*_to;
			size_t _size;
			constexpr void never_in_array_check()const noexcept{
				if constexpr(type_info<T>.has_attribute(never_in_array))
					template_error("You can\'t construct an array for never_in_array type.");
			}
			template<class...Args> requires able<Args...>
			force_inline void base_call(Args&&...rest)const noexcept(nothrow<Args...>){
				auto tmp=_size;
				while(tmp--)new(_to+tmp)T(forward<Args>(rest)...);
			}
			template<class...Args> requires able<Args...>
			force_inline T* operator()(Args&&...rest)const noexcept(nothrow<Args...>){
				never_in_array_check();
				base_call(forward<Args>(rest)...);
				return _to;
			}
			//复制构造速度优化
			force_inline T* operator()(const T&v)const noexcept(nothrow<const T&>)requires able<const T&>{
				never_in_array_check();
				if constexpr(trivial<const T&> && ::std::is_trivially_copyable_v<T>)
					super_speed_trivial_copy_from_one(_to,v,_size);
				else
					base_call(forward<const T&>(v));
				return _to;
			}
			//默认构造逻辑优化
			force_inline T* operator()()const noexcept(nothrow<>)requires able<>{
				never_in_array_check();
				if constexpr(!trivial<>)
					base_call();
				return _to;
			}
		};
		struct placement_construct_t{
			T*_to;
			template<class...Args> requires able<Args...>
			force_inline void base_call(Args&&...rest)const noexcept(nothrow<Args...>){
				new(_to)T(forward<Args>(rest)...);
			}
			template<class...Args> requires able<Args...>
			force_inline T* operator()(Args&&...rest)const noexcept(nothrow<Args...>){
				base_call(forward<Args>(rest)...);
				return _to;
			}
			//复制构造速度优化
			force_inline T* operator()(const T&v)const noexcept(nothrow<const T&>)requires able<const T&>{
				if constexpr(trivial<const T&> && ::std::is_trivially_copyable_v<T>)
					super_speed_trivial_copy_from_one(_to,v);
				else
					base_call(forward<const T&>(v));
				return _to;
			}
			//默认构造逻辑优化
			force_inline T* operator()()const noexcept(nothrow<>)requires able<>{
				if constexpr(!trivial<>)
					base_call();
				return _to;
			}
			[[nodiscard]]force_inline constexpr array_construct_t operator[](size_t size)const noexcept{return{_to,size};}
		};
		[[nodiscard]]force_inline constexpr placement_construct_t operator[](T*p)const noexcept{return{p};}
	};
	/*!
	constexpr变量模板，用于构造实例
	用法：
	construct<类型>.able<构造参数类型>		->	bool
	construct<类型>.nothrow<构造参数类型>	->	bool
	construct<T>(参数)						->	T		（以参数构建T类型实例）

	construct<T>[T*ptr](参数)				->	T*		（以参数在ptr地址处构建T类型实例，返回ptr）
	construct<T>[T*ptr][size_t size](参数)	->	T*		（以参数在ptr地址处构建size个T类型实例，返回ptr）
	*/
	template<typename T>
	constexpr construct_t<T>construct{};

	/*!
	用于销毁实例
	用法：
	destruct.able<类型>		->	bool
	destruct.nothrow<类型>	->	bool

	destruct(T*ptr)					-> void		（在ptr地址处析构T类型实例，T可为数组）
	destruct[size_t size](T*ptr)	-> void		（析构以ptr地址起始共size个T类型实例，T可为数组）
	*/
	constexpr struct destruct_t{
		template<class T>
		static constexpr bool able=destruct_able<T>;
		template<class T>
		static constexpr bool nothrow=destruct_nothrow<T>;
		template<class T>
		static constexpr bool trivial=destruct_trivial<T>;

		template<class T> requires able<T>
		static force_inline void base_call([[maybe_unused]]T*to)noexcept(nothrow<T>){
			if constexpr(!trivial<T>)
				if constexpr(::std::is_array_v<T>)
					for(auto&i : *to)
						base_call(addressof(i));
				else
					push_and_disable_msvc_warning(26457)
					to->~T();
					pop_msvc_warning()
		}

		template<class T> requires able<T>
		static void base_call([[maybe_unused]]T*begin,[[maybe_unused]]size_t size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
			if constexpr(!trivial<T>)
				while(size--)base_call(begin+size);
		}

		template<class T> requires able<T>
		force_inline void operator()(T*begin)const noexcept(nothrow<T>){
			base_call(begin);
		}

		struct array_destruct_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline void operator()(T*begin)const noexcept(nothrow<T>){
				base_call(begin,_size);
			}
		};

		[[nodiscard]]force_inline constexpr array_destruct_t operator[](size_t size)const noexcept{return{size};}

		struct not_t{};
		/*适用于unget(this,not destruct);*/
		force_inline constexpr not_t operator!()const noexcept{return not_t{};}
	}destruct{};

	/*!
	用于重新构造实例：先摧毁，再原地构建
	用法：
	re_construct.able<类型>		->	bool
	re_construct.nothrow<类型>	->	bool

	re_construct(T*ptr)						->	T*		（以无参数在ptr地址处重新构建T类型实例，返回ptr）
	re_construct[T*ptr](参数)				->	T*		（以参数在ptr地址处重新构建T类型实例，返回ptr）
	re_construct[T*ptr][size_t size](参数)	->	T*		（以参数在ptr地址处重新构建size个T类型实例，返回ptr）
	常见用法：
	re_construct(this)
	*/
	constexpr struct re_construct_t{
		template<class T,class...Args>
		static constexpr bool able=destruct.able<T>&&construct<T>.able<Args...>;
		template<class T,class...Args>
		static constexpr bool nothrow=destruct.nothrow<T>&&construct<T>.nothrow<Args...>;
		template<class T,class...Args>
		static constexpr bool trivial=destruct.trivial<T>&&construct<T>.trivial<Args...>;

		template<class T> requires able<T>
		force_inline T* operator()(T*to)const noexcept(nothrow<T>){
			destruct(to);
			construct<T>[to]();
			return to;
		}
		template<class T>
		struct array_re_construct_t{
			T*_to;
			size_t _size;
			template<class...Args> requires able<T,Args...>
			T* operator()(Args&&...rest)const noexcept(nothrow<T,Args...>){
				if constexpr(type_info<T>.has_attribute(never_in_array))
					template_error("You cannot perform array operations on never_in_array type.");
				destruct[_size](_to);
				construct<T>[_to][_size](forward<Args>(rest)...);
				return _to;
			}
		};
		template<class T>
		struct placement_re_construct_t{
			T*_to;
			template<class...Args> requires able<T,Args...>
			T* operator()(Args&&...rest)const noexcept(nothrow<T,Args...>){
				destruct(_to);
				construct<T>[_to](forward<Args>(rest)...);
				return _to;
			}
			[[nodiscard]]force_inline constexpr array_re_construct_t<T> operator[](size_t size)const noexcept{return{_to,size};}
		};
		template<class T>
		[[nodiscard]]force_inline constexpr placement_re_construct_t<T> operator[](T*p)const noexcept{return{p};}
	}re_construct;

	constexpr struct copy_construct_t{
		template<class T>
		static constexpr bool r_able=copy_construct_able<T>?
									 copy_construct_trivial<T>||!(construct<T>.trivial<>&&copy_assign_trivial<T>)
									 :false;//trivial操作优先考虑
		template<class T>
		static constexpr bool able=r_able<T>?true:(construct<T>.able<>&&copy_assign_able<T>);
		template<class T>
		static constexpr bool nothrow=r_able<T>?copy_construct_nothrow<T>:
										(construct<T>.nothrow<>&&copy_assign_nothrow<T>);
		template<class T>
		static constexpr bool trivial=r_able<T>?copy_construct_trivial<T>:
										(construct<T>.trivial<>&&copy_assign_trivial<T>);

		template<class T> requires able<T>
		static T*base_call(T*to,const T*from)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				return reinterpret_cast<T*>(::std::memcpy(to,add_const(from),sizeof(T)));
			else{
				if constexpr(r_able<T>)
					new(to)T(*from);
				else{
					construct<T>[to]();
					*to=*from;
				}
				return to;
			}
		}

		template<class T> requires able<T>
		static T*base_call(T*to,const T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				return reinterpret_cast<T*>(::std::memcpy(to,add_const(from),sizeof(T)*size));
			else{
				while(size--)
					base_call(to+size,from+size);
				return to;
			}
		}

		template<class T> requires able<T>
		force_inline T*operator()(T*to,const T*from)const noexcept(nothrow<T>)
		{return base_call(to,from);}

		template<class T> requires able<T>
		force_inline T*operator()(note::to_t<T*>to,note::from_t<const T*>from)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		template<class T> requires able<T>
		force_inline T*operator()(note::from_t<const T*>from,note::to_t<T*>to)const noexcept(nothrow<T>)
		{return base_call(to(),from());}


		template<class T> requires able<T>
		force_inline T*operator()(T*to,const T*from,size_t size)const noexcept(nothrow<T>)
		{return base_call(to,from,size);}

		template<class T> requires able<T>
		force_inline T*operator()(note::to_t<T*>to,note::from_t<const T*>from,size_t size)const noexcept(nothrow<T>)
		{return base_call(to(),from(),size);}

		template<class T> requires able<T>
		force_inline T*operator()(note::from_t<const T*>from,note::to_t<T*>to,size_t size)const noexcept(nothrow<T>)
		{return base_call(to(),from(),size);}

		template<class T> requires able<T>
		static T*base_call(T*to,const T&from)noexcept(nothrow<T>){
			if constexpr(r_able<T>)
				construct<T>[to](from);
			else{
				construct<T>[to]();
				*to=from;
			}
			return to;
		}

		template<class T> requires able<T>
		static T*base_call(T*to,const T&from,size_t size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
			if constexpr(::std::is_trivially_copyable_v<T>)
				super_speed_trivial_copy_from_one(to,from,size);
			else
				while(size--)
					base_call(to+size,from);
			return to;
		}

		template<class T> requires able<T>
		force_inline T*operator()(T*to,const T&from)const noexcept(nothrow<T>)
		{return base_call(to,from);}

		struct array_copy_construct_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,const T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(T*to,const T&from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<const T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<const T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
		};
		[[nodiscard]]force_inline constexpr array_copy_construct_t operator[](size_t a)const noexcept{return{a};}
	}copy_construct{};

	constexpr struct move_construct_t{
		template<class T>
		static constexpr bool r_able=move_construct_able<T>?
									 move_construct_trivial<T>||!copy_construct.trivial<T>
									 :false;//trivial操作优先考虑
		template<class T>
		static constexpr bool able=r_able<T>?true:copy_construct.able<T>;
		template<class T>
		static constexpr bool nothrow=r_able<T>?move_construct_nothrow<T>:
												copy_construct.nothrow<T>;
		template<class T>
		static constexpr bool trivial=r_able<T>?move_construct_trivial<T>:
												copy_construct.trivial<T>;

		template<class T> requires able<T>
		static T*base_call(T*to,T*from)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				return reinterpret_cast<T*>(::std::memcpy(to,add_const(from),sizeof(T)));
			else{
				if constexpr(r_able<T>){
					construct<T>[to](::std::move(*from));
					return to;
				}else
					return copy_construct(to,from);
			}
		}
		template<class T> requires able<T>
		static T*base_call(T*to,T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
			if constexpr(trivial<T>)
				return reinterpret_cast<T*>(::std::memcpy(to,add_const(from),sizeof(T)*size));
			else{
				if constexpr(r_able<T>){
					while(size--)
						construct<T>[to+size](::std::move(from[size]));
					return to;
				}else
					return copy_construct[size](to,from);
			}
		}

		template<class T> requires able<T>
		force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>)
		{return base_call(to,from);}

		template<class T> requires able<T>
		force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		template<class T> requires able<T>
		force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		struct array_move_construct_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
		};
		[[nodiscard]]force_inline constexpr array_move_construct_t operator[](size_t a)const noexcept{return{a};}
	}move_construct{};

	constexpr struct move_t{
		template<class T>
		static constexpr bool able=move_construct.able<T>&&destruct.able<T>;
		template<class T>
		static constexpr bool nothrow=move_construct.nothrow<T>&&destruct.nothrow<T>;
		template<class T>
		static constexpr bool trivial=move_construct.trivial<T>&&destruct.trivial<T>;

		template<class T> requires able<T>
		static T*base_call(T*to,T*from)noexcept(nothrow<T>){
			move_construct(to,from);
			destruct(from);
			return to;
		}
		template<class T> requires able<T>
		static T*base_call(T*to,T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
			move_construct[size](to,from);
			destruct[size](from);
			return to;
		}

		template<class T> requires able<T>
		force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>)
		{return base_call(to,from);}

		template<class T> requires able<T>
		force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		template<class T> requires able<T>
		force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		struct array_move_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
		};
		[[nodiscard]]force_inline constexpr array_move_t operator[](size_t a)const noexcept{return{a};}

		//特殊使用
		template<class T>
		[[nodiscard]]constexpr remove_ref<T>&& operator()(T&&a)const noexcept{
			return static_cast<remove_ref<T>&&>(a);
		}
	}move{};

	constexpr struct copy_t{
		//特殊使用
		//UF
		template<class T> requires(copy_construct.able<T>)
		[[nodiscard]]constexpr T operator()(const T&a)const noexcept{
			return copy_construct<T>(a);
		}
	}copy{};

	constexpr struct copy_assign_t{
		template<class T>
		static constexpr bool r_able=copy_assign_able<T>?
									 copy_assign_trivial<T>||!(copy_construct_trivial<T>&&destruct.trivial<T>)
									 :false;//trivial操作优先考虑
		template<class T>
		static constexpr bool able=r_able<T>?true:(copy_construct_able<T>&&destruct.able<T>);
		template<class T>
		static constexpr bool nothrow=r_able<T>?copy_assign_nothrow<T>:
											(copy_construct_nothrow<T>&&destruct.nothrow<T>);
		template<class T>
		static constexpr bool trivial=r_able<T>?copy_assign_trivial<T>:
											(copy_construct_trivial<T>&&destruct.trivial<T>);

		template<class T> requires able<T>
		static T& base_call(T&a,const T&b)noexcept(nothrow<T>){
			if constexpr(r_able<T>)
				a=b;
			else{
				destruct(&a);
				construct<T>[&a](b);
			}
			return a;
		}
		template<class T> requires able<T>
		static T* base_call(T*to,const T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				::std::memcpy(to,add_const(from),size*sizeof(T));
			else
				while(size--)
					base_call(to[size],from[size]);
			return to;
		}
		template<class T> requires able<T>
		static T* base_call(T* to,const T& from,size_t size)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				super_speed_trivial_copy_from_one(to,from,size);
			else
				while(size--)
					base_call(to[size],from);
			return to;
		}

		template<class T> requires able<T>
		force_inline T& operator()(T&a,const T&b)const noexcept(nothrow<T>){
			return base_call(a,b);
		}

		struct array_copy_assign_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,const T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<const T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<const T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(const T&from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return base_call(to(),from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,const T&from)const noexcept(nothrow<T>){
				return base_call(to(),from,_size);
			}
		};
		[[nodiscard]]force_inline constexpr array_copy_assign_t operator[](size_t a)const noexcept{return{a};}
	}copy_assign{};

	constexpr struct move_assign_t{
		template<class T>
		static constexpr bool r_able=move_assign_able<T>;
		template<class T>
		static constexpr bool able=r_able<T>?true:copy_assign.able<T>;
		template<class T>
		static constexpr bool nothrow=r_able<T>?move_assign_nothrow<T>:copy_assign.nothrow<T>;
		template<class T>
		static constexpr bool trivial=r_able<T>?move_assign_trivial<T>:copy_assign.trivial<T>;

		template<class T> requires able<T>
		static T& base_call(T&a,T&&b)noexcept(nothrow<T>){
			if constexpr(r_able<T>)
				a=move(b);
			else
				copy_assign(a,b);
			return a;
		}
		template<class T> requires able<T>
		static T* base_call(T*to,T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				::std::memcpy(to,add_const(from),size*sizeof(T));
			else
				while(size--)
					base_call(to[size],from[size]);
			return to;
		}

		template<class T> requires able<T>
		force_inline T& operator()(T&a,T&b)const noexcept(nothrow<T>){
			return base_call(a,move(b));
		}

		struct array_move_assign_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
		};
		[[nodiscard]]force_inline constexpr array_move_assign_t operator[](size_t a)const noexcept{return{a};}
	}move_assign{};
}

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_export.hpp"
//_export.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_export.hpp"
#define export using lifetime_n::
export construct;
export destruct;
export re_construct;
export copy_assign;
export move_assign;
export move;
export copy;
export copy_construct;
export move_construct;
#undef export

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_test.hpp"
//_test.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_test.hpp"
namespace lifetime_n{
	//BLOCK:for debug
	inline void test(){
		ELC_TEST_EVENTNAME("lifetime部分测试");
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
	//BLOCK_END
}

//file_end

	#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_body.hpp"
#endif

//file_end

		#line 45 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
	}
	using namespace memory;
	namespace base{
		//依赖lifetime
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/_body.hpp"
//_body.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/_body.hpp"
//D?
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/flag.hpp"
//flag.hpp
//at namespace elc::defs::base
#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/flag.hpp"
enum class flag_set_type:bool{seted=true,not_set=false};
using enum flag_set_type;
#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/flag.hpp"
class flag{
	bool _m;
public:
	constexpr explicit flag(flag_set_type a=not_set)noexcept:_m(bool(a)){}
	[[nodiscard]]explicit operator bool()const noexcept{return _m;}
	flag(flag&a)noexcept:_m((bool)a){}
	flag(flag&&a)noexcept:_m((bool)a){}
	inline void operator=(flag&)&noexcept=delete;
	inline void operator=(flag&&)&noexcept=delete;
	inline void set()noexcept{_m=true;}
	inline void unset()noexcept{_m=false;}
};

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/mark_type.hpp"
//mark_type.hpp
//at namespace elc::defs::base
#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/mark_type.hpp"
enum class mark_type:bool{marked=true,not_mark=false};
using enum mark_type;
#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/mark_type.hpp"
template<typename T>
class mark_able:non_copyable,non_moveable{
	mutable flag _m;
public:
	constexpr explicit mark_able(mark_type a=not_mark)noexcept:_m(a==not_mark?not_set:seted){};
	inline void mark()const noexcept{_m.set();}
	inline void unmark()const noexcept{_m.unset();}
	[[nodiscard]]bool was_marked()const noexcept{return(bool)_m;}
};

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/iterator.hpp"
//iterator.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/iterator.hpp"
namespace iterator_n{
	using namespace memory;//copy_assign、move_assign
	template<typename base_t_w>
	struct reverse_base_t{
		typedef reverse_base_t<base_t_w> this_t;
		typedef remove_cv<base_t_w> base_t_rw;
		base_t_rw _m;
		template<typename build_base_t_T> requires(construct<base_t_rw>.able<build_base_t_T>)
		constexpr reverse_base_t(build_base_t_T&& a)noexcept(construct<base_t_rw>.nothrow<build_base_t_T>):_m(a){}
		constexpr reverse_base_t(const reverse_base_t&a)noexcept(construct<base_t_rw>.nothrow<const base_t_rw&>):_m(a._m){}
		constexpr reverse_base_t(reverse_base_t&&a)noexcept(construct<base_t_rw>.nothrow<base_t_rw&&>):_m(move(a._m)){}
		constexpr reverse_base_t& operator=(const reverse_base_t&a)&noexcept{_m=a._m;return*this;}
		constexpr reverse_base_t& operator=(const reverse_base_t&&a)&noexcept{_m=move(a._m);return*this;}
		constexpr auto operator==(const reverse_base_t&a)const noexcept{return _m==a._m;}
		constexpr auto operator<=>(const reverse_base_t&a)const noexcept{return _m<=>a._m;}

		static constexpr bool is_pointer=::std::is_pointer_v<base_t_w>;

		[[nodiscard]]static constexpr bool is_get_before_noexcept()noexcept{
			if constexpr(is_pointer)
				return true;
			else return noexcept(declvalue(base_t_w).get_next());
		}
		[[nodiscard]]static constexpr bool is_get_next_noexcept()noexcept{
			if constexpr(is_pointer)
				return true;
			else return noexcept(declvalue(base_t_w).get_before());
		}
		[[nodiscard]]static constexpr bool is_get_handle_noexcept()noexcept{
			if constexpr(is_pointer)
				return true;
			else return noexcept(declvalue(base_t_w).get_handle());
		}

		[[nodiscard]]auto get_before()noexcept(is_get_before_noexcept()){
			if constexpr(is_pointer)
				return _m+1;
			else return ((base_t_w&)_m).get_next();
		}
		[[nodiscard]]auto get_next()noexcept(is_get_next_noexcept()){
			if constexpr(is_pointer)
				return _m-1;
			else return ((base_t_w&)_m).get_before();
		}
		[[nodiscard]]auto get_handle()noexcept(is_get_handle_noexcept()){
			if constexpr(is_pointer)
				return _m;
			else return ((base_t_w&)_m).get_handle();
		}
	};
	template<typename base_t> requires(compare.able<base_t>)
	[[nodiscard]]auto operator<=>(const reverse_base_t<base_t>&a,const reverse_base_t<base_t>&b)noexcept(compare.nothrow<base_t>){
		return compare((const base_t&)b._m,(const base_t&)a._m);
	}
	template<typename base_t,typename T> requires(compare.able<T,base_t> && type_info<remove_cvref<T>> != type_info<reverse_base_t<base_t>::base_t_rw>)
	[[nodiscard]]auto operator<=>(const reverse_base_t<base_t>& a,T&& b)noexcept(compare.nothrow<T,base_t>){
		return compare(b,(const base_t&)a._m);
	}
	template<typename base_t,typename T> requires(compare.able<base_t,T> && type_info<remove_cvref<T>> != type_info<reverse_base_t<base_t>::base_t_rw>)
	[[nodiscard]]auto operator<=>(T&& a,const reverse_base_t<base_t>& b)noexcept(compare.nothrow<base_t,T>){
		return compare((const base_t&)b._m,a);
	}
	template<typename base_t,typename T> requires(equal.able<T,base_t> && type_info<remove_cvref<T>> != type_info<reverse_base_t<base_t>::base_t_rw>)
	[[nodiscard]]auto operator==(const reverse_base_t<base_t>& a,T&& b)noexcept(equal.nothrow<T,base_t>){
		return equal(b,(const base_t&)a._m);
	}
	template<typename base_t,typename T> requires(equal.able<base_t,T> && type_info<remove_cvref<T>> != type_info<reverse_base_t<base_t>::base_t_rw>)
	[[nodiscard]]auto operator==(T&& a,const reverse_base_t<base_t>& b)noexcept(equal.nothrow<base_t,T>){
		return equal((const base_t&)b._m,a);
	}
	template<typename base_t>
	inline void swap(reverse_base_t<base_t>&a,reverse_base_t<base_t>&b)noexcept_as(swap(a._m,b._m))
	{swap(a._m,b._m);}

	template<typename value_t,typename base_t_w>
	class same_base_t{
		template<typename,typename>
		friend class same_base_t;
	protected:
		typedef same_base_t<value_t,base_t_w>this_t;
		typedef remove_cv<base_t_w> base_t_rw;
		//
		mutable base_t_rw _m;
		//
		[[nodiscard]]static constexpr bool is_handle_getter_noexcept()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_handle()))
				return noexcept(declvalue(base_t_w)->get_handle());
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_handle()))
				return noexcept(declvalue(base_t_w).get_handle());
		}
		[[nodiscard]]inline value_t*handle_getter()const noexcept(is_handle_getter_noexcept()){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return ((base_t_w)_m);
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_handle()))
				return ((base_t_w)_m)->get_handle();
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_handle()))
				return ((base_t_w)_m).get_handle();
		}
		//
		[[nodiscard]]static constexpr bool is_value_getter_noexcept()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_value()))
				return noexcept(declvalue(base_t_w)->get_value());
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_value()))
				return noexcept(declvalue(base_t_w).get_value());
		}

		[[nodiscard]]static constexpr auto value_type_getter()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return type_info<decltype(*((base_t_w)_m))>;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_value()))
				return type_info<decltype(((base_t_w)_m)->get_value())>;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_value()))
				return type_info<decltype(((base_t_w)_m).get_value())>;
			else
				return type_info<decltype(*declvalue(value_t*))>;
		}
		typedef decltype(value_type_getter())::template_name type value_type;

		[[nodiscard]]inline value_type value_getter()const noexcept(is_handle_getter_noexcept()){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return *((base_t_w)_m);
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_value()))
				return ((base_t_w)_m)->get_value();
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_value()))
				return ((base_t_w)_m).get_value();
			else
				return *handle_getter();
		}
		//
		[[nodiscard]]static constexpr bool is_next_getter_noexcept()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_next()))
				return noexcept(declvalue(base_t_w)->get_next());
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_next()))
				return noexcept(declvalue(base_t_w).get_next());
		}
		[[nodiscard]]inline base_t_w next_getter()const noexcept(is_next_getter_noexcept()){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return ((base_t_w)_m)+1;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_next()))
				return ((base_t_w)_m)->get_next();
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_next()))
				return ((base_t_w)_m).get_next();
		}
		//
		[[nodiscard]]static constexpr bool is_before_getter_noexcept()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_before()))
				return noexcept(declvalue(base_t_w)->get_before());
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_before()))
				return noexcept(declvalue(base_t_w).get_before());
		}
		[[nodiscard]]inline base_t_w before_getter()const noexcept(is_before_getter_noexcept()){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return ((base_t_w)_m)-1;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_before()))
				return ((base_t_w)_m)->get_before();
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_before()))
				return ((base_t_w)_m).get_before();
		}
	public:
		constexpr void swap_with(this_t&a)noexcept_as(swap(declvalue(base_t_rw&),declvalue(base_t_rw&))){swap(_m,a._m);}
		//
		constexpr same_base_t()noexcept=default;
		template<typename build_base_t_T> requires(construct<base_t_rw>.able<build_base_t_T>)
		constexpr same_base_t(build_base_t_T&&a)noexcept(construct<base_t_rw>.nothrow<build_base_t_T>):_m(a){}
		constexpr same_base_t(const this_t&a)noexcept(construct<base_t_rw>.nothrow<const base_t_rw>):_m(a._m){}
		constexpr same_base_t(this_t&&a)noexcept_as(construct<base_t_rw>.nothrow<base_t_rw&&>):_m(move(a._m)){}
		template<typename other_T,typename other_base_t> requires(construct<base_t_rw>.able<other_base_t>)
		constexpr same_base_t(const same_base_t<other_T,other_base_t>&a)noexcept(construct<base_t_rw>.nothrow<other_base_t>):_m(a._m){}
		~same_base_t()noexcept(destruct.nothrow<base_t_rw>)=default;
		[[nodiscard]]constexpr bool		  operator==(const this_t& a)const noexcept_as(declvalue(base_t_rw) == declvalue(base_t_rw)){ return _m == a._m; }
		[[nodiscard]]constexpr value_t*   operator->()noexcept(is_handle_getter_noexcept()){ return handle_getter(); }
		[[nodiscard]]constexpr value_type operator*()noexcept_as(is_value_getter_noexcept()){ return value_getter(); }
		[[nodiscard]]constexpr			  operator value_t*()noexcept_as(declvalue(this_t).operator->()){ return operator->(); }
		[[nodiscard]]constexpr bool		  operator==(value_t* a)const noexcept(is_handle_getter_noexcept()&&noexcept(pointer_equal(declvalue(value_t*),declvalue(value_t*)))){ return pointer_equal(handle_getter(),a); }
		template<typename other_value_t,typename other_base_t_w> requires(equal.able<base_t_rw,other_base_t_w>)
		[[nodiscard]]constexpr bool operator==(const same_base_t<other_value_t,other_base_t_w>& a)const noexcept(equal.nothrow<base_t_rw,other_base_t_w>){
			return equal(_m,a._m);
		}
		template<typename other_value_t,typename other_base_t_w>
		[[nodiscard]]constexpr auto operator<=>(const same_base_t<other_value_t,other_base_t_w>& a)const noexcept(compare.nothrow<base_t_rw,other_base_t_w>){
			if constexpr(compare.able<base_t_rw,other_base_t_w>)
				return compare(_m,a._m);
		}
		base_t_rw& get_base()noexcept{ return _m; }
		const base_t_rw& get_base()const noexcept{ return _m; }
	};
	template<typename value_t,typename base_t_w>
	inline void swap(same_base_t<value_t,base_t_w>&a,same_base_t<value_t,base_t_w>&b)noexcept_as(a.swap_with(b))
	{a.swap_with(b);}

	template<typename value_t,typename base_t_w>
	struct base_iterator_t:same_base_t<value_t,base_t_w>{
		typedef base_iterator_t<value_t,base_t_w> this_t;
		typedef same_base_t<value_t,base_t_w> base_t;
	protected:
		using base_t::is_before_getter_noexcept;
		using base_t::is_next_getter_noexcept;
		using base_t::before_getter;
		using base_t::next_getter;
		typedef remove_cv<base_t_w> base_t_rw;
	public:
		using base_t::base_t;
		constexpr this_t&operator=(const base_t_rw&a)&noexcept(copy_assign.nothrow<base_t_rw>){copy_assign(base_t::_m,a);return*this;}
		constexpr this_t&operator=(base_t_rw&&a)&noexcept(move_assign.nothrow<base_t_rw>){move_assign(base_t::_m,a);return*this;}
		constexpr this_t&operator++()&noexcept(is_next_getter_noexcept()){return*this=next_getter();}
		constexpr this_t&operator--()&noexcept(is_before_getter_noexcept()){return*this=before_getter();}
		constexpr this_t operator++(int)&noexcept_as(this_t(++declvalue(this_t&))){auto a=*this;operator++();return a;}
		constexpr this_t operator--(int)&noexcept_as(this_t(--declvalue(this_t&))){auto a=*this;operator--();return a;}
		constexpr this_t operator+(ptrdiff_t num)const noexcept_as(this_t(--declvalue(this_t&)),++declvalue(this_t&)){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return base_t::_m+num;
			else{
				auto a=*this;
				if(num>0)
					while(num--)
						++a;
				else
					while(num++)
						--a;
				return a;
			}
		}
		constexpr this_t operator-(ptrdiff_t num)const noexcept_as(declvalue(this_t&)+0){ return *this+(-num); }
	};
	template<typename value_t,typename base_t_w>
	base_iterator_t(base_iterator_t<value_t,base_t_w>) -> base_iterator_t<value_t,base_t_w>;
	template<typename value_t,typename base_t_w>
	base_iterator_t(value_t*) -> base_iterator_t<value_t,base_t_w>;

	template<typename value_t,typename base_t_w=value_t*>
	using iterator_t = base_iterator_t<remove_cvref<value_t>,base_t_w>;
	template<typename value_t,typename base_t_w=const value_t*>
	using const_iterator_t = base_iterator_t<const remove_cvref<value_t>,base_t_w>;
	template<typename value_t,typename base_t_w=value_t*>
	using reverse_iterator_t = base_iterator_t<remove_cvref<value_t>,reverse_base_t<base_t_w>>;
	template<typename value_t,typename base_t_w=const value_t*>
	using reverse_const_iterator_t = base_iterator_t<const remove_cvref<value_t>,reverse_base_t<base_t_w>>;
}
using iterator_n::base_iterator_t;
using iterator_n::iterator_t;
using iterator_n::const_iterator_t;
using iterator_n::reverse_iterator_t;
using iterator_n::reverse_const_iterator_t;

//file_end

#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/list.hpp"
//list.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/list.hpp"
//copy from old ELC
template<typename T>
class list_t;
#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/list.hpp"
template<typename T>
struct cons_t:non_copyable,non_moveable,is_common_attribute(cons_t){
	typedef cons_t<T> this_t;
private:
	friend list_t<T>;
	friend iterator_t<T,this_t*>::base_t;
	typedef attribute<T,this_t> attribute_t;

	mutable this_t*_before;//为了在析构时修改前一项的next，勿删
	mutable this_t*_next;

	[[nodiscard]]this_t*get_before()noexcept{return _before;}
	[[nodiscard]]this_t*get_next()noexcept{return _next;}

	constexpr cons_t(this_t*a,this_t*b):_before(a),_next(b){}

	constexpr void set_before(this_t*a){
		_before=a;
		a->_next=this;
	}
	constexpr void set_next(this_t*a){
		_next=a;
		a->_before=this;
	}
	constexpr void insert_to_before(this_t*a){
		set_before(a->_before);
		set_next(a);
	}
	constexpr void bind_with(this_t*a)noexcept{
		set_next(a);
		set_before(a);
	}
	constexpr void remove_from_list()noexcept{
		_before->set_next(_next);
	}
	[[nodiscard]]constexpr T*get_handle(){
		return attribute_t::get_handle();
	}
public:
	constexpr cons_t()=default;
	~cons_t(){
		remove_from_list();
	}
};
#line 90 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/list.hpp"
template<typename T>
struct list_t{
	typedef list_t<T> this_t;
	typedef cons_t<T> cons;
	typedef iterator_t<T,cons*>iterator;
private:
	cons _begin,_end;
public:
	constexpr list_t()noexcept{_begin.bind_with(&_end);}
	inline constexpr void add(cons*a)noexcept{
		a->insert_to_before(&_end);
	}
	[[nodiscard]]constexpr iterator begin()noexcept{return _begin.get_next();}//这叫头迭代器
	[[nodiscard]]constexpr iterator end()noexcept{return&_end;}//这叫超尾迭代器
	[[nodiscard]]constexpr iterator head()noexcept{return&_begin;}//。。。。这个大概就是超头迭代器了😂
	[[nodiscard]]constexpr bool empty()const noexcept{return _begin.get_next()==&_end;}
};

//file_end

#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/function_base.hpp"
//function_base.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/function_base.hpp"
namespace function_base_n{
	#if !defined(_MSC_VER)
	template<typename>
	struct function_type_getter_helper{};

	template<typename Ret_t,typename T,typename...Args_t,bool nothrow>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)noexcept(nothrow)>
	{using type=Ret_t(Args_t...)noexcept(nothrow);};

	template<typename Ret_t,typename T,typename...Args_t,bool nothrow>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)&noexcept(nothrow)>
	{using type=Ret_t(Args_t...)noexcept(nothrow);};

	template<typename Ret_t,typename T,typename...Args_t,bool nothrow>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const noexcept(nothrow)>
	{using type=Ret_t(Args_t...)noexcept(nothrow);};

	template<typename Ret_t,typename T,typename...Args_t,bool nothrow>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const&noexcept(nothrow)>
	{using type=Ret_t(Args_t...)noexcept(nothrow);};

	template<typename T>
	[[nodiscard]]constexpr auto function_type_getter_conditional_helper()noexcept{
		if constexpr(::std::is_function_v<T>)
			return type_info<T>;
		elseif constexpr(is_pointer<T> && ::std::is_function_v<::std::remove_pointer_t<T>>)//不支持多级函数指针：懒得写（其实挺简单的），而且function_t若支持多级函数指针的推导指引会很不安全
			return function_type_getter_conditional_helper<::std::remove_pointer_t<T>>();
		else
			return type_info<type_name function_type_getter_helper<decltype(&T::operator())>::type>;
	}
	template<typename T>
	struct function_type_getter{
		typedef decltype(function_type_getter_conditional_helper<T>())::template_name type type;
	};

	#line 70 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/function_base.hpp"
	template<typename T>
	using get_function_type=function_type_getter<T>::type;

	#line 77 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/function_base.hpp"
	template<class T,class Func_t=get_function_type<T>>
	class function_data_wrapper_t;
	template<class T,bool nothrow,class Ret_t,class...Args_t>
	struct function_data_wrapper_t<T,Ret_t(Args_t...)noexcept(nothrow)>{
		static_assert(!::std::is_function_v<T>);

		T _value;

		function_data_wrapper_t(T a)noexcept(construct<T>.nothrow<T>):_value(a){}
		~function_data_wrapper_t()noexcept(destruct.nothrow<T>)=default;
		Ret_t operator()(Args_t...args)noexcept(nothrow || invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>){
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		Ret_t operator()(Args_t...args)const noexcept(nothrow || invoke<const T>.with_return_type<Ret_t>.nothrow<Args_t...>){
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		[[nodiscard]]auto&get_data()noexcept{return _value;}
	};
	#else
	//MSVC，我滴垃圾堆
	template<typename>
	struct function_type_getter_helper{};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)>
	{using type=Ret_t(Args_t...);};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)&>
	{using type=Ret_t(Args_t...);};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const>
	{using type=Ret_t(Args_t...);};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const&>
	{using type=Ret_t(Args_t...);};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)noexcept>
	{using type=Ret_t(Args_t...)noexcept;};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)&noexcept>
	{using type=Ret_t(Args_t...)noexcept;};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const noexcept>
	{using type=Ret_t(Args_t...)noexcept;};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const&noexcept>
	{using type=Ret_t(Args_t...)noexcept;};

	template<typename T>
	[[nodiscard]]constexpr auto function_type_getter_conditional_helper()noexcept{
		if constexpr(::std::is_function_v<T>)
			return type_info<T>;
		elseif constexpr(is_pointer<T> && ::std::is_function_v<::std::remove_pointer_t<T>>)//不支持多级函数指针：懒得写（其实挺简单的），而且function_t若支持多级函数指针的推导指引会很不安全
			return function_type_getter_conditional_helper<::std::remove_pointer_t<T>>();
		else
			return type_info<type_name function_type_getter_helper<decltype(&T::operator())>::type>;
	}
	template<typename T>
	struct function_type_getter{
		typedef decltype(function_type_getter_conditional_helper<T>())::template_name type type;
	};

	#line 168 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/function_base.hpp"
	template<typename T>
	using get_function_type=function_type_getter<T>::type;

	#line 175 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/function_base.hpp"
	template<class T,class Func_t=get_function_type<T>>
	class function_data_wrapper_t;
	template<class T,class Ret_t,class...Args_t>
	struct function_data_wrapper_t<T,Ret_t(Args_t...)noexcept>{
		static_assert(!::std::is_function_v<T>);

		T _value;

		function_data_wrapper_t(T a)noexcept(construct<T>.nothrow<T>):_value(a){}
		~function_data_wrapper_t()noexcept(destruct.nothrow<T>)=default;
		Ret_t operator()(Args_t...args)noexcept{
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>)
				template_warning("this T may throw an exception.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		Ret_t operator()(Args_t...args)const noexcept{
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>)
				template_warning("this T may throw an exception.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		[[nodiscard]]auto&get_data()noexcept{return _value;}
	};
	#line 219 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/function_base.hpp"
	template<class T,class Ret_t,class...Args_t>
	struct function_data_wrapper_t<T,Ret_t(Args_t...)>{
		static_assert(!::std::is_function_v<T>);

		T _value;

		function_data_wrapper_t(T a)noexcept(construct<T>.nothrow<T>):_value(a){}
		~function_data_wrapper_t()noexcept(destruct.nothrow<T>)=default;
		Ret_t operator()(Args_t...args)noexcept(invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>){
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		Ret_t operator()(Args_t...args)const noexcept(invoke<const T>.with_return_type<Ret_t>.nothrow<Args_t...>){
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		[[nodiscard]]auto&get_data()noexcept{return _value;}
		[[nodiscard]]const auto&get_data()const noexcept{return _value;}
	};
	#endif
}
using function_base_n::get_function_type;
using function_base_n::function_data_wrapper_t;

//file_end

#line 38 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/_body.hpp"

//file_end

		#line 49 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
	}

	namespace memory{
		//依赖list
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/defs.hpp"
/// @brief 提供gc定义
namespace gc_n{
	/// @brief 当alloc失败时调用此函数
	void gc_for_alloc()noexcept;
}
/// @brief 底层内存管理泛用类型的模板定义
namespace alloc_n{
	using ::elc::defs::memory::gc_n::gc_for_alloc;

	//允许自定义对象的alloc/free/realloc/get_size_of_alloc方法：为pool留的后门（大概）
	//这里是缺省时的默认方法定义
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/default_method/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory::alloc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/default_method/defs.hpp"
namespace default_method{
	//BLOCK:for debug
	#if defined(_MSC_VER)
		#if defined(ELC_TEST_CHECK_MEMORY_LACK)
			#pragma detect_mismatch("ELC_TEST_CHECK_MEMORY_LACK","true")
		#else
			#pragma detect_mismatch("ELC_TEST_CHECK_MEMORY_LACK","false")
		#endif
	#endif

	/*!
	Reallocates a block of memory.

	@param ptr The pointer to the block of memory to reallocate.
	@param nsize The new size of the block of memory.
	@param align The alignment of the block of memory.

	@returns The new pointer to the block of memory.
	*/
	[[nodiscard]]inline byte*base_realloc(byte*ptr,size_t nsize,size_t align)noexcept{
		byte*p=::elc::APIs::alloc::realloc(ptr,nsize,align);
		#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
			if(nsize==0)
				stest_uneventlog(ptr);
			if(p){
				ELC_TEST_EVENTNAME("base_realloc调用");
				if(p!=ptr)
					stest_uneventlog(ptr);
				stest_eventlog(p);
			}
		#endif
		return p;
	}
	/*!
	Allocates aligned memory.

	@param align The alignment of the memory.
	@param size The size of the memory.

	@returns A pointer to the allocated memory.
	*/
	[[nodiscard]]inline byte*base_aligned_alloc(size_t align,size_t size)noexcept{
		byte*p=::elc::APIs::alloc::aligned_alloc(align,size);
		#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
			if(p){
				ELC_TEST_EVENTNAME("base_aligned_alloc调用");
				stest_eventlog(p);
			}
		#endif
		return p;
	}
	/*!
	Frees a pointer allocated by base_alloc.

	@param p The pointer to free.
	@param align The alignment of the pointer.
	*/
	inline void base_free(byte*p,size_t align)noexcept{
		//传入需释放的数据块起始点与大小（字节）
		#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
			auto tmp=stest_geteventlistfromlog(p);
			if(!tmp){
				stest_putsf(L"释放了已释放或未分配指针%p，当前的事件记录如下：",p);
				stest_printeventlist(stderr,stest_geteventlist());
				stest_wait();
				return;
			}else{
				stest_deleteevent(tmp);
				stest_uneventlog(p);
			}
		#endif
		::elc::APIs::alloc::free(p,align);
	}
	/*!
	Computes the size of an allocation.

	@param arg The pointer to the start of the allocation.
	@param align The alignment of the allocation.

	@returns The size of the allocation.
	*/
	inline size_t base_get_size_of_alloc(const byte*arg, size_t align)noexcept{
		//arg保证不与null_ptr相等
		const auto tmp= ::elc::APIs::alloc::get_size_of_alloc(arg,align);
		return tmp;
	}
	//BLOCK_END

	template<typename T>
	inline void*alloc_method(type_info_t<T>)noexcept{
		//return空指针被允许，会引起gc_for_alloc
		return ::std::assume_aligned<alignof(T)>(base_aligned_alloc(alignof(T),sizeof(T)));
	}
	template<typename T>
	inline void*alloc_method(type_info_t<T>,size_t size)noexcept{
		//return空指针被允许，会引起gc_for_alloc
		//size被保证不为0
		if constexpr(type_info<T>.has_attribute(never_in_array))
			template_error("You cannot perform array operations on never_in_array type.");
		return ::std::assume_aligned<alignof(T)>(base_aligned_alloc(alignof(T),sizeof(T)*size));
	}
	template<typename T>
	inline size_t get_size_of_alloc_method(const T*arg)noexcept{
		//arg保证不与null_ptr相等
		return base_get_size_of_alloc(cast_to_data(arg),alignof(T))/sizeof(T);
	}
	template<typename T>
	inline void free_method(T*arg)noexcept{
		base_free(cast_to_data(arg),alignof(T));
	}
	template<typename T>
	inline void*realloc_method(T*ptr,size_t new_size)noexcept{
		//return空指针被允许，会引起gc_for_alloc，但ptr值必须保持有效以保证gc_for_alloc后再次realloc有效
		//new_size被保证不为0
		//align维持不变
		//但只允许在扩大数据块时可选的移动数据块
		if constexpr(type_info<T>.has_attribute(never_in_array))
			template_error("You cannot perform array operations on never_in_array type.");
		return reinterpret_cast<T*>(base_realloc(cast_to_data(ptr),sizeof(T)*new_size,alignof(T)));
	}
}

//file_end

	#line 42 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/defs.hpp"

	enable_adl(the_alloc_method);
	template<typename T>
	inline void*alloc_method(type_info_t<T>)noexcept{
		//return空指针被允许，会引起gc_for_alloc
		if constexpr(was_not_an_ill_form(the_alloc_method(type_info<T>)))
			return the_alloc_method(type_info<T>);
		else
			return default_method::alloc_method(type_info<T>);
	}
	template<typename T>
	inline void*alloc_method(type_info_t<T>,size_t size)noexcept{
		//return空指针被允许，会引起gc_for_alloc
		//size被保证不为0
		if constexpr(was_not_an_ill_form(the_alloc_method(type_info<T>,size)))
			return the_alloc_method(type_info<T>,size);
		else
			return default_method::alloc_method(type_info<T>,size);
	}
	enable_adl(the_get_size_of_alloc_method);
	template<typename T>
	inline size_t get_size_of_alloc_method(const T*arg)noexcept{
		//arg保证不与null_ptr相等
		if constexpr(was_not_an_ill_form(the_get_size_of_alloc_method(arg)))
			return the_get_size_of_alloc_method(arg);
		else
			return default_method::get_size_of_alloc_method(arg);
	}
	enable_adl(the_free_method);
	template<typename T>
	inline void free_method(T*arg)noexcept{
		if constexpr(was_not_an_ill_form(the_free_method(arg)))
			the_free_method(arg);
		else
			default_method::free_method(arg);
	}
	enable_adl(the_realloc_method);
	template<typename T>
	inline void*realloc_method(T*ptr,size_t new_size)noexcept{
		//return空指针被允许，会引起gc_for_alloc，但ptr值必须保持有效以保证gc_for_alloc后再次realloc有效
		//new_size被保证不为0
		//align维持不变
		//但只允许在扩大数据块时可选的移动数据块
		if constexpr(was_not_an_ill_form(the_realloc_method(ptr,new_size)))
			return the_realloc_method(ptr,new_size);
		else
			return default_method::realloc_method(ptr,new_size);
	}

	/// @brief 所有alloc_t的基类
	/// @details 尽管意义不明，但这个类就是在这里
	struct base_alloc_t{};

	/// @brief 用于对特定类型进行alloc的类
	/// @warning 这个类不会对内存进行初始化，如需要进行new like操作，请使用 get_t
	template<class T>
	struct alloc_t:base_alloc_t{
		typedef base_alloc_t base_t;
		[[nodiscard]]static T*base_call()noexcept{
			void*tmp;
			while(!assign(tmp,alloc_method(type_info<T>)))gc_for_alloc();
			return reinterpret_cast<T*>(tmp);
		}
		[[nodiscard]]static T*base_call(size_t size)noexcept{
			const APIs::alloc::source_location_guard slg{1};
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You can\'t alloc an array for never_in_array type.");
			if(size){//null_ptr不一定等价于nullptr，请勿删除本行
				void*tmp;
				while(!assign(tmp,alloc_method(type_info<T>,size)))gc_for_alloc();
				return reinterpret_cast<T*>(tmp);
			}else return null_ptr;
		}
		[[nodiscard]]/*static*/force_inline T*operator()()const noexcept{return base_call();}
		[[nodiscard]]/*static*/force_inline T*operator()(size_t size)const noexcept{return base_call(size);}
		struct alloc_array_t{
			size_t _size;
			[[nodiscard]]force_inline T*operator()()const noexcept{return base_call(_size);}
		};
		[[nodiscard]]force_inline constexpr alloc_array_t operator[](size_t a)const noexcept{return{a};}
	};
	/// @brief 用于对特定类型进行alloc的类实例
	/// @see alloc_t
	/// @warning 不会对内存进行初始化，如需要进行new like操作，请使用 get_t
	template<class T>
	constexpr alloc_t<T>alloc{};

	/// @brief 用于对特定类型进行free
	/// @warning 这个类不会对类实例进行析构，如需要进行new like操作，请使用 get_t & unget_t
	constexpr struct free_t{
		typedef free_t base_t;
		template<class T>
		static void base_call(T*p)noexcept{
			const APIs::alloc::source_location_guard slg{1};
			if(p!=null_ptr)//null_ptr不一定等价于nullptr，请勿删除本行
				free_method(p);
		}
		template<class T>
		/*static*/force_inline void operator()(T*p)const noexcept{base_call(p);}
	}free{};

	/// @brief 用于对特定类型进行realloc
	/// @warning 这个类不会对类实例进行移动函数调用，也不会创造或结束生命周期，如需要进行new like操作，请使用 get_resize_t
	constexpr struct realloc_t{
		typedef realloc_t base_t;
		template<class T>
		static void base_call(T*&ptr,size_t nsize)noexcept{
			const APIs::alloc::source_location_guard slg{1};
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
				//template_warning("For never_in_array type,realloc will free ptr when new_size=0 else do nothing.");
			if(nsize){//null_ptr不一定等价于nullptr，请勿删除本行
				if constexpr(type_info<T>.not_has_attribute(never_in_array))
					if(ptr!=null_ptr){//null_ptr不一定等价于nullptr，请勿删除本行
						void*tmp;
						while(!assign(tmp,realloc_method(ptr,nsize)))gc_for_alloc();
						ptr=reinterpret_cast<T*>(tmp);
					}else
						ptr=alloc<T>(nsize);
			}else{
				free(ptr);
				ptr=null_ptr;
			}
		}
		template<class T>
		/*static*/force_inline void operator()(T*&ptr,size_t nsize)const noexcept{
			base_call(ptr,nsize);
		}
		struct realloc_array_t{
			size_t _size;
			template<class T>
			[[nodiscard]]force_inline T*operator()(T*&ptr)const noexcept{return base_call(ptr,_size);}
		};
		[[nodiscard]]force_inline constexpr realloc_array_t operator[](size_t a)const noexcept{return{a};}
	}realloc{};

	/// @brief 用于自特定类型的内存分配结果获取分配大小
	/// 对于null_ptr，返回0
	/// 对于单个对象的分配，返回1
	constexpr struct get_size_of_alloc_t{
		template<typename T>
		static constexpr bool able=true;
		template<typename T>
		static constexpr bool nothrow=noexcept(get_size_of_alloc_method(declvalue(const T*)));

		template<typename T> requires able<T>
		static size_t base_call(const T*arg)noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg{1};
			if(arg==null_ptr)
				return 0;
			return get_size_of_alloc_method(arg);
		}

		template<typename T> requires able<T>
		force_inline size_t operator()(const T*arg)const noexcept(nothrow<T>){
			return base_call(arg);
		}
	}get_size_of_alloc{};

	/// @brief 对于特定类型的内存分配结果，获取分配大小并复制一份同样大小的内存
	/// @warning 这个类不会对类实例进行复制函数调用，也不会创造或结束生命周期，如需要进行new like操作，请使用 copy_get_t
	constexpr struct copy_alloc_t{
		template<typename T>
		static constexpr bool able=true;
		template<typename T>
		static constexpr bool nothrow=get_size_of_alloc.nothrow<T>;

		template<typename T> requires able<T>
		static T*base_call(const T*arg)noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg{1};
			return alloc<T>(get_size_of_alloc(arg));
		}

		template<typename T> requires able<T>
		force_inline T*operator()(const T*arg)const noexcept(nothrow<T>){
			return base_call(arg);
		}
	}copy_alloc{};
}

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_export.hpp"
//_export.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_export.hpp"
#define export using alloc_n::
export alloc;
export free;
export realloc;
export get_size_of_alloc;
export copy_alloc;
#undef export

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_body.hpp"
#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_test.hpp"
//_test.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_test.hpp"
/*!
Checks for memory leaks.
*/
inline void check_memory_lack()noexcept{
	stest_mapeventlogwith(lambda(const void*p,steventlist*a)noexcept{
		stest_putsf(L"内存泄露于%p,分配自:",p);
		stest_printeventlist(stdout,stest_copyeventlist(a));
		//alloc_n::base_free(remove_const(p));
		//stest_puts(L"已释放");
		stest_wait();
	});
}
#if defined(ELC_TEST_ON)
	namespace alloc_n{
		//BLOCK:for debug
		inline void test(){
			ELC_TEST_EVENTNAME("alloc部分测试");
			rand_seed.set_by_time();
			for(int i=rand<int>()%100+40;i--;){
				int*p=alloc<int>(50);
				p[0]=72;
				stest_accert(get_size_of_alloc(p)==50);
				p[49]=rand<int>();
				p[19]=666;
				realloc(p,20);
				stest_accert(get_size_of_alloc(p)==20);
				stest_accert(p[19]==666);
				stest_accert(p[0]==72);
				free(p);
			}
			check_memory_lack();
		}
		inline void test_log_out(){
		}
		inline void test_end(){
		}
		//BLOCK_END
	}
#endif

//file_end

	#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_body.hpp"
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/defs.hpp"
namespace abstract_base_n{
	#line 40 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/defs.hpp"
	common_attribute_t abstract_base;
}
namespace get_n{
	using abstract_base_n::abstract_base;
	//struct build_by_get_only{};已定义于 "../../base_defs/special_attribute.hpp"

	/*!
	向后减小数据块大小并转移原有实例的生命周期，但并不析构旧的实例

	@param arg 原有数据块
	@param to_size 新的数据块大小
	*/
	template<typename T>
	void alloc_size_cut(T*&arg,size_t to_size)noexcept{
		realloc(arg,to_size);
	}
	/*!
	向后扩大数据块大小并转移原有实例的生命周期，但并不构造新的实例

	@param arg 原有数据块
	@param to_size 新的数据块大小
	*/
	template<typename T>
	void alloc_size_grow(T*&arg,size_t to_size)noexcept(move.trivial<T> or move.nothrow<T>){
		if constexpr(move.trivial<T>)
			realloc(arg,to_size);
		else{
			T*tmp=alloc<T>(to_size);
			const auto from_size=get_size_of_alloc(arg);
			if constexpr(!move.nothrow<T>){
				template_warning("the move of T was not noexcept,this may cause memory lack.");
				try{
					move[from_size](note::from(arg),note::to(tmp));
				}catch(...){
					free(tmp);
					throw;
				}
			}else{
				move[from_size](note::from(arg),note::to(tmp));
			}
			free(arg);
			arg=tmp;
		}
	}
	/*!
	在指定位置插入未初始化数据块并转移原有实例的生命周期，但并不构造新的实例

	@param arg 原有数据块
	@param insert_pos 插入位置
	@param insert_size 插入大小
	*/
	template<typename T>
	void alloc_size_grow_with_insert_uninitialized_data(T*&arg,size_t insert_pos,size_t insert_size)noexcept(move.trivial<T> or move.nothrow<T>){
		const auto from_size=get_size_of_alloc(arg);
		const auto to_size=from_size+insert_size;
		const auto size_before_insert=insert_pos;
		const auto size_after_insert=from_size-insert_pos;
		if constexpr(move.trivial<T>){
			realloc(arg,to_size);
			memmove(arg+size_before_insert+insert_size,arg+size_before_insert,size_after_insert*sizeof(T));
		}
		else{
			T*tmp=alloc<T>(to_size);
			if constexpr(!move.nothrow<T>){
				template_warning("the move of T was not noexcept,this may cause memory lack.");
				try{
					move[size_before_insert](note::from(arg),note::to(tmp));
					move[size_after_insert](note::from(arg+insert_pos),note::to(tmp+insert_pos+insert_size));
				}catch(...){
					free(tmp);
					throw;
				}
			}else{
				move[size_before_insert](note::from(arg),note::to(tmp));
				move[size_after_insert](note::from(arg+insert_pos),note::to(tmp+insert_pos+insert_size));
			}
			free(arg);
			arg=tmp;
		}
	}
	/*!
	在指定位置插入未初始化数据块并转移原有实例的生命周期，但并不构造新的实例
	若有多余的大小，追加到末尾

	@param arg 原有数据块
	@param to_size 新的数据块大小
	@param insert_pos 插入位置
	@param insert_size 插入大小

	@returns 多余的大小
	*/
	template<typename T>
	size_t alloc_size_grow_with_insert_uninitialized_data(T*&arg,size_t to_size,size_t insert_pos,size_t insert_size)noexcept(move.trivial<T> or move.nothrow<T>){
		const auto from_size=get_size_of_alloc(arg);
		const auto size_before_insert=insert_pos;
		const auto size_after_insert=from_size-insert_pos;
		if constexpr(move.trivial<T>){
			realloc(arg,to_size);
			memmove(arg+size_before_insert+insert_size,arg+size_before_insert,size_after_insert*sizeof(T));
		}
		else{
			T*tmp=alloc<T>(to_size);
			if constexpr(!move.nothrow<T>){
				template_warning("the move of T was not noexcept,this may cause memory lack.");
				try{
					move[size_before_insert](note::from(arg),note::to(tmp));
					move[size_after_insert](note::from(arg+insert_pos),note::to(tmp+insert_pos+insert_size));
				}catch(...){
					free(tmp);
					throw;
				}
			}else{
				move[size_before_insert](note::from(arg),note::to(tmp));
				move[size_after_insert](note::from(arg+insert_pos),note::to(tmp+insert_pos+insert_size));
			}
			free(arg);
			arg=tmp;
		}
		return to_size-from_size-insert_size;
	}
	/*!
	向前减小数据块大小并转移原有实例的生命周期，但并不析构旧的实例

	@param arg 原有数据块
	@param to_size 新的数据块大小
	*/
	template<typename T>
	void forward_alloc_size_cut(T*&arg,size_t to_size)noexcept(move.trivial<T> or move.nothrow<T>){
		const auto from_size=get_size_of_alloc(arg);
		const auto cut_size=from_size-to_size;
		if constexpr(move.trivial<T>){
			::std::memmove(arg,add_const(arg+cut_size),to_size*sizeof(T));
			realloc(arg,to_size);
		}
		else{
			T*tmp=alloc<T>(to_size);
			if constexpr(!move.nothrow<T>){
				template_warning("the move of T was not noexcept,this may cause memory lack.");
				try{
					move[to_size](note::from(arg+cut_size),note::to(tmp));
				}catch(...){
					free(tmp);
					throw;
				}
			}else{
				move[to_size](note::from(arg+cut_size),note::to(tmp));
			}
			free(arg);
			arg=tmp;
		}
	}
	/*!
	向前扩大数据块大小并转移原有实例的生命周期，但并不构造新的实例

	@param arg 原有数据块
	@param to_size 新的数据块大小
	*/
	template<typename T>
	void forward_alloc_size_grow(T*&arg,size_t to_size)noexcept(move.trivial<T> or move.nothrow<T>){
		const auto from_size=get_size_of_alloc(arg);
		const auto grow_size=to_size-from_size;
		if constexpr(move.trivial<T>){
			realloc(arg,to_size);
			::std::memmove(arg+grow_size,add_const(arg),from_size*sizeof(T));
		}
		else{
			T*tmp=alloc<T>(to_size);
			if constexpr(!move.nothrow<T>){
				template_warning("the move of T was not noexcept,this may cause memory lack.");
				try{
					move[from_size](note::from(arg),note::to(tmp+grow_size));
				}catch(...){
					free(tmp);
					throw;
				}
			}else{
				move[from_size](note::from(arg),note::to(tmp+grow_size));
			}
			free(arg);
			arg=tmp;
		}
	}
	#line 227 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/defs.hpp"
	/*!
	在指定位置插入未初始化数据块并转移原有实例的生命周期，但并不构造新的实例
	若有多余的大小，追加到前端

	@param arg 原有数据块
	@param to_size 新的数据块大小
	@param insert_pos 插入位置
	@param insert_size 插入大小

	@returns 多余的大小
	*/
	template<typename T>
	size_t forward_alloc_size_grow_with_insert_uninitialized_data(T*&arg,size_t to_size,size_t insert_pos,size_t insert_size)noexcept(move.trivial<T> or move.nothrow<T>){
		const auto from_size=get_size_of_alloc(arg);
		const auto grow_size=to_size-from_size;
		const auto before_grow_size=grow_size-insert_size;
		const auto size_before_insert=insert_pos;
		const auto size_after_insert=from_size-insert_pos;
		if constexpr(move.trivial<T>){
			realloc(arg,to_size);
			const auto orogin_data_ptr=arg+before_grow_size;
			::std::memmove(orogin_data_ptr+size_before_insert+insert_size,arg+size_before_insert,size_after_insert*sizeof(T));
			::std::memmove(orogin_data_ptr,arg,size_before_insert*sizeof(T));
		}
		else{
			T*tmp=alloc<T>(to_size);
			if constexpr(!move.nothrow<T>){
				template_warning("the move of T was not noexcept,this may cause memory lack.");
				try{
					const auto orogin_data_ptr=tmp+before_grow_size;
					move[size_before_insert](note::from(arg),note::to(orogin_data_ptr));
					move[size_after_insert](note::from(arg+size_before_insert),note::to(orogin_data_ptr+size_before_insert+insert_size));
				}catch(...){
					free(tmp);
					throw;
				}
			}else{
				const auto orogin_data_ptr=tmp+before_grow_size;
				move[size_before_insert](note::from(arg),note::to(orogin_data_ptr));
				move[size_after_insert](note::from(arg+size_before_insert),note::to(orogin_data_ptr+size_before_insert+insert_size));
			}
			free(arg);
			arg=tmp;
		}
		return before_grow_size;
	}

	struct base_get_t{};
	template<typename T>
	struct get_t:base_get_t{
		typedef base_get_t base_t;
		template<class...Args>
		static constexpr bool able=construct<T>.able<Args...>&&destruct.able<T>;
		template<class...Args>
		static constexpr bool nothrow=construct<T>.nothrow<Args...>;

		/*!
		Constructs an object of type T.

		@param rest The arguments to pass to the constructor of T.

		@returns A pointer to the newly constructed object.
		*/
		template<class...Args> requires able<Args...>
		[[nodiscard]]T* operator()(Args&&...rest)const noexcept(nothrow<Args...>){
			const APIs::alloc::source_location_guard slg;
			return construct<T>[alloc<T>()](forward<Args>(rest)...);
		}

		/*!
		Allocates an array of T with the specified size.
		*/
		struct array_get_t{
			size_t _size;
			/*!
			Constructs an array of objects of type T.

			@param rest The arguments to pass to the constructor of T.

			@returns An array of objects of type T.
			*/
			template<class...Args> requires able<Args...>
			[[nodiscard]]T* operator()(Args&&...rest)const noexcept(nothrow<Args...>){
				const APIs::alloc::source_location_guard slg;
				if constexpr(type_info<T>.has_attribute(never_in_array))
					template_error("You can\'t get an array for never_in_array type.");
				return construct<T>[alloc<T>(_size)][_size](forward<Args>(rest)...);
			}
		};
		[[nodiscard]]constexpr array_get_t operator[](size_t size)const noexcept{return{size};}

		static constexpr struct as_array_t{
			template<typename U>
			static constexpr bool able=copy_construct.able<T>&&destruct.able<T>&&is_array_like_for<T,U>;
			template<typename U>
			static constexpr bool nothrow=copy_construct.nothrow<T>;

			[[nodiscard]]T* operator()(array_like_view_t<const T>a)const noexcept(nothrow<void>){
				const APIs::alloc::source_location_guard slg;
				if constexpr(type_info<T>.has_attribute(never_in_array))
					template_error("You can\'t get an array for never_in_array type.");
				const auto size=a.size();
				auto aret=alloc<T>[size]();
				copy_construct[size](note::from(a.begin()),note::to(aret));
				return aret;
			}
		}as_array{};

		static constexpr struct apply_end_t{
			template<typename U>
			static constexpr bool able=copy_construct.able<T>&&move.able<T>&&is_array_like_for<T,U>;
			template<typename U>
			static constexpr bool nothrow=copy_construct.nothrow<T>&&move.nothrow<T>;

			T* operator()(note::to_t<T*&> to,array_like_view_t<const T>a)const noexcept(nothrow<void>){
				const APIs::alloc::source_location_guard slg;
				auto&ptr=to.value;
				auto from_size=get_size_of_alloc(ptr);
				auto a_size=a.size();
				alloc_size_grow(ptr,from_size+a_size);
				copy_construct[a_size](note::from(a.begin()),note::to(ptr+from_size));
				return ptr;
			}
			T* operator()(note::to_t<T*&> to,const T&a)const noexcept(nothrow<void>){
				const APIs::alloc::source_location_guard slg;
				auto&ptr=to.value;
				auto from_size=get_size_of_alloc(ptr);
				alloc_size_grow(ptr,from_size+1);
				copy_construct(note::from(&a),note::to(ptr+from_size));
				return ptr;
			}
			T* operator()(note::to_t<T*&> to,T&&a)const noexcept(nothrow<void>){
				const APIs::alloc::source_location_guard slg;
				auto&ptr=to.value;
				auto from_size=get_size_of_alloc(ptr);
				alloc_size_grow(ptr,from_size+1);
				move_construct(note::from(&a),note::to(ptr+from_size));
				return ptr;
			}
		}apply_end{};

		static constexpr struct remove_t{
			template<typename U>
			static constexpr bool able=destruct.able<T>&&move.able<T>&&is_array_like_for<T,U>;
			template<typename U>
			static constexpr bool nothrow=destruct.nothrow<T>&&move.nothrow<T>;

			bool operator()(array_like_view_t<const T>a,note::from_t<T*>from)const noexcept(nothrow<void>){
				const APIs::alloc::source_location_guard slg;
				auto ptr=from.value;
				auto from_size=get_size_of_alloc(ptr);
				T*ptr_to_a=in_range(a,{ptr,note::size(from_size)});
				auto a_size=a.size();
				if(!ptr_to_a)
					return false;

				destruct[a_size](ptr_to_a);
				move[(ptr+from_size)-(ptr_to_a+a_size)](note::from(ptr_to_a+a_size),note::to(ptr_to_a));
				alloc_size_cut(ptr,from_size-a_size);
				return true;
			}
		}remove{};
	};
	template<typename T>
	constexpr get_t<T>get{};


	constexpr struct unget_t{
		template<typename T>
		static constexpr bool able=destruct.able<T>;
		template<typename T>
		static constexpr bool nothrow=destruct.nothrow<T>;

		template<typename T> requires able<T>
		void operator()(T*a)const noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg;
			if(a!=null_ptr){
				if constexpr(type_info<T>.has_attribute(abstract_base))
					#if defined(_MSC_VER)
						[[gsl::suppress(f.6)]]
					#endif
					attribute_ptr_cast<abstract_base>(a)->abstract_method_unget_this();
				else{
					if constexpr(!destruct.nothrow<T>)
						template_warning("the destructer of T was not noexcept,this may cause memory lack.");
					if constexpr(type_info<T>.has_attribute(never_in_array))
						destruct(a);
					else
						destruct[get_size_of_alloc(a)](a);
					free(a);
				}
			}
		}
		/*适用于unget(this,not destruct);*/
		template<typename T> requires able<T>
		void operator()(T*a,decltype(destruct)::not_t)const noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg;
			free(a);
		}
	}unget{};

	constexpr struct get_resize_t{
		template<typename T>
		static constexpr bool able=construct<T>.able<>&&destruct.able<T>&&move.able<T>;
		template<typename T>
		static constexpr bool nothrow=type_info<T>.not_has_attribute(abstract_base)&&construct<T>.nothrow<>&&destruct.nothrow<T>&&move.nothrow<T>;

		template<typename T> requires able<T>
		static void base_call(T*&arg,const size_t to_size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array)){
				template_warning("For never_in_array type,get_resize will unget ptr when new_size=0 else do nothing.");
				if(to_size)
					return;
				unget(arg);
				arg=null_ptr;
			}elseif constexpr(type_info<T>.has_attribute(abstract_base)){
				arg=attribute_ptr_cast<abstract_base>(arg)->abstract_method_get_resize_this(to_size);
			}else{
				const size_t from_size=get_size_of_alloc(arg);
				if(from_size==to_size)
					return;
				elseif(from_size > to_size){
					destruct[from_size-to_size](arg+to_size);
					alloc_size_cut(arg,to_size);
				}elseif(from_size){
					alloc_size_grow(arg,to_size);
					construct<T>[arg+from_size][to_size-from_size]();
				}else
					arg=get<T>[to_size]();
			}
		}

		template<typename T> requires able<T>
		inline void operator()(T*&arg,size_t to_size)const noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg;
			base_call(arg,to_size);
		}
		template<typename T> requires able<T>
		[[nodiscard]]inline T* operator()(T*&&arg,size_t to_size)const noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg;
			base_call(arg,to_size);
			return arg;
		}

		static constexpr struct insert_t{
			template<typename T>
			static constexpr bool able=get_resize_t::able<T>;
			template<typename T>
			static constexpr bool nothrow=get_resize_t::nothrow<T>;
			template<typename T> requires(able<T> && construct<T>.able<>)
			void operator()(T*&arg,size_t insert_pos,size_t insert_size)const noexcept(nothrow<T>){
				if(insert_size){
					const APIs::alloc::source_location_guard slg;
					alloc_size_grow_with_insert_uninitialized_data(arg,insert_pos,insert_size);
					construct<T>[arg+insert_pos][insert_size]();
				}
			}
			template<typename T> requires(able<T> && copy_construct.able<T>)
			void operator()(T*&arg,size_t insert_pos,size_t insert_size,const T*insert_data)const noexcept(nothrow<T>){
				if(insert_size){
					const APIs::alloc::source_location_guard slg;
					alloc_size_grow_with_insert_uninitialized_data(arg,insert_pos,insert_size);
					copy_construct[insert_size](note::from(insert_data),note::to(arg+insert_pos));
				}
			}
		}insert{};
		static constexpr struct insert_resize_t{
			template<typename T>
			static constexpr bool able=get_resize_t::able<T>;
			template<typename T>
			static constexpr bool nothrow=get_resize_t::nothrow<T>;
			template<typename T> requires(able<T> && construct<T>.able<> && copy_construct.able<T>)
			void operator()(T*&arg,size_t insert_pos,size_t insert_size,const T*insert_data,size_t to_size)const noexcept(nothrow<T>){
				const APIs::alloc::source_location_guard slg;
				auto end_grow_size=alloc_size_grow_with_insert_uninitialized_data(arg,to_size,insert_pos,insert_size);
				copy_construct[insert_size](note::from(insert_data),note::to(arg+insert_pos));
				construct<T>[arg+to_size-end_grow_size][end_grow_size]();
			}
		}insert_with_resize{};
	}get_resize{};

	constexpr struct get_forward_resize_t{
		template<typename T>
		static constexpr bool able=construct<T>.able<>&&destruct.able<T>&&move.able<T>;
		template<typename T>
		static constexpr bool nothrow=type_info<T>.not_has_attribute(abstract_base)&&construct<T>.nothrow<>&&destruct.nothrow<T>&&move.nothrow<T>;

		template<typename T> requires able<T>
		static void base_call(T*&arg,const size_t to_size)noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg{1};
			if constexpr(type_info<T>.has_attribute(never_in_array)){
				template_warning("For never_in_array type,get_forward_resize will unget ptr when new_size=0 else do nothing.");
				if(to_size)
					return;
				unget(arg);
				arg=null_ptr;
			}elseif constexpr(type_info<T>.has_attribute(abstract_base)){
				arg=attribute_ptr_cast<abstract_base>(arg)->abstract_method_get_forward_resize_this(to_size);
			}else{
				const size_t from_size=get_size_of_alloc(arg);
				if(from_size==to_size)
					return;
				elseif(from_size > to_size){
					destruct[from_size-to_size](arg);
					forward_alloc_size_cut(arg,to_size);
				}elseif(from_size){
					forward_alloc_size_grow(arg,to_size);
					construct<T>[arg][to_size-from_size]();
				}else
					arg=get<T>[to_size]();
			}
		}

		template<typename T> requires able<T>
		inline void operator()(T*&arg,size_t to_size)const noexcept(nothrow<T>){
			base_call(arg,to_size);
		}
		template<typename T> requires able<T>
		[[nodiscard]]inline T* operator()(T*&&arg,size_t to_size)const noexcept(nothrow<T>){
			base_call(arg,to_size);
			return arg;
		}

		static constexpr struct insert_t{
			template<typename T>
			static constexpr bool able=get_resize_t::able<T>;
			template<typename T>
			static constexpr bool nothrow=get_resize_t::nothrow<T>;
			template<typename T> requires(able<T> && construct<T>.able<>)
			void operator()(T*&arg,size_t insert_pos,size_t insert_size)const noexcept(nothrow<T>){
				const APIs::alloc::source_location_guard slg;
				get_resize.insert(arg,insert_pos,insert_size);
			}
			template<typename T> requires(able<T> && copy_construct.able<T>)
			void operator()(T*&arg,size_t insert_pos,size_t insert_size,const T*insert_data)const noexcept(nothrow<T>){
				const APIs::alloc::source_location_guard slg;
				get_resize.insert(arg,insert_pos,insert_size,insert_data);
			}
		}insert{};
		static constexpr struct insert_resize_t{
			template<typename T>
			static constexpr bool able=get_resize_t::able<T>;
			template<typename T>
			static constexpr bool nothrow=get_resize_t::nothrow<T>;
			template<typename T> requires(able<T> && construct<T>.able<> && copy_construct.able<T>)
			void operator()(T*&arg,size_t insert_pos,size_t insert_size,const T*insert_data,size_t to_size)const noexcept(nothrow<T>){
				if(insert_size){
					const APIs::alloc::source_location_guard slg;
					auto before_grow_size=forward_alloc_size_grow_with_insert_uninitialized_data(arg,to_size,insert_pos,insert_size);
					const auto orogin_arg=arg+before_grow_size;
					copy_construct[insert_size](note::from(insert_data),note::to(orogin_arg+insert_pos));
					construct<T>[arg][before_grow_size]();
				}
			}
		}insert_with_resize{};
	}get_forward_resize{};

	constexpr struct get_size_of_get_t{
		template<typename T>
		static constexpr bool able=true;
		template<typename T>
		static constexpr bool nothrow=noexcept(get_size_of_alloc(declvalue(const T*)));

		template<typename T> requires able<T>
		[[nodiscard]]inline static size_t base_call(const T*arg)noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg{1};
			return get_size_of_alloc(arg);
		}

		template<typename T> requires able<T>
		[[nodiscard]]inline size_t operator()(const T*arg)const noexcept(nothrow<T>){
			return base_call(arg);
		}
	}get_size_of_get{};

	constexpr struct copy_get_t{
		template<typename T>
		static constexpr bool able=copy_construct.able<T> || type_info<T>.has_attribute(abstract_base);
		template<typename T>
		static constexpr bool nothrow=copy_construct.nothrow<T>;

		template<typename T> requires able<T>
		[[nodiscard]]inline static T*base_call(const T*arg)noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg{1};
			if constexpr(type_info<T>.has_attribute(abstract_base))
				return remove_const(attribute_ptr_cast<abstract_base>(arg))->abstract_method_copy_get_this();
			else
				return copy_construct(note::from(arg),note::to(copy_alloc(arg)),get_size_of_get(arg));
		}

		template<typename T> requires able<T>
		[[nodiscard]]inline T*operator()(const T*arg)const noexcept(nothrow<T>){
			return base_call(arg);
		}
	}copy_get{};
}

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_export.hpp"
//_export.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_export.hpp"
#define export using get_n::
export get;
export get_resize;
export get_forward_resize;
export unget;
export get_size_of_get;
export copy_get;
//export build_by_get_only;
#undef export

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_test.hpp"
//_test.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_test.hpp"
namespace get_n{
	//BLOCK:for debug
	inline void test(){
		ELC_TEST_EVENTNAME("get部分测试");
		{
			ste::tester::setzero();
			tester*p=get<tester>[50]();
			stest_accert(tester::getbuildtime()==50);
			get_resize(p,60);
			//destroytime:50(+50) cause move(move_construct&destruct).
			stest_accert(tester::getdestroytime()==50);
			stest_accert(tester::getbuildtime()==60);
			int i=0;
			do
				p[i]();//写入测试
			while(++i!=60);
			stest_accert(tester::getcalltime()==60);
			unget(p);
			//destroytime:110(+60) cause destruct.
			stest_accert(tester::getdestroytime()==110);
		}
		check_memory_lack();
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
	//BLOCK_END
}

//file_end

	#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_body.hpp"
#endif

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"
//UF
namespace abstract_base_n{
	#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/pointer_off_set.hpp"
//pointer_off_set.hpp
//at namespace elc::defs::memory::abstract_base_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/pointer_off_set.hpp"
inline thread_local pointer base_ptr;
inline thread_local ptrdiff_t off_set;
distinctive inline void is_base_ptr(void*a)noexcept{base_ptr=a;}
distinctive inline void is_instance_ptr(void*a)noexcept{off_set=get_off_set(note::from(a),note::to(base_ptr));}
distinctive inline void*get_ptr_after_off_set(void*a)noexcept{return apply_off_set(a,off_set);}

//file_end

	#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/abstract_base_vtable.hpp"
//abstract_base_vtable.hpp
//at namespace elc::defs::memory::abstract_base_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/abstract_base_vtable.hpp"
no_vtable_class abstract_base_vtable{
protected:
	virtual void* _abstract_method_copy_get_this()=0;
	virtual void* _abstract_method_get_resize_this(size_t size)=0;
	virtual void* _abstract_method_get_forward_resize_this(size_t size)=0;

	virtual void abstract_method_unget_this()=0;
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept=0;

	friend class get_n::unget_t;
	friend class get_n::get_resize_t;
	friend class get_n::get_size_of_get_t;
	friend class get_n::copy_get_t;
};

//file_end

	#line 42 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/abstract_base.hpp"
//abstract_base.hpp
//at namespace elc::defs::memory::abstract_base_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/abstract_base.hpp"
template<class T>
no_vtable_class abstract_base:virtual public abstract_base_vtable{
	T* abstract_method_copy_get_this(){
		is_base_ptr(this);
		return reinterpret_cast<T*>(get_ptr_after_off_set(this->_abstract_method_copy_get_this()));
	}
	T* abstract_method_get_resize_this(size_t size){
		is_base_ptr(this);
		return reinterpret_cast<T*>(get_ptr_after_off_set(this->_abstract_method_get_resize_this(size)));
	}
	T* abstract_method_get_forward_resize_this(size_t size){
		is_base_ptr(this);
		return reinterpret_cast<T*>(get_ptr_after_off_set(this->_abstract_method_get_forward_resize_this(size)));
	}

	friend class get_n::unget_t;
	friend class get_n::get_resize_t;
	friend class get_n::get_size_of_get_t;
	friend class get_n::copy_get_t;
};

//file_end

	#line 43 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/instance_struct.hpp"
//instance_struct.hpp
//at namespace elc::defs::memory::abstract_base_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/instance_struct.hpp"
push_and_disable_msvc_warning(26436);//无虚析构函数警告diss
template<class T>
class instance_struct:is_common_attribute(instance_struct),virtual public abstract_base_vtable{
protected:
	virtual void abstract_method_unget_this()noexcept_as(unget(get_handle(this)))override{unget(get_handle(this));}
	virtual void* _abstract_method_copy_get_this()noexcept(copy_get.able<T>?copy_get.nothrow<T>:1)override{
		if constexpr(copy_get.able<T>){
			is_instance_ptr(this);
			return copy_get(get_handle(this));
		}
		else{
			return get_handle(this);
		}
	}
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept(get_resize.able<T>?get_resize.nothrow<T>:1)override{
		if constexpr(get_resize.able<T>){
			is_instance_ptr(this);
			return get_resize(get_handle(this),size);
		}
		else{
			return get_handle(this);
		}
	}
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept(get_forward_resize.able<T>?get_forward_resize.nothrow<T>:1)override{
		if constexpr(get_forward_resize.able<T>){
			is_instance_ptr(this);
			return get_forward_resize(get_handle(this),size);
		}
		else{
			return get_handle(this);
		}
	}
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return get_size_of_get(get_handle(this));}
};
pop_msvc_warning();

//file_end

	#line 44 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"
}
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_export.hpp"
//_export.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_export.hpp"
#define export using abstract_base_n::
export abstract_base;
export instance_struct;
#undef export

//file_end

#line 46 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"

//#include "pool/_body.hpp"//依赖list

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/defs.hpp"
namespace others_n{
	template<typename T>
	struct replace_able;
}
using others_n::replace_able;
namespace ptr_n{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/ref_t.hpp"
//ref_t.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/ref_t.hpp"
typedef size_t link_num_t;
class ref_t:non_copyable,non_moveable{
	mutable link_num_t _ref_num=0;
public:
	constexpr ref_t()noexcept=default;
	constexpr explicit ref_t(never_ref_num_zero_t)noexcept:_ref_num(1){}
	inline constexpr void add_ref()const noexcept{_ref_num++;}
protected:
	[[nodiscard]]inline constexpr bool cut_ref()const noexcept{return!--_ref_num;}
public:
	inline constexpr void init_never_ref_num_zero()noexcept{add_ref();}
	[[nodiscard]]link_num_t link_num()const noexcept{return _ref_num;}
};

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/ref_base.hpp"
//ref_base.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/ref_base.hpp"
enable_adl(the_waiting_for_destroy);
template<typename T>
void waiting_for_destroy(T*a)noexcept{
	if constexpr(was_not_an_ill_form(the_waiting_for_destroy(a)))
		return the_waiting_for_destroy(a);
	else
		template_error("this function should not be instantiated,please overload the function the_waiting_for_destroy in the namespace where this type is defined.");
}
enable_adl(the_destroy_and_free);
template<typename T>
void destroy_and_free(T*a)noexcept{
	if constexpr(was_not_an_ill_form(the_destroy_and_free(a)))
		return the_destroy_and_free(a);
	elseif constexpr(type_info<T>.has_attribute(build_by_get_only)&&type_info<T>.has_attribute(never_in_array))
		unget(a);
	else
		template_error("please overload the function the_destroy_and_free in the namespace where this type is defined.");
}
//
common_attribute_t ref_able;
common_attribute_t weak_ref_able;

template<typename T>
constexpr bool was_ref_able=type_info<T>.has_attribute(ref_able);
template<typename T>
constexpr bool was_weak_ref_able=type_info<T>.has_attribute(weak_ref_able);

template<typename T>
[[nodiscard]]link_num_t get_ref_num(const T*a)noexcept{
	if constexpr(!was_ref_able<T>)
		template_error("hey.");
	return attribute_ptr_cast<const ref_able>(a)->link_num();
}
template<typename T>
[[nodiscard]]link_num_t get_weak_ref_num(const T*a)noexcept{
	if constexpr(!was_weak_ref_able<T>)
		template_error("hey.");
	return attribute_ptr_cast<const weak_ref_able>(a)->link_num();
}

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/ref_able.hpp"
//ref_able.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/ref_able.hpp"
template<typename T>
struct ref_able:ref_t,can_t_use_default_null_ptr,is_common_attribute(ref_able){
private:
	typedef ref_t base_t;
public:
	using base_t::base_t;
	inline void cut_ref()const noexcept{
		T*this_T=remove_const(get_handle(this));
		if(base_t::cut_ref())
			if constexpr(was_weak_ref_able<T>)
				if(get_weak_ref_num(this_T)!=0)
					waiting_for_destroy(this_T);
				else
					destroy_and_free(this_T);
			else
				destroy_and_free(this_T);
	}
};

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/weak_ref_able.hpp"
//weak_ref_able.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/weak_ref_able.hpp"
template<typename T>
struct weak_ref_able:ref_t,can_t_use_default_null_ptr,is_common_attribute(weak_ref_able){
private:
	typedef ref_t base_t;
public:
	inline void cut_ref()const noexcept{
		if constexpr(!was_ref_able<T>)
			template_error("base on ref_able before base on weak_ref_able,please.");
		T*this_T=remove_const(get_handle(this));
		if(base_t::cut_ref())
			if(get_ref_num(this_T)==0)
				destroy_and_free(this_T);
	}
};

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/_body.hpp"

//file_end

	#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/defs.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/base_ptr_t.hpp"
//base_ptr_t.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/base_ptr_t.hpp"
//copy from old ELC & adepted.
template<class T>
struct same_ptr_p_t{
protected:
	mutable T*_to;
	explicit same_ptr_p_t(T*a)noexcept:_to(a){}
public:
	same_ptr_p_t(const same_ptr_p_t&)noexcept=default;
	[[nodiscard]]T*get()const noexcept{return _to;}
};
template<class T,typename ref_type>
struct same_ref_p_t:same_ptr_p_t<T>{
	using same_ptr_p_t<T>::_to;
	explicit same_ref_p_t(T*a)noexcept:same_ptr_p_t<T>(a){}
	explicit same_ref_p_t(const same_ptr_p_t<T>&a)noexcept:same_ptr_p_t<T>(a){}

	void swap_with(same_ref_p_t&a)noexcept{swap(_to,a._to);}

	static constexpr bool cut_nothrow=noexcept(declvalue(ref_type).cut_ref());
protected:
	static void cut_ref(T*a)noexcept(cut_nothrow){attribute_ptr_cast<ref_type>(a)->cut_ref();}
	static void add_ref(T*a)noexcept{attribute_ptr_cast<ref_type>(a)->add_ref();}

	void cut_ref()const noexcept_as(cut_ref(nullptr)){cut_ref(_to);}
	void add_ref()const noexcept{add_ref(_to);}
};

template<class T,typename ref_type>
inline void swap(same_ref_p_t<T,ref_type>&a,same_ref_p_t<T,ref_type>&b)noexcept{
	a.swap_with(b);
}

template<class T,typename ref_type,bool do_replace_check>
struct ptr_t:same_ref_p_t<T,ref_type>{
	typedef ptr_t<T,ref_type,do_replace_check>this_t;

	typedef same_ref_p_t<T,ref_type>base_t;
	typedef same_ref_p_t<T,ref_type>same_ref;
	typedef same_ptr_p_t<T>same_ptr;
	using base_t::cut_nothrow;
	using same_ref::add_ref;
	using same_ref::cut_ref;
	using same_ref::swap_with;
	using same_ptr::_to;

	explicit ptr_t(T*a,special_init_t)noexcept:same_ref(a){}
	constexpr ptr_t(T*a)noexcept:same_ref(a){add_ref();}
	ptr_t(const same_ptr&a)noexcept:same_ref(a){
		if constexpr(type_info<T>.has_attribute(weak_ref_able) && type_info<ref_type> == type_info<ref_able<remove_cv<T>>>)
			if(get_ref_num(_to))
				add_ref();
			else
				add_ref(_to=null_ptr);
		else
			add_ref();
	}
	ptr_t(const same_ref&a)noexcept:same_ref(a){add_ref();}
	ptr_t(const ptr_t&a)noexcept:ptr_t((same_ptr&)a){}
	ptr_t(const ptr_t<remove_cv<T>,ref_type,do_replace_check>&a)noexcept requires(type_info<remove_cv<T>>!=type_info<T>):ptr_t(a.get()){}
	ptr_t(ptr_t&&a)noexcept:ptr_t((same_ptr&)a){
		//为什么不默认构造后swap_with？
		#line 105 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/base_ptr_t.hpp"
	}
	constexpr ptr_t(nullptr_t=nullptr)noexcept:ptr_t(null_ptr){}
	constexpr ptr_t(null_ptr_t)noexcept:ptr_t((T*)(null_ptr)){}
	~ptr_t()noexcept(cut_nothrow){cut_ref();}

	static constexpr bool reset_nothrow=cut_nothrow;
	void reset(T*a)const noexcept(reset_nothrow){auto tmp=_to;add_ref(_to=a);cut_ref(tmp);}
	void reset(nullptr_t=nullptr)const noexcept(reset_nothrow){reset(null_ptr);}
public:
	static constexpr bool replace_check_nothrow=(type_info<T>.not_has_attribute(replace_able))||reset_nothrow;
	inline void replace_check()const noexcept(replace_check_nothrow){
		if constexpr(do_replace_check&&type_info<remove_cvref<T>>.has_attribute(replace_able))
			if(attribute_ptr_cast<replace_able>(_to)->replaced())
				reset(attribute_ptr_cast<replace_able>(_to)->get_ptr());
	}
	inline void do_replace(T*p)noexcept(replace_check_nothrow&&reset_nothrow){
		if constexpr(type_info<remove_cvref<T>>.has_attribute(replace_able)){
			attribute_ptr_cast<replace_able>(_to)->be_replace_as(p);
			reset(p);
		}
	}
	template<typename ref_type_,bool do_replace_check_>
	inline void do_replace(const ptr_t<T,ref_type_,do_replace_check_>&p)noexcept(replace_check_nothrow&&reset_nothrow){
		do_replace(p.get());
	}
	static constexpr bool get_nothrow=replace_check_nothrow;
	[[nodiscard]]T*get()const noexcept(get_nothrow){
		replace_check();
		return base_t::get();
	}
	[[nodiscard]]bool unique()const noexcept{return attribute_ptr_cast<ref_able>(get())->link_num()==1;}
	[[nodiscard]]constexpr
	conditional<do_replace_check&&type_info<T>.has_attribute(replace_able),
				unstable_hash_t,hash_t> hash()const noexcept_as(elc::defs::hash(get())){//注意：当T可replace时，同一ptr的hash可能变动
		using elc::defs::hash;
		return hash(get());
	}

	[[nodiscard]]inline auto operator==(const T*a)const noexcept_as(pointer_equal(add_const(declvalue(const this_t&).get()),a)){
		return pointer_equal(add_const(get()),a);
	}
	[[nodiscard]]inline auto operator==(nullptr_t)const noexcept_as(operator==(null_ptr)){
		return operator==(null_ptr);
	}
	[[nodiscard]]inline auto operator==(null_ptr_t)const noexcept_as(operator==((T*)null_ptr)){
		return operator==((T*)null_ptr);
	}
	template<typename ref_type_,bool do_replace_check_>
	[[nodiscard]]inline auto operator==(const ptr_t<T,ref_type_,do_replace_check_>&b)const
	noexcept_as(pointer_equal(
			declvalue(const this_t&).get(),
			b.get())
	){
		return pointer_equal(get(),b.get());
	}
	template<typename ref_type_,bool do_replace_check_> requires(type_info<remove_cv<T>>!=type_info<T>)
	[[nodiscard]]inline auto operator==(const ptr_t<const T,ref_type_,do_replace_check_>&b)const
	noexcept_as(pointer_equal(
			declvalue(const this_t&).get(),
			b.get())
	){
		return pointer_equal(get(),b.get());
	}
	template<typename ref_type_,bool do_replace_check_> requires(type_info<remove_cv<T>>!=type_info<T>)
	[[nodiscard]]inline auto operator==(const ptr_t<remove_cv<T>,ref_type_,do_replace_check_>&b)const
	noexcept_as(pointer_equal(
			declvalue(const this_t&).get(),
			add_const(b.get()))
	){
		return pointer_equal(get(),add_const(b.get()));
	}
};

template<typename T_,typename T,typename ref_type,bool do_replace_check,enable_if(type_info<T_>.base_on<T>)>
[[nodiscard]]inline auto operator==(const T_*a,ptr_t<T,ref_type,do_replace_check>&b)noexcept_as(b.operator==(static_cast<const T*>(a))){
	return b.operator==(static_cast<const T*>(a));
}

template<typename T,typename T_> requires(equal.able<T,T_>)
[[nodiscard]]inline auto operator!=(T&&a,T_&&b)noexcept_as(!(a==b)){
	return !(a==b);
}

template<class T,typename ref_type,bool do_replace_check>
struct base_ptr_t:ptr_t<T,ref_type,do_replace_check>{
	static_assert(type_info<T>.base_on<ref_type>);
	typedef ptr_t<T,ref_type,do_replace_check>base_t;
	typedef base_ptr_t<T,ref_type,do_replace_check>this_t;
	using typename base_t::same_ref;
	using typename base_t::same_ptr;
	using base_t::reset;
	using base_t::get;
	using same_ref::swap_with;
	using same_ptr::_to;

	using base_t::get_nothrow;
	using base_t::reset_nothrow;

	using base_t::base_t;

	base_ptr_t(base_ptr_t&a)noexcept:base_t(a){}
	base_ptr_t(base_ptr_t&&a)noexcept:base_t(move(a)){}

	[[nodiscard]]T*operator->()const noexcept(get_nothrow){return get();}
	[[nodiscard]]T&operator*()const noexcept(get_nothrow){return*get();}
	[[nodiscard]]explicit operator bool()const noexcept(get_nothrow){return bool(pointer_to_bool(get()));}
	[[nodiscard]]auto operator!()const noexcept(get_nothrow){return!pointer_to_bool(get());}
	[[nodiscard]]explicit operator T*()const noexcept(get_nothrow){return get();}

	base_ptr_t&operator=(T*a)&noexcept(reset_nothrow){reset(a);return*this;}
	base_ptr_t&operator=(const same_ptr&a)&noexcept(reset_nothrow&&get_nothrow){reset(a.get());return*this;}
	base_ptr_t&operator=(const base_ptr_t&a)&noexcept(reset_nothrow&&get_nothrow){reset(a.get());return*this;}
	base_ptr_t&operator=(same_ref&&a)&noexcept{swap_with(a);return*this;}
	base_ptr_t&operator=(base_ptr_t&&a)&noexcept{swap_with(a);return*this;}
	base_ptr_t&operator=(null_ptr_t)&noexcept(reset_nothrow){return*this=(T*)null_ptr;}
	base_ptr_t&operator=(nullptr_t)&noexcept(reset_nothrow){return*this=null_ptr;}

private:
	static inline thread_local class for_delete_t{
		T*_m;
		friend class this_t;
		for_delete_t*operator()(T*a)noexcept{
			_m=a;
			return this;
		}
	public:
		static void operator delete(void*a)noexcept{}
		static void operator delete(for_delete_t*a,std::destroying_delete_t)noexcept_as(destroy(declvalue(T*))){
			destroy((a)->_m);
		}
	}for_delete{};
public:
	[[nodiscard]]explicit operator bool()noexcept(get_nothrow){return add_const(this)->operator bool();}
	[[nodiscard]]distinctive operator for_delete_t*()noexcept(get_nothrow){return for_delete(get());}

	template<typename...Args> requires(invoke<T>.able<Args...>)
	inline decltype(auto)operator()(Args&&... rest)noexcept(invoke<T>.nothrow<Args...>){return(operator*())(forward<Args>(rest)...);}
};

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/comn_ptr_t.hpp"
//comn_ptr_t.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/comn_ptr_t.hpp"
template<typename T>
using comn_ptr_t=base_ptr_t<T,ref_able<remove_cvref<T>>,true>;

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/weak_ptr_t.hpp"
//weak_ptr_t.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/weak_ptr_t.hpp"
template<typename T>
using weak_ptr_t=base_ptr_t<T,weak_ref_able<remove_cvref<T>>,true>;

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/nocheck_ptr_t.hpp"
//nocheck_ptr_t.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/nocheck_ptr_t.hpp"
template<typename T>
using nocheck_ptr_t=base_ptr_t<T,ref_able<remove_cvref<T>>,false>;

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/deduction_guides.hpp"
//deduction_guides.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/deduction_guides.hpp"
template<class T,common_attribute_t ref_type,bool has_check>
base_ptr_t(T*) -> base_ptr_t<remove_cvref<T>,ref_type<remove_cvref<T>>,has_check>;

template<class T,common_attribute_t ref_type,bool has_check>
base_ptr_t(same_ptr_p_t<T>) -> base_ptr_t<T,ref_type<remove_cvref<T>>,has_check>;

//file_end

#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/_body.hpp"

//file_end

	#line 38 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/defs.hpp"
}

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_export.hpp"
//_export.hpp
//at namespace elc
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_export.hpp"
#define export using ptr_n::
export ref_able;
export weak_ref_able;
export base_ptr_t;
export comn_ptr_t;
export weak_ptr_t;
#undef export

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_test.hpp"
//_test.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_test.hpp"
namespace ptr_n{
	struct tester:type_info_t<tester>::template_name
		with_common_attribute<ref_able,weak_ref_able,never_in_array>,build_by_get_only{};
	void waiting_for_destroy(tester*)noexcept{}
	inline void test(){
		ELC_TEST_EVENTNAME("ptr部分测试");
		{
			comn_ptr_t a=get<tester>();
			weak_ptr_t b=a;
		}
		check_memory_lack();
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
}

//file_end

	#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_body.hpp"
#endif

//file_end

#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"
//依赖list
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/other/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/other/_body.hpp"
namespace others_n{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/other/replace_able.hpp"
//replace_able.hpp
//at namespace elc::defs::memory::others_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/other/replace_able.hpp"
//此属性配合 "../ptr" 食用
template<typename T>
struct replace_able:non_copyable,non_moveable,is_common_attribute(replace_able){
private:
	mutable T*_m;
public:
	constexpr replace_able()noexcept:_m(get_handle(this)){}
	constexpr ~replace_able()noexcept{
		if(replaced())
			attribute_ptr_cast<ref_able>(_m)->cut_ref();
	}
	constexpr bool replaced()const noexcept{return _m!=get_handle(this);}
	constexpr T*get_ptr()const noexcept{
		if(!replaced())
			return _m;
		else
			return attribute_ptr_cast<replace_able>(_m)->get_ptr();
	}
	constexpr void be_replace_as(T*new_p)noexcept{
		if(replaced())
			attribute_ptr_cast<ref_able>(_m)->cut_ref();
		_m=new_p;
		if(replaced())
			attribute_ptr_cast<ref_able>(_m)->add_ref();
	}
	constexpr void be_replace_as(nullptr_t)noexcept{be_replace_as(null_ptr);}
};

//file_end

	#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/other/_body.hpp"
	//依赖list
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/other/can_map_all.hpp"
//can_map_all.hpp
//at namespace elc::defs::memory::others_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/other/can_map_all.hpp"
template<typename T>
struct can_map_all:cons_t<can_map_all<T>>,is_common_attribute(can_map_all){
	typedef can_map_all<T> this_t;
private:
	distinctive static inline list_t<this_t> type_list;

	template<class,class func_t>
	friend inline void map_all_helper(func_t&&a);
public:
	constexpr can_map_all()noexcept{
		type_list.add(this);
	}
};
template<class T,class func_t>
inline void map_all_helper(func_t&&a){
	auto tmp=can_map_all<T>::type_list.begin();
	auto end=can_map_all<T>::type_list.end();
	while(tmp!=end)
		a(get_handle<T,can_map_all>(tmp++));
}
#define expr declvalue(func_t)(declvalue(T*))
template<class T,class func_t,enable_if(was_not_an_ill_form(expr))>
inline void map_all(func_t&&a)noexcept_as(expr){
	map_all_helper<T,func_t>(forward<func_t>(a));
}
#undef expr

//file_end

	#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/other/_body.hpp"
}

//file_end

#line 38 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"

//#include "gc/_body.hpp"//NOTE:gc不在此处定义，因为它依赖container

#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_test.hpp"
//_test.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_test.hpp"
inline void test(){
	ELC_TEST_EVENTNAME("memory部分测试");
	alloc_n::test();
	lifetime_n::test();
	get_n::test();
	//pool_n::test();
}
inline void test_log_out(){
	alloc_n::test_log_out();
	lifetime_n::test_log_out();
	get_n::test_log_out();
	//pool_n::test_log_out();
}
inline void test_end(){
	alloc_n::test_end();
	lifetime_n::test_end();
	get_n::test_end();
	//pool_n::test_end();
}

//file_end

	#line 43 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"
#endif

//file_end

		#line 53 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
	}
	using namespace memory;

	namespace container{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"
//_body.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_body.hpp"
//_body.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/defs.hpp"
//defs.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/defs.hpp"
namespace array_n{
	template<typename T>
	class array_t{
		typedef array_t<T>this_t;
		T*_m;

		/*return{ptr};*/
		constexpr array_t(T*a)noexcept:_m(a){}
		/*返回一个自身的副本*/
		[[nodiscard]]this_t copy()const noexcept(copy_get.nothrow<T>) requires(copy_get.able<T>){
			return{copy_get(_m)};
		}
	public:
		void swap_with(this_t&a)noexcept{swap(_m,a._m);}
	public:
		/*默认构造*/
		constexpr array_t()noexcept:_m(null_ptr){}
		#line 51 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/defs.hpp"
		explicit array_t(note::size_t<size_t>size)noexcept(get<T>.nothrow<>){
			_m=get<T>[size.value]();
		}
		explicit array_t(note::size_t<size_t>size,const T&elem)noexcept(get<T>.nothrow<>){
			_m=get<T>[size.value](elem);
		}
		#line 60 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/defs.hpp"
		//template<as_concept<get<T>.as_array.able> U>
		template<class U> requires(get<T>.as_array.able<U> && type_info<remove_cvref<U>>!=type_info<this_t>)
		array_t(U&&a)noexcept(get<T>.as_array.nothrow<U>){
			_m=get<T>.as_array(forward<U>(a));
		}

		//复制和移动函数
		array_t(const this_t&a)noexcept_as(declvalue(this_t).copy()):array_t(a.copy()){}
		this_t&operator=(const this_t&a)&noexcept_as(declvalue(this_t).copy()){
			return operator=(a.copy());
		}
		array_t(this_t&&a)noexcept:array_t(){swap_with(a);}
		this_t&operator=(this_t&&a)&noexcept{
			swap_with(a);
			return*this;
		}

		~array_t()noexcept(unget.nothrow<T>){
			unget(_m);
		}
		[[nodiscard]]size_t size()const noexcept{
			return get_size_of_get(_m);
		}
		[[nodiscard]]size_t size_in_byte()const noexcept{
			return size()*sizeof(T);
		}
		static constexpr bool resize_nothrow = get_resize.nothrow<T>;
		void resize(size_t size)noexcept(resize_nothrow){
			get_resize(_m,size);
		}
		static constexpr bool forward_resize_nothrow = get_forward_resize.nothrow<T>;
		void forward_resize(size_t size)noexcept(forward_resize_nothrow){
			get_forward_resize(_m,size);
		}
		static constexpr bool insert_nothrow = get_resize.insert.nothrow<T>;
		void insert(size_t index,size_t count)noexcept(insert_nothrow){
			get_resize.insert(_m,index,count);
		}
		void insert(size_t index,size_t count,const T*data)noexcept(insert_nothrow){
			get_resize.insert(_m,index,count,data);
		}
		void insert_with_resize(size_t index,size_t count,const T*data,size_t new_size)noexcept(insert_nothrow){
			get_resize.insert_with_resize(_m,index,count,data,new_size);
		}
		static constexpr bool insert_with_forward_resize_nothrow = get_forward_resize.insert_with_resize.nothrow<T>;
		void insert_with_forward_resize(size_t index,size_t count,const T*data,size_t new_size)noexcept(insert_with_forward_resize_nothrow){
			get_forward_resize.insert_with_resize(_m,index,count,data,new_size);
		}
		[[nodiscard]]bool empty()const noexcept{
			return _m==null_ptr;
		}
		void clear()noexcept(re_construct.nothrow<this_t>){
			re_construct(this);
		}
		[[nodiscard]]T*data()noexcept{return _m;}
		[[nodiscard]]const T*data()const noexcept{return _m;}
		[[nodiscard]]T&operator[](size_t pos)noexcept{return _m[pos];}
		[[nodiscard]]const T&operator[](size_t pos)const noexcept{return _m[pos];}
		[[nodiscard]]explicit operator hash_t()const noexcept(hash.nothrow<T>){return hash(_m,size());}
		[[nodiscard]]explicit operator T*()noexcept{return _m;}
		[[nodiscard]]explicit operator const T*()const noexcept{return _m;}

		typedef iterator_t<T>iterator;
		typedef const_iterator_t<T>const_iterator;

		[[nodiscard]]constexpr iterator get_iterator_at(size_t a)noexcept{
			return _m+a;
		}
		[[nodiscard]]constexpr const_iterator get_iterator_at(size_t a)const noexcept{
			return _m+a;
		}
		[[nodiscard]]constexpr iterator begin()noexcept{
			return get_iterator_at(zero);
		}
		[[nodiscard]]iterator end()noexcept{
			return get_iterator_at(size());
		}
		[[nodiscard]]constexpr const_iterator begin()const noexcept{
			return get_iterator_at(zero);
		}
		[[nodiscard]]const_iterator end()const noexcept{
			return get_iterator_at(size());
		}
		[[nodiscard]]const_iterator cbegin()const noexcept{
			return begin();
		}
		[[nodiscard]]const_iterator cend()const noexcept{
			return end();
		}
		typedef reverse_iterator_t<T>reverse_iterator;
		typedef reverse_const_iterator_t<T>reverse_const_iterator;
		[[nodiscard]]reverse_iterator rbegin()noexcept{
			return _m+size()-1;
		}
		[[nodiscard]]constexpr reverse_iterator rend()noexcept{
			return _m-1;
		}
		[[nodiscard]]reverse_const_iterator rbegin()const noexcept{
			return _m+size()-1;
		}
		[[nodiscard]]auto&front()noexcept{
			return*begin();
		}
		[[nodiscard]]auto&front()const noexcept{
			return*begin();
		}
		[[nodiscard]]auto&back()noexcept{
			return*rbegin();
		}
		[[nodiscard]]auto&back()const noexcept{
			return*rbegin();
		}
		[[nodiscard]]constexpr reverse_const_iterator rend()const noexcept{
			return _m-1;
		}
		[[nodiscard]]reverse_const_iterator rcbegin()const noexcept{
			return rbegin();
		}
		[[nodiscard]]constexpr reverse_const_iterator rcend()const noexcept{
			return rend();
		}

		[[nodiscard]]constexpr auto operator<=>(array_like_view_t<const T> a)const noexcept(compare.nothrow<array_like_view_t<T>>){
			return compare(array_like_view_t<const T>(*this),a);
		}
		[[nodiscard]]constexpr auto operator==(array_like_view_t<const T> a)const noexcept(equal.nothrow<array_like_view_t<T>>){
			return equal(array_like_view_t<const T>(*this),a);
		}
		[[nodiscard]]constexpr auto operator<=>(const this_t&a)const noexcept(compare.nothrow<array_like_view_t<T>>){
			return operator<=>(array_like_view_t<const T>(a));
		}
		[[nodiscard]]constexpr auto operator==(const this_t&a)const noexcept(equal.nothrow<array_like_view_t<T>>){
			return operator==(array_like_view_t<const T>(a));
		}

		#define expr declvalue(func_t)(declvalue(T&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each(func_t&&func)noexcept_as(expr){
			auto asize=size();
			while(asize--)
				func((*this)[asize]);
		}
		#undef expr

		#define expr declvalue(func_t)(declvalue(const T&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each(func_t&&func)const noexcept_as(expr){
			auto asize=size();
			while(asize--)
				func((*this)[asize]);
		}
		#undef expr

		void push_back(const T&a)noexcept(get<T>.apply_end.nothrow<const T&>){
			get<T>.apply_end(note::to<T*&>(_m),a);
		}
		void push_back(T&&a)noexcept(get<T>.apply_end.nothrow<T>){
			get<T>.apply_end(note::to<T*&>(_m),move(a));
		}
		void remove(T a)noexcept(get<T>.remove.nothrow<T>){
			get<T>.remove(a,note::from(_m));
		}
		//template<as_concept<get<T>.apply_end.able> U>
		template<class U,enable_if(get<T>.apply_end.able)>
		friend this_t&operator+=(this_t&a,U&&b)noexcept(get<T>.apply_end.nothrow<U>){
			get<T>.apply_end(note::to(a._m),b);
			return a;
		}
		friend this_t&operator+=(this_t&a,zero_t b)noexcept(get<T>.apply_end.nothrow<T>){
			return a+=T(0);
		}
		template<typename U>
		friend this_t operator+(const this_t&a,U&&b)noexcept_as(a.copy()+=b) requires was_not_an_ill_form(a.copy()+=b){
			return a.copy()+=b;
		}
		template<typename U>
		friend this_t operator+(U&&a,const this_t&b)noexcept_as(this_t(a)+=b) requires was_not_an_ill_form(this_t(a)+=b){
			return this_t(a)+=b;
		}

		template<typename U>
		this_t&& operator+(U&& b)&&noexcept_as(*this+=b) requires was_not_an_ill_form(*this+=b){//对右值的operator+优化为operator+=
			return *this+=b;
		}


		template<typename U>
		[[nodiscard]]iterator find(U&&a)noexcept requires was_not_an_ill_form(in_range(declvalue(this_t),a)){
			return in_range(*this,a);
		}
		template<typename U>
		[[nodiscard]]const_iterator find(U&&a)const noexcept requires was_not_an_ill_form(in_range(declvalue(this_t),a)){
			return in_range(*this,a);
		}
	};
	template<typename T>
	inline void swap(array_t<T>&a,array_t<T>&b)noexcept{a.swap_with(b);}

	template<class T>
	[[nodiscard]]inline auto size_of_array_like(const array_t<remove_cv<T>>&a)noexcept{return a.size();}
	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(array_t<remove_cv<T>>&a)noexcept{return(T*)a.begin();}
	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(const array_t<remove_cv<T>>&a)noexcept{return(const T*)a.begin();}
}

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/deduction_guides.hpp"
//deduction_guides.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/deduction_guides.hpp"
namespace array_n{
	template <class T,class...U>
	array_t(T,U...) -> array_t<T>;
	template <class T>
	array_t(array_t<T>) -> array_t<T>;
}

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_export.hpp"
//_export.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_export.hpp"
#define export using array_n::
export array_t;
#undef export

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_test.hpp"
//_test.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_test.hpp"
namespace array_n{
	//BLOCK:for debug
	inline void test(){
		ELC_TEST_EVENTNAME("array部分测试");
		{
			array_t<int>anarray;
			stest_accert(anarray.size()==0);
			anarray.resize(5);
			stest_accert(anarray.size()==5);
			anarray[2]=99;
			stest_accert(anarray[2]==99);
			anarray.resize(3);
			stest_accert(anarray[2]==99);
			anarray=anarray;
			swap(anarray,anarray);
		}
		check_memory_lack();
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
	//BLOCK_END
}

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_body.hpp"
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_body.hpp"
//_body.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/base_function_t.hpp"
//base_function_t.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/base_function_t.hpp"
namespace function_n{
	template<class T>
	class base_func_data_t;
	template<class Ret_t,class...Args_t>
	no_vtable_struct base_func_data_t<Ret_t(Args_t...)>:type_info_t<base_func_data_t<Ret_t(Args_t...)>>::template_name with_common_attribute<abstract_base,ref_able,never_in_array>,build_by_get_only{
		typedef base_func_data_t<Ret_t(Args_t...)>this_t;
		typedef comn_ptr_t<this_t>ptr_t;

		virtual ~base_func_data_t()=default;
		virtual Ret_t call(Args_t...)=0;
		//for equal:
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept=0;
		[[nodiscard]]virtual const void*get_data_begin()const noexcept=0;
		[[nodiscard]]virtual bool equal_with(const void*)const=0;
		[[noreturn]] virtual void throw_self_ptr()const=0;
		[[noreturn]] virtual void throw_self_ptr()=0;
		[[nodiscard]]bool operator==(const this_t&a)const{
			return this->get_type_info()==a.get_type_info()&&this->equal_with(a.get_data_begin());
		}
		template<typename T>
		[[nodiscard]]bool operator==(const T&a)const{
			return this->get_type_info()==type_info<T>&&this->equal_with(addressof(a));
		}
		typedef Ret_t(*func_ptr_t)(Args_t...);
		virtual func_ptr_t get_func_ptr()const noexcept{return nullptr;}
	};

	template<class T,class Func_t>
	class func_data_t;
	template<class T,class Ret_t,class...Args_t>
	struct func_data_t<T,Ret_t(Args_t...)>final:
	type_info_t<func_data_t<T,Ret_t(Args_t...)>>::template_name with_common_attribute<instance_struct>,
	base_func_data_t<Ret_t(Args_t...)>,function_data_wrapper_t<T,Ret_t(Args_t...)>{
		static_assert(!::std::is_function_v<T>);
		typedef base_func_data_t<Ret_t(Args_t...)>base_t;
		typedef func_data_t<T,Ret_t(Args_t...)>this_t;
		typedef function_data_wrapper_t<T,Ret_t(Args_t...)>data_t;
		typedef base_t::ptr_t ptr_t;
		typedef base_t::func_ptr_t func_ptr_t;

		[[nodiscard]]bool is_unique()const noexcept{return get_ref_num((base_t*)this)==1;}

		using data_t::data_t;
		virtual ~func_data_t()override=default;
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<T>;}
		[[nodiscard]]virtual const void*get_data_begin()const noexcept override final{return addressof(data_t::get_data());}
		[[noreturn]] virtual void throw_self_ptr()const override final{throw addressof(data_t::get_data());}
		[[noreturn]] virtual void throw_self_ptr()override final{throw addressof(data_t::get_data());}
		[[nodiscard]]virtual bool equal_with(const void*a)const noexcept(equal.able<T>?equal.nothrow<T>:true)override final{
			if constexpr(equal.able<T>)
				return data_t::get_data()==*remove_const(reinterpret_cast<const T*>(a));
			else
				return false;
		}
		[[nodiscard]]virtual Ret_t call(Args_t...args)noexcept(invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>)override final{
			return data_t::operator()(forward<Args_t>(args)...);
		}

		//func ptr convert
		virtual func_ptr_t get_func_ptr()const noexcept override final{
			if constexpr(type_info<const T>.can_convert_to<func_ptr_t>)
				return static_cast<func_ptr_t>(data_t::get_data());
			else
				return nullptr;
		}
	};

	template<class T>
	class default_func_data_t;
	template<class Ret_t,class...Args_t>
	struct default_func_data_t<Ret_t(Args_t...)>final:base_func_data_t<Ret_t(Args_t...)>,instance_struct<default_func_data_t<Ret_t(Args_t...)>>{
		typedef base_func_data_t<Ret_t(Args_t...)>base_t;
		typedef base_t::ptr_t ptr_t;

		virtual ~default_func_data_t()noexcept override final{}
		virtual Ret_t call(Args_t...)noexcept_as(Ret_t())override final{return Ret_t();}
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<void>;}
		[[nodiscard]]virtual const void*get_data_begin()const noexcept override final{return null_ptr;}//这玩意实际上用不到，艹
		[[noreturn]] virtual void throw_self_ptr()const override final{throw(const void*)null_ptr;}
		[[noreturn]] virtual void throw_self_ptr()override final{throw(void*)null_ptr;}
		[[nodiscard]]virtual bool equal_with(const void*)const noexcept override final{return true;}
	};
	template<class Ret_t,class...Args_t>
	distinctive inline default_func_data_t<Ret_t(Args_t...)>default_func_data{};

	template<class Ret_t,class...Args_t>
	[[nodiscard]]constexpr base_func_data_t<Ret_t(Args_t...)>*the_get_null_ptr(const base_func_data_t<Ret_t(Args_t...)>*)noexcept{
		return&default_func_data<Ret_t,Args_t...>;
	}

	template<class T>
	class function_data_saver_t;
	template<class Ret_t,class...Args_t>
	class function_data_saver_t<Ret_t(Args_t...)>{
	protected:
		typedef function_data_saver_t<Ret_t(Args_t...)>this_t;
		typedef base_func_data_t<Ret_t(Args_t...)> base_t_w;
		typedef comn_ptr_t<base_t_w>ptr_t;

		mutable ptr_t _m;
		void swap_with(this_t&a)noexcept{swap(_m,a._m);}
	public:
		function_data_saver_t()noexcept=default;
		function_data_saver_t(const this_t&a)noexcept:_m(a._m){}
		function_data_saver_t(this_t&&a)noexcept{swap_with(a);}
		[[nodiscard]]bool operator==(const this_t&a)const{
			return *_m==*(a._m);
		}
		template<typename T> requires(equal.able<base_t_w,T>)
		[[nodiscard]]bool operator==(T&&a)const noexcept(equal.nothrow<base_t_w,T>){
			return *_m==a;
		}
		template<typename T>
		[[nodiscard]]bool was_an()const noexcept{
			try{
				_m->throw_self_ptr();
			}
			catch(const T*p){
				return true;
			}
			catch(const void*){}
			return false;
		}
		template<typename T>
		[[nodiscard]]maybe_fail_reference<T> get_as()noexcept{
			try{
				_m->throw_self_ptr();
			}
			catch(T*p){
				return *p;
			}
			catch(void*){}
			return note::fail;
		}
		push_and_disable_msvc_warning(26440);//nothrow警告diss
		void operator=(const this_t&a){_m=a._m;}
		Ret_t call(Args_t&&...rest)const{return _m->call(forward<Args_t>(rest)...);}
		pop_msvc_warning();
	};

	template<class T,bool promise_nothrow_at_destruct>
	class base_function_t;

	template<class T>
	struct is_function_t_helper {
		constexpr static bool value = false;
	};
	template<class T, bool promise_nothrow_at_destruct>
	struct is_function_t_helper<base_function_t<T, promise_nothrow_at_destruct>> {
		constexpr static bool value = true;
	};
	template<class T>
	constexpr static bool is_function_t = is_function_t_helper<T>::value;
	#if !defined(_MSC_VER)
	template<class Ret_t,class...Args_t,bool nothrow,bool promise_nothrow_at_destruct>
	struct base_function_t<Ret_t(Args_t...)noexcept(nothrow),promise_nothrow_at_destruct>:function_data_saver_t<Ret_t(Args_t...)>{
	protected:
		typedef function_data_saver_t<Ret_t(Args_t...)>base_t;
		typedef base_function_t<Ret_t(Args_t...)noexcept(nothrow),promise_nothrow_at_destruct>this_t;

		template<class,bool>
		friend class base_function_t;

		template<class U>
		using func_data_t=function_n::func_data_t<U,Ret_t(Args_t...)>;

		typedef Ret_t(*func_ptr_t)(Args_t...)noexcept(nothrow);

		using base_t::ptr_t;
		using base_t::_m;

		template<class T>
		static constexpr bool base_on_this_t_or_more_stringent_restrictions=(
			type_info<T>.base_on<this_t>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept(bool(nothrow+1)),	promise_nothrow_at_destruct			>>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept(nothrow),			bool(promise_nothrow_at_destruct+1)	>>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept(bool(nothrow+1)),	bool(promise_nothrow_at_destruct+1)	>>
		);

		template<class T>
		static constexpr bool get_data_able_helper()noexcept{
			if constexpr(base_on_this_t_or_more_stringent_restrictions<T>)
				return true;
			elseif constexpr(is_function_t<T>)
				return false;
			elseif constexpr(::std::is_function_v<T>)
				return get_data_able_helper<decltype(&declvalue(T))>();
			elseif constexpr(invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				return get<func_data_t<remove_cvref<T>>>.able<T>;
			else
				return false;
		}
		template<class T>
		static constexpr bool get_data_able=get_data_able_helper<T>();
		template<class T>
		static constexpr bool get_data_nothrow_helper()noexcept{
			if constexpr(base_on_this_t_or_more_stringent_restrictions<T>)
				return true;
			elseif constexpr(is_function_t<T>)
				return false;
			elseif constexpr(::std::is_function_v<T>)
				return get_data_nothrow_helper<decltype(&declvalue(T))>();
			elseif constexpr(invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				return get<func_data_t<remove_cvref<T>>>.nothrow<T>;
			else
				return false;
		}
		template<class T>
		static constexpr bool get_data_nothrow=get_data_nothrow_helper<T>();

		template<class T> requires get_data_able<T>
		static auto get_data_from(T&&a)noexcept(get_data_nothrow<T>){
			if constexpr(::std::is_function_v<T>)
				return get_data_from(&a);
			elseif constexpr(is_function_t<T>)
				return a._m;
			else{
				//BLOCK:constexpr checks
				if constexpr(promise_nothrow_at_destruct and not destruct.nothrow<T>)
					template_error("unexpected assign.");
				if constexpr(nothrow)
					if constexpr(!invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>)
						template_warning("the call of T was not noexcept,this may cause terminate.");
				//BLOCK_END
				return get<func_data_t<remove_cvref<T>>>(a);
			}
		}
		explicit base_function_t(base_t::ptr_t a)noexcept{_m=a;}
	public:
		void swap_with(this_t&a)noexcept{//不与base_t::swap_with重复：与更加严格（或宽松）的this_t进行swap是错误的
			base_t::swap_with(a);
		}

		base_function_t()noexcept=default;
		template<class T> requires base_on_this_t_or_more_stringent_restrictions<T>
		base_function_t(const T&a)noexcept:base_t(a){}
		base_function_t(const this_t&a)noexcept:base_t(a){}
		base_function_t(this_t&&a)noexcept:base_function_t(){
			swap_with(a);
		}
		base_function_t(null_ptr_t)noexcept:base_function_t(){}
		base_function_t(nullptr_t)noexcept:base_function_t(null_ptr){}
		template<class T> requires get_data_able<T>
		base_function_t(T&&a)noexcept(get_data_nothrow<T>){
			_m=get_data_from(forward<T>(a));
		}
		base_function_t(func_ptr_t a)noexcept{//当nothrow==0时，noexcept(true)的参数可自动转为noexcept(false)的，不用再次考虑
			_m=get<func_data_t<func_ptr_t>>(a);
		}
		~base_function_t()noexcept(promise_nothrow_at_destruct)=default;

		this_t&operator=(const this_t&a)&noexcept(promise_nothrow_at_destruct)=default;
		this_t&operator=(this_t&&a)&noexcept(promise_nothrow_at_destruct)=default;
		this_t&operator=(null_ptr_t)&noexcept(promise_nothrow_at_destruct){_m=null_ptr;return *this;}
		this_t&operator=(nullptr_t)&noexcept(promise_nothrow_at_destruct){return *this=null_ptr;}
		template<class T> requires base_on_this_t_or_more_stringent_restrictions<T>
		this_t&operator=(const T&a)&noexcept(promise_nothrow_at_destruct){
			base_t::operator=(a);
			return*this;
		}
		template<class T> requires get_data_able<T>
		this_t&operator=(T&&a)noexcept(get_data_nothrow<T> && promise_nothrow_at_destruct){
			_m=get_data_from(forward<T>(a));
			return*this;
		}

		this_t deep_copy(){return this_t{copy_get(_m.get())};}

		[[nodiscard]]explicit operator bool()const noexcept{
			return bool(_m);
		}

		Ret_t operator()(Args_t...args)const noexcept(nothrow){
			push_and_disable_msvc_warning(26447);
			return base_t::call(forward<Args_t>(args)...);
			pop_msvc_warning();
		}

	private:
		//以下是突然想加的功能(没什么用<迷惑行为大赏>).
		static thread_local inline base_t::base_t_w* _func_ptr_data_local=nullptr;
		static inline ::std::atomic<decltype(_func_ptr_data_local)> _func_ptr_data_gobal=nullptr;
		static Ret_t _func_ptr_value(Args_t...args)noexcept{
			if(!_func_ptr_data_local)
				_func_ptr_data_local=_func_ptr_data_gobal.load(::std::memory_order_relaxed);
			return _func_ptr_data_local->call(forward<Args_t>(args)...);
		}
	public:
		//自当前function对象生成一个函数指针，具有与当前function对象相同的行为
		//注意：该函数指针的有效性保留到当前线程下一个同类型的函数指针生成时或当前function对象析构时
		//若自该函数指针创建一个新的线程，该函数指针在新线程中的行为与调用时以前所有线程中最后一个生成的同类型的函数指针行为相同
		[[nodiscard]]explicit operator func_ptr_t()const noexcept(promise_nothrow_at_destruct){
			func_ptr_t a=(func_ptr_t)_m->get_func_ptr();
			if(a)return a;
			_func_ptr_data_local=base_t::_m.get();
			_func_ptr_data_gobal.store(_func_ptr_data_local,::std::memory_order_relaxed);
			return _func_ptr_value;
		}
	};
	#else
	//MSVC，我滴垃圾堆
	template<class Ret_t,class...Args_t,bool promise_nothrow_at_destruct>
	struct base_function_t<Ret_t(Args_t...),promise_nothrow_at_destruct>:function_data_saver_t<Ret_t(Args_t...)>{
	protected:
		typedef function_data_saver_t<Ret_t(Args_t...)>base_t;
		typedef base_function_t<Ret_t(Args_t...),promise_nothrow_at_destruct>this_t;

		template<class,bool>
		friend class base_function_t;

		template<class U>
		using func_data_t=function_n::func_data_t<U,Ret_t(Args_t...)>;

		typedef Ret_t(*func_ptr_t)(Args_t...);

		using base_t::ptr_t;
		using base_t::_m;

		template<class T>
		static constexpr bool base_on_this_t_or_more_stringent_restrictions=(
			type_info<T>.base_on<this_t>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept,	promise_nothrow_at_destruct			>>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...),			bool(promise_nothrow_at_destruct+1)	>>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept,	bool(promise_nothrow_at_destruct+1)	>>
		);

		template<class T>
		static constexpr bool get_data_able_helper()noexcept{
			if constexpr(base_on_this_t_or_more_stringent_restrictions<T>)
				return true;
			elseif constexpr(is_function_t<T>)
				return false;
			elseif constexpr(::std::is_function_v<T>)
				return get_data_able_helper<decltype(&declvalue(T))>();
			elseif constexpr(invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				return get<func_data_t<remove_cvref<T>>>.able<T>;
			else
				return false;
		}
		template<class T>
		static constexpr bool get_data_able=get_data_able_helper<T>();
		template<class T>
		static constexpr bool get_data_nothrow_helper()noexcept{
			if constexpr(base_on_this_t_or_more_stringent_restrictions<T>)
				return true;
			elseif constexpr(is_function_t<T>)
				return false;
			elseif constexpr(::std::is_function_v<T>)
				return get_data_nothrow_helper<decltype(&declvalue(T))>();
			elseif constexpr(invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				return get<func_data_t<remove_cvref<T>>>.nothrow<T>;
			else
				return false;
		}
		template<class T>
		static constexpr bool get_data_nothrow=get_data_nothrow_helper<T>();

		template<class T> requires get_data_able<T>
		static auto get_data_from(T&&a)noexcept(get_data_nothrow<T>){
			if constexpr(::std::is_function_v<T>)
				return get_data_from(&a);
			elseif constexpr(is_function_t<T>)
				return a._m;
			else{
				//BLOCK:constexpr checks
				if constexpr(promise_nothrow_at_destruct and not destruct.nothrow<T>)
					template_error("unexpected assign.");
				//BLOCK_END
				return get<func_data_t<remove_cvref<T>>>(a);
			}
		}
		explicit base_function_t(base_t::ptr_t a)noexcept{_m=a;}
	public:
		void swap_with(this_t&a)noexcept{//不与base_t::swap_with重复：与更加严格（或宽松）的this_t进行swap是错误的
			base_t::swap_with(a);
		}

		base_function_t()noexcept=default;
		template<class T> requires base_on_this_t_or_more_stringent_restrictions<T>
		base_function_t(const T&a)noexcept:base_t(a){}
		base_function_t(const this_t&a)noexcept:base_t(a){}
		base_function_t(this_t&&a)noexcept:base_function_t(){
			swap_with(a);
		}
		base_function_t(null_ptr_t)noexcept:base_function_t(){}
		base_function_t(nullptr_t)noexcept:base_function_t(null_ptr){}
		template<class T> requires get_data_able<T>
		base_function_t(T&&a)noexcept(get_data_nothrow<T>){
			_m=get_data_from(forward<T>(a));
		}
		base_function_t(func_ptr_t a)noexcept{//当nothrow==0时，noexcept(true)的参数可自动转为noexcept(false)的，不用再次考虑
			_m=get<func_data_t<func_ptr_t>>(a);
		}
		~base_function_t()noexcept(promise_nothrow_at_destruct)=default;

		this_t&operator=(const this_t&a)noexcept(promise_nothrow_at_destruct)=default;
		this_t&operator=(this_t&&a)noexcept(promise_nothrow_at_destruct)=default;
		this_t&operator=(null_ptr_t)noexcept(promise_nothrow_at_destruct){_m=null_ptr;return *this;}
		this_t&operator=(nullptr_t)noexcept(promise_nothrow_at_destruct){return *this=null_ptr;}
		template<class T> requires base_on_this_t_or_more_stringent_restrictions<T>
		this_t&operator=(const T&a)&noexcept(promise_nothrow_at_destruct){
			base_t::operator=(a);
			return*this;
		}
		template<class T> requires get_data_able<T>
		this_t&operator=(T&&a)noexcept(get_data_nothrow<T> && promise_nothrow_at_destruct){
			_m=get_data_from(forward<T>(a));
			return*this;
		}

		this_t deep_copy(){return this_t{copy_get(_m.get())};}

		[[nodiscard]]explicit operator bool()const noexcept{
			return bool(_m);
		}

		Ret_t operator()(Args_t...args){
			return base_t::call(forward<Args_t>(args)...);
		}
		Ret_t operator()(Args_t...args)const{
			return base_t::call(forward<Args_t>(args)...);
		}

	private:
		//以下是突然想加的功能(没什么用<迷惑行为大赏>).
		static thread_local inline base_t::base_t_w* _func_ptr_data_local=nullptr;
		static inline ::std::atomic<decltype(_func_ptr_data_local)> _func_ptr_data_gobal=nullptr;
		static Ret_t _func_ptr_value(Args_t...args)noexcept{
			if(!_func_ptr_data_local)
				_func_ptr_data_local=_func_ptr_data_gobal.load(::std::memory_order_relaxed);
			return _func_ptr_data_local->call(forward<Args_t>(args)...);
		}
	public:
		//自当前function对象生成一个函数指针，具有与当前function对象相同的行为
		//注意：该函数指针的有效性保留到当前线程下一个同类型的函数指针生成时或当前function对象析构时
		//若自该函数指针创建一个新的线程，该函数指针在新线程中的行为与调用时以前所有线程中最后一个生成的同类型的函数指针行为相同
		[[nodiscard]]explicit operator func_ptr_t()const noexcept(promise_nothrow_at_destruct){
			func_ptr_t a=(func_ptr_t)_m->get_func_ptr();
			if(a)return a;
			_func_ptr_data_local=base_t::_m.get();
			_func_ptr_data_gobal.store(_func_ptr_data_local,::std::memory_order_relaxed);
			return _func_ptr_value;
		}
	};
	template<class Ret_t,class...Args_t,bool promise_nothrow_at_destruct>
	struct base_function_t<Ret_t(Args_t...)noexcept,promise_nothrow_at_destruct>:function_data_saver_t<Ret_t(Args_t...)>{
	protected:
		typedef function_data_saver_t<Ret_t(Args_t...)>base_t;
		typedef base_function_t<Ret_t(Args_t...)noexcept,promise_nothrow_at_destruct>this_t;

		template<class,bool>
		friend class base_function_t;

		template<class U>
		using func_data_t=function_n::func_data_t<U,Ret_t(Args_t...)>;

		typedef Ret_t(*func_ptr_t)(Args_t...)noexcept;

		using base_t::ptr_t;
		using base_t::_m;

		template<class T>
		static constexpr bool base_on_this_t_or_more_stringent_restrictions=(
			type_info<T>.base_on<this_t>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept,	promise_nothrow_at_destruct			>>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept,	bool(promise_nothrow_at_destruct+1)	>>
		);

		template<class T>
		static constexpr bool get_data_able_helper()noexcept{
			if constexpr(base_on_this_t_or_more_stringent_restrictions<T>)
				return true;
			elseif constexpr(is_function_t<T>)
				return false;
			elseif constexpr(::std::is_function_v<T>)
				return get_data_able_helper<decltype(&declvalue(T))>();
			elseif constexpr(invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				return get<func_data_t<remove_cvref<T>>>.able<T>;
			else
				return false;
		}
		template<class T>
		static constexpr bool get_data_able=get_data_able_helper<T>();
		template<class T>
		static constexpr bool get_data_nothrow_helper()noexcept{
			if constexpr(base_on_this_t_or_more_stringent_restrictions<T>)
				return true;
			elseif constexpr(is_function_t<T>)
				return false;
			elseif constexpr(::std::is_function_v<T>)
				return get_data_nothrow_helper<decltype(&declvalue(T))>();
			elseif constexpr(invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				return get<func_data_t<remove_cvref<T>>>.nothrow<T>;
			else
				return false;
		}
		template<class T>
		static constexpr bool get_data_nothrow=get_data_nothrow_helper<T>();

		template<class T> requires get_data_able<T>
		static auto get_data_from(T&&a)noexcept(get_data_nothrow<T>){
			if constexpr(::std::is_function_v<T>)
				return get_data_from(&a);
			elseif constexpr(is_function_t<T>)
				return a._m;
			else{
				//BLOCK:constexpr checks
				if constexpr(promise_nothrow_at_destruct and not destruct.nothrow<T>)
					template_error("unexpected assign.");
				if constexpr(1)
					if constexpr(!invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>)
						template_warning("the call of T was not noexcept,this may cause terminate.");
				//BLOCK_END
				return get<func_data_t<remove_cvref<T>>>(a);
			}
		}
		explicit base_function_t(base_t::ptr_t a)noexcept{_m=a;}
	public:
		void swap_with(this_t&a)noexcept{//不与base_t::swap_with重复：与更加严格（或宽松）的this_t进行swap是错误的
			base_t::swap_with(a);
		}

		base_function_t()noexcept=default;
		template<class T> requires base_on_this_t_or_more_stringent_restrictions<T>
		base_function_t(const T&a)noexcept:base_t(a){}
		base_function_t(const this_t&a)noexcept:base_t(a){}
		base_function_t(this_t&&a)noexcept:base_function_t(){
			swap_with(a);
		}
		base_function_t(null_ptr_t)noexcept:base_function_t(){}
		base_function_t(nullptr_t)noexcept:base_function_t(null_ptr){}
		template<class T> requires get_data_able<T>
		base_function_t(T&&a)noexcept(get_data_nothrow<T>){
			_m=get_data_from(forward<T>(a));
		}
		base_function_t(func_ptr_t a)noexcept{//当nothrow==0时，noexcept(true)的参数可自动转为noexcept(false)的，不用再次考虑
			_m=get<func_data_t<func_ptr_t>>(a);
		}
		~base_function_t()noexcept(promise_nothrow_at_destruct)=default;

		this_t&operator=(const this_t&a)&noexcept(promise_nothrow_at_destruct)=default;
		this_t&operator=(this_t&&a)&noexcept(promise_nothrow_at_destruct)=default;
		this_t&operator=(null_ptr_t)&noexcept(promise_nothrow_at_destruct){_m=null_ptr;return *this;}
		this_t&operator=(nullptr_t)&noexcept(promise_nothrow_at_destruct){return *this=null_ptr;}
		template<class T> requires base_on_this_t_or_more_stringent_restrictions<T>
		this_t&operator=(const T&a)&noexcept(promise_nothrow_at_destruct){
			base_t::operator=(a);
			return*this;
		}
		template<class T> requires get_data_able<T>
		this_t&operator=(T&&a)noexcept(get_data_nothrow<T> && promise_nothrow_at_destruct){
			_m=get_data_from(forward<T>(a));
			return*this;
		}

		this_t deep_copy(){return this_t{copy_get(_m.get())};}

		[[nodiscard]]explicit operator bool()const noexcept{
			return bool(_m);
		}

		push_and_disable_msvc_warning(26447);
		Ret_t operator()(Args_t...args)noexcept{
			return base_t::call(forward<Args_t>(args)...);
		}
		Ret_t operator()(Args_t...args)const noexcept{
			return base_t::call(forward<Args_t>(args)...);
		}
		pop_msvc_warning();

	private:
		//以下是突然想加的功能(没什么用<迷惑行为大赏>).
		static thread_local inline base_t::base_t_w* _func_ptr_data_local=nullptr;
		static inline ::std::atomic<decltype(_func_ptr_data_local)> _func_ptr_data_gobal=nullptr;
		static Ret_t _func_ptr_value(Args_t...args)noexcept{
			if(!_func_ptr_data_local)
				_func_ptr_data_local=_func_ptr_data_gobal.load(::std::memory_order_relaxed);
			return _func_ptr_data_local->call(forward<Args_t>(args)...);
		}
	public:
		//自当前function对象生成一个函数指针，具有与当前function对象相同的行为
		//注意：该函数指针的有效性保留到当前线程下一个同类型的函数指针生成时或当前function对象析构时
		//若自该函数指针创建一个新的线程，该函数指针在新线程中的行为与调用时以前所有线程中最后一个生成的同类型的函数指针行为相同
		[[nodiscard]]explicit operator func_ptr_t()const noexcept(promise_nothrow_at_destruct){
			func_ptr_t a=(func_ptr_t)_m->get_func_ptr();
			if(a)return a;
			_func_ptr_data_local=base_t::_m.get();
			_func_ptr_data_gobal.store(_func_ptr_data_local,::std::memory_order_relaxed);
			return _func_ptr_value;
		}
	};
	#endif
	template<class T,bool promise_nothrow_at_destruct>
	void swap(base_function_t<T,promise_nothrow_at_destruct>&a,base_function_t<T,promise_nothrow_at_destruct>&b)noexcept{
		a.swap_with(b);
	}
}

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/defs.hpp"
//defs.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/defs.hpp"
namespace function_n{
	template<class T>
	using function_t=base_function_t<T,true>;

	//[[deprecated("not safe")]]//用这么长名字的人大概知道自己在干啥
	template<class T>
	using may_throw_in_destruct_function_t=base_function_t<T,false>;
}

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/deduction_guides.hpp"
//deduction_guides.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/deduction_guides.hpp"
namespace function_n{
	template<typename T,typename Func_t=get_function_type<T>,bool promise_nothrow_at_destruct>
	base_function_t(T)->base_function_t<Func_t,promise_nothrow_at_destruct>;
}

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_export.hpp"
//_export.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_export.hpp"
#define export using function_n::
export function_t;
//export may_throw_in_destruct_function_t;
#undef export

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_test.hpp"
//_test.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_test.hpp"
namespace function_n{
	//BLOCK:for debug
	inline void test(){
		ELC_TEST_EVENTNAME("function部分测试");
		{
			int tester=0;
			#if !defined(_MSC_VER)
				function_t
			#else
				function_t<void()noexcept>
			#endif
			a(lambda_with_catch (&tester)()noexcept{ tester=1; });
			static_assert(type_info<decltype(a)> == type_info<function_t<void()noexcept>>);
			stest_accert(tester==0);
			a();
			stest_accert(tester==1);
			#if !defined(_MSC_VER)
				function_t
			#else
				function_t<void()>
			#endif
			b=test;
			static_assert(type_info<decltype(b)> == type_info<function_t<void()>>);
			b=a;
			a=null_ptr;
			tester=0;
			a();
			stest_accert(tester==0);
			b();
			stest_accert(tester==1);
			swap(a,a);
			stest_accert(a!=b);
			b=a;
			stest_accert(a==b);
		}
		check_memory_lack();
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
	//BLOCK_END
}

//file_end

	#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_body.hpp"
#endif

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_body.hpp"
//_body.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_body.hpp"
namespace stack_n{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/base_stack.hpp"
//defs.hpp
//at namespace elc::defs::container::stack_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/base_stack.hpp"
template<typename T>
class base_stack_t:non_copyable{//基础容器，可用于hashtable
	typedef base_stack_t<T>this_t;
protected:
	struct data_t{
		T _data;
		data_t*_next;

		constexpr_as(construct<T>(declvalue(const T&)))data_t(const T&a,data_t*b)noexcept(construct<T>.nothrow<const T&>):_data(a),_next(b){}
		constexpr_as(construct<T>(declvalue(const T&)))data_t(const data_t&a)noexcept(construct<T>.nothrow<const T&>):_data(a._data),_next(null_ptr){}
	}*_m;
	size_t _size;
private:
	this_t copy()const noexcept(copy_get.nothrow<data_t>){
		this_t tmp;
		const data_t*p=_m;
		data_t**p_=&tmp._m;
		while(p!=null_ptr){
			*p_=copy_get(p);
			p_=&(**p_)._next;
			p=p->_next;
		}
		tmp._size=size();
		return tmp;
	}
public:
	constexpr base_stack_t()noexcept:_m(null_ptr),_size(0){}
	void swap_with(this_t&a)noexcept{
		swap(_m,a._m);
		swap(_size,a._size);
	}
	this_t&operator=(this_t&&a)&noexcept{
		swap_with(a);
		return*this;
	}
	base_stack_t(this_t&&a)noexcept:base_stack_t(){
		operator=(move(a));
	}
	this_t&operator=(const this_t&a)&noexcept_as(declvalue(this_t).copy()){
		return operator=(a.copy());
	}
	base_stack_t(const this_t&a)noexcept_as(declvalue(this_t).copy()):base_stack_t(a.copy()){}
	~base_stack_t()noexcept(unget.nothrow<data_t>){
		push_and_disable_msvc_warning(26494);//未初始化警告diss
		data_t*tmp;
		pop_msvc_warning();
		while(_m!=null_ptr){
			tmp=_m;
			_m=_m->_next;
			unget(tmp);
		}
	}
	void clear()noexcept(re_construct.nothrow<this_t>){
		re_construct(this);
	}
	[[nodiscard]]bool empty()const noexcept{
		return _m==null_ptr;
	}
	template<typename U>
	[[nodiscard]]maybe_fail_reference<T>find(U&&a)noexcept_as(declvalue(T&)==a){
		data_t*tmp=_m;
		while(tmp!=null_ptr){
			if(tmp->_data==a)
				return tmp->_data;
			tmp=tmp->_next;
		}
		return note::fail;
	}
	[[nodiscard]]bool in_stack(const T&a)const noexcept_as(declvalue(this_t).find(a).not_fail()){
		return remove_const(this)->find(a).not_fail();
	}
	[[nodiscard]]bool not_in_stack(const T&a)const noexcept_as(declvalue(this_t).in_stack(a)){
		return not in_stack(a);
	}
	[[nodiscard]]size_t size()const noexcept{
		return _size;
	}

	static constexpr bool add_nothrow=noexcept(get<data_t>(declvalue(const T&),declvalue(data_t*)));
	void add(const T&a)noexcept(add_nothrow){
		_m=get<data_t>(a,_m);
		_size++;
	}

	static constexpr bool remove_nothrow=unget.nothrow<data_t>;
	template<typename T_>
	bool remove(const T_&a)noexcept(remove_nothrow && equal.nothrow<T_,T>){//返回值：是否成功移除（容器里是否有此T）
		data_t*tmp=_m,**tmp_=&_m;
		while(tmp!=null_ptr){
			if(a==tmp->_data){
				_size--;
				*tmp_=tmp->_next;
				unget(tmp);
				return true;
			}
			tmp_=&tmp->_next;
			tmp=*tmp_;
		}
		return false;
	}
	#define expr declvalue(func_t)(declvalue(T&))
	template<typename func_t> requires was_not_an_ill_form(expr)
	void for_each(func_t&&func)noexcept_as(expr){
		data_t*tmp=_m;
		while(tmp!=null_ptr){
			func(tmp->_data);
			tmp=tmp->_next;
		}
	}
	#undef expr

	#define expr declvalue(func_t)(declvalue(const T&))
	template<typename func_t> requires was_not_an_ill_form(expr)
	void for_each(func_t&&func)const noexcept_as(expr){
		const data_t*tmp=_m;
		while(tmp!=null_ptr){
			func(tmp->_data);
			tmp=tmp->_next;
		}
	}
	#undef expr
protected:
	void add(data_t*a)noexcept{
		a->_next=_m;
		_m=a;
		_size++;
	}
public:
	[[nodiscard]]hash_t get_top_hash()noexcept_as(hash(declvalue(T&))){
		if(_m)
			return hash(_m->_data);
		else
			return hash(_m);
	}
	void move_top_to(this_t&a)noexcept{
		_size--;
		auto tmp=_m;
		_m=_m->_next;
		a.add(tmp);
	}
};

//file_end

	#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/auto_stack.hpp"
//defs.hpp
//at namespace elc::defs::container::stack_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/auto_stack.hpp"
template<typename T>
struct auto_stack_t:base_stack_t<T>{//提头优化容器，可用于hashtable
private:
	typedef base_stack_t<T>base_t;
	typedef auto_stack_t<T>this_t;

	using base_t::data_t;
	using base_t::_m;
public:
	using base_t::base_t;
	auto_stack_t(const base_t&a)noexcept_as(base_t(a)):base_t(a){}
	auto_stack_t(base_t&&a)noexcept_as(base_t(a)):base_t(a){}

	this_t&operator=(this_t&&a)&noexcept{base_t::operator=(move(a));return*this;}
	template<typename U>
	[[nodiscard]]maybe_fail_reference<T>find(U&&a)noexcept_as(declvalue(T&)==a){
		data_t*tmp=_m,**tmp_=&_m;
		while(tmp!=null_ptr){
			if(tmp->_data==a){
				*tmp_=tmp->_next;
				tmp->_next=_m;//提头
				_m=tmp;
				return tmp->_data;
			}
			tmp_=&tmp->_next;
			tmp=*tmp_;
		}
		return note::fail;
	}
	[[nodiscard]]bool in_stack(const T&a)const noexcept_as(declvalue(this_t).find(a).not_fail()){
		return remove_const(this)->find(a).not_fail();
	}
	[[nodiscard]]bool not_in_stack(const T&a)const noexcept_as(declvalue(this_t).in_stack(a)){
		return not in_stack(a);
	}
};

//file_end

	#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_body.hpp"

	#if defined(ELC_TEST_ON)
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_test.hpp"
//_test.hpp
//at namespace elc::defs::container::stack_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_test.hpp"
inline void test(){
	ELC_TEST_EVENTNAME("stack部分测试");
	{
		base_stack_t<int>a;
		stest_accert(a.size()==0);
		a.add(1);
		a.add(2);
		a.add(3);
		stest_accert(a.size()==3);
		a.remove(2);
		stest_accert(a.size()==2);
		int add_num=0;
		a.for_each(lambda_with_catch(&add_num)(int a){add_num+=a;});
		stest_accert(add_num==4);
		auto_stack_t<int>b=a;
		stest_accert(b.not_in_stack(2));
		b.remove(3);
		stest_accert(a.in_stack(3));
		a.clear();
		b=a;
		a=b;
		stest_accert(b.size()==0);
	}
	check_memory_lack();
}
inline void test_log_out(){
}
inline void test_end(){
}

//file_end

		#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_body.hpp"
	#endif
}
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_export.hpp"
//_export.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_export.hpp"
#define export using stack_n::
export auto_stack_t;
export base_stack_t;
#undef export

//file_end

#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_body.hpp"

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_body.hpp"
//_body.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/defs.hpp"
//defs.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/defs.hpp"
namespace hash_table_n{
	template<typename T,template<typename>class stack_t=auto_stack_t,size_t bucket_max_size=256>
	class hash_table_t{
		typedef hash_table_t<T,stack_t,bucket_max_size>this_t;
		typedef stack_t<T>bucket_t;
	public:
		typedef array_t<bucket_t>base_t_w;
	private:
		base_t_w _m;
	public:
		void swap(base_t_w&a)noexcept{_m.swap_with(a);}
	private:
		[[nodiscard]]bucket_t&find_bucket(hash_t a)noexcept{
			return _m[a%_m.size()];
		}
		void bucket_count_grow()noexcept{
			this_t tmp(special_init,get_next_gold_size_to_resize_for_hash(_m.size()));
			for(bucket_t&a:_m){
				while(!a.empty())
					a.move_top_to(tmp.find_bucket(a.get_top_hash()));
			}
			swap(tmp);
		}
		hash_table_t(const base_t_w&a)noexcept:_m(a){}
		this_t copy()noexcept(copy_construct.nothrow<base_t_w>){
			return{_m};
		}
	public:
		hash_table_t()noexcept:_m(5){}
		hash_table_t(special_init_t,size_t bucket_size)noexcept:_m(bucket_size){}
		~hash_table_t()noexcept(destruct.nothrow<base_t_w>)=default;

		operator base_t_w&()noexcept{return _m;}
		operator const base_t_w&()const noexcept{return _m;}

		hash_table_t(const this_t&a)noexcept:_m(a._m){}
		hash_table_t(this_t&&a)noexcept:_m(a._m){}

		this_t&operator=(base_t_w&&a)&noexcept{
			swap(_m,a);
			return*this;
		}
		this_t&operator=(const base_t_w&a)&noexcept{
			_m=a;
			return*this;
		}

		template<typename U>
		static constexpr bool hash_nothrow=noexcept(hash(declvalue(U)));
		template<typename U>
		static constexpr bool find_nothrow=hash_nothrow<U>&&noexcept(declvalue(bucket_t).find(declvalue(U)));

		void add(const T&a)noexcept(hash_nothrow<const T&>&&bucket_t::add_nothrow){
			auto&bucket=find_bucket(hash(a));
			bucket.add(a);
			if(bucket.size() > bucket_max_size)
				bucket_count_grow();
		}
		bool remove(const T&a)noexcept(bucket_t::remove_nothrow){
			auto&bucket=find_bucket(hash(a));
			bool remove_success=bucket.remove(a);
			if constexpr(is_unstable_hash<T>)
				if(not remove_success){
					for(auto&i:_m){
						if(is_eq(i,bucket))
							continue;
						remove_success=i.remove(a);
						if(remove_success)
							break;
					}
				}
			return remove_success;
		}
		template<typename U>
		[[nodiscard]]maybe_fail_reference<T>find(U&&a)noexcept(find_nothrow<U>){
			auto&bucket=find_bucket(hash(a));
			push_and_disable_msvc_warning(26496)//?
			auto reference=bucket.find(a);
			if constexpr(is_unstable_hash<T>)
				if(reference.fail()){
					for(auto&i:_m){
						if(is_eq(i,bucket))
							continue;
						re_construct[&reference](i.find(a));
						if(reference.not_fail())
							break;
					}
				}
			pop_msvc_warning();
			return reference;
		}
		[[nodiscard]]bool in_table(const T&a)noexcept_as(declvalue(this_t).find(a).not_fail()){
			return find(a).not_fail();
		}
		[[nodiscard]]bool not_in_table(const T&a)noexcept_as(declvalue(this_t).in_table(a)){
			return not in_table(a);
		}

		size_t size()noexcept{
			size_t aret=0;
			for(const bucket_t&a:_m){
				aret+=a.size();
			}
			return aret;
		}

		void clear()noexcept(re_construct.nothrow<this_t>){
			re_construct(this);
		}

		#define expr declvalue(func_t)(declvalue(T&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each(func_t&&func)noexcept_as(expr){
			for(bucket_t&a:_m){
				a.for_each(func);
			}
		}
		#undef expr

		#define expr declvalue(func_t)(declvalue(const T&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each(func_t&&func)const noexcept_as(expr){
			for(bucket_t&a:_m){
				a.for_each(func);
			}
		}
		#undef expr

		#define expr declvalue(func_t)(declvalue(bucket_t&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each_bucket(func_t&&func)noexcept_as(expr){
			_m.for_each(func);
		}
		#undef expr

		#define expr declvalue(func_t)(declvalue(const bucket_t&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each_bucket(func_t&&func)const noexcept_as(expr){
			_m.for_each(func);
		}
		#undef expr
	};
	template<typename T,template<typename>class stack_t,size_t _,size_t __>
	inline void swap(hash_table_t<T,stack_t,_>&a,hash_table_t<T,stack_t,__>&b)noexcept{a.swap(b);}
	template<typename T,template<typename>class stack_t,size_t _>
	inline void swap(hash_table_t<T,stack_t,_>&a,typename hash_table_t<T,stack_t,_>::base_t_w&b)noexcept{a.swap(b);}
	template<typename T,template<typename>class stack_t,size_t _>
	inline void swap(typename hash_table_t<T,stack_t,_>::base_t_w&b,hash_table_t<T,stack_t,_>&a)noexcept{a.swap(b);}
}

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_export.hpp"
//_export.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_export.hpp"
#define export using hash_table_n::
export hash_table_t;
#undef export

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_test.hpp"
//_test.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_test.hpp"
namespace hash_table_n{
	//BLOCK:for debug
	inline void test(){
		ELC_TEST_EVENTNAME("hash_table部分测试");
		{

		}
		check_memory_lack();
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
	//BLOCK_END
}

//file_end

	#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_body.hpp"
#endif

//file_end

#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_body.hpp"
//_body.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/defs.hpp"
//defs.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/defs.hpp"
namespace map_n{
	template<typename T,typename key_t,template<typename>class stack_t=auto_stack_t,size_t bucket_max_size=256>
	class map_t{
		typedef map_t<T,key_t,stack_t,bucket_max_size>this_t;

		struct data_t{
			key_t _key;
			T _value;

			data_t(const data_t&) = default;
			data_t(const key_t&a,const T&b)noexcept(copy_construct.nothrow<key_t> && copy_construct.nothrow<T>):_key(a),_value(b){}

			struct seek_value_t{
				const T*_m;
				constexpr seek_value_t(const T&a)noexcept:_m(addressof(a)){};
				[[nodiscard]]bool operator==(const data_t&a)const noexcept_as(a._value==*_m){
					return bool(a._value==*_m);
				}
			};

			[[nodiscard]]bool operator==(const key_t&a)noexcept_as(_key==a){
				return bool(_key==a);
			}
			[[nodiscard]]constexpr_as(hash(_key))operator decltype(hash(_key))()const noexcept_as(hash(_key)){
				return hash(_key);
			}
			/* operator T&()noexcept{
				return _value;
			} */
			[[nodiscard]]bool empty(){
				return _value==const_default_value_of<T>;
			}
		};
		typedef hash_table_t<data_t,stack_t,bucket_max_size>base_t_w;

		mutable base_t_w _m;//mutable cause shrink.

		map_t(const base_t_w&a)noexcept:_m(a){}
		this_t copy()noexcept(copy_construct.nothrow<base_t_w>){
			return{_m};//不用疑惑，这是deep copy
		}
	public:
		map_t()noexcept=default;
		~map_t()noexcept(destruct.nothrow<base_t_w>)=default;
		map_t(const this_t&a)noexcept=default;
		map_t(this_t&&a)noexcept=default;

		this_t&operator=(this_t&&a)noexcept{
			swap(_m,a._m);
			return*this;
		}
		this_t&operator=(const this_t&a)noexcept{
			return operator=(a.copy());
		}

		template<size_t _>
		void swap(map_t<T,key_t,stack_t,_>&a)noexcept{swap(_m,a._m);}

		[[nodiscard]]T&operator[](const key_t&a)noexcept_as(_m.add({a,T()})){
			auto tmp=_m.find(a);
			if(tmp.fail()){
				_m.add({a,T()});
				tmp=_m.find(a);
			}
			return tmp.get_ref()._value;
		}
		[[nodiscard]]const T&operator[](const key_t&a)const noexcept{
			auto tmp=_m.find(a);
			return tmp.fail()?const_default_value_of<T>:tmp.get_ref()._value;
		}
		void clear()noexcept(re_construct.nothrow<this_t>){
			re_construct(this);
		}

		#define expr declvalue(func_t)(declvalue(T&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each(func_t&&func)noexcept_as(expr){
			_m.for_each(lambda(data_t&a)noexcept_as(expr){
				func(a._value);
			});
		}
		#undef expr

		#define expr declvalue(func_t)(declvalue(const T&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each(func_t&&func)const noexcept_as(expr){
			_m.for_each(lambda(data_t&a)noexcept_as(expr){
				func(add_const<T&>(a._value));
			});
		}
		#undef expr

		static constexpr bool shrink_nothow=stack_t<data_t>::remove_nothrow;
		void shrink()const noexcept(shrink_nothow){
			_m.for_each_bucket(lambda(stack_t<data_t>&a)noexcept(shrink_nothow && equal.nothrow<T>){
				while(a.remove(data_t::seek_value_t(const_default_value_of<T>)));
			});
		}

		using_method_from_value(size,_m,const);

		bool operator==(const this_t&a)const noexcept(shrink_nothow && equal.nothrow<T>){
			shrink();
			a.shrink();
			if(size()!=a.size())
				return 0;
			try{
				_m.for_each(lambda_with_catch(&a)(data_t&b){
					if(a[b._key]!=b._value)
						throw (this_t*)(nullptr);
				});
			}
			catch(this_t*){
				return 0;
			}
			return 1;
		}
	};
	template<typename T,typename key_t,template<typename>class stack_t,size_t _,size_t __>
	inline void swap(map_t<T,key_t,stack_t,_>&a,map_t<T,key_t,stack_t,__>&b)noexcept{a.swap(b);}
}

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_export.hpp"
//_export.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_export.hpp"
#define export using map_n::
export map_t;
#undef export

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_test.hpp"
//_test.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_test.hpp"
namespace map_n{
	//BLOCK:for debug
	inline void test(){
		ELC_TEST_EVENTNAME("map部分测试");
		{

		}
		check_memory_lack();
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
	//BLOCK_END
}

//file_end

	#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_body.hpp"
#endif

//file_end

#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"

#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_test.hpp"
//_test.hpp
//at namespace elc::defs::container
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_test.hpp"
inline void test(){
	ELC_TEST_EVENTNAME("container部分测试");
	array_n::test();
	function_n::test();
	stack_n::test();
}
inline void test_log_out(){
	array_n::test_log_out();
	function_n::test_log_out();
	stack_n::test_log_out();
}
inline void test_end(){
	array_n::test_end();
	function_n::test_end();
	stack_n::test_end();
}

//file_end

	#line 40 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"
#endif

//file_end

		#line 58 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
	}
	using namespace container;

	namespace memory::gc_n{//gc定义，依赖container（但container依赖memory的其他部分）
		//依赖container
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/roots/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/roots/_body.hpp"
struct have_root{};

template<typename T>
class root_of;

template<typename T>
class roots_t{
	typedef roots_t<T>this_t;
	typedef root_of<T>root_t;
	typedef root_of<T>*value_t;

	base_stack_t<value_t>_roots;
public:
	constexpr roots_t()noexcept=default;
	~roots_t()noexcept=default;

	using_method_from_value(map,_roots);
	using_method_from_value(add,_roots);
	using_method_from_value(remove,_roots);
	using_method_from_value(for_each,_roots);

	void map_and_mark()noexcept_as(declvalue(value_t)->map_and_mark()){
		_roots.for_each(
			lambda(value_t&a)noexcept_as(a->map_and_mark())
			{
				a->map_and_mark();
			}
		);
	}
};
template<typename T>
distinctive inline roots_t<T>roots_of{};

template<typename T>
class root_of{
	typedef root_of<T>this_t;
public:
	root_of()noexcept_as(roots_of<T>.add(declvalue(this_t*))){
		roots_of<T>.add(this);
	}
	virtual T& get()noexcept=0;
	virtual void map_and_mark()noexcept=0;
};
template<typename T>
inline T& root_of<T>::get()noexcept{return const_default_value_of<T>;}
template<typename T>
inline void root_of<T>::map_and_mark()noexcept{}

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/mark_able_for_gc/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/mark_able_for_gc/_body.hpp"
template<typename T>
struct mark_able_for_gc:mark_able<T>{
	mark_able_for_gc()noexcept:mark_able<T>(not_mark){}
	mark_able_for_gc(const mark_able_for_gc&)noexcept{}
};

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/others/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/others/_body.hpp"
def_common_attribute_with_nothing(can_shrink);
def_common_attribute_with_nothing(can_map_all);

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/_body.hpp"

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/default_method/decl.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/default_method/decl.hpp"
template<class T,enable_flag>
inline void gc_method_of()noexcept;
template<class T,enable_flag>
[[nodiscard]]inline bool gc_success_identifier_of()noexcept;

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/_body.hpp"
//
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/defs.hpp"
class gc_t{
	typedef gc_t this_t;
	typedef function_t<void()noexcept>gc_method_t;
	typedef function_t<bool()noexcept>success_identifier_t;

	base_stack_t<gc_method_t>_gc_methods;
	base_stack_t<success_identifier_t>_gc_success_identifiers;
	mutable flag _gc_running=flag(not_set);
public:
	inline void operator()()const noexcept{
		if(_gc_running)
			die_with(locale::str::gc_fail);
		_gc_running.set();
		if(_gc_methods.empty())
			die_with(locale::str::empty_gc_method);
		_gc_methods.for_each(invoke<const gc_method_t>._as(nothing));
		_gc_running.unset();
	}
	[[nodiscard]]inline bool success()const noexcept{
		bool success=_gc_success_identifiers.empty();
		_gc_success_identifiers.for_each(
			lambda_with_catch(&success)(const success_identifier_t&a)noexcept{
				if(not success)
					success=a();
			}
		);
		return success;
	}

	inline void add_gc_method(gc_method_t a)noexcept{
		_gc_methods.add(a);
	}
	inline void remove_gc_method(gc_method_t a){
		_gc_methods.remove(a);
	}

	inline void add_gc_success_identifier(success_identifier_t a)noexcept{
		_gc_success_identifiers.add(a);
	}
	inline void remove_gc_success_identifier(success_identifier_t a){
		_gc_success_identifiers.remove(a);
	}

	template<class T>
	inline void add_gc_method(type_info_t<T>)noexcept{
		add_gc_method((void(*)()noexcept)gc_method_of<T>);
		add_gc_success_identifier(gc_success_identifier_of<T>);
	}
	template<class T>
	inline void remove_gc_method(type_info_t<T>)noexcept{
		remove_gc_method(gc_method_of<T>);
		remove_gc_success_identifier(gc_success_identifier_of<T>);
	}
};

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/_body.hpp"
//
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/default_method/defs.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/default_method/defs.hpp"
namespace default_gc_for_type{
	template<class T,enable_if(type_info<T>.has_attribute(count_able))>
	distinctive inline size_t count_for_success_identify;

	template<class T>
	constexpr bool use_default_gc_able =
	(
		type_info<T>.has_attribute(mark_able_for_gc) &&
		type_info<T>.has_attribute(have_root)
	)&&(
			type_info<T>.has_attribute(can_map_all)
		&&(
				type_info<T>.has_attribute(can_shrink)
			||(
				type_info<T>.has_attribute(mark_able_for_gc) &&
				type_info<T>.has_attribute(have_root)
			)
		)
	);

	enable_adl(destory_by_gc);
	template<class T>
	void destory_by_gc(T*){
		template_error("this function should not be instantiated,please overload the function destory_by_gc in the namespace where this type is defined.");
	}

	template<class T> requires use_default_gc_able<T>
	inline void default_gc_method()noexcept{
		constexpr auto&info=type_info<T>;
		//
		if constexpr(info.has_attribute(count_able))
			count_for_success_identify<T> = the_number_of(info);
		//
		if constexpr(info.has_attribute(can_map_all)){
			if constexpr(info.has_attribute(mark_able_for_gc)&&info.has_attribute(have_root))
				roots_of<T>.map_and_mark();
			if constexpr(info.has_attribute(can_shrink) || (info.has_attribute(mark_able_for_gc)&&info.has_attribute(have_root)))
				map_all<T>(
					lambda(T*a)noexcept{
						if constexpr(info.has_attribute(can_shrink))
							a->shrink();
						if constexpr(info.has_attribute(mark_able_for_gc)&&info.has_attribute(have_root)){
							auto& b=attribute_cast<mark_able_for_gc>(*a);
							if(b.was_marked())
								b.unmark();
							else
								destory_by_gc(a);
						}
					}
				);
		}
	}
	//
	template<class T>
	constexpr bool use_default_gc_success_identifier_able = type_info<T>.has_attribute(count_able);

	template<class T> requires use_default_gc_success_identifier_able<T>
	[[nodiscard]]inline bool default_gc_success_identifier()noexcept{
		constexpr auto&info=type_info<T>;
		if constexpr(info.has_attribute(count_able)){//重复判定，勿删，方便日后扩展
			return count_for_success_identify<T> _big_than_ the_number_of(info);
		}
	}
}
template<class T,enable_if(default_gc_for_type::use_default_gc_able<T>)>
inline void gc_method_of()noexcept{
	default_gc_for_type::default_gc_method<T>();
}
template<class T,enable_if(default_gc_for_type::use_default_gc_success_identifier_able<T>)>
[[nodiscard]]inline bool gc_success_identifier_of()noexcept{
	return default_gc_for_type::default_gc_success_identifier<T>();
}

//file_end

#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/_body.hpp"

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory::gc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/defs.hpp"
distinctive inline gc_t gc;

//file_end

#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"

//for alloc (def in "../alloc/defs.hpp#L10" )
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_for_alloc/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_for_alloc/_body.hpp"
inline void gc_for_alloc()noexcept{
	gc();
}

//file_end

#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/_body.hpp"
BREAK_NAMESPACE//in namespace elc::defs
INTER_NAMESPACE(memory::ptr_n)

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/defs.hpp"
enable_adl(map_and_mark_for_gc);
template<typename T>
void map_and_mark_for_gc(T*)noexcept{
	template_error("this function should not be instantiated,please overload the function map_and_mark_for_gc in the namespace where this type is defined");
}
using ::elc::defs::memory::gc_n::root_of;
template<class T,enable_if(
								was_ref_able<T> &&
								comn_ptr_t<T>::replace_check_nothrow &&
								type_info<T>.has_attribute(gc_n::have_root)
							)>
struct root_ptr_t:comn_ptr_t<T>,root_of<T>{
	typedef comn_ptr_t<T>base_t;
	typedef root_ptr_t<T>this_t;
public:
	using base_t::base_t;
	template<class assign_t> requires was_not_an_ill_form(declvalue(base_t)=declvalue(assign_t))
	this_t&operator=(assign_t&&a)noexcept_as(base_t::operator=(forward<assign_t>(a))){
		base_t::operator=(forward<assign_t>(a));
		return*this;
	}
	virtual T& get()noexcept override{
		return base_t::operator*();
	}
	virtual void map_and_mark()noexcept override{
		map_and_mark_for_gc(&**this);
	}
};

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/deduction_guides.hpp"
//deduction_guides.hpp
//at namespace elc::defs::memory::ptr_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/deduction_guides.hpp"
template<class T>
root_ptr_t(T*) -> root_ptr_t<T>;

//file_end

#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/_body.hpp"

BREAK_NAMESPACE//in namespace elc::defs

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/_export.hpp"
//_export.hpp
//at namespace elc::defs
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/_export.hpp"
INTER_NAMESPACE(memory)
#define export using memory::ptr_n::
export root_ptr_t;
#undef export
BREAK_NAMESPACE

//file_end

#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/_body.hpp"

INTER_NAMESPACE(memory::gc_n)

//file_end

#line 38 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_export.hpp"
//_export.hpp
//at namespace elc::defs::memory::gc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_export.hpp"
BREAK_NAMESPACE//in namespace elc::defs
INTER_NAMESPACE(memory)
#define export using gc_n::
export gc;
export have_root;
export root_of;
export mark_able_for_gc;
export can_shrink;
#undef export
BREAK_NAMESPACE//in namespace elc::defs
INTER_NAMESPACE(memory::gc_n)

//file_end

#line 40 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"

#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_test.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_test.hpp"
#if!defined(_MSC_VER)//貌似msvc在这里有bug
struct gc_tester:type_info_t<gc_tester>::template_name
	with_common_attribute<can_map_all,can_shrink,count_able,mark_able_for_gc,never_in_array,ref_able>,
	have_root,build_by_get_only,force_use_default_null_ptr{
	distinctive static inline int shrink_time=0;
	distinctive static inline int destroy_time=0;
	~gc_tester()noexcept{destroy_time++;}
	void shrink(){
		shrink_time++;
	}
	static void reset_times(){
		shrink_time=destroy_time=0;
	}
};
static_assert(type_info<gc_tester>.base_on<can_map_all<gc_tester>>);
void map_and_mark_for_gc(gc_tester*a){
	attribute_ptr_cast<mark_able_for_gc>(a)->mark();
}
void destory_by_gc(gc_tester*a){
	a->~gc_tester();
}
#endif
inline void test(){
	#if!defined(_MSC_VER)
	ELC_TEST_EVENTNAME("gc部分测试");
	rand_seed.set_by_time();
	gc.add_gc_method(type_info<gc_tester>);
	for(int t=rand<int>()%7;t--;)
	{
		int i;
		root_ptr_t<gc_tester> name=get<gc_tester>();
		for(i=rand<int>()%72;i--;){
			#pragma warning(suppress: 4189)
			auto p=get<gc_tester>();
		}
		gc();
		stest_accert(gc_tester::shrink_time==i+1);
		stest_accert(gc_tester::destroy_time==i);
		stest_accert(get_size_of_get(&*name)==1);
	}
	check_memory_lack();
	#endif
}
inline void test_log_out(){

}
inline void test_end(){

}

//file_end

	#line 43 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"
#endif

//file_end

		#line 63 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
	}
	using namespace memory;//只是强迫症

	#if defined(ELC_TEST_ON)
	namespace base_part_test{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_test.hpp"
//_test.hpp
//at namespace elc::defs::base_part_test
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_test.hpp"
inline void test(){
	ELC_TEST_EVENTNAME("base部分测试");
	memory::test();
	container::test();
	gc_n::test();
}
inline void test_log_out(){
	memory::test_log_out();
	container::test_log_out();
}
inline void test_end(){
	memory::test_end();
	container::test_end();
}

//file_end

		#line 69 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
	}
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 73 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
}
namespace elc{
	//导出base承诺于名称空间elc中提供的内容
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_export.hpp"
//_export.hpp
//at namespace elc
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_export.hpp"
#define export using defs::base::
#undef export

//file_end

	#line 76 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
}

//file_end

	#line 40 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
#endif

//file_end

	#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/core"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
//base_exception
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
#if !defined(ELC_BASE_EXCEPTION)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
//using.hpp
#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
#line 45 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"

//file_end

	#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
	#define ELC_BASE_EXCEPTION
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
//_body.hpp
//at namespace ::
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
#if defined(ELC_TEST)
	#error "this part cannot be tested."
#endif
//char_t
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
//default_data_type.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
namespace elc{
	/*ELC内部string统一采用char_t宽字符，使用setlocale(LC_ALL,"en_US.utf8")下的UTF编码。*/
	typedef char32_t char_t;
	/*c_string表示*/
	typedef char_t* string_ptr_t;
	/*c_string表示*/
	typedef const char_t* const_string_ptr_t;
	/*ELC内部钦定int_t类型*/
	typedef int64_t int_t;
	/*ELC内部钦定uint_t类型*/
	typedef uint64_t uint_t;
	/*ELC内部钦定float_t类型*/
	typedef double float_t;
	/*ELC内部钦定float_size_t类型，用以描述内存大小的浮点状况*/
	typedef long double float_size_t;
}

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"

	namespace exception_n{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/exception/_body.hpp"
//_body.hpp
//at namespace elc::defs::exception_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/exception/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/exception/exception.hpp"
//_body.hpp
//at namespace elc::defs::exception_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/exception/exception.hpp"
no_vtable_class exception{
	const_string_ptr_t _constexpr_str=locale::str::exception::unknow_error;
public:
	constexpr exception()noexcept=default;
	constexpr exception(const constexpr_str&str)noexcept:_constexpr_str(str){}
	virtual constexpr ~exception()noexcept=0;
	virtual constexpr const_string_ptr_t what()noexcept{return _constexpr_str;}
};
inline constexpr exception::~exception()noexcept{}

struct runtime_exception:exception{
	using exception::exception;
};

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/exception/_body.hpp"

//file_end

		#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
	}
	namespace exceptions=exception_n;

	#if defined(ELC_TEST_ON)
	namespace base_exception_part_test{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_test.hpp"
//_test.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_test.hpp"
inline void test(){
	ELC_TEST_EVENTNAME("base_exception部分测试");
}
inline void test_log_out(){
}
inline void test_end(){
}

//file_end

		#line 45 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
	}
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 49 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
}
namespace elc{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_export.hpp"
//_export.hpp
//at namespace elc
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_export.hpp"
#define export using defs::exception_n::
export exception;
export runtime_exception;
#undef export

//file_end

	#line 52 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
}

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
#endif

//file_end

	#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/core"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
//base_stream
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
#if !defined(ELC_BASE_STREAM)
	//abstract_base
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
//base
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"

//file_end

	#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
	#include <istream>//std::istream for wrap
	#include <ostream>//std::ostream for wrap
	//do not include <iostream> as it will import some gobal objects like std::cin and std::cout that we may not want to use
	#define ELC_BASE_STREAM
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
//_body.hpp
//at namespace ::
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
#if defined(ELC_TEST)
	#error "this part cannot be tested."
#endif
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"

	namespace stream_n{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/base_streams/_body.hpp"
//_body.hpp
//at namespace elc::defs::stream_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/base_streams/_body.hpp"
push_and_disable_msvc_warning(4250);
enum class seek_type{beg,end,cur};
using enum seek_type;
no_vtable_struct base_stream_t:abstract_base<base_stream_t>{
	virtual ~base_stream_t()=default;
	virtual int_t seek(seek_type,int_t)=0;
	virtual int_t tell(){return this->seek(cur,0);}
	virtual bool seek_to(int_t)=0;
	virtual void sync()=0;
	virtual void flush()=0;
	virtual void close()=0;
};
no_vtable_struct base_not_unreadable_istream_t:abstract_base<base_not_unreadable_istream_t>,virtual base_stream_t{
	virtual bool is_end()=0;
	virtual bool waitting_for_data()=0;
	virtual explicit operator bool(){
		return !this->is_end();
	}
};
no_vtable_struct base_istream_t:abstract_base<base_istream_t>,virtual base_not_unreadable_istream_t{};
no_vtable_struct base_ostream_t:abstract_base<base_ostream_t>,virtual base_stream_t{};
no_vtable_struct base_iostream_t:abstract_base<base_iostream_t>,virtual base_ostream_t,virtual base_istream_t{};

//concept: any class that base on base_stream_t
template<class T>
concept stream_class=is_base_of<base_stream_t,T>;
template<class T>
concept not_unreadable_istream_class=is_base_of<base_not_unreadable_istream_t,T>;
template<class T>
concept istream_class=is_base_of<base_istream_t,T>;
template<class T>
concept ostream_class=is_base_of<base_ostream_t,T>;
template<class T>
concept iostream_class=is_base_of<base_iostream_t,T>;


no_vtable_struct noexcept_stream_t:abstract_base<noexcept_stream_t>,virtual base_stream_t{
	virtual int_t seek(seek_type,int_t)noexcept override=0;
	virtual int_t tell()noexcept override{return this->seek(cur,0);}
	virtual bool seek_to(int_t)noexcept override=0;
	virtual void sync()noexcept override=0;
	virtual void flush()noexcept override=0;
	virtual void close()noexcept override=0;
};
no_vtable_struct noexcept_not_unreadable_istream_t:abstract_base<noexcept_not_unreadable_istream_t>,virtual base_not_unreadable_istream_t{
	virtual bool is_end()noexcept override=0;
	virtual bool waitting_for_data()noexcept override=0;
	virtual explicit operator bool()noexcept override{
		return !this->is_end();
	}
};
no_vtable_struct noexcept_istream_t:abstract_base<noexcept_istream_t>,virtual base_istream_t,virtual noexcept_stream_t,virtual noexcept_not_unreadable_istream_t{};
no_vtable_struct noexcept_ostream_t:abstract_base<noexcept_ostream_t>,virtual base_ostream_t,virtual noexcept_stream_t{};
no_vtable_struct noexcept_iostream_t:abstract_base<noexcept_iostream_t>,virtual base_iostream_t,virtual noexcept_ostream_t,virtual noexcept_istream_t{};
static_assert(noexcept(((noexcept_iostream_t*)(nullptr))->~noexcept_iostream_t()));
static_assert(noexcept(((noexcept_iostream_t*)(nullptr))->sync()));

//concept: any class that base on noexcept_stream_t
template<class T>
concept noexcept_stream_class=is_base_of<noexcept_stream_t,T>;
template<class T>
concept noexcept_not_unreadable_istream_class=is_base_of<noexcept_not_unreadable_istream_t,T>;
template<class T>
concept noexcept_istream_class=is_base_of<noexcept_istream_t,T>;
template<class T>
concept noexcept_ostream_class=is_base_of<noexcept_ostream_t,T>;
template<class T>
concept noexcept_iostream_class=is_base_of<noexcept_iostream_t,T>;

//text streams
template<class char_T>
no_vtable_struct text_stream_t:abstract_base<text_stream_t<char_T>>,virtual base_stream_t{
	typedef char_T char_type;
	typedef char_type data_type;
};
template<class char_T>
no_vtable_struct text_not_unreadable_istream_t:abstract_base<text_not_unreadable_istream_t<char_T>>,virtual base_not_unreadable_istream_t,virtual text_stream_t<char_T>{
	virtual size_t read(char_T*buf,size_t size)=0;
};
template<class char_T>
no_vtable_struct text_istream_t:abstract_base<text_istream_t<char_T>>,virtual base_istream_t,virtual text_not_unreadable_istream_t<char_T>{
	virtual void unread(const char_T*buf,size_t size)=0;
	virtual char_T peek(){
		char_T buf;
		const size_t size=this->read(&buf,1);
		if(size==0)return 0;
		this->unread(&buf,1);
		return buf;
	}
	virtual char_T get(){
		char_T buf;
		const size_t size=this->read(&buf,1);
		if(size==0)return 0;
		return buf;
	}
};
template<class char_T>
no_vtable_struct text_ostream_t:abstract_base<text_ostream_t<char_T>>,virtual base_ostream_t,virtual text_stream_t<char_T>{
	virtual void write(const char_T*buf,size_t size)=0;
};
template<class char_T>
no_vtable_struct text_iostream_t:abstract_base<text_iostream_t<char_T>>,virtual base_iostream_t,virtual text_istream_t<char_T>,virtual text_ostream_t<char_T>{};

//concept: any class that base on text_stream_t<char_t>
template<class T>
concept text_stream_class=is_base_of<text_stream_t<typename remove_cvref<T>::char_type>,T>;
template<class T>
concept text_not_unreadable_istream_class=is_base_of<text_not_unreadable_istream_t<typename remove_cvref<T>::char_type>,T>;
template<class T>
concept text_istream_class=is_base_of<text_istream_t<typename remove_cvref<T>::char_type>,T>;
template<class T>
concept text_ostream_class=is_base_of<text_ostream_t<typename remove_cvref<T>::char_type>,T>;
template<class T>
concept text_iostream_class=is_base_of<text_iostream_t<typename remove_cvref<T>::char_type>,T>;
template<class T>
concept text_stream=is_base_of<text_stream_t<char_t>,T>;
template<class T>
concept text_not_unreadable_istream=is_base_of<text_not_unreadable_istream_t<char_t>,T>;
template<class T>
concept text_istream=is_base_of<text_istream_t<char_t>,T>;
template<class T>
concept text_ostream=is_base_of<text_ostream_t<char_t>,T>;
template<class T>
concept text_iostream=is_base_of<text_iostream_t<char_t>,T>;

//noexcept_
template<class char_T>
no_vtable_struct noexcept_text_stream_t:abstract_base<noexcept_text_stream_t<char_T>>,virtual text_stream_t<char_T>,virtual noexcept_stream_t{};
template<class char_T>
no_vtable_struct noexcept_not_unreadable_text_istream_t:abstract_base<noexcept_not_unreadable_text_istream_t<char_T>>,virtual noexcept_text_stream_t<char_T>,virtual noexcept_not_unreadable_istream_t,virtual text_not_unreadable_istream_t<char_T>{
	virtual size_t read(char_T*buf,size_t size)noexcept override=0;
};
template<class char_T>
no_vtable_struct noexcept_text_istream_t:abstract_base<noexcept_text_istream_t<char_T>>,virtual noexcept_istream_t,virtual noexcept_not_unreadable_text_istream_t<char_T>,virtual text_istream_t<char_T>{
	virtual void unread(const char_T*buf,size_t size)noexcept override=0;
	virtual char_T peek()noexcept override{
		char_T buf;
		const size_t size=this->read(&buf,1);
		if(size==0)return 0;
		this->unread(&buf,1);
		return buf;
	}
	virtual char_T get()noexcept override{
		char_T buf;
		const size_t size=this->read(&buf,1);
		if(size==0)return 0;
		return buf;
	}
};
template<class char_T>
no_vtable_struct noexcept_text_ostream_t:abstract_base<noexcept_text_ostream_t<char_T>>,virtual noexcept_text_stream_t<char_T>,virtual noexcept_ostream_t,virtual text_ostream_t<char_T>{
	virtual void write(const char_T*buf,size_t size)noexcept override=0;
};
template<class char_T>
no_vtable_struct noexcept_text_iostream_t:abstract_base<noexcept_text_iostream_t<char_T>>,
	virtual noexcept_iostream_t,virtual text_iostream_t<char_T>,
	virtual noexcept_text_istream_t<char_T>,virtual noexcept_text_ostream_t<char_T>{};

//concept: any class that base on noexcept_text_stream<char_t>
template<class T>
concept noexcept_text_stream_class=is_base_of<noexcept_text_stream_t<typename remove_cvref<T>::char_type>,T>;
template<class T>
concept noexcept_not_unreadable_text_istream_class=is_base_of<noexcept_not_unreadable_text_istream_t<typename remove_cvref<T>::char_type>,T>;
template<class T>
concept noexcept_text_istream_class=is_base_of<noexcept_text_istream_t<typename remove_cvref<T>::char_type>,T>;
template<class T>
concept noexcept_text_ostream_class=is_base_of<noexcept_text_ostream_t<typename remove_cvref<T>::char_type>,T>;
template<class T>
concept noexcept_text_iostream_class=is_base_of<noexcept_text_iostream_t<typename remove_cvref<T>::char_type>,T>;
template<class T>
concept noexcept_text_not_unreadable_istream=is_base_of<noexcept_not_unreadable_text_istream_t<char_t>,T>;
template<class T>
concept noexcept_text_istream=is_base_of<noexcept_text_istream_t<char_t>,T>;
template<class T>
concept noexcept_text_ostream=is_base_of<noexcept_text_ostream_t<char_t>,T>;
template<class T>
concept noexcept_text_iostream=is_base_of<noexcept_text_iostream_t<char_t>,T>;

//data streams
no_vtable_struct data_stream_t:abstract_base<data_stream_t>,virtual base_stream_t{
	typedef byte data_type;
};
no_vtable_struct data_not_unreadable_istream_t:abstract_base<data_not_unreadable_istream_t>,virtual data_stream_t,virtual base_not_unreadable_istream_t{
	virtual size_t read(byte*buf,size_t size)=0;
	template<class T> requires ::std::is_trivially_copyable_v<T>
	size_t read(T*v,size_t size=1){
		return this->read(cast_to_data(v),size*sizeof(T))/sizeof(T);
	}
};
no_vtable_struct data_istream_t:abstract_base<data_istream_t>,virtual base_istream_t,virtual data_not_unreadable_istream_t{
	virtual void unread(const byte*buf,size_t size)=0;
	template<class T> requires ::std::is_trivially_copyable_v<T>
	void unread(const T*v,size_t size=1){
		this->unread(cast_to_data(v),size*sizeof(T));
	}
};
no_vtable_struct data_ostream_t:abstract_base<data_ostream_t>,virtual data_stream_t,virtual base_ostream_t{
	virtual void write(const byte*buf,size_t size)=0;
	template<class T> requires ::std::is_trivially_copyable_v<T>
	void write(const T*v,size_t size=1){
		this->write(cast_to_data(v),size*sizeof(T));
	}
};
no_vtable_struct data_iostream_t:abstract_base<data_iostream_t>,virtual base_iostream_t,virtual data_istream_t,virtual data_ostream_t{};

//concept: any class that base on data_stream
template<class T>
concept data_stream_class=is_base_of<data_stream_t,T>;
template<class T>
concept data_not_unreadable_istream_class=is_base_of<data_not_unreadable_istream_t,T>;
template<class T>
concept data_istream_class=is_base_of<data_istream_t,T>;
template<class T>
concept data_ostream_class=is_base_of<data_ostream_t,T>;
template<class T>
concept data_iostream_class=is_base_of<data_iostream_t,T>;

//noexcept_
no_vtable_struct noexcept_data_stream_t:abstract_base<noexcept_stream_t>,virtual noexcept_stream_t,virtual data_stream_t{};
no_vtable_struct noexcept_not_unreadable_data_istream_t:abstract_base<noexcept_not_unreadable_data_istream_t>,virtual noexcept_data_stream_t,virtual noexcept_not_unreadable_istream_t,virtual data_not_unreadable_istream_t{
	virtual size_t read(byte*buf,size_t size)noexcept override=0;
	template<class T> requires ::std::is_trivially_copyable_v<T>
	size_t read(T*v,size_t size=1)noexcept{
		return this->read(cast_to_data(v),size*sizeof(T))/sizeof(T);
	}
};
no_vtable_struct noexcept_data_istream_t:abstract_base<noexcept_data_istream_t>,virtual noexcept_not_unreadable_data_istream_t,virtual noexcept_istream_t,virtual data_istream_t{
	virtual void unread(const byte*buf,size_t size)noexcept override=0;
	template<class T> requires ::std::is_trivially_copyable_v<T>
	void unread(const T*v,size_t size=1)noexcept{
		this->unread(cast_to_data(v),size*sizeof(T));
	}
};
no_vtable_struct noexcept_data_ostream_t:abstract_base<noexcept_data_ostream_t>,virtual noexcept_data_stream_t,virtual noexcept_ostream_t,virtual data_ostream_t{
	virtual void write(const byte*buf,size_t size)noexcept override=0;
	template<class T> requires ::std::is_trivially_copyable_v<T>
	void write(const T*v,size_t size=1)noexcept{
		this->write(cast_to_data(v),size*sizeof(T));
	}
};
no_vtable_struct noexcept_data_iostream_t:abstract_base<noexcept_data_iostream_t>,
	virtual noexcept_iostream_t,virtual data_iostream_t,
	virtual noexcept_data_istream_t,virtual noexcept_data_ostream_t{};

//concept: any class that base on noexcept_data_stream
template<class T>
concept noexcept_data_stream_class=is_base_of<noexcept_data_stream_t,T>;
template<class T>
concept noexcept_not_unreadable_data_istream_class=is_base_of<noexcept_not_unreadable_data_istream_t,T>;
template<class T>
concept noexcept_data_istream_class=is_base_of<noexcept_data_istream_t,T>;
template<class T>
concept noexcept_data_ostream_class=is_base_of<noexcept_data_ostream_t,T>;
template<class T>
concept noexcept_data_iostream_class=is_base_of<noexcept_data_iostream_t,T>;

pop_msvc_warning();

//special streams
template<class char_T>
struct null_text_stream:noexcept_text_iostream_t<char_T>,instance_struct<null_text_stream<char_T>>{
	virtual int_t seek(seek_type,int_t)noexcept override{return 0;}
	virtual int_t tell()noexcept override{return 0;}
	virtual bool seek_to(int_t)noexcept override{return true;}
	virtual void sync()noexcept override{}
	virtual void flush()noexcept override{}
	virtual void close()noexcept override{}
	virtual void write(const char_T*,size_t)noexcept override{}
	virtual size_t read(char_T*,size_t)noexcept override{return 0;}
	virtual void unread(const char_T*,size_t)noexcept override{}
	virtual bool is_end()noexcept override{return false;}
	virtual bool waitting_for_data()noexcept override{return false;}
};
struct null_data_stream:noexcept_data_iostream_t,instance_struct<null_data_stream>{
	virtual int_t seek(seek_type,int_t)noexcept override{return 0;}
	virtual int_t tell()noexcept override{return 0;}
	virtual bool seek_to(int_t)noexcept override{return true;}
	virtual void sync()noexcept override{}
	virtual void flush()noexcept override{}
	virtual void close()noexcept override{}
	virtual void write(const byte*,size_t)noexcept override{}
	virtual size_t read(byte*,size_t)noexcept override{return 0;}
	virtual void unread(const byte*,size_t)noexcept override{}
	virtual bool is_end()noexcept override{return false;}
	virtual bool waitting_for_data()noexcept override{return false;}
};

//file_end

		#line 38 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/operators/_body.hpp"
//_body.hpp
//at namespace elc::defs::stream_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/operators/_body.hpp"
//text_stream_t

//operator<< of template<class char_T>struct text_ostream_t
template<text_ostream_class text_ostream_T,class char_T> requires(type_info<char_T> == type_info<typename remove_cvref<text_ostream_T>::char_type>)
decltype(auto)operator<<(text_ostream_T&&stream,const char_T ch)noexcept(noexcept_text_ostream_class<text_ostream_T>){
	stream.write(&ch,1);
	return stream;
}
template<text_ostream_class text_ostream_T,class char_T> requires(type_info<char_T> == type_info<typename remove_cvref<text_ostream_T>::char_type>)
decltype(auto)operator<<(text_ostream_T&&stream,array_like_view_t<const char_T>str)noexcept(noexcept_text_ostream_class<text_ostream_T>){
	stream.write(str.data(),str.size());
	return stream;
}
template<text_ostream_class text_ostream_T,class char_T> requires(type_info<char_T> == type_info<typename remove_cvref<text_ostream_T>::char_type>)
decltype(auto)operator<<(text_ostream_T&&stream,const char_T*str)noexcept(noexcept_text_ostream_class<text_ostream_T>){
	return stream << array_end_by_zero_t<const char_T>{str};
}
//operator>> of template<class char_T>struct text_istream_t
template<text_istream_class text_istream_T,class char_T> requires(type_info<char_T> == type_info<typename remove_cvref<text_istream_T>::char_type>)
decltype(auto)operator>>(text_istream_T&stream,char_T&ch)noexcept(noexcept_text_istream_class<text_istream_T>){
	stream.read(&ch,1);
	return stream;
}

//data_stream of any is_trivially_copyable

//operator<< of template<class T>struct data_ostream_t
template<data_ostream_class data_ostream_T,class T> requires ::std::is_trivially_copyable_v<T>
decltype(auto)operator<<(data_ostream_T&&stream,const T&data)noexcept(noexcept_data_ostream_class<data_ostream_T>){
	stream.write(&data,1);
	return stream;
}
template<data_ostream_class data_ostream_T,class T,size_t N> requires ::std::is_trivially_copyable_v<T>
decltype(auto)operator<<(data_ostream_T&&stream,const T(&data)[N])noexcept(noexcept_data_ostream_class<data_ostream_T>){
	stream.write(data,N);
	return stream;
}
//operator>> of template<class T>struct data_istream_t
template<data_istream_class data_istream_T,class T> requires ::std::is_trivially_copyable_v<T>
decltype(auto)operator>>(data_istream_T&&stream,T&data)noexcept(noexcept_data_istream_class<data_istream_T>){
	stream.read(&data,1);
	return stream;
}
template<data_istream_class data_istream_T,class T,size_t N> requires ::std::is_trivially_copyable_v<T>
decltype(auto)operator>>(data_istream_T&&stream,T(&data)[N])noexcept(noexcept_data_istream_class<data_istream_T>){
	stream.read(data,N);
	return stream;
}

//flush
inline constexpr struct flush_t{
	template<ostream_class ostream_T>
	constexpr decltype(auto)operator()(ostream_T&stream)const noexcept(noexcept_ostream_class<ostream_T>){
		stream.flush();
		return stream;
	}
}flush{};

//endline
inline constexpr struct endline_t{
	template<text_ostream_class text_ostream_T,class char_T=typename remove_cvref<text_ostream_T>::char_type>
	constexpr decltype(auto)operator()(text_ostream_T& stream)const noexcept(noexcept_text_ostream_class<text_ostream_T>){
		stream << char_T{'\n'};
		stream.flush();
		return stream;
	}
	//对于换行的读入特殊处理
	template<text_istream_class text_istream_T,class char_T=typename remove_cvref<text_istream_T>::char_type>
	constexpr decltype(auto)operator()(text_istream_T& stream)const noexcept(noexcept_text_istream_class<text_istream_T>){
		char_T ch;
		while(stream>>ch){
			if(ch==char_T{'\n'})
				break;
			if(ch==char_T{'\r'}){
				if(!stream.waitting_for_data() && stream>>ch) {
					if(ch==char_T{'\n'})
						break;
					stream.unread(&ch,1);
				}
				break;
			}
		}
		return stream;
	}
}endline{};

//operator<< of functions
template<class callable_T,ostream_class stream_T> requires(invoke<callable_T>.able<stream_T>)
decltype(auto)operator<<(stream_T&&stream,callable_T&&callable)noexcept(invoke<callable_T>.nothrow<stream_T>){
	return callable(stream);
}
//operator>> of functions
template<class callable_T,istream_class stream_T> requires(invoke<callable_T>.able<stream_T>)
decltype(auto)operator>>(stream_T&&stream,callable_T&&callable)noexcept(invoke<callable_T>.nothrow<stream_T>){
	return callable(stream);
}

//file_end

		#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/unreadable_wrap/_body.hpp"
//_body.hpp
//at namespace elc::defs::stream_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/unreadable_wrap/_body.hpp"
//warp for not_unreadable_istream to make it unreadable
template<class stream_T> requires not_unreadable_istream_class<stream_T>
struct unreadable_wrap:stream_T,instance_struct<unreadable_wrap<stream_T>>,virtual conditional<
	//use conditional as workaround, see https://github.com/ELC-lang/ELC/commit/d352be02ff232d1e2b8b15197a34058166775b92 for more detail.
	noexcept_stream_class<stream_T>,
		conditional<data_stream_class<stream_T>,
			noexcept_data_istream_t
		,
			noexcept_text_istream_t<typename stream_T::char_type>
	>,
		conditional<data_stream_class<stream_T>,
			data_istream_t
		,
			text_istream_t<typename stream_T::char_type>
	>
>{
private:
	typedef stream_T base_t;
	typedef unreadable_wrap<stream_T> this_t;
	override_instance_struct;
public:
	using stream_T::stream_T;
	typedef stream_T::data_type data_type;
private:
	static constexpr size_t default_buffer_size=1<<10;

	array_t<data_type> _buffer{note::size(default_buffer_size)};
	size_t _using_size=default_buffer_size,_reading_pos=default_buffer_size;
protected:
	virtual size_t base_read_impl_for_wrapper(data_type*data,size_t size)noexcept_as(stream_T::read(nullptr,0)){
		return stream_T::read(data,size);
	}
	virtual bool base_waitting_for_data_impl_for_wrapper()noexcept_as(stream_T::waitting_for_data()){
		return stream_T::waitting_for_data();
	}
public:
	virtual size_t read(data_type*data,size_t size)noexcept_as(stream_T::read(nullptr,0)) override{
		if(size==0)return 0;
		size_t aret=0;
		if(_reading_pos!=_using_size){
			const auto read_size=min(size,_using_size-_reading_pos);
			copy_assign[read_size](note::from(add_const(_buffer.data()+_reading_pos)),note::to(data));
			_reading_pos+=read_size;
			size-=read_size;
			aret+=read_size;
			data+=read_size;
		}
		aret+=base_read_impl_for_wrapper(data,size);
		return aret;
	}
	virtual void unread(const data_type*data,size_t size)noexcept override{
		if(size==0)return;
		if(_reading_pos<size){//unread size more than buffer can hold
			const auto more_size=size-_reading_pos;
			_buffer.forward_resize(more_size);
			_using_size+=more_size;
			_reading_pos+=more_size;
		}
		_reading_pos-=size;
		copy_assign[size](note::from(data),note::to(_buffer.data()+_reading_pos));
	}
	virtual bool is_end()noexcept_as(stream_T::is_end())override{
		return _reading_pos==_using_size && stream_T::is_end();
	}
	virtual bool waitting_for_data()noexcept_as(stream_T::waitting_for_data())override{
		return _reading_pos==_using_size && stream_T::waitting_for_data();
	}
};

//file_end

		#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/std_wrap/_body.hpp"
//_body.hpp
//at namespace elc::defs::stream_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/std_wrap/_body.hpp"
push_and_disable_msvc_warning(26447);//noexcept警告diss
//wrap std::istream to elc::noexcept_text_istream_t
template<class char_T,class traits=::std::char_traits<char_T>>
struct std_istream_wrap:noexcept_text_istream_t<char_T>,instance_struct<std_istream_wrap<char_T,traits>>{
	typedef ::std::basic_istream<char_T,traits> stream_t;
	stream_t& _stream;
	std_istream_wrap(stream_t&stream)noexcept:_stream(stream){}
private:
	void clear_badbit()noexcept{
		_stream.clear(_stream.rdstate()&~::std::ios_base::badbit);
	}
public:
	virtual ~std_istream_wrap()noexcept override=default;
	virtual int_t seek(seek_type dir,int_t off)noexcept override{
		typename stream_t::iostate state = stream_t::goodbit;
		const typename stream_t::sentry isok(_stream);

		if(!isok)
			state |= stream_t::badbit;
		else{
			try{
				switch(dir){
					case beg:
						_stream.seekg(off);
						break;
					case cur:
						_stream.seekg(off,_stream.cur);
						break;
					case end:
						_stream.seekg(off,_stream.end);
						break;
				}
				return tell();
			}catch(...){
				state |= stream_t::badbit;
			}
		}
		_stream.setstate(state);
		return -1;
	}
	virtual int_t tell()noexcept override{
		typename stream_t::iostate state = stream_t::goodbit;
		const typename stream_t::sentry isok(_stream);

		if(!isok)
			state |= stream_t::badbit;
		else{
			try{
				const typename stream_t::pos_type base_p;
				return int_t(_stream.tellg()-base_p);
			}catch(...){
				state |= stream_t::badbit;
			}
		}
		_stream.setstate(state);
		return -1;
	}
	virtual void seek_to(int_t pos)noexcept override{
		const typename stream_t::pos_type base_p;
		_stream.seekg(base_p+pos);
	}
	virtual void sync()noexcept override{
		_stream.sync();
	}
	virtual void flush()noexcept override{
		_stream.sync();
	}
	virtual void close()noexcept override{
		_stream.sync();
	}
	virtual size_t read(char_T*buf,size_t size)noexcept override{
		typename stream_t::iostate state = stream_t::goodbit;
		const typename stream_t::sentry isok(_stream);

		if(!isok)
			state |= stream_t::badbit;
		else{
			try{
				_stream.read(buf,size);
				return size_t(_stream.gcount());
			}catch(...){
				state |= stream_t::badbit;
			}
		}
		_stream.setstate(state);
		return 0;
	}
};
//wrap std::ostream to elc::noexcept_text_ostream_t
template<class char_T,class traits=::std::char_traits<char_T>>
struct std_ostream_wrap:noexcept_text_ostream_t<char_T>,instance_struct<std_ostream_wrap<char_T,traits>>{
	typedef ::std::basic_ostream<char_T,traits> stream_t;
	stream_t& _stream;
	std_ostream_wrap(stream_t&stream)noexcept:_stream(stream){}
private:
	void clear_badbit()noexcept{
		_stream.clear(_stream.rdstate()&~::std::ios_base::badbit);
	}
public:
	virtual ~std_ostream_wrap()noexcept override=default;
	virtual int_t seek(seek_type dir,int_t off)noexcept override{
		typename stream_t::iostate state = stream_t::goodbit;
		const typename stream_t::sentry isok(_stream);

		if(!isok)
			state |= stream_t::badbit;
		else{
			try{
				switch(dir){
					case beg:
						_stream.seekp(off);
						break;
					case cur:
						_stream.seekp(off,_stream.cur);
						break;
					case end:
						_stream.seekp(off,_stream.end);
						break;
				}
				return tell();
			}catch(...){
				state |= stream_t::badbit;
			}
		}
		_stream.setstate(state);
		return -1;
	}
	virtual int_t tell()noexcept override{
		const typename stream_t::pos_type base_p;
		return int_t(_stream.tellp()-base_p);
	}
	virtual void seek_to(int_t pos)noexcept override{
		const typename stream_t::pos_type base_p;
		_stream.seekp(base_p+pos);
	}
	virtual void sync()noexcept override{
		_stream.flush();
	}
	virtual void flush()noexcept override{
		_stream.flush();
	}
	virtual void close()noexcept override{
		_stream.flush();
	}
	virtual void write(const char_T*buf,size_t size)noexcept override{
		typename stream_t::iostate state = stream_t::goodbit;
		const typename stream_t::sentry isok(_stream);

		if(!isok)
			state |= stream_t::badbit;
		else{
			try{
				_stream.write(buf,size);
			}catch(...){
				state |= stream_t::badbit;
			}
		}
		_stream.setstate(state);
	}
};
pop_msvc_warning();

//inject operator<< of elc::array_like_view_t to std::ostream
BREAK_NAMESPACE//elc::defs
INTER_NAMESPACE(base::array_like_n)//elc::defs::base::array_like_n

template<class char_T,class traits>
auto&operator<<(
	::std::basic_ostream<remove_cvref<char_T>,traits>&stream,
	const array_like_view_t<char_T>&view
)noexcept{
	stream_n::std_ostream_wrap wrap(stream);
	wrap << view;
	return stream;
}

BREAK_NAMESPACE//elc::defs
INTER_NAMESPACE(stream_n)//elc::defs::stream_n

//file_end

		#line 42 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
	}
	using namespace stream_n;

	#if defined(ELC_TEST_ON)
	namespace base_stream_part_test{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_test.hpp"
//_test.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_test.hpp"
inline void test(){
	ELC_TEST_EVENTNAME("base_stream部分测试");
}
inline void test_log_out(){
}
inline void test_end(){
}

//file_end

		#line 48 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
	}
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 52 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
}
namespace elc{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_export.hpp"
//_export.hpp
//at namespace elc
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_export.hpp"
#define export using defs::
export base_stream_t;
export base_ostream_t;
export base_not_unreadable_istream_t;
export base_istream_t;
export base_iostream_t;
export noexcept_stream_t;
export noexcept_ostream_t;
export noexcept_not_unreadable_istream_t;
export noexcept_istream_t;
export noexcept_iostream_t;
export text_not_unreadable_istream_t;
export text_stream_t;
export text_istream_t;
export text_ostream_t;
export text_iostream_t;
export noexcept_text_stream_t;
export noexcept_not_unreadable_text_istream_t;
export noexcept_text_istream_t;
export noexcept_text_ostream_t;
export noexcept_text_iostream_t;
export data_stream_t;
export data_not_unreadable_istream_t;
export data_istream_t;
export data_ostream_t;
export data_iostream_t;
export noexcept_data_stream_t;
export noexcept_not_unreadable_data_istream_t;
export noexcept_data_istream_t;
export noexcept_data_ostream_t;
export noexcept_data_iostream_t;
export null_text_stream;
export null_data_stream;
export endline;
export flush;
#undef export

//file_end

	#line 55 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
}
#if defined(ELC_STRING)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"
//type_name_test_output.hpp
//at namespace ::
//multi when ELC_STRING & ELC_BASE_STREAM
#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"
#if !defined(ELC_multi_type_name_test_output)//pls skip define check as this part is muti
#define ELC_multi_type_name_test_output
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"

	namespace stream_n{
		//typename output only for text_ostream_t<char_t>
		template<text_ostream stream_T>
		decltype(auto)operator<<(stream_T&&stream,const type_name_t&name)noexcept(noexcept_text_ostream<stream_T>){
			return stream << to_char_t_str(name);
		}
		//output type_info
		template<text_ostream stream_T>
		decltype(auto)operator<<(stream_T&&stream,const base_type_info_t&info)noexcept(noexcept_text_ostream<stream_T>){
			return stream << info.get_name();
		}
		//output ::std::type_info
		template<text_ostream stream_T>
		decltype(auto)operator<<(stream_T&&stream,const ::std::type_info&info)noexcept(noexcept_text_ostream<stream_T>){
			return stream << type_name_t{info.name()};
		}
	}

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 55 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"
}
#endif

//file_end

	#line 58 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
#endif
#if defined(ELC_NUMERICAL_REPRESENTATION)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/arithmetic_text_io.hpp"
//arithmetic_text_io.hpp
//at namespace ::
//multi when ELC_NUMERICAL_REPRESENTATION & ELC_BASE_STREAM
#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/arithmetic_text_io.hpp"
#if !defined(ELC_multi_arithmetic_text_io)//pls skip define check as this part is muti
#define ELC_multi_arithmetic_text_io
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/arithmetic_text_io.hpp"

	namespace stream_n{
		using namespace numerical_representation_n;

		const auto&default_numerical_representation=decimal;
		const auto&default_bool_representation=common_bool_representation;

		template<text_stream stream_T>
		decltype(auto)get_numerical_representation_of(stream_T&&stream)noexcept{
			if constexpr was_not_an_ill_form(stream.get_numerical_representation())
				return stream.get_numerical_representation();
			else
				return default_numerical_representation;
		}

		template<text_stream stream_T>
		decltype(auto)get_bool_representation_of(stream_T&&stream)noexcept{
			if constexpr was_not_an_ill_form(stream.get_bool_representation())
				return stream.get_bool_representation();
			else
				return default_bool_representation;
		}

		//arithmetic output only for text_ostream
		template<arithmetic_type T,text_ostream stream_T> requires(type_info<remove_cvref<T>> != type_info<char_t> &&
																   type_info<remove_cvref<T>> != type_info<bool>)
		decltype(auto)operator<<(stream_T&&stream,T&&data)noexcept(noexcept_text_ostream<stream_T>){
			return stream << to_string(forward<T>(data),get_numerical_representation_of(stream));
		}

		template<typename T,text_ostream stream_T> requires(!::std::is_arithmetic_v<remove_cvref<T>> &&
															to_arithmetic.able<remove_cvref<T>>)
		decltype(auto)operator<<(stream_T&&stream,T&&data)noexcept(noexcept_text_ostream<stream_T> && to_arithmetic.nothrow<T>) {
			return stream << to_arithmetic(forward<T>(data));
		}

		template<typename T,text_ostream stream_T> requires(type_info<T> == type_info<bool>)
		decltype(auto)operator<<(stream_T&&stream,T data)noexcept(noexcept_text_ostream<stream_T>){
			const auto&representation=get_bool_representation_of(stream);
			if(data==true)
				stream << representation.get_true();
			elseif(data==false)
				stream << representation.get_false();
			else
				stream << representation.get_other_prefix() << union_cast<unsigned_specific_size_t<sizeof(bool)>>(data) << representation.get_other_suffix();
			return stream;
		}

		//arithmetic input only for text_istream
		template<arithmetic_type T,text_istream stream_T> requires(type_info<remove_cvref<T>> != type_info<char_t> &&
																   type_info<remove_cvref<T>> != type_info<bool>)
		decltype(auto)operator>>(stream_T&&stream,T&data)noexcept(noexcept_text_istream<stream_T>){
			string temp;
			stream >> temp;
			data=from_string_get<T>(temp,get_numerical_representation_of(stream));
			return stream;
		}
		template<typename T,text_istream stream_T> requires(type_info<T> == type_info<bool>)
		decltype(auto)operator>>(stream_T&&stream,T&data)noexcept(noexcept_text_istream<stream_T>){
			string temp;
			stream >> temp;
			const auto&representation=get_bool_representation_of(stream);
			if(temp==representation.get_true())
				data=true;
			elseif(temp==representation.get_false())
				data=false;
			else{
				if(temp.starts_with(representation.get_other_prefix())){
					temp.remove_front(representation.get_other_prefix().size());
					if(temp.ends_with(representation.get_other_suffix())){
						temp.remove_back(representation.get_other_suffix().size());
						data=union_cast<bool>(from_string_get<unsigned_specific_size_t<sizeof(bool)>>(temp,get_numerical_representation_of(stream)));
					}
				}
			}
			return stream;
		}

		//T* output only for text_ostream
		template<typename T,text_ostream stream_T>
		decltype(auto)operator<<(stream_T&&stream,T*data)noexcept(noexcept_text_ostream<stream_T>){
			//output name of type at first
			stream << type_info<T>.get_name();
			if constexpr(::std::is_polymorphic_v<T> && !::std::is_final_v<T>){//RTTI
				const auto typeinfo = type_info_of(*data);
				if(typeinfo != type_info<T>)
					stream << ec("(") << typeinfo.get_name() << ec(")");
			}
			//output address
			stream << ec("@") << to_string((size_t)data,hexadecimal);
			return stream;
		}
	}

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 130 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/arithmetic_text_io.hpp"
}
#endif

//file_end

	#line 61 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
#endif

//file_end

	#line 38 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
#endif

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/core"
	#define ELC_CORE
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
//_body.hpp
//at namespace ::
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
#if defined(ELC_TEST)
	#error "this part cannot be tested."
#endif
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"

	namespace core{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/_body.hpp"
//_body.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/decl.hpp"
//decl.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/decl.hpp"
struct node_like;
typedef comn_ptr_t<node_like>ptr;
typedef weak_ptr_t<node_like>weak_ptr;
typedef comn_ptr_t<const node_like>const_ptr;
typedef weak_ptr_t<const node_like>const_weak_ptr;
struct value;

BREAK_NAMESPACE
namespace string_n{
	template<typename char_T>
	struct string_t;
	typedef string_t<char_t> string;
	template<constexpr_str_n::constexpr_str_t_literal_helper str_helper>
	inline constexpr string operator""_elc_string()noexcept;
}
using string_n::string_t;
using string_n::string;
INTER_NAMESPACE(core)

template<typename T>
[[nodiscard]]inline ptr make_long_term_binary_node_from(T a)noexcept;

template<typename T>
constexpr bool as_ptr_nothrow_helper()noexcept{
	if constexpr(was_not_an_ill_form(ptr(&declvalue(T))))
		return noexcept(ptr(&declvalue(T)));
	elseif constexpr(was_not_an_ill_form(const_ptr(&declvalue(T))))
		return noexcept(const_ptr(&declvalue(T)));
	elseif constexpr(was_not_an_ill_form(static_cast<node_like&>(declvalue(T))))
		return noexcept(&static_cast<node_like&>(declvalue(T)));
	elseif constexpr(was_not_an_ill_form(static_cast<const node_like&>(declvalue(T))))
		return noexcept(&static_cast<const node_like&>(declvalue(T)));
	elseif constexpr(was_not_an_ill_form(static_cast<value&>(declvalue(T))))
		return noexcept(ptr(static_cast<value&>(declvalue(T))));
	elseif constexpr(was_not_an_ill_form(static_cast<const value&>(declvalue(T))))
		return noexcept(const_ptr(static_cast<value&>(declvalue(T))));
	elseif constexpr(was_not_an_ill_form(ptr(declvalue(T))))
		return noexcept(ptr(declvalue(T)));
	elseif constexpr(was_not_an_ill_form(const_ptr(declvalue(T))))
		return noexcept(const_ptr(declvalue(T)));
	elseif constexpr(type_info<remove_cvref<T>> == type_info<char_t>)
		return noexcept(make_long_term_binary_node_from<char_t>(declvalue(T)));
	elseif constexpr(::std::is_integral_v<remove_cvref<T>>){
		if constexpr(::std::is_signed_v<remove_cvref<T>>)
			return noexcept(make_long_term_binary_node_from<int_t>(declvalue(T)));
		else
			return noexcept(make_long_term_binary_node_from<uint_t>(declvalue(T)));
	}
	elseif constexpr(::std::is_floating_point_v<remove_cvref<T>>)
		return noexcept(make_long_term_binary_node_from<float_t>(declvalue(T)));
	elseif constexpr(construct<string>.able<T>){
		return noexcept(make_long_term_binary_node_from<string>(declvalue(T)));
	}
}
template<typename T>
decltype(auto) as_ptr(T&&a)noexcept(as_ptr_nothrow_helper<T>()){
	ELC_TEST_EVENTNAME("as_ptr转换");
	if constexpr(was_not_an_ill_form(ptr(&a)))
		return ptr(&a);
	elseif constexpr(was_not_an_ill_form(const_ptr(&a)))
		return const_ptr(&a);
	elseif constexpr(was_not_an_ill_form(static_cast<node_like&>(a)))
		return &static_cast<node_like&>(a);
	elseif constexpr(was_not_an_ill_form(static_cast<const node_like&>(a)))
		return &static_cast<const node_like&>(a);
	elseif constexpr(was_not_an_ill_form(static_cast<value&>(a)))
		return ptr(static_cast<value&>(a));
	elseif constexpr(was_not_an_ill_form(static_cast<const value&>(a)))
		return const_ptr(static_cast<value&>(a));
	elseif constexpr(was_not_an_ill_form(ptr(a)))
		return ptr(a);
	elseif constexpr(was_not_an_ill_form(const_ptr(a)))
		return const_ptr(a);
	elseif constexpr(type_info<remove_cvref<T>> == type_info<char_t>)
		return make_long_term_binary_node_from<char_t>(a);
	elseif constexpr(::std::is_integral_v<remove_cvref<T>>){
		if constexpr(::std::is_signed_v<remove_cvref<T>>)
			return make_long_term_binary_node_from<int_t>(a);
		else
			return make_long_term_binary_node_from<uint_t>(a);
	}
	elseif constexpr(::std::is_floating_point_v<remove_cvref<T>>)
		return make_long_term_binary_node_from<float_t>(a);
	elseif constexpr(construct<string>.able<T>){
		return make_long_term_binary_node_from<string>(a);
	}
}

template<typename T>
constexpr bool as_value_nothrow_helper()noexcept{
	if constexpr(was_not_an_ill_form(static_cast<value&>(declvalue(T))))
		return noexcept(static_cast<value&>(declvalue(T)));
	elseif constexpr(was_not_an_ill_form(static_cast<const value&>(declvalue(T))))
		return noexcept(static_cast<const value&>(declvalue(T)));
	elseif constexpr(was_not_an_ill_form(as_ptr(declvalue(T)))){
		if constexpr(type_info<decltype(as_ptr(declvalue(T)))> == type_info<ptr>)
			return noexcept(value(as_ptr(declvalue(T))));
		elseif constexpr(type_info<decltype(as_ptr(declvalue(T)))> == type_info<const_ptr>)
			return noexcept((const value)remove_const((const node_like*)as_ptr(declvalue(T))));
	}
}
template<typename T>
decltype(auto) as_value(T&& a)noexcept(as_value_nothrow_helper<T>()){
	ELC_TEST_EVENTNAME("as_value转换");
	if constexpr(was_not_an_ill_form(static_cast<value&>(a)))
		return static_cast<value&>(a);
	elseif constexpr(was_not_an_ill_form(static_cast<const value&>(a)))
		return static_cast<const value&>(a);
	elseif constexpr(was_not_an_ill_form(as_ptr(declvalue(T)))){
		if constexpr(type_info<decltype(as_ptr(declvalue(T)))> == type_info<ptr>)
			return value(as_ptr(forward<T>(a)));
		elseif constexpr(type_info<decltype(as_ptr(declvalue(T)))> == type_info<const_ptr>)
			return (const value)remove_const((const node_like*)as_ptr(forward<T>(a)));
	}
}

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/node_like.hpp"
//defs.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/node_like.hpp"
[[nodiscard]]inline ptr make_list()noexcept;
template<typename T,typename...Args>
[[nodiscard]]inline ptr make_list(T&&first,Args&&...rest);

no_vtable_struct node_like:type_info_t<node_like>::template_name
	with_common_attribute<abstract_base,weak_ref_able,replace_able,ref_able>{
public:
	typedef node_like this_t;

	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept=0;

	[[nodiscard]]virtual value be_eval();
	[[nodiscard]]virtual value be_call(ptr);
protected:
	[[nodiscard]]virtual logical_bool equal_with(const_ptr)const noexcept=0;
	[[nodiscard]]virtual logical_bool eq_with(const_ptr a)const noexcept{return a.get()==this;}//不是a==this：ptr的opertaor==将调用在下方定义的pointer_equal，这会通过eq间接调用eq_with
	[[nodiscard]]virtual constexpr size_t equal_level()const noexcept{return 36;}
	[[nodiscard]]virtual constexpr size_t eq_level()const noexcept{return 36;}
public:
	node_like()noexcept=default;
	node_like(never_ref_num_zero_t)noexcept{ attribute_ptr_cast<ref_able>(this)->init_never_ref_num_zero(); }
	virtual ~node_like()=default;

	[[nodiscard]]virtual value arec(const value)=0;

	[[nodiscard]]value operator[](const value index);
	[[nodiscard]]value operator[](auto&&index){
		return operator[](as_value(index));
	}

	virtual void clear()noexcept=0;

	[[nodiscard]]virtual explicit operator hash_t()const noexcept{return hash((void*)this);}
	void destroy()noexcept{
		this->be_replace_as(null_ptr);
	}
	virtual void be_replace_as(ptr a)noexcept{
		this->clear();
		replace_able<this_t>::be_replace_as(a.get());
	}

	[[nodiscard]]virtual explicit operator logical_bool()const noexcept{return true;}
	[[nodiscard]]explicit operator bool()const noexcept{return(bool)this->operator logical_bool();}

	template<typename...Args>
	inline value operator()(Args&&...rest){return this->be_call(make_list(forward<Args>(rest)...));}

	[[nodiscard]]logical_bool eq(const_ptr a)const noexcept{
		const auto this_eqlv = this->eq_level();
		const auto arg_eqlv	 = a->eq_level();
		if(this_eqlv _small_than_ arg_eqlv)
			return a->eq_with(this);
		elseif(this_eqlv _big_than_ arg_eqlv)
			return this->eq_with(a);
		else
			return this->eq_with(a)&&a->eq_with(this);
	}
	[[nodiscard]]logical_bool equal(const_ptr a)const noexcept{
		const auto this_equlv = this->equal_level();
		const auto arg_equlv  = a->equal_level();
		if(this_equlv _small_than_ arg_equlv)
			return a->equal_with(this);
		elseif(this_equlv _big_than_ arg_equlv)
			return this->equal_with(a);
		else
			return this->equal_with(a)&&a->equal_with(this);
	}

	[[nodiscard]]ptr operator&()noexcept{return this;}
	[[nodiscard]]const_ptr operator&()const noexcept{return this;}
	[[nodiscard]]logical_bool operator==(const this_t&a)const noexcept{
		return a.equal(this);
	}
protected:
	friend void the_waiting_for_destroy(node_like* a)noexcept;
	virtual void waiting_for_destroy()noexcept{clear();}
};

//base中的类型功能适应器
[[nodiscard]]inline constexpr node_like*the_get_null_ptr(const node_like*)noexcept;//{return&void;}
[[nodiscard]]inline logical_bool the_pointer_to_bool(const node_like*a)noexcept{
	return a->operator logical_bool();
}
[[nodiscard]]inline logical_bool the_pointer_equal(const node_like*a,const node_like*b)noexcept{
	return a->eq(b);
}
[[nodiscard]]inline hash_t the_pointer_hash(const node_like*a)noexcept{
	return a->operator hash_t();
}
//ptr中的类型功能适应器
inline void the_waiting_for_destroy(node_like*a)noexcept{
	a->waiting_for_destroy();
}
inline void the_destroy_and_free(node_like*a)noexcept{
	unget(a);
}

//gc中的类型功能适应器
inline void the_destroy(node_like*a)noexcept{
	a->destroy();
}

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/ptr.hpp"
//def.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/ptr.hpp"
typedef comn_ptr_t<node_like>ptr;
typedef weak_ptr_t<node_like>weak_ptr;
typedef comn_ptr_t<const node_like>const_ptr;
typedef weak_ptr_t<const node_like>const_weak_ptr;

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/value.hpp"
//value.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/value.hpp"
struct value:non_copy_assign_able{
	typedef value this_t;
	no_vtable_struct base_data_t:type_info_t<base_data_t>::template_name
		with_common_attribute<abstract_base,ref_able,never_in_array,replace_able>,
		build_by_get_only{
		/*//COMMIT:
		是否应当支持value data的引用计数？
		否的原因：
			这将导致应当对value的data加入gc机制（否则容易出现闭环value垃圾！）
			而这将严重增加elc的运行时时空负担
			有人可能得到递归引用的value
		是的原因：
			防御式编程
			更佳多样的value实现
			引用计数以降低value的复制开销
		对否定想法的驳回：
			严重增加elc的运行时时空负担？：value的复制开销可能更大
			有人可能得到递归引用的value？这将导致应当对value的data加入gc机制？：
				没见哪个语言不允许写while(true)
				自定义value的应该都是聪明人，如果真的会出现循环引用那他们自己解决就好
		总结：
			加引用计数，但不加gc
			elc的设计理念包括“不应禁止用户做什么”，所以应当提供高自由度的value定制可能
			但出于性能考虑，不加gc
			如果真的有需要gc解决的value data那么让那聪明的设计者自己给自己的data类加gc解决这种问题就好
		*/
		base_data_t()noexcept=default;
		base_data_t(never_ref_num_zero_t)noexcept{ attribute_ptr_cast<ref_able>(this)->init_never_ref_num_zero(); }
		virtual ~base_data_t()noexcept=default;

		virtual void be_set(ptr)=0;
		[[nodiscard]]virtual ptr get_value()=0;
		[[nodiscard]]virtual base_data_t*copy()const noexcept=0;
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept=0;//为什么要加这个？我不知道，万一将来有人用上了呢？
	};

	distinctive static inline struct null_data_t final:instance_struct<null_data_t>
	,value::base_data_t{
		null_data_t()noexcept:value::base_data_t(never_ref_num_zero){}
		virtual ~null_data_t()noexcept override final=default;

		virtual void be_set(ptr a)noexcept override final{}
		[[nodiscard]]virtual ptr get_value()noexcept override final{return null_ptr;}
		[[nodiscard]]virtual base_data_t*copy()const noexcept override final{return remove_const(this);}
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<null_data_t>;}
	}null_data{};

	struct constexpr_data_t final:instance_struct<constexpr_data_t>
	,base_data_t{
		ptr _m;
		constexpr_data_t(ptr a)noexcept:_m(a){}
		constexpr_data_t(const constexpr_data_t&)noexcept=default;
		virtual ~constexpr_data_t()noexcept override final=default;

		virtual void be_set(ptr)noexcept override final{}
		[[nodiscard]]virtual ptr get_value()noexcept override final{return _m;}
		[[nodiscard]]virtual base_data_t*copy()const noexcept override final{return get<constexpr_data_t>(_m);}
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<constexpr_data_t>;}
	};

	struct variable_data_t final:instance_struct<variable_data_t>
	,base_data_t{
		ptr _m;
		variable_data_t(ptr a)noexcept:_m(a){}
		variable_data_t(const variable_data_t&)noexcept=default;
		virtual ~variable_data_t()noexcept override final=default;

		virtual void be_set(ptr a)noexcept override final{_m=a;}
		[[nodiscard]]virtual ptr get_value()noexcept override final{return _m;}
		[[nodiscard]]virtual base_data_t*copy()const noexcept override final{return get<variable_data_t>(_m);}
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<variable_data_t>;}
	};
private:
	mutable comn_ptr_t<base_data_t> _m;
public:
	explicit value()noexcept:_m(get<variable_data_t>(null_ptr)){}
	constexpr explicit value(special_init_t)noexcept:_m(null_ptr){}
	explicit value(ptr a)noexcept:_m(get<constexpr_data_t>(a)){}
	explicit value(node_like* a)noexcept:value(ptr(a)){}
	value(base_data_t*a)noexcept:_m(a){}

	value(const this_t&a)noexcept=default;
	value(this_t&&a)noexcept=default;
	~value()noexcept=default;

	this_t&operator=(ptr a){
		_m->be_set(a);
		return *this;
	}
	this_t&operator=(auto&&a){
		return operator=(as_ptr(a));
	}

	[[nodiscard]]operator ptr(){
		return _m->get_value();
	}
	[[nodiscard]]operator const_ptr()const{
		return _m->get_value();
	}
	[[nodiscard]]ptr operator&(){
		return operator ptr();
	}
	[[nodiscard]]const_ptr operator&()const{
		return operator const_ptr();
	}
	[[nodiscard]]explicit operator bool()const{return bool(_m->get_value());}

	void ref_to(this_t a)noexcept{
		_m.do_replace(a._m);
	}
	void un_ref()noexcept{
		_m=_m->copy();
	}
	void re_ref_to(this_t a)noexcept{
		_m=a._m;
	}
	this_t& operator>>(this_t a)noexcept{
		a.ref_to(*this);
		return*this;
	}

	template<typename T>
	[[nodiscard]]auto operator[](T&&index){
		return (*operator&())[forward<T>(index)];
	}
	template<typename...Args> requires(invoke<node_like>.able<Args...>)
	inline auto operator()(Args&&... rest)noexcept(invoke<node_like>.nothrow<Args...>){return(*operator&())(forward<Args>(rest)...);}
	[[nodiscard]]auto operator==(auto&&a)const noexcept{
		try{
			return const_ptr(*this) == const_ptr(as_value(a));
		}
		catch(...){
			return unknown;
		}
	}
	[[nodiscard]]auto operator!=(auto&&a)const{
		return !operator==(a);
	}
	[[nodiscard]]operator ptr::for_delete_t*(){
		return _m->get_value();
	}
};

static value::base_data_t*the_get_null_ptr(const value::base_data_t*)noexcept{
	return&value::null_data;
}

BREAK_NAMESPACE

INTER_NAMESPACE(base)
template<>
distinctive inline core::value const_default_value_of<core::value>{special_init};
BREAK_NAMESPACE

INTER_NAMESPACE(core)

//file_end

#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/node_like_using_value_func_defs.hpp"
//defs.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/node_like_using_value_func_defs.hpp"
push_and_disable_msvc_warning(26440);//nothrow警告diss
[[nodiscard]]inline value node_like::be_eval(){
	return value(this);
}
[[nodiscard]]inline value node_like::be_call(ptr){
	return value(this);
}
pop_msvc_warning();

[[nodiscard]]inline value node_like::operator[](const value index){
	return arec(index);
}

//file_end

#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/_body.hpp"

//file_end

		#line 38 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/runtime_exception/_body.hpp"
//_body.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/runtime_exception/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/runtime_exception/base_runtime_exception.hpp"
//base_runtime_exception.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/runtime_exception/base_runtime_exception.hpp"
struct base_runtime_exception:runtime_exception{
	using runtime_exception::runtime_exception;
};

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/runtime_exception/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/runtime_exception/core_runtime_internal_helper.hpp"
//_body.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/runtime_exception/core_runtime_internal_helper.hpp"
namespace core_runtime_internal_helper_n{
	struct base_t:base_runtime_exception{
		using base_runtime_exception::base_runtime_exception;
		constexpr base_t()noexcept:
			base_runtime_exception(locale::str::exception::core_runtime_internal_helper_leak){}
	};
	//
	struct goto_t:base_t{
		ptr to;
	};
	struct return_t:base_t{};
}
//#include ".hpp"

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/runtime_exception/_body.hpp"

//file_end

		#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/_body.hpp"
//_body.hpp
//at namespace elc::defs::base
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/base_constexpr.hpp"
//base_constexpr.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/base_constexpr.hpp"
struct base_constexpr_t:node_like,instance_struct<base_constexpr_t>{
	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<base_constexpr_t>;}
protected:
	[[nodiscard]]virtual constexpr size_t equal_level()const noexcept override{return magic_number::god;}
	[[nodiscard]]virtual constexpr size_t eq_level()const noexcept override{return magic_number::god;}
public:
	base_constexpr_t()noexcept:node_like(never_ref_num_zero){}
	constexpr virtual ~base_constexpr_t()noexcept override=default;

	[[nodiscard]]virtual value arec(const value)noexcept override{return value(this);}

	virtual void clear()noexcept override final{nothing}

	virtual void be_replace_as(ptr)noexcept override{nothing}
};

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/void.hpp"
//void.hpp
//at namespace elc::defs::core
#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/void.hpp"
distinctive inline struct void_t final:base_constexpr_t{
	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<void_t>;}
protected:
	[[nodiscard]]virtual constexpr size_t equal_level()const noexcept override{return max(type_info<size_t>);}
	[[nodiscard]]virtual constexpr size_t eq_level()const noexcept override{return max(type_info<size_t>);}
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{
		if(this==a)
			return either;//当void是void时，void不是void
		else
			return neither;//当a不是void时，void是a
	}
	//我不知道为什么这么写，反正很有趣
public:
	[[nodiscard]]virtual constexpr explicit operator hash_t()const noexcept override{return hash(nothing);}
	[[nodiscard]]virtual constexpr explicit operator logical_bool()const noexcept override{return neither;}//void 应当不真不假
}the_void{};

[[nodiscard]]constexpr node_like*the_get_null_ptr(const node_like*)noexcept{return addressof((node_like&)the_void);}

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/nil.hpp"
//nil.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/nil.hpp"
distinctive inline struct nil_t final:base_constexpr_t{
	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<nil_t>;}
protected:
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{return !logical_bool(a);}
public:
	[[nodiscard]]virtual constexpr explicit operator hash_t()const noexcept override{return hash(false);}
	[[nodiscard]]virtual constexpr explicit operator logical_bool()const noexcept override{return false;}
}nil{};

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/t.hpp"
//t.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/t.hpp"
distinctive inline struct t_t final:base_constexpr_t{
	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<t_t>;}
protected:
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{return logical_bool(a);}
public:
	[[nodiscard]]virtual constexpr explicit operator hash_t()const noexcept override{return hash(true);}
	[[nodiscard]]virtual constexpr explicit operator logical_bool()const noexcept override{return true;}

	//nothing is true,everything is permitted.
	[[noreturn]]virtual void be_replace_as(ptr)noexcept override{::std::exit(0);}
}t{};

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/_body.hpp"

//file_end

		#line 40 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"
//_body.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/common_node.hpp"
//common_node.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/common_node.hpp"
struct common_node:node_like,instance_struct<common_node>{
	typedef common_node this_t;

	map_t<value,const_weak_ptr> _m;

	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<this_t>;}
protected:
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{
		if(a->get_type_info() != this->get_type_info())
			return false;
		const this_t*p=down_cast<const this_t*>(a.get());
		return _m==p->_m;
	}
public:
	[[nodiscard]]virtual value arec(const value index)override{return _m[&index];}

	virtual void clear()noexcept override{_m.clear();}
};

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/cons.hpp"
//common_node.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/cons.hpp"
inline value car_of(ptr p){
	return (*p)[t];
}
inline value cdr_of(ptr p){
	return (*p)[nil];
}
inline value car_of(auto&&node){
	return car_of(as_ptr(node));
}
inline value cdr_of(auto&&node){
	return cdr_of(as_ptr(node));
}

struct cons:node_like,instance_struct<cons>{
	typedef cons this_t;

	value _car;
	value _cdr;

	cons(ptr car,ptr cdr){
		_car = car;
		_cdr = cdr;
	}

	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<cons>;}
protected:
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{
		if(a->get_type_info() != this->get_type_info())
			return false;
		const this_t*p=down_cast<const this_t*>(a.get());
		return _car==p->_car&&_cdr==p->_cdr;
	}
public:
	[[nodiscard]]virtual value arec(const value index)override{
		const_ptr v=index;
		if(v==&nil)
			return _cdr;
		elseif(v==&t)
			return _car;
		else{
			ptr to=get<common_node>();
			_car >> car_of(to);
			_cdr >> cdr_of(to);
			be_replace_as(to);
			return (*to)[v];
		}
	}

	virtual void clear()noexcept override{as_value(&the_void)>>_car>>_cdr;}
};

[[nodiscard]]inline ptr make_list()noexcept{return &nil;}
template<typename T,typename...Args>
[[nodiscard]]inline ptr make_list(T&&first,Args&&...rest){
	ELC_TEST_EVENTNAME("make_list调用");
	return get<cons>(as_ptr(first),make_list(forward<Args>(rest)...));
}

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/expr.hpp"
//expr.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/expr.hpp"
struct expr:cons,instance_struct<expr>{
	typedef expr this_t;
	override_instance_struct;
public:
	using cons::_car;
	using cons::_cdr;
	using cons::cons;

	[[nodiscard]]virtual value be_eval()override{
		return as_ptr(_car)->be_call(_cdr);
	}
	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<expr>;}
};

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/base_binary_function_node.hpp"
//base_binary_function_node.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/base_binary_function_node.hpp"
struct base_binary_function_node:node_like,instance_struct<base_binary_function_node>{
	typedef base_binary_function_node this_t;

	function_t<value(ptr)> _func;

	base_binary_function_node(function_t<value(ptr)> func)noexcept:_func(func){}
	base_binary_function_node(function_t<void(ptr)> func)noexcept{
		_func = lambda_with_catch(func)(ptr p)mutable{
			func(p);
			return as_value(the_void);
		};
	}
	base_binary_function_node(function_t<void()> func)noexcept{
		_func = lambda_with_catch(func)(ptr)mutable{
			func();
			return as_value(the_void);
		};
	}

	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<this_t>;}
	[[nodiscard]]virtual value be_call(ptr arg_list)override{return _func(arg_list);}
protected:
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{
		if(a->get_type_info() != this->get_type_info())
			return false;
		const this_t*p=down_cast<const this_t*>(a.get());
		try{
			return _func==p->_func;
		}
		catch(...){
			return unknown;
		}
	}
public:
	[[nodiscard]]virtual value arec(const value index)override{return the_void[index];}

	virtual void clear()noexcept override{_func=nullptr;}
};

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/binary_node_t.hpp"
//binary_node_t.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/binary_node_t.hpp"
no_vtable_struct binary_node_base_t:node_like{
	typedef binary_node_base_t this_t;

	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<this_t>;}
	[[nodiscard]]virtual base_type_info_t get_additional_type_info()const noexcept=0;
protected:
	[[noreturn]] virtual void throw_self_ptr()const=0;
	[[noreturn]] virtual void throw_self_ptr()=0;
	template<typename T>
	friend[[nodiscard]]inline maybe_fail_reference<T> maybe_fail_use_by_ref_as(ptr p)noexcept;
	template<typename T>
	friend[[nodiscard]]inline maybe_fail_reference<T> maybe_fail_use_by_ref_as(ptr p)noexcept;
	template<typename T>
	friend[[nodiscard]]inline const T& const_use_by_ref_as(const_ptr p)noexcept;
};
template<typename T>
struct binary_node_t:binary_node_base_t,instance_struct<binary_node_t<T>>{
	typedef binary_node_t<T> this_t;
	typedef binary_node_base_t base_t;

	T _m;

	binary_node_t(const T&a)noexcept:_m(a){}
	binary_node_t(T&&a)noexcept:_m(a){}

	[[nodiscard]]virtual base_type_info_t get_additional_type_info()const noexcept override{return type_info<this_t>;}
private:
	static constexpr bool hash_nothrow_helper=hash.able<T>?
											  hash.nothrow<T>:1;
public:
	[[nodiscard]]virtual explicit operator hash_t()const noexcept(hash_nothrow_helper)override{
		if constexpr(hash.able<T>)
			return hash(_m);
		else
			#if defined(_MSC_VER)
				[[gsl::suppress(f.6)]]
			#endif
			return node_like::operator hash_t();
	}
protected:
	[[noreturn]] virtual void throw_self_ptr()const override{throw&_m;}
	[[noreturn]] virtual void throw_self_ptr()override{throw&_m;}
	[[nodiscard]]virtual logical_bool eq_with(const_ptr a)const noexcept override{
		using defs::equal;//貌似msvc在这里有bug
		if constexpr(equal.able<T>){
			if(a->get_type_info() != this->get_type_info())
				return false;
			const base_t*base_p=down_cast<const base_t*>(a.get());
			if(base_p->get_type_info() != this->get_type_info())
				return false;
			const this_t*p=down_cast<const this_t*>(base_p);
			return _m==p->_m;
		}
		else
			return node_like::eq_with(a);
	}
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{
		return eq_with(a);
	}
private:
	static constexpr bool arec_nothrow_helper=was_not_an_ill_form(arec_as_value(_m,declvalue(const value&)))?
											  was_not_an_ill_form_and_noexcept(arec_as_value(_m,declvalue(const value&))):1;
public:
	[[nodiscard]]virtual value arec(const value index)noexcept(arec_nothrow_helper)override{
		if constexpr(was_not_an_ill_form(arec_as_value(_m,index)))
			return arec_as_value(_m,index);
		else
			return as_value(this);
	}
private:
	static constexpr bool clear_nothrow_helper= was_not_an_ill_form(declvalue(T).clear())?
												was_not_an_ill_form_and_noexcept(declvalue(T).clear()):
												re_construct.nothrow<T>;
public:
	virtual void clear()noexcept(clear_nothrow_helper)override{
		if constexpr(was_not_an_ill_form(declvalue(T).clear()))
			_m.clear();
		else
			re_construct(&_m);
	}
};

template<typename T>
[[nodiscard]]inline bool was_an(const_ptr p)noexcept{
	typedef binary_node_t<T> target_node_t;
	if(p->get_type_info() == type_info<binary_node_base_t>){
		auto base_p = down_cast<const binary_node_base_t*>(p.get());
		if(base_p->get_additional_type_info() == type_info<target_node_t>)
			return true;
		elseif constexpr(::std::is_class_v<T> && !::std::is_final_v<T>){
			try{
				base_p->throw_self_ptr();
			}
			catch(const T*){
				return true;
			}
			catch(const void*){}
		}
	}
	return false;
}
template<typename T>
[[nodiscard]]inline maybe_fail_reference<T> maybe_fail_use_by_ref_as(ptr p)noexcept{
	typedef binary_node_t<T> target_node_t;
	if(p->get_type_info() == type_info<binary_node_base_t>){
		auto base_p = down_cast<binary_node_base_t*>(p.get());
		if(base_p->get_additional_type_info() == type_info<target_node_t>)
			return down_cast<target_node_t*>(base_p)->_m;
		elseif constexpr(::std::is_class_v<T> && !::std::is_final_v<T>){
			try{
				base_p->throw_self_ptr();
			}
			catch(T*aret){
				return*aret;
			}
			catch(void*){}
		}
	}
	return note::fail;
}
template<typename T>
[[nodiscard]]inline T& use_by_ref_as(ptr p)noexcept{
	return maybe_fail_use_by_ref_as<T>(p).get_ref();
}
template<typename T>
[[nodiscard]]inline const T& const_use_by_ref_as(const_ptr p)noexcept{
	typedef binary_node_t<T> target_node_t;
	if(p->get_type_info() == type_info<binary_node_base_t>){
		auto base_p = down_cast<const binary_node_base_t*>(p.get());
		if(base_p->get_additional_type_info() == type_info<target_node_t>)
			return down_cast<const target_node_t*>(base_p)->_m;
		elseif constexpr(::std::is_class_v<T> && !::std::is_final_v<T>){
			try{
				base_p->throw_self_ptr();
			}
			catch(const T*aret){
				return*aret;
			}
			catch(const void*){}
		}
	}
	return const_default_value_of<T>;
}
template<typename T>
[[nodiscard]]inline T use_as(const_ptr p)noexcept{
	return const_use_by_ref_as<T>(p);
}
template<typename T>
[[nodiscard]]inline const T& use_by_ref_as(const_ptr p)noexcept{
	return const_use_by_ref_as<T>(p);
}
template<typename T>
[[nodiscard]]inline const T& use_by_ref_as(auto&&a)noexcept{
	return use_by_ref_as<T>(as_ptr(a));
}
template<typename T>
[[nodiscard]]inline ptr make_binary_node_from(T a)noexcept{
	return get<binary_node_t<T>>(move(a));
}
template<typename T>
distinctive inline map_t<ptr,T> long_term_binary_node_storager{};
template<typename T>
[[nodiscard]]inline ptr make_long_term_binary_node_from(T a)noexcept{
	ptr& to = long_term_binary_node_storager<T>[a];
	if(!bool(to) || const_use_by_ref_as<T>(to)!=a)
		to = make_binary_node_from<T>(move(a));
	return to;
}

//file_end

#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/code_list.hpp"
//code_list.hpp
//at namespace elc::defs::core
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/code_list.hpp"
inline value eval(ptr p){
	return p->be_eval();
}
inline value eval(auto&&node){
	return eval(as_ptr(node));
}
struct code_list:cons,instance_struct<code_list>{
	typedef code_list this_t;
	override_instance_struct;
public:
	using cons::cons;

	[[nodiscard]]virtual value be_eval()override{
		ptr self = this;
		value aret{special_init};
	from_goto:
		try{
			do{
				eval(car_of(self)) >> aret;
				self=cdr_of(self);
			}while(self);
		}
		catch(core_runtime_internal_helper_n::goto_t&info){
			self=info.to;
			goto from_goto;
		}
		catch(core_runtime_internal_helper_n::return_t&){
		}
		return aret;
	}
	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<code_list>;}
};

//file_end

#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"

//file_end

		#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
	}

	#if defined(ELC_TEST_ON)
	namespace core_part_test{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_test.hpp"
//_test.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_test.hpp"
inline void test(){
	ELC_TEST_EVENTNAME("core部分测试");
}
inline void test_log_out(){
}
inline void test_end(){
}

//file_end

		#line 46 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
	}
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 50 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
}
namespace elc{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_export.hpp"
//_export.hpp
//at namespace elc
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_export.hpp"
#define export using defs::core::
export node_like;
export ptr;
export const_ptr;
export weak_ptr;
export const_weak_ptr;
export value;

export nil;
export t;
export the_void;

export as_value;
export as_ptr;
export common_node;
#undef export

//file_end

	#line 53 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
}
#if defined(ELC_STRING)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"
//string_arec_as_value.hpp
//at namespace ::
//multi when ELC_STRING & ELC_CORE
#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"
#if !defined(ELC_multi_string_arec_as_value)//pls skip define check as this part is muti
#define ELC_multi_string_arec_as_value
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"

	namespace string_n{
		template<class char_T>
		value arec_as_value(string_t<char_T>&str,const value index){
			size_t i=size_t(use_as<int_t>(index));
			if(!i)
				i=size_t(use_as<uint_t>(index));
			struct arec_data_t final:instance_struct<arec_data_t>
			,value::base_data_t{
				typename string_t<char_T>::arec_t _m;
				arec_data_t(string_t<char_T>&str,size_t index)noexcept:_m(&str,index){};
				arec_data_t(const arec_data_t&ref)noexcept:_m(special_init,ref._m){}
				virtual ~arec_data_t()noexcept override final=default;

				virtual void be_set(ptr a)noexcept override final{move(_m)=use_as<char_T>(a);}
				[[nodiscard]]virtual ptr get_value()noexcept override final{return core::make_binary_node_from<char_T>(move(_m));}
				[[nodiscard]]virtual base_data_t*copy()const noexcept override final{return get<arec_data_t>(*this);}
				[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<arec_data_t>;}
			};
			return get<arec_data_t>(str,i);
		}
	}

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 59 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"
}
#endif

//file_end

	#line 56 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
#endif

//file_end

	#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/core"
#endif

//file_end

	#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/namespace"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
//string
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
#if !defined(ELC_STRING)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
//base
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"

//file_end

	#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
	//operator<< & operator>>
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
//base_stream
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"

//file_end

	#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
	#define ELC_STRING
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
//_body.hpp
//at namespace ::
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
#if defined(ELC_TEST)
	#error "this part cannot be tested."
#endif
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/defs.hpp"
//defs.hpp
//at namespace elc::defs
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/defs.hpp"
namespace string_n{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"
//_body.hpp
//at namespace elc::defs::string_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"
inline namespace string_data_n{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_decl.hpp"
//_decl.hpp
//at namespace elc::defs::string_n::string_data_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_decl.hpp"
template<typename char_T>
struct base_string_data_t;

template<typename char_T>
struct null_string_data_t;
template<typename char_T>
struct constexpr_string_data_t;

template<typename char_T>
struct comn_string_data_t;

template<typename char_T>
struct substr_string_data_t;

template<typename char_T>
struct head_apply_string_data_t;
template<typename char_T>
struct end_apply_string_data_t;

template<typename char_T>
struct sum_string_data_t;

template<typename char_T>
struct erased_string_data_t;
template<typename char_T>
struct inserted_string_data_t;

//template<typename char_T>
//struct replaced_string_data_t;

template<typename char_T>
struct same_value_compress_string_data_t;

//file_end

	#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/base_string_data_t.hpp"
//base_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/base_string_data_t.hpp"
template<typename char_T>
no_vtable_struct base_string_data_t:type_info_t<base_string_data_t<char_T>>::template_name
	with_common_attribute<abstract_base,never_in_array,replace_able,ref_able>,build_by_get_only{
	typedef base_string_data_t<char_T> this_t;
	typedef comn_ptr_t<this_t> ptr_t;
	typedef string_view_t<char_T> string_view_t;
	typedef char_T*string_ptr_t;
	typedef const char_T*const_string_ptr_t;

	static_assert(noexcept(declvalue(ptr_t).operator*()));//貌似msvc在这里有bug

	static constexpr bool copy_assign_nothrow=copy_assign.nothrow<char_T>;
	static constexpr bool copy_construct_nothrow=copy_construct.nothrow<char_T>;
	static constexpr bool move_construct_nothrow=move_construct.nothrow<char_T>;
	static constexpr bool construct_nothrow=construct<char_T>.nothrow<>;
	static constexpr bool destruct_nothrow=destruct.nothrow<char_T>;
	static constexpr bool clear_nothrow=destruct_nothrow;
	static constexpr bool ptr_reset_nothrow=destruct_nothrow;
	static constexpr bool hash_nothrow=hash.nothrow<char_T>;
	static constexpr bool get_data_nothrow=copy_construct_nothrow&&destruct_nothrow;
	static constexpr bool apply_data_nothrow=construct_nothrow&&copy_assign_nothrow;

	friend class null_string_data_t<char_T>;
	friend class constexpr_string_data_t<char_T>;
	friend class comn_string_data_t<char_T>;
	friend class substr_string_data_t<char_T>;
	friend class head_apply_string_data_t<char_T>;
	friend class end_apply_string_data_t<char_T>;
	friend class sum_string_data_t<char_T>;
	friend class erased_string_data_t<char_T>;
	friend class inserted_string_data_t<char_T>;
	//friend class replaced_string_data_t<char_T>;
	friend class same_value_compress_string_data_t<char_T>;

	base_string_data_t()noexcept=default;
	base_string_data_t(never_ref_num_zero_t)noexcept{ attribute_ptr_cast<ref_able>(this)->init_never_ref_num_zero(); }

	[[nodiscard]]bool is_unique()noexcept{ return get_ref_num(this)==1; }
	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)=0;

	virtual ~base_string_data_t()noexcept(destruct_nothrow)=default;

	[[nodiscard]]virtual string_ptr_t get_c_str(ptr_t&)noexcept(get_data_nothrow);
	[[nodiscard]]virtual const_string_ptr_t get_const_c_str(ptr_t&p)noexcept(get_data_nothrow){return get_c_str(p);}
	[[nodiscard]]virtual const char_T* get_data(ptr_t&p)noexcept(get_data_nothrow){return get_c_str(p);}//不要求以0结尾
	[[nodiscard]]virtual string_ptr_t get_unique_c_str(ptr_t&)noexcept(get_data_nothrow);
	[[nodiscard]]virtual size_t get_size()noexcept=0;
	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept;
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow);
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow);
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow);
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow);

	[[nodiscard]]virtual ptr_t do_insert(size_t pos,string_view_t str)noexcept(copy_construct_nothrow);
	[[nodiscard]]virtual ptr_t do_insert(size_t pos,ptr_t str)noexcept;
	[[nodiscard]]virtual ptr_t do_erase(size_t pos,size_t size)noexcept;

	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow){
		if(size==0)return this;
		const auto pos	  = this->get_size()-size;
		const auto before = get_substr_data(0,pos);
		return before;
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow){
		if(size==0)return this;
		const auto pos	  = size;
		const auto after  = get_substr_data(pos,this->get_size()-size);
		return after;
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow){
		if(size==0)return null_ptr;
		const auto pos	  = this->get_size()-size;
		const auto before = get_substr_data(0,pos);
		const auto after  = get_substr_data(pos,size);
		self			  = before;
		return after;
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow){
		if(size==0)return null_ptr;
		const auto pos	  = size;
		const auto before = get_substr_data(0,pos);
		const auto after  = get_substr_data(pos,this->get_size()-size);
		self			  = after;
		return before;
	}
	#line 131 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/base_string_data_t.hpp"
	typedef compare_t::type<char_T> compare_type;
protected:
	bool same_type(ptr_t a)noexcept{return typeid(*this)==typeid(*a);}
	[[nodiscard]]virtual bool same_struct(ptr_t)noexcept=0;
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)=0;
	[[nodiscard]]virtual compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)=0;
protected:
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept=0;
private:
	[[nodiscard]]bool base_equal_with(ptr_t with)noexcept(equal.nothrow<char_T>){
		push_and_disable_msvc_warning(26494);//未初始化警告diss
		bool aret;
		{
			//同结构比较优化比较方式
			if(same_type(with)&&same_struct(with))
				aret=same_struct_equal(with);
			//否则默认比较
			else
				aret=default_equal_method(with);
		}
		pop_msvc_warning();
		//如果equal，则eq处理
		if(aret)
			equivalent_optimization(this,with);
		return aret;
	}
public:
	[[nodiscard]]bool equal_with(ptr_t with)noexcept(equal.nothrow<char_T>){
		//eq->equal优化
		if(this==with)
			return true;
		//hash_diff->not_equal优化
		if(this->has_hash_cache()&&with->has_hash_cache())
			if(this->get_hash_cache()!=with->get_hash_cache())
				return false;
		//size比较优化
		if(this->get_size()!=with->get_size())
			return false;
		//快速比较结束，实际比较段
		return base_equal_with(with);
	}
	[[nodiscard]]bool equal_with_same_size(ptr_t with)noexcept(equal.nothrow<char_T>){
		//eq->equal优化
		if(this==with)
			return true;
		//hash_diff->not_equal优化
		if(this->has_hash_cache()&&with->has_hash_cache())
			if(this->get_hash_cache()!=with->get_hash_cache())
				return false;
		//size比较优化被移除
		//快速比较结束，实际比较段
		return base_equal_with(with);
	}
protected:
	[[nodiscard]]bool default_equal_method(ptr_t with)noexcept(equal.nothrow<char_T>){
		const size_t self_size=get_size();
		return equal_with(with,0,self_size);
	}
public:
	[[nodiscard]]bool equal_with(ptr_t with,size_t pos,size_t size)noexcept(equal.nothrow<char_T>){
		//eq->equal优化
		if(this==with)
			return true;
		size_t index=pos;
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		auto b=with->get_the_largest_complete_data_block_begin_form(index);
		while(size){
			const size_t step=min({a.size(),b.size(),size});
			if(a.begin()!=b.begin())//起始地址不同时才需要真的比较
				if(!equal(a.begin(),b.begin(),step))
					return false;
			index+=step;
			size-=step;
			if(a.size()==step)
				a=this->get_the_largest_complete_data_block_begin_form(index);
			else
				a={a.begin()+step,note::size(a.size()-step)};
			if(b.size()==step)
				b=with->get_the_largest_complete_data_block_begin_form(index);
			else
				b={b.begin()+step,note::size(b.size()-step)};
			if(!a.size()&&!b.size())
				return a.size()==b.size();
		}
		return true;
	}
	[[nodiscard]]bool equal_with(string_view_t with)noexcept(equal.nothrow<char_T>){
		size_t size=with.size();
		size_t index=0;
		if(this->get_size()!=with.size())
			return false;
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		if(a.begin()==with.begin() && a.size()==with.size())
			return true;
		floop{
			auto b=with.begin()+index;
			const size_t step=min({a.size(),with.size()-index,size});
			if(!equal(a.begin(),b,step))
				return false;
			index+=step;
			size-=step;
			if(a.size()==step)
				a=this->get_the_largest_complete_data_block_begin_form(index);
			else
				a={a.begin()+step,note::size(a.size()-step)};
			if(!a.size()||!size)
				return a.size()==size;
		}
	}
	[[nodiscard]]bool equal_with(const_string_ptr_t with)noexcept(equal.nothrow<char_T>){
		size_t size=get_size();
		size_t index=0;
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		if(a.begin()==with && with[a.size()]==char_T{})
			return true;
		floop{
			auto b=with+index;
			if(!*b)
				return false;
			const size_t step=min({a.size(),size});
			if(!equal(a.begin(),step,just_an_part,b,end_by_zero))
				return false;
			index+=step;
			size-=step;
			if(a.size()==step)
				a=this->get_the_largest_complete_data_block_begin_form(index);
			else
				a={a.begin()+step,note::size(a.size()-step)};
			if(!*(b+step))
				return !a.size();
			if(!a.size())
				return !*(b+step);
		}
	}
private:
	[[nodiscard]]compare_type base_compare_with(ptr_t with)noexcept(compare.nothrow<char_T>){
		push_and_disable_msvc_warning(26494);//未初始化警告diss
		compare_type aret;
		{
			//同结构比较优化比较方式
			if(same_type(with)&&same_struct(with))
				aret=same_struct_compare(with);
			//否则默认比较
			else
				aret=default_compare_method(with);
		}
		pop_msvc_warning();
		//如果equal，则eq处理
		if(aret==0)
			equivalent_optimization(this,with);
		return aret;
	}
public:
	[[nodiscard]]compare_type compare_with(ptr_t with)noexcept(compare.nothrow<char_T>){
		//eq->equal优化
		if(this==with)
			return strong_ordering::equivalent;
		//size比较优化
		{
			auto scom=compare(this->get_size(),with->get_size());
			if(scom!=0)
				return scom;
		}
		//快速比较结束，实际比较段
		return base_compare_with(with);
	}
	[[nodiscard]]compare_type compare_with_same_size(ptr_t with)noexcept(compare.nothrow<char_T>){
		//eq->equal优化
		if(this==with)
			return strong_ordering::equivalent;
		//size比较优化被移除
		//快速比较结束，实际比较段
		return base_compare_with(with);
	}
protected:
	[[nodiscard]]compare_type default_compare_method(ptr_t with)noexcept(compare.nothrow<char_T>){
		const size_t self_size=get_size();
		return compare_with(with,0,self_size);
	}
public:
	[[nodiscard]]compare_type compare_with(ptr_t with,size_t pos,size_t size)noexcept(compare.nothrow<char_T>){
		//eq->equal优化
		if(this==with)
			return strong_ordering::equivalent;
		size_t index=pos;
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		auto b=with->get_the_largest_complete_data_block_begin_form(index);
		while(size){
			const size_t step=min({a.size(),b.size(),size});
			if(a.begin()!=b.begin())//起始地址不同时才需要真的比较
				if(auto tmp=compare(a.begin(),b.begin(),step); tmp!=0)
					return tmp;
			index+=step;
			size-=step;
			if(a.size()==step)
				a=this->get_the_largest_complete_data_block_begin_form(index);
			else
				a={a.begin()+step,note::size(a.size()-step)};
			if(b.size()==step)
				b=with->get_the_largest_complete_data_block_begin_form(index);
			else
				b={b.begin()+step,note::size(b.size()-step)};
			if(!a.size()||!b.size())
				return a.size()<=>b.size();
		}
		return strong_ordering::equivalent;
	}
	[[nodiscard]]compare_type compare_with(string_view_t with)noexcept(compare.nothrow<char_T>){
		size_t size=with.size();
		size_t index=0;
		{
			auto scom=compare(this->get_size(),size);
			if(scom!=0)
				return scom;
		}
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		if(a.begin()==with.begin() && a.size()==with.size())
			return strong_ordering::equivalent;
		floop{
			auto b=with.begin()+index;
			size_t step=min({a.size(),with.size()-index,size});
			if(auto tmp=compare(a.begin(),b,step); tmp!=0)
				return tmp;
			index+=step;
			size-=step;
			if(a.size()==step)
				a=this->get_the_largest_complete_data_block_begin_form(index);
			else
				a={a.begin()+step,note::size(a.size()-step)};
			if(!a.size()||!size)
				return a.size()<=>size;
		}
	}
	[[nodiscard]]compare_type compare_with(const_string_ptr_t with)noexcept(compare.nothrow<char_T>){
		size_t size=get_size();
		size_t index=0;
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		if(a.begin()==with && with[a.size()]==char_T{})
			return strong_ordering::equivalent;
		floop{
			auto b=with+index;
			if(!*b)
				return strong_ordering::greater;
			size_t step=min({a.size(),size});
			if(auto tmp=compare(a.begin(),step,just_an_part,b,end_by_zero); tmp!=0)
				return tmp;
			index+=step;
			size-=step;
			if(a.size()==step)
				a=this->get_the_largest_complete_data_block_begin_form(index);
			else
				a={a.begin()+step,note::size(a.size()-step)};
			if(!a.size())
				return *(with+index)==char_T{}? strong_ordering::equivalent:
												strong_ordering::less;
			if(!*(with+index))
				return strong_ordering::greater;
		}
	}
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)=0;
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)=0;
	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)=0;
protected:
	hash_t _hash_cache{};
	bool _has_hash_cache=false;
	bool has_hash_cache()noexcept{return _has_hash_cache;}
	void reset_hash_cache()noexcept{_has_hash_cache=false;}
	hash_t get_hash_cache()noexcept{return _hash_cache;}
	hash_t set_hash_cache(hash_t value)noexcept{_has_hash_cache=true;return _hash_cache=value;}
public:
	hash_t get_hash(ptr_t&p)noexcept(hash_nothrow){
		if(has_hash_cache())
			return get_hash_cache();
		else{
			const auto tmp=this->get_hash_detail(p);
			return p->set_hash_cache(tmp);
		}
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&p)noexcept(hash_nothrow){
		const auto size=get_size();
		const auto data=get_data(p);
		return hash(data,size);
	}
public:
	hash_t get_others_hash_with_calculated_before(hash_t before,size_t before_size,ptr_t&p,size_t pos,size_t size)noexcept(hash_nothrow){
		if(pos==0&&size==get_size())
			return hash.merge_array_hash_results(before,before_size,get_hash(p),size);
		return this->get_others_hash_with_calculated_before_detail(before,before_size,p,pos,size);
	}
protected:
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&p,size_t pos,size_t size)noexcept(hash_nothrow){
		return hash.with_calculated_before(before,before_size,get_data(p)+pos,size);
	}
protected:
	void self_changed()noexcept{
		reset_hash_cache();
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept=0;
public:
	[[nodiscard]]float_size_t get_memory_cost()noexcept{
		return get_base_memory_cost()/get_ref_num(this);
	}
	[[nodiscard]]float_size_t get_memory_cost_after_gc()noexcept;
	[[nodiscard]]float_size_t get_gc_profit()noexcept{return get_memory_cost()-get_memory_cost_after_gc();}
	[[nodiscard]]bool positive_gc_profit()noexcept{return get_gc_profit() > 0;}
	//for gc:
	#line 449 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/base_string_data_t.hpp"
	[[nodiscard]]virtual const range_n::match_pattern<const char_T>& get_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow);
	[[nodiscard]]virtual const range_n::reverse_match_pattern<const char_T>& get_reverse_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow);

protected:
	static inline void be_replace(this_t* a,ptr_t b)noexcept(ptr_reset_nothrow){
		a->be_replace_as(b);
	}
	static inline void be_replace(ptr_t& a,ptr_t b)noexcept(ptr_reset_nothrow){
		a.do_replace(b);
	}
	static inline void equivalent_optimization(auto&& a,auto&& b)noexcept(ptr_reset_nothrow){
		if(a->get_memory_cost() >= b->get_memory_cost())
			be_replace(a,b);
		else
			be_replace(b,a);
	}
public:
	//Pre-alloc before begin memory
	[[nodiscard]]virtual ptr_t pre_alloc_before_begin(size_t size)noexcept;
	//Pre-alloc after end memory
	[[nodiscard]]virtual ptr_t pre_alloc_after_end(size_t size)noexcept;

	//io
	virtual void do_output(text_ostream_t<char_T>& os){
		size_t index=0;
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		while(a.size()){
			os.write(a.begin(),a.size());
			index+=a.size();
			a=this->get_the_largest_complete_data_block_begin_form(index);
		}
	}
};
template<typename char_T>
void base_string_data_t<char_T>::be_replace_as(ptr_t a)noexcept(clear_nothrow){
	replace_able<this_t>::be_replace_as(a.get());
}

//file_end

	#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/null_string_data_t.hpp"
//null_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/null_string_data_t.hpp"
template<typename char_T>
struct null_string_data_t final:base_string_data_t<char_T>,instance_struct<null_string_data_t<char_T>>{
	typedef null_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	null_string_data_t()noexcept:base_t(never_ref_num_zero){}

	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{nothing;}
	[[nodiscard]]virtual string_ptr_t get_c_str(ptr_t&)noexcept override final{
		static char_T data[1]{};
		return data;
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return 0; }
	[[nodiscard]]virtual ptr_t get_substr_data([[maybe_unused]]size_t begin,[[maybe_unused]]size_t size)noexcept override final{ return this; }
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{ return get<comn_string_data_t<char_T>>(str); }
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{ return str; }
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{ return get<comn_string_data_t<char_T>>(str); }
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept override final{ return str; }

	[[nodiscard]]virtual ptr_t do_insert([[maybe_unused]]size_t pos,[[maybe_unused]]string_view_t str)noexcept(construct_nothrow&&copy_assign_nothrow)override final{ return get<comn_string_data_t<char_T>>(str); }
	[[nodiscard]]virtual ptr_t do_insert([[maybe_unused]]size_t pos,[[maybe_unused]]ptr_t str)noexcept override final{ return str; }
	[[nodiscard]]virtual ptr_t do_erase([[maybe_unused]]size_t pos,[[maybe_unused]]size_t size)noexcept override final{ return this; }
protected:
	virtual void copy_part_data_to([[maybe_unused]]char_T* to,[[maybe_unused]]size_t pos,[[maybe_unused]]size_t size)noexcept override final{ return; }
public:
	[[nodiscard]]virtual char_T arec([[maybe_unused]]size_t index)noexcept override final{ return char_T{}; }
	virtual void arec_set([[maybe_unused]]size_t index,[[maybe_unused]]char_T a,[[maybe_unused]]ptr_t& p)noexcept override final{ nothing; }
	[[nodiscard]]virtual ptr_t do_remove_front([[maybe_unused]]size_t size)noexcept override final{ return this; }
	[[nodiscard]]virtual ptr_t do_remove_back([[maybe_unused]]size_t size)noexcept override final{ return this; }
	[[nodiscard]]virtual ptr_t do_pop_back([[maybe_unused]]size_t size,[[maybe_unused]]ptr_t& self)noexcept override final{ return this; }
	[[nodiscard]]virtual ptr_t do_pop_front([[maybe_unused]]size_t size,[[maybe_unused]]ptr_t& self)noexcept override final{ return this; }
protected:
	virtual hash_t get_hash_detail([[maybe_unused]]ptr_t&p)noexcept override final{ return hash(nothing); }
	virtual hash_t get_others_hash_with_calculated_before_detail([[maybe_unused]]hash_t before,[[maybe_unused]]size_t before_size,[[maybe_unused]]ptr_t&p,[[maybe_unused]]size_t pos,[[maybe_unused]]size_t size)noexcept override final{ return before; }
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t)noexcept override final{return false;}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form([[maybe_unused]]size_t begin)noexcept override final{return{0,0};}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept override final{return false;}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept override final{return strong_ordering::equivalent;}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{return 0;}
};
template<typename char_T>
distinctive inline null_string_data_t<char_T> null_string_data{};
template<typename char_T>
base_string_data_t<char_T>* the_get_null_ptr(const base_string_data_t<char_T>*)noexcept{ return&null_string_data<char_T>; }

//file_end

	#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/constexpr_string_data_t.hpp"
//constexpr_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/constexpr_string_data_t.hpp"
template<typename char_T>
struct constexpr_string_data_t final:base_string_data_t<char_T>,instance_struct<constexpr_string_data_t<char_T>>{
	typedef constexpr_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	const char_T* _m;
	size_t _size;

	const range_n::match_pattern<const char_T>*			_p_match_pattern		 = nullptr;
	const range_n::reverse_match_pattern<const char_T>* _p_reverse_match_pattern = nullptr;
	bool												match_pattern_by_get	 = 0;

	void clear_match_pattern()noexcept{
		if(match_pattern_by_get){
			unget(remove_const(_p_match_pattern));
			unget(remove_const(_p_reverse_match_pattern));
			_p_match_pattern = nullptr;
			_p_reverse_match_pattern = nullptr;
		}
	}

	constexpr_string_data_t(const constexpr_str_t<char_T>&str)noexcept{
		_m=str.begin();
		_size=str.size();
		set_hash_cache(hash(str));
		_p_match_pattern=&str.match_pattern;
		_p_reverse_match_pattern=&str.reverse_match_pattern;
		match_pattern_by_get=0;
	}
	constexpr_string_data_t(string_view_t str)noexcept{
		_m=str.begin();
		_size=str.size();
		if(!_size)
			be_replace_as(null_ptr);
	}
	virtual ~constexpr_string_data_t()noexcept(destruct_nothrow)override final{
		clear_match_pattern();
	}

	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{
		return get<this_t>(string_view_t{_m+begin,size});
	}
	[[nodiscard]]virtual const char_T* get_data(ptr_t&)noexcept(get_data_nothrow)override final{return _m;}
	[[nodiscard]]virtual const_string_ptr_t get_const_c_str(ptr_t&p)noexcept(get_data_nothrow)override final{
		if(!_m[_size])
			return _m;
		else
			return base_t::get_const_c_str(p);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _size; }
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{ copy_assign[size](note::from(_m+pos),note::to(to)); }
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{ return _m[index]; }

	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{base_t::be_replace_as(a);}
	virtual void arec_set(size_t index,char_T a,ptr_t&p)noexcept override final{base_t::arec_set(index,a,p);}

	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		return true;//总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{return{&_m[begin],note::size(_size-begin)};}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		if(_m==wp->_m)
			return true;
		return equal(_m,wp->_m,_size);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		if(_m==wp->_m)
			return strong_ordering::equivalent;
		return compare(_m,wp->_m,_size);
	}
protected:
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this);
	}
public:
	[[nodiscard]]virtual const range_n::match_pattern<const char_T>& get_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(!_p_match_pattern){
			_p_match_pattern=get<range_n::match_pattern<const char_T>>(array_like_view_t{this->get_data(self),this->get_size()});
			match_pattern_by_get = 1;
		}
		return *_p_match_pattern;
	}
	[[nodiscard]]virtual const range_n::reverse_match_pattern<const char_T>&get_reverse_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(!_p_reverse_match_pattern){
			_p_reverse_match_pattern=get<range_n::reverse_match_pattern<const char_T>>(array_like_view_t{this->get_data(self),this->get_size()});
			match_pattern_by_get = 1;
		}
		return *_p_reverse_match_pattern;
	}
};

//file_end

	#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/comn_string_data_t.hpp"
//comn_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/comn_string_data_t.hpp"
template<typename char_T>
struct comn_string_data_t final:base_string_data_t<char_T>,instance_struct<comn_string_data_t<char_T>>{
	typedef comn_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	array_t<char_T> _m;
	range_n::match_pattern<const char_T>*		  _p_match_pattern		   = nullptr;
	range_n::reverse_match_pattern<const char_T>* _p_reverse_match_pattern = nullptr;
	void clear_match_pattern()noexcept{
		unget(_p_match_pattern);
		unget(_p_reverse_match_pattern);
		_p_match_pattern=nullptr;
		_p_reverse_match_pattern=nullptr;
	}
	void self_changed()noexcept{
		clear_match_pattern();
		base_t::self_changed();
	}

	comn_string_data_t(string_view_t str)noexcept(construct_nothrow&&copy_assign_nothrow):_m(note::size(str.size()+1)){
		copy_assign[str.size()](note::from(str.begin()),note::to(_m.data()));
		_m[str.size()]=zero;
	}
	comn_string_data_t(ptr_t str)noexcept(construct_nothrow&&copy_assign_nothrow):_m(note::size(str->get_size()+1)){
		const auto size=this->get_size();
		str->copy_part_data_to(_m.data(),0,size);
		_m[size]=zero;
	}
	comn_string_data_t(ptr_t str,size_t pos,size_t size)noexcept(construct_nothrow&&copy_assign_nothrow):_m(note::size(size+1)){
		str->copy_part_data_to(_m.data(),pos,size);
		_m[size]=zero;
	}
	comn_string_data_t(size_t size,char_T ch)noexcept(construct_nothrow&&copy_assign_nothrow):_m(note::size(size+1),ch){
		_m[size]=zero;
	}
	comn_string_data_t(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow):_m(note::size(size+1)){
		_m[size]=zero;
	}

	virtual ~comn_string_data_t()noexcept(destruct_nothrow)override final{
		clear_match_pattern();
	}

	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		_m.clear();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual string_ptr_t get_c_str(ptr_t&)noexcept override final{ return _m.data(); }
	[[nodiscard]]virtual string_ptr_t get_unique_c_str(ptr_t&p)noexcept(get_data_nothrow)override final{
		if(this->is_unique())
			return _m.data();
		else
			return base_t::get_unique_c_str(p);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _m.size()-1; }
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{ copy_assign[size](note::from((const char_T*)_m+pos),note::to(to)); }
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{ return _m[index]; }
	virtual void arec_set(size_t index,char_T a,ptr_t&p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			copy_assign(_m[index],a);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}

	[[nodiscard]]virtual bool same_struct(ptr_t)noexcept override final{
		return true;//总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{return{&_m[begin],note::size(get_size()-begin)};}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return equal(_m, wp->_m);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return compare(_m, wp->_m);
	}
protected:
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this) + _m.size_in_byte();
	}
public:
	[[nodiscard]]virtual const range_n::match_pattern<const char_T>& get_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(!_p_match_pattern)
			_p_match_pattern=get<range_n::match_pattern<const char_T>>(array_like_view_t{this->get_data(self),this->get_size()});
		return *_p_match_pattern;
	}
	[[nodiscard]]virtual const range_n::reverse_match_pattern<const char_T>&get_reverse_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(!_p_reverse_match_pattern)
			_p_reverse_match_pattern=get<range_n::reverse_match_pattern<const char_T>>(array_like_view_t{this->get_data(self),this->get_size()});
		return *_p_reverse_match_pattern;
	}
};
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::string_ptr_t base_string_data_t<char_T>::get_c_str(ptr_t&a)noexcept(get_data_nothrow){
	auto comn_data=get<comn_string_data_t<char_T>>(this);
	if(positive_gc_profit())
		a.do_replace(comn_data);
	else
		a=comn_data;
	return comn_data->get_c_str(a);
}
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::string_ptr_t base_string_data_t<char_T>::get_unique_c_str(ptr_t&a)noexcept(get_data_nothrow){
	auto comn_data=get<comn_string_data_t<char_T>>(this);
	a=comn_data;
	return comn_data->get_c_str(a);
}
template<typename char_T>
void base_string_data_t<char_T>::arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow){
	copy_assign(this->get_unique_c_str(p)[index],a);
}
template<typename char_T>
[[nodiscard]]float_size_t base_string_data_t<char_T>::get_memory_cost_after_gc()noexcept{
	const auto size_of_base_array=this->get_size()*sizeof(char_T);
	const auto size=float_size_of(comn_string_data_t<char_T>)+size_of_base_array;
	return size/get_ref_num(this);
}
template<typename char_T>
[[nodiscard]]const range_n::match_pattern<const char_T>& base_string_data_t<char_T>::get_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow){
	auto comn_data=get<comn_string_data_t<char_T>>(this);
	self=comn_data;
	return comn_data->get_match_pattern_from_self(self);
}
template<typename char_T>
[[nodiscard]]const range_n::reverse_match_pattern<const char_T>& base_string_data_t<char_T>::get_reverse_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow){
	auto comn_data=get<comn_string_data_t<char_T>>(this);
	self=comn_data;
	return comn_data->get_reverse_match_pattern_from_self(self);
}

//file_end

	#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/substr_string_data_t.hpp"
//substr_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/substr_string_data_t.hpp"
template<typename char_T>
struct substr_string_data_t final:base_string_data_t<char_T>,instance_struct<substr_string_data_t<char_T>>{
	typedef substr_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	ptr_t _to;
	size_t _sub_begin;
	size_t _sub_size;

	void null_equivalent_check()noexcept{
		if(!_sub_size)
			be_replace_as(null_ptr);
	}

	substr_string_data_t(ptr_t str,size_t sub_begin,size_t sub_size)noexcept:_to(str),_sub_begin(sub_begin),_sub_size(sub_size){
		null_equivalent_check();
	}

	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		_to.reset();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{ return get<substr_string_data_t<char_T>>(_to,begin+_sub_begin,size); }
	[[nodiscard]]virtual const_string_ptr_t get_const_c_str(ptr_t&p)noexcept(get_data_nothrow)override final{
		if(_sub_begin+_sub_size==_to->get_size())
			return _to->get_const_c_str(_to)+_sub_begin;
		else
			return base_t::get_const_c_str(p);
	}
	[[nodiscard]]virtual const char_T* get_data(ptr_t&)noexcept(get_data_nothrow)override final{ return _to->get_data(_to)+_sub_begin; }
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _sub_size; }
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{ _to->copy_part_data_to(to,pos+_sub_begin,size); }
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{ return _to->arec(index+_sub_begin); }
	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			_to->arec_set(index+_sub_begin,a,_to);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique() && _sub_begin==0){
			_to=_to->apply_str_to_begin(str);
			_sub_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique() && _sub_begin==0){
			_to=_to->apply_str_to_begin(str);
			_sub_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique() && _sub_begin+_sub_size==_to->get_size()){
			_to=_to->apply_str_to_end(str);
			_sub_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique() && _sub_begin+_sub_size==_to->get_size()){
			_to=_to->apply_str_to_end(str);
			_sub_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _sub_begin==0){
			auto aret=_to->do_pop_front(size,_to);
			_sub_size-=size;
			null_equivalent_check();
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_front(size,self);
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _sub_begin+_sub_size==_to->get_size()){
			auto aret=_to->do_pop_back(size,_to);
			_sub_size-=size;
			null_equivalent_check();
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_back(size,self);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			if(_sub_begin==0){
				_to=_to->do_remove_front(size);
				_sub_size-=size;
			}
			else{
				_sub_begin+=size;
				_sub_size-=size;
			}
			null_equivalent_check();
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_front(size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			if(_sub_begin+_sub_size==_to->get_size())
				_to=_to->do_remove_back(size);
			_sub_size-=size;
			null_equivalent_check();
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_back(size);
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		auto result=hash(nothing);
		result=_to->get_others_hash_with_calculated_before(result,0,_to,_sub_begin,_sub_size);
		return result;
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,size_t pos,size_t size)noexcept(hash_nothrow)override final{
		return _to->get_others_hash_with_calculated_before(before,before_size,_to,pos+_sub_begin,size);
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp = down_cast<this_t*>(with.get());
		return _sub_begin == wp->_sub_begin;//总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{
		auto result = _to->get_the_largest_complete_data_block_begin_form(_sub_begin+begin);
		auto size	= min(result.size(),_sub_size-begin);
		return{result.begin(), note::size(size)};
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return _to->equal_with(wp->_to,_sub_begin,_sub_size);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return _to->compare_with(wp->_to,_sub_begin,_sub_size);
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this)+_to->get_memory_cost();
	}
};
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::get_substr_data(size_t begin,size_t size)noexcept{
	if(begin==0&&size==get_size())
		return this;
	else
		return get<substr_string_data_t<char_T>>(this,begin,size);
}

//file_end

	#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/head_apply_string_data_t.hpp"
//end_apply_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/head_apply_string_data_t.hpp"
template<typename char_T>
struct head_apply_string_data_t final:base_string_data_t<char_T>,instance_struct<head_apply_string_data_t<char_T>>{
	typedef head_apply_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	array_t<char_T> _m;//意义为向前延续的数组：当需要向前附加内容时向前拓展以避免重新分配内存
	ptr_t _to;
	size_t _to_size;
	size_t _used_size;

	head_apply_string_data_t(ptr_t str,string_view_t head)noexcept(construct_nothrow&&copy_assign_nothrow):
		_to_size(str->get_size()),
		_used_size(head.size()),
		_to(str)
	{
		_m.resize(get_next_gold_size_to_resize_for_array(_to_size+_used_size));
		copy_assign[_used_size](note::from<const char_T*>(head.begin()),note::to<char_T*>(_m.end()-_used_size));
	}
	head_apply_string_data_t(ptr_t str,pre_alloc_t,size_t head_size)noexcept(construct_nothrow):
		_to_size(str->get_size()),
		_used_size(0),
		_to(str)
	{
		_m.resize(head_size);
	}

	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{
		if(begin>=_used_size)
			return _to->get_substr_data(begin-_used_size,size);
		else
			return base_t::get_substr_data(begin,size);
	}
	[[nodiscard]]virtual string_ptr_t get_c_str(ptr_t&p)noexcept(get_data_nothrow)override final{
		if(!_used_size)
			return _to->get_c_str(_to);
		else
			return base_t::get_c_str(p);
	}
	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		if(type_info<this_t> == typeid(*a)){
			const auto p = down_cast<this_t*>(a.get());
			if(_used_size==p->_used_size && _to!=p->_to)
				base_t::equivalent_optimization(_to, p->_to);
		}
		_m.clear();
		_to.reset();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _used_size+_to_size; }
	[[nodiscard]]virtual ptr_t do_insert(size_t pos,string_view_t str)noexcept(copy_construct_nothrow)override final{
		if(pos==0)
			return this->apply_str_to_begin(str);
		elseif(pos==get_size())
			return this->apply_str_to_end(str);
		elseif(this->is_unique()){
			if(pos<_used_size){
				if(_m.size()-_used_size>=str.size()){
					char_T* orogin_head_begin=_m.end()-_used_size;
					char_T* head_begin=orogin_head_begin-str.size();
					copy_assign[pos](note::from<const char_T*>(orogin_head_begin),note::to<char_T*>(head_begin));
					copy_assign[str.size()](note::from<const char_T*>(str.begin()),note::to<char_T*>(head_begin+pos));
				}
				else{
					const auto size_now=this->get_size()+str.size();
					const auto size_new=get_next_gold_size_to_resize_for_array(size_now);
					_m.insert_with_forward_resize(pos,str.size(),str.begin(),size_new);
				}
				_used_size+=str.size();
			}else{
				_to=_to->do_insert(pos-_used_size,str);
				_to_size=_to->get_size();
			}
			self_changed();
			return this;
		}
		else
			return base_t::do_insert(pos,str);
	}
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{
		if(pos<_used_size){
			const char_T* head_begin=_m.end()-_used_size;
			const char_T* head_end=_m.end();
			const char_T* copy_begin=pos+head_begin;
			size_t size_of_copy_from_head=min(size_t(head_end-copy_begin),size);

			copy_assign[size_of_copy_from_head](note::from(copy_begin),note::to(to));
			if(size!=size_of_copy_from_head){
				const size_t size_left=size-size_of_copy_from_head;
				char_T* next_copy_begin_pos=to+size_of_copy_from_head;
				_to->copy_part_data_to(next_copy_begin_pos,0,size_left);
			}
		}
		else
			_to->copy_part_data_to(to,pos-_used_size,size);
	}
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{
		if(index<_used_size){
			const char_T* head_begin=_m.end()-_used_size;
			return head_begin[index];
		}
		else
			return _to->arec(index-_used_size);
	}
	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			if(index<_used_size){
				char_T* head_begin=_m.end()-_used_size;
				copy_assign(head_begin[index],a);
			}
			else
				_to->arec_set(index-_used_size,a,_to);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			if(_m.size()-_used_size>=str.size())
				copy_assign[str.size()](note::from<const char_T*>(str.begin()),note::to<char_T*>(_m.end()-_used_size-str.size()));
			else{
				const auto size_now=this->get_size()+str.size();
				const auto size_new=get_next_gold_size_to_resize_for_array(size_now);
				_m.insert_with_forward_resize(0,str.size(),str.begin(),size_new);
			}
			_used_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{
		this->shrink();
		return base_t::apply_str_to_begin(str);
	}
	void shrink()noexcept(_m.forward_resize_nothrow){
		_m.forward_resize(_used_size);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_end(str);
			_to_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_end(str);
			_to_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(size>=_used_size)
			return _to->do_remove_front(size-_used_size);
		if(this->is_unique()){//&& size<_used_size
			_used_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_front(size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		#line 227 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/head_apply_string_data_t.hpp"
		if(this->is_unique() && size<_to_size){
			_to=_to->do_remove_back(size);
			_to_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_back(size);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _used_size>=size){
			_used_size-=size;
			self_changed();
			return get<comn_string_data_t<char_T>>(string_view_t{(char_T*)_m.end()-_used_size-size,size});
		}
		else
			return base_t::do_pop_front(size,self);
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			auto aret=_to->do_pop_back(size,_to);
			_to_size-=size;
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_back(size,self);
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		push_and_disable_msvc_warning(26494);//未初始化警告diss
		hash_t result;
		pop_msvc_warning();
		if(_used_size){
			const char_T* head_begin=_m.end()-_used_size;
			result=hash(head_begin,_used_size);
			if(_to_size)
				result=hash.merge_array_hash_results(result,_used_size,_to->get_hash(_to),_to_size);
		}
		else
			result=_to->get_hash(_to);
		return result;
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,size_t pos,size_t size)noexcept(hash_nothrow)override final{
		if(pos<_used_size){
			const char_T* head_begin=_m.end()-_used_size;
			const char_T* head_end=_m.end();
			const char_T* calculate_begin=pos+head_begin;
			const size_t size_of_calculate_from_head=min(size_t(head_end-calculate_begin),size);

			before=hash.with_calculated_before(before,before_size,calculate_begin,size_of_calculate_from_head);
			if(size!=size_of_calculate_from_head){
				const size_t size_left=size-size_of_calculate_from_head;
				before_size+=size_of_calculate_from_head;
				before=_to->get_others_hash_with_calculated_before(before,before_size,_to,0,size_left);
			}
		}
		else
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos-_used_size,size);
		return before;
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp=down_cast<this_t*>(with.get());
		return _used_size==wp->_used_size;// && _to_size==wp->_to_size; //总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{
		if(begin >= _used_size)
			return _to->get_the_largest_complete_data_block_begin_form(begin-_used_size);
		else {
			const char_T* head_begin = _m.end() - _used_size;
			const char_T* head_end	 = _m.end();
			const char_T* ret_begin	 = begin+head_begin;
			return{ret_begin, head_end};
		}
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		const char_T* head_begin = _m.end() - _used_size;
		const char_T* wp_head_begin = wp->_m.end() - _used_size;
		return equal(head_begin,wp_head_begin,_used_size) && _to->equal_with_same_size(wp->_to);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		const char_T* head_begin = _m.end() - _used_size;
		const char_T* wp_head_begin = wp->_m.end() - _used_size;
		if(auto tmp=compare(head_begin,wp_head_begin,_used_size); tmp!=0)
			return tmp;
		return _to->compare_with_same_size(wp->_to);
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return _to->get_memory_cost()+float_size_of(*this)+_m.size_in_byte();
	}
public:
	[[nodiscard]]virtual ptr_t pre_alloc_before_begin(size_t size)noexcept override final{
		if(this->is_unique()){
			const auto size_new=_used_size+size;
			if(size_new>_m.size())
				_m.forward_resize(size_new);
			return this;
		}
		return base_t::pre_alloc_before_begin(size);
	}
};
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow){
	if(str.size())
		return get<head_apply_string_data_t<char_T>>(this,str);
	else
		return this;
}
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::pre_alloc_before_begin(size_t size)noexcept{
	if(size)
		return get<head_apply_string_data_t<char_T>>(this,pre_alloc,size);
	else
		return this;
}

//file_end

	#line 43 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/end_apply_string_data_t.hpp"
//end_apply_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/end_apply_string_data_t.hpp"
template<typename char_T>
struct end_apply_string_data_t final:base_string_data_t<char_T>,instance_struct<end_apply_string_data_t<char_T>>{
	typedef end_apply_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	array_t<char_T> _m;
	ptr_t _to;
	size_t _to_size;
	size_t _used_size;

	end_apply_string_data_t(ptr_t str,string_view_t end)noexcept(construct_nothrow&&copy_assign_nothrow):
		_to_size(str->get_size()),
		_used_size(end.size()),
		_to(str)
	{
		_m.resize(get_next_gold_size_to_resize_for_array(_to_size+_used_size));
		copy_assign[_used_size](note::from(end.begin()),note::to(_m.data()));
	}
	end_apply_string_data_t(ptr_t str,size_t count,char_T ch)noexcept:
		_to_size(str->get_size()),
		_used_size(count),
		_to(str)
	{
		_m.resize(get_next_gold_size_to_resize_for_array(_to_size+_used_size));
		copy_assign[_used_size](ch,note::to(_m.data()));
	}
	end_apply_string_data_t(ptr_t str,size_t count)noexcept:
		_to_size(str->get_size()),
		_used_size(count),
		_to(str)
	{
		_m.resize(get_next_gold_size_to_resize_for_array(_to_size+_used_size));
	}
	end_apply_string_data_t(ptr_t str,pre_alloc_t,size_t end_count)noexcept(construct_nothrow):
		_to_size(str->get_size()),
		_used_size(0),
		_to(str)
	{
		_m.resize(end_count);
	}

	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{
		if(begin+size<=_to_size)
			return _to->get_substr_data(begin,size);
		else
			return base_t::get_substr_data(begin,size);
	}
	[[nodiscard]]virtual string_ptr_t get_c_str(ptr_t&p)noexcept(get_data_nothrow)override final{
		if(!_used_size)
			return _to->get_c_str(_to);
		else
			return base_t::get_c_str(p);
	}
	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		if(type_info<this_t> == typeid(*a)){
			const auto p = down_cast<this_t*>(a.get());
			if(_used_size==p->_used_size && _to!=p->_to)
				base_t::equivalent_optimization(_to, p->_to);
		}
		_m.clear();
		_to.reset();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _used_size+_to_size; }
	[[nodiscard]]virtual ptr_t do_insert(size_t pos,string_view_t str)noexcept(copy_construct_nothrow)override final{
		if(pos==0)
			return this->apply_str_to_begin(str);
		elseif(pos==get_size())
			return this->apply_str_to_end(str);
		elseif(this->is_unique()){
			if(pos<_to_size){
				_to=_to->do_insert(pos-_used_size,str);
				_to_size=_to->get_size();
			}
			else{
				pos-=_to_size;
				if(_m.size()-_used_size>=str.size()){
					copy_assign[_used_size-pos](note::from<const char_T*>(&_m[pos]),note::to((char_T*)&_m[pos+str.size()]));
					copy_assign[str.size()](note::from<const char_T*>(str.begin()),note::to<char_T*>(&_m[pos]));
				}
				else{
					const auto size_now=this->get_size()+str.size();
					const auto size_new=get_next_gold_size_to_resize_for_array(size_now);
					_m.insert_with_resize(pos,str.size(),str.begin(),size_new);
				}
				_used_size+=str.size();
			}
			self_changed();
			return this;
		}
		else
			return base_t::do_insert(pos,str);
	}
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{
		if(pos+size<=_to_size)
			_to->copy_part_data_to(to,pos,size);
		else{
			if(pos<_to_size){
				_to->copy_part_data_to(to,pos,_to_size-pos);
				auto copied_size=_to_size-pos;
				pos=0;
				size-=copied_size;
				to+=copied_size;
			}
			else
				pos-=_to_size;
			copy_assign[size](note::from((const char_T*)_m+pos),note::to(to));
		}
	}
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{
		if(index<_to_size)
			return _to->arec(index);
		else
			return _m[index-_to_size];
	}
	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			if(index<_to_size)
				_to->arec_set(index,a,_to);
			else
				copy_assign(_m[index - _to_size],a);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}

	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			if(_m.size()-_used_size>=str.size())
				copy_assign[str.size()](note::from(str.begin()),note::to(_m.data()+_used_size));
			else{
				const auto size_now=this->get_size()+str.size();
				const auto size_new=get_next_gold_size_to_resize_for_array(size_now);
				_m.insert_with_resize(_used_size,str.size(),str.begin(),size_new);
			}
			_used_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow)override final{
		this->shrink();
		return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_begin(str);
			_to_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_begin(str);
			_to_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		#line 222 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/end_apply_string_data_t.hpp"
		if(this->is_unique() && size<_to_size){
			_to=_to->do_remove_front(size);
			_to_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_front(size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(size>=_used_size)
			return _to->do_remove_back(size-_used_size);
		if(this->is_unique()){//&& size<_used_size
			_used_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_back(size);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && size<_to_size){
			auto aret=_to->do_pop_front(size,_to);
			_to_size-=size;
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_front(size,self);
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _used_size>=size){
			_used_size-=size;
			self_changed();
			return get<comn_string_data_t<char_T>>(string_view_t{_m.data()+_used_size,size});
		}
		else
			return base_t::do_pop_back(size,self);
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		return hash.with_calculated_before(_to->get_hash(_to),_to_size,string_view_t(_m.begin(),_used_size));
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,size_t pos,size_t size)noexcept(hash_nothrow)override final{
		if(pos+size<=_to_size)
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos,size);
		else{
			if(pos<_to_size){
				before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos,_to_size-pos);
				const auto calculated_size=_to_size-pos;
				pos=0;
				size-=calculated_size;
				before_size+=calculated_size;
			}
			else
				pos-=_to_size;
			before=hash.with_calculated_before(before,before_size,(const char_T*)_m+pos,size);
		}
		return before;
	}
	void shrink()noexcept(_m.resize_nothrow){
		_m.resize(_used_size);
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp = down_cast<this_t*>(with.get());
		return _used_size==wp->_used_size;// && _to_size==wp->_to_size; //总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{
		if(begin < _to_size)
			return _to->get_the_largest_complete_data_block_begin_form(begin);
		else {
			begin-=_to_size;
			return{_m.begin()+begin,note::size(_used_size-begin)};
		}
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return _to->equal_with_same_size(wp->_to) && equal((char_T*)_m.begin(),(char_T*)wp->_m.begin(),_used_size);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		if(auto tmp=_to->compare_with_same_size(wp->_to); tmp!=0)
			return tmp;
		return compare((char_T*)_m.begin(),(char_T*)wp->_m.begin(),_used_size);
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return _to->get_memory_cost()+float_size_of(*this)+_m.size_in_byte();
	}
public:
	[[nodiscard]]virtual ptr_t pre_alloc_after_end(size_t size)noexcept override final{
		if(this->is_unique()){
			const auto size_new=_used_size+size;
			if(size_new>_m.size())
				_m.resize(size_new);
			return this;
		}
		return base_t::pre_alloc_after_end(size);
	}
};
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow){
	if(str.size())
		return get<end_apply_string_data_t<char_T>>(this,str);
	else
		return this;
}
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::pre_alloc_after_end(size_t size)noexcept{
	if(size)
		return get<end_apply_string_data_t<char_T>>(this,pre_alloc,size);
	else
		return this;
}

//file_end

	#line 44 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/sum_string_data_t.hpp"
//sum_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/sum_string_data_t.hpp"
template<typename char_T>
struct sum_string_data_t final:base_string_data_t<char_T>,instance_struct<sum_string_data_t<char_T>>{
	typedef sum_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	ptr_t  _before;
	ptr_t  _after;
	size_t _before_size;
	size_t _after_size;

	sum_string_data_t(ptr_t before,ptr_t after)noexcept:_before(before),_after(after),_before_size(_before->get_size()),_after_size(_after->get_size()){
		if(!_before_size)
			be_replace_as(_after);
		elseif(!_after_size)
			be_replace_as(_before);
	}

	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{
		if(begin+size<=_before_size)
			return _before->get_substr_data(begin,size);
		elseif(begin>=_before_size)
			return _after->get_substr_data(begin-_before_size,size);
		else
			return base_t::get_substr_data(begin,size);
	}
	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		if(type_info<this_t> == typeid(*a)){
			const auto p = down_cast<this_t*>(a.get());
			if(_before_size==p->_before_size){
				if(_before!=p->_before)
					base_t::equivalent_optimization(_before, p->_before);
				if(_after!=p->_after)
					base_t::equivalent_optimization(_after, p->_after);
			}
		}
		_before.reset();
		_after.reset();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _before_size+_after_size; }
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{
		if(pos<_before_size){
			const auto copy_before_begin=pos;
			const auto copy_before_end=min(pos+size,_before_size);
			const auto copy_before_size=copy_before_end-copy_before_begin;
			_before->copy_part_data_to(to,copy_before_begin,copy_before_size);
			if(size!=copy_before_size){
				const auto copy_after_size=size-copy_before_size;
				to+=copy_before_size;
				_after->copy_part_data_to(to,0,copy_after_size);
			}
		}
		else
			_after->copy_part_data_to(to,pos-_before_size,size);
	}
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{
		if(index<_before_size)
			return _before->arec(index);
		else
			return _after->arec(index-_before_size);
	}
	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			if(index<_before_size)
				_before->arec_set(index,a,_before);
			else
				_after->arec_set(index-_before_size,a,_after);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			_before=_before->apply_str_to_begin(str);
			_before_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			_before=_before->apply_str_to_begin(str);
			_before_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			_after=_after->apply_str_to_end(str);
			_after_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			_after=_after->apply_str_to_end(str);
			_after_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(_before_size==size)
			return _after;
		if(_before_size<size)
			return _after->do_remove_front(size-_before_size);
		if(this->is_unique()){
			_before=_before->do_remove_front(size);
			_before_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_front(size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(_after_size==size)
			return _before;
		if(_after_size<size)
			return _before->do_remove_back(size-_after_size);
		if(this->is_unique()){
			_after=_after->do_remove_back(size);
			_after_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_back(size);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _before_size>=size){
			ptr_t aret;
			if(_before_size==size)
				swap(aret,_before);
			else
				aret=_before->do_pop_front(size,_before);
			_before_size-=size;
			if(!_before_size)
				be_replace_as(_after);
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_front(size,self);
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _after_size>=size){
			ptr_t aret;
			if(_before_size==size)
				swap(aret,_after);
			else
				aret=_after->do_pop_back(size,_after);
			_after_size-=size;
			if(!_after_size)
				be_replace_as(_before);
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_back(size,self);
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		push_and_disable_msvc_warning(26494);//未初始化警告diss
		hash_t result;
		pop_msvc_warning();
		if(_before_size){
			result=_before->get_hash(_before);
			if(_after_size)
				result=hash.merge_array_hash_results(result,_before_size,_after->get_hash(_after),_after_size);
		}
		else
			result=_after->get_hash(_after);
		return result;
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,size_t pos,size_t size)noexcept(hash_nothrow)override final{
		if(pos<_before_size){
			const auto calculate_before_begin=pos;
			const auto calculate_before_end=min(pos+size,_before_size);
			const auto calculate_before_size=calculate_before_end-calculate_before_begin;
			before=_before->get_others_hash_with_calculated_before(before,before_size,_before,calculate_before_begin,calculate_before_size);
			if(size!=calculate_before_size){
				const auto calculate_after_size=size-calculate_before_size;
				before_size+=calculate_before_size;
				before=_after->get_others_hash_with_calculated_before(before,before_size,_after,0,calculate_after_size);
			}
		}
		else
			before=_after->get_others_hash_with_calculated_before(before,before_size,_after,pos-_before_size,size);
		return before;
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp=down_cast<this_t*>(with.get());
		return _before_size==wp->_before_size;//总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{
		if(begin < _before_size)
			return _before->get_the_largest_complete_data_block_begin_form(begin);
		else
			return _after->get_the_largest_complete_data_block_begin_form(begin - _before_size);
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return this->_before->equal_with_same_size(wp->_before) && this->_after->equal_with_same_size(wp->_after);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		if(auto tmp=this->_before->compare_with_same_size(wp->_before); tmp!=0)
			return tmp;
		return this->_after->compare_with_same_size(wp->_after);
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this)+_before->get_memory_cost()+_after->get_memory_cost();
	}
};
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow){
	return get<sum_string_data_t<char_T>>(this,str);
}
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow){
	return get<sum_string_data_t<char_T>>(str,this);
}

//file_end

	#line 46 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/erased_string_data_t.hpp"
//erased_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/erased_string_data_t.hpp"
template<typename char_T>
struct erased_string_data_t final:base_string_data_t<char_T>,instance_struct<erased_string_data_t<char_T>>{
	typedef erased_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	ptr_t  _to;
	size_t _to_size;
	size_t _erase_pos;
	size_t _erase_size;

	void null_equivalent_check()noexcept{
		if(_to_size==_erase_size || !_to_size)
			be_replace_as(null_ptr);
	}

	erased_string_data_t(ptr_t str,size_t erase_pos,size_t erase_size)noexcept:_to(str),_to_size(_to->get_size()),_erase_pos(erase_pos),_erase_size(erase_size){
		null_equivalent_check();
	}

	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{
		if(begin+size<_erase_pos)
			return _to->get_substr_data(begin,size);
		elseif(begin>=_erase_pos)
			return _to->get_substr_data(begin+_erase_size,size);
		else
			return base_t::get_substr_data(begin,size);
	}
	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final {
		if(type_info<this_t> == typeid(*a)){
			const auto p = down_cast<this_t*>(a.get());
			if(_erase_pos==p->_erase_pos && _erase_size==p->_erase_size && _to!=p->_to)
				base_t::equivalent_optimization(_to, p->_to);
		}
		_to.reset();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _to_size-_erase_size; }
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{
		if(pos+size<_erase_pos)
			_to->copy_part_data_to(to,pos,size);
		elseif(pos>=_erase_pos)
			_to->copy_part_data_to(to,pos+_erase_size,size);
		else{
			const auto size_before_erase_pos=_erase_pos-pos;
			const auto size_after_erase_pos=size-size_before_erase_pos;
			_to->copy_part_data_to(to,pos,size_before_erase_pos);
			_to->copy_part_data_to(to+size_before_erase_pos,_erase_pos+_erase_size,size_after_erase_pos);
		}
	}
public:
	[[nodiscard]]virtual ptr_t do_erase(size_t pos,size_t size)noexcept override final{
		if(this->is_unique()){
			if(pos<=_erase_pos && pos+size>=_erase_pos+_erase_size){
				_erase_pos=pos;
				_erase_size+=size;
				self_changed();
				return this;
			}
		}
		return base_t::do_erase(pos,size);
	}
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{
		if(index>=_erase_pos)
			return _to->arec(index+_erase_size);
		else
			return _to->arec(index);
	}

	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			if(index>=_erase_pos)
				_to->arec_set(index+_erase_size,a,_to);
			else
				_to->arec_set(index,a,_to);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_begin(str);
			const auto strsize=str.size();
			_to_size+=strsize;
			_erase_pos+=strsize;
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_begin(str);
			const auto strsize=str->get_size();
			_to_size+=strsize;
			_erase_pos+=strsize;
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_end(str);
			_to_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_end(str);
			_to_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(size>=_erase_pos)
			return _to->do_remove_front(size+_erase_size);
		if(this->is_unique()){//&& size<_erase_pos
			_to=_to->do_remove_front(size);
			_to_size-=size;
			_erase_pos-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_front(size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(size>=_to_size-_erase_pos-_erase_size)
			return _to->do_remove_back(size+_erase_size);
		if(this->is_unique()){//&& size<_to_size-_erase_pos-_erase_size
			_to=_to->do_remove_back(size);
			_to_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_back(size);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _erase_pos > size){
			auto aret=_to->do_pop_front(size,_to);
			_to_size-=size;
			_erase_pos-=size;
			null_equivalent_check();
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_front(size,self);
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _erase_pos+_erase_size <= _to_size-size){
			auto aret=_to->do_pop_back(size,_to);
			_to_size-=size;
			null_equivalent_check();
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_back(size,self);
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		auto result=hash(nothing);
		const auto size=get_size();
		const auto size_before_erase_pos=_erase_pos;
		const auto size_after_erase_pos=size-size_before_erase_pos;
		result=_to->get_others_hash_with_calculated_before(result,0,_to,0,size_before_erase_pos);
		result=_to->get_others_hash_with_calculated_before(result,size_before_erase_pos,_to,_erase_pos+_erase_size,size_after_erase_pos);
		return result;
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,size_t pos,size_t size)noexcept(hash_nothrow)override final{
		if(pos+size<_erase_pos)
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos,size);
		elseif(pos>=_erase_pos)
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos+_erase_size,size);
		else{
			const auto size_before_erase_pos=_erase_pos-pos;
			const auto size_after_erase_pos=size-size_before_erase_pos;
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos,size_before_erase_pos);
			before=_to->get_others_hash_with_calculated_before(before,before_size+size_before_erase_pos,_to,_erase_pos+_erase_size,size_after_erase_pos);
		}
		return before;
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp = down_cast<this_t*>(with.get());
		return _erase_pos == wp->_erase_pos && _erase_size == wp->_erase_size;
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{
		if(begin < _erase_pos){
			auto aret=_to->get_the_largest_complete_data_block_begin_form(begin);
			if(aret.size() > _erase_pos)
				aret = {aret.begin(),_erase_pos};
			return aret;
		}
		else
			return _to->get_the_largest_complete_data_block_begin_form(begin + _erase_size);
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return _to->equal_with(wp->_to,0,_erase_pos) && _to->equal_with(wp->_to,_erase_pos+_erase_size,_to_size);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		if(auto tmp=_to->compare_with(wp->_to,0,_erase_pos); tmp!=0)
			return tmp;
		return _to->compare_with(wp->_to,_erase_pos+_erase_size,_to_size);
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this)+_to->get_memory_cost();
	}
};
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::do_erase(size_t pos,size_t size)noexcept{
	if(size==get_size())
		return null_ptr;
	else
		return get<erased_string_data_t<char_T>>(this,pos,size);
}

//file_end

	#line 48 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/inserted_string_data_t.hpp"
//inserted_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/inserted_string_data_t.hpp"
template<typename char_T>
struct inserted_string_data_t final: base_string_data_t<char_T>,instance_struct<inserted_string_data_t<char_T>>{
	typedef inserted_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	ptr_t  _to;
	ptr_t  _insert_data;
	size_t _to_size;
	size_t _insert_pos;
	size_t _insert_size;

	inserted_string_data_t(ptr_t to,ptr_t insert_data,size_t insert_pos)noexcept:_to(to),_insert_data(insert_data),_insert_pos(insert_pos),_to_size(to->get_size()),_insert_size(insert_data->get_size()){}

	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{
		if(begin+size<_insert_pos)
			return _to->get_substr_data(begin,size);
		elseif(begin>_insert_pos+_insert_size)
			return _to->get_substr_data(begin-_insert_size,size);
		elseif(begin>=_insert_pos && begin+size<=_insert_pos+_insert_size)
			return _insert_data->get_substr_data(begin-_insert_pos,size);
		else
			return base_t::get_substr_data(begin,size);
	}
	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		if(type_info<this_t> == typeid(*a)){
			const auto p = down_cast<this_t*>(a.get());
			if(_insert_pos==p->_insert_pos && _insert_size==p->_insert_size){
				if(_to!=p->_to)
					base_t::equivalent_optimization(_to, p->_to);
				if(_insert_data!=p->_insert_data)
					base_t::equivalent_optimization(_insert_data, p->_insert_data);
			}
		}
		_to.reset();
		_insert_data.reset();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _to_size+_insert_size; }
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{
		if(pos+size<_insert_pos)
			_to->copy_part_data_to(to,pos,size);
		elseif(pos>_insert_pos+_insert_size)
			_to->copy_part_data_to(to,pos-_insert_size,size);
		else{
			if(_insert_pos>pos){
				auto size_before_insert_pos=_insert_pos-pos;
				_to->copy_part_data_to(to,pos,size_before_insert_pos);
				to+=size_before_insert_pos;
				size-=size_before_insert_pos;
			}
			auto size_before_insert_end=min(size,_insert_size);
			_insert_data->copy_part_data_to(to,0,size_before_insert_end);
			to+=size_before_insert_end;
			size-=size_before_insert_end;
			if(size)
				_to->copy_part_data_to(to,_insert_pos,size);
		}
	}
public:
	[[nodiscard]]virtual ptr_t do_insert(size_t pos,string_view_t str)noexcept(copy_construct_nothrow)override final{
		if(this->is_unique()){
			if(pos>=_insert_pos && pos<=_insert_pos+_insert_size){
				_insert_data=_insert_data->do_insert(pos-_insert_pos,str);
				_insert_size+=str.size();
			}
			elseif(pos<_insert_pos){
				_to=_to->do_insert(pos,str);
				_to_size+=str.size();
				_insert_pos+=str.size();
			}
			elseif(pos>_insert_pos+_insert_size){
				_to=_to->do_insert(pos-_insert_size,str);
				_to_size+=str.size();
			}
			self_changed();
			return this;
		}
		return base_t::do_insert(pos,str);
	}
	[[nodiscard]]virtual ptr_t do_erase(size_t pos,size_t size)noexcept override final{
		if(this->is_unique()){
			if(pos>=_insert_pos && pos+size<=_insert_pos+_insert_size){
				_insert_data=_insert_data->do_erase(pos-_insert_pos,size);
				_insert_size-=size;
				self_changed();
				return this;
			}
			elseif(pos+size<_insert_pos){
				_to=_to->do_erase(pos,size);
				_to_size-=size;
				_insert_pos-=size;
				self_changed();
				return this;
			}
			elseif(pos>_insert_pos+_insert_size){
				_to=_to->do_erase(pos-_insert_size,size);
				_to_size-=size;
				self_changed();
				return this;
			}
		}
		return base_t::do_erase(pos,size);
	}
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{
		if(index>=_insert_pos && index<_insert_pos+_insert_size)
			return _insert_data->arec(index-_insert_pos);
		elseif(index>=_insert_pos+_insert_size)
			return _to->arec(index-_insert_size);
		else
			return _to->arec(index);
	}

	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			if(index>=_insert_pos && index<_insert_pos+_insert_size)
				_insert_data->arec_set(index-_insert_pos,a,p);
			elseif(index>=_insert_pos+_insert_size)
				_to->arec_set(index-_insert_size,a,p);
			else
				_to->arec_set(index,a,p);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			const auto size=str.size();
			if(_insert_pos==0){
				_insert_data=_insert_data->apply_str_to_begin(str);
				_insert_size+=size;
			}
			else{
				_to=_to->apply_str_to_begin(str);
				_to_size+=str.size();
				_insert_pos+=size;
			}
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			const auto size=str->get_size();
			if(_insert_pos==0){
				_insert_data=_insert_data->apply_str_to_begin(str);
				_insert_size+=size;
			}
			else{
				_to=_to->apply_str_to_begin(str);
				_to_size+=str->get_size();
				_insert_pos+=size;
			}
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			if(_insert_pos==_to_size){
				_insert_data=_insert_data->apply_str_to_end(str);
				_insert_size+=str.size();
			}
			else{
				_to=_to->apply_str_to_end(str);
				_to_size+=str.size();
			}
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			if(_insert_pos==_to_size){
				_insert_data=_insert_data->apply_str_to_end(str);
				_insert_size+=str->get_size();
			}
			else{
				_to=_to->apply_str_to_end(str);
				_to_size+=str->get_size();
			}
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(size>=_insert_pos+_insert_size)
			return _to->do_remove_front(size-_insert_size);
		if(this->is_unique()){
			if(_insert_pos > size){
				_to=_to->do_remove_front(size);
				_to_size-=size;
				_insert_pos-=size;
				self_changed();
				return this;
			}
			elseif(_insert_pos==0 && _insert_size>=size){
				_insert_data=_insert_data->do_remove_front(size);
				_insert_size-=size;
				self_changed();
				return this;
			}
		}
		return base_t::do_remove_front(size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(size>=_to_size-_insert_pos)
			return _to->do_remove_back(size-_insert_pos);
		if(this->is_unique()){
			if(_insert_pos+_insert_size <= _to_size-size){
				_to=_to->do_remove_back(size);
				_to_size-=size;
				self_changed();
				return this;
			}
			elseif(_insert_pos==_to_size && _insert_size>=size){
				_insert_data=_insert_data->do_remove_front(size);
				_insert_size-=size;
				self_changed();
				return this;
			}
		}
		return base_t::do_remove_back(size);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			if(_insert_pos > size){
				auto aret=_to->do_pop_front(size,_to);
				_to_size-=size;
				_insert_pos-=size;
				self_changed();
				return aret;
			}
			elseif(_insert_pos==0 && _insert_size>=size){
				auto aret=_insert_data->do_pop_front(size,_insert_data);
				_insert_size-=size;
				self_changed();
				return aret;
			}
		}
		return base_t::do_pop_front(size,self);
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			if(_insert_pos+_insert_size <= _to_size-size){
				auto aret=_to->do_pop_back(size,_to);
				_to_size-=size;
				self_changed();
				return aret;
			}
			elseif(_insert_pos==_to_size && _insert_size>=size){
				auto aret=_insert_data->do_pop_front(size,_insert_data);
				_insert_size-=size;
				self_changed();
				return aret;
			}
		}
		return base_t::do_pop_back(size,self);
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		auto result=hash(nothing);
		if(_insert_pos)
			result=_to->get_others_hash_with_calculated_before(result,0,_to,0,_insert_pos);
		result=hash.merge_array_hash_results(result,_insert_pos,_insert_data->get_hash(_insert_data),_insert_size);
		const auto size=_to_size-_insert_pos;
		if(size)
			result=_to->get_others_hash_with_calculated_before(result,_insert_pos+_insert_size,_to,_insert_pos,size);
		return result;
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,size_t pos,size_t size)noexcept(hash_nothrow)override final{
		if(pos+size<_insert_pos)
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos,size);
		elseif(pos>_insert_pos+_insert_size)
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos-_insert_size,size);
		else{
			if(_insert_pos>pos){
				const auto size_before_insert_pos=_insert_pos-pos;
				before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos,size_before_insert_pos);
				size-=size_before_insert_pos;
				before_size+=size_before_insert_pos;
			}
			auto size_before_insert_end=min(size,_insert_size);
			before=_insert_data->get_others_hash_with_calculated_before(before,before_size,_insert_data,0,size_before_insert_end);
			size-=size_before_insert_end;
			before_size+=size_before_insert_end;
			if(size)
				before=_to->get_others_hash_with_calculated_before(before,before_size,_to,_insert_pos,size);
		}
		return before;
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp=down_cast<this_t*>(with.get());
		return _insert_pos==wp->_insert_pos && _insert_size==wp->_insert_size;//总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t index)noexcept override final{
		if(index>=_insert_pos && index<_insert_pos+_insert_size)
			return _insert_data->get_the_largest_complete_data_block_begin_form(index-_insert_pos);
		elseif(index>=_insert_pos+_insert_size)
			return _to->get_the_largest_complete_data_block_begin_form(index-_insert_size);
		else {
			auto aret=_to->get_the_largest_complete_data_block_begin_form(index);
			if(aret.size()+index > _insert_pos)
				aret = {aret.begin(), note::size(_insert_pos-index)};
			return aret;
		}
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return _insert_data->equal_with_same_size(wp->_insert_data) && _to->equal_with_same_size(wp->_to);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		if(auto tmp=_to->compare_with(wp->_to,0,_insert_pos); tmp!=0)
			return tmp;
		if(auto tmp=_insert_data->compare_with_same_size(wp->_insert_data); tmp!=0)
			return tmp;
		return _to->compare_with(wp->_to,_insert_pos,_to_size-(_insert_pos+_insert_size));
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this)+_insert_data->get_memory_cost()+_to->get_memory_cost();
	}
};
template<typename char_T>
base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::do_insert(size_t pos,ptr_t str)noexcept{
	return get<inserted_string_data_t<char_T>>(this,str,pos);
}
template<typename char_T>
base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::do_insert(size_t pos,string_view_t str)noexcept(copy_construct_nothrow){
	if(pos==0)
		return this->apply_str_to_begin(str);
	elseif(pos==get_size())
		return this->apply_str_to_end(str);
	else
		return this->do_insert(pos,get<comn_string_data_t<char_T>>(str));
}

//file_end

	#line 49 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	//#include "replaced_string_data_t.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/same_value_compress_string_data_t.hpp"
//sum_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/same_value_compress_string_data_t.hpp"
template<typename char_T>
struct same_value_compress_string_data_t final:base_string_data_t<char_T>,instance_struct<same_value_compress_string_data_t<char_T>>{
	typedef same_value_compress_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	size_t _size;
	char_T _value;
	ptr_t _static_data_p;//必要时创建一个较大的数组，用于向外提供数据
	static constexpr size_t max_static_data_size=size_t(pow(BIT_POSSIBILITY, 9));

	same_value_compress_string_data_t(size_t size,char_T value)noexcept:_size(size),_value(value){}
	same_value_compress_string_data_t(size_t size,char_T value,ptr_t static_data_p)noexcept:_size(size),_value(value),_static_data_p(static_data_p){}
	ptr_t get_clone_with_new_size(size_t new_size)noexcept{
		if(new_size==_size)return this;
		if(new_size==0)return nullptr;
		return get<same_value_compress_string_data_t<char_T>>(new_size,_value,_static_data_p);
	}

	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual ptr_t get_substr_data([[maybe_unused]]size_t begin,size_t size)noexcept override final{
		return get_clone_with_new_size(size);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _size; }
protected:
	virtual void copy_part_data_to(char_T* to,[[maybe_unused]]size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{
		copy_assign[size](_value,note::to(to));
	}
public:
	[[nodiscard]]virtual char_T arec([[maybe_unused]]size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{
		return _value;
	}
	void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		//小优化
		if(a==_value)return;
		if(_size==1){_value=a;_static_data_p.reset();return;}
		//若_size>max_static_data_size，将当前类型转换为sum_string_data_t
		if(_size>max_static_data_size){
			//中间一段为comn_string_data_t，大小为max_static_data_size
			ptr_t tmp=get<comn_string_data_t<char_T>>(max_static_data_size,_value);
			//尽量确保index在中间一段的中间
			const size_t index_in_tmp=min(index,max_static_data_size/2);
			//将中间一段的index处的值改为a
			tmp->arec_set(index_in_tmp,a,tmp);
			//判断是否需要附加其他段
			if(index>max_static_data_size/2){
				const size_t first_size=index-max_static_data_size/2;
				ptr_t first_p=get_clone_with_new_size(first_size);
				tmp=get<sum_string_data_t<char_T>>(first_p,tmp);
			}
			const size_t last_size=_size-tmp->get_size();
			if(last_size){
				ptr_t last_p=get_clone_with_new_size(last_size);
				tmp=get<sum_string_data_t<char_T>>(tmp,last_p);
			}
			p=tmp;
			return;
		}
		else
			base_t::arec_set(index,a,p);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			_size-=size;
			self_changed();
			return this;
		}
		else
			return get_clone_with_new_size(_size-size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			_size-=size;
			self_changed();
			return this;
		}
		else
			return get_clone_with_new_size(_size-size);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t&self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			_size-=size;
			self_changed();
			return get_clone_with_new_size(size);
		}
		else{
			auto aret=get_clone_with_new_size(size);
			self=get_clone_with_new_size(_size-size);
			return aret;
		}
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t&self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			_size-=size;
			self_changed();
			return get_clone_with_new_size(size);
		}
		else{
			auto aret=get_clone_with_new_size(size);
			self=get_clone_with_new_size(_size-size);
			return aret;
		}
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		return hash.repeat_times(_value,_size);
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,[[maybe_unused]]size_t pos,size_t size)noexcept(hash_nothrow)override final{
		return hash.merge_array_hash_results(before,before_size,hash.repeat_times(_value,size),size);
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp=down_cast<this_t*>(with.get());
		if(wp->_value==_value && wp->_static_data_p!=_static_data_p){
			if(_static_data_p)
				wp->_static_data_p.do_replace(_static_data_p);
			elseif(wp->_static_data_p)
				_static_data_p.do_replace(wp->_static_data_p);
		}
		return true;//总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form([[maybe_unused]]size_t begin)noexcept override final{
		if constexpr(construct<char_T>.trivial<const char_T&> && destruct.trivial<char_T>){
			if(!_static_data_p)
				_static_data_p=get<comn_string_data_t<char_T>>(max_static_data_size,_value);
			return{_static_data_p->get_data(_static_data_p),note::size(min(_size-begin,max_static_data_size))};
		}
		else
			return{&_value,note::size<size_t>(1)};
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return equal(_value,wp->_value);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return compare(_value,wp->_value);
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this)+_static_data_p->get_memory_cost();
	}
};

//file_end

	#line 53 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"
}

//file_end

	#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/defs.hpp"
	template<typename char_T>
	struct string_t{
		static_assert(type_info<char_T> != type_info<const char_T>);

		typedef base_string_data_t<char_T>			base_t_w;
		typedef base_t_w::ptr_t						ptr_t;
		typedef base_t_w::string_view_t				string_view_t;
		typedef base_t_w::string_ptr_t				string_ptr_t;
		typedef base_t_w::const_string_ptr_t		const_string_ptr_t;
		typedef const constexpr_str_t<char_T>		constexpr_str_t;
		typedef string_t<char_T>					this_t;
		typedef char_T								value_type;
		typedef value_type							char_type;
		typedef size_t								size_type;
		static constexpr size_t						npos = range_n::npos;

	private:
		//_cso_info用于存储不同cso情况下string所用到的数据
		mutable union _cso_info_t{
			ptr_t _mptr;
			const constexpr_str_t* _str;
			char_T _ch;

			push_and_disable_msvc_warning(26495);//未初始化警告diss
			force_inline constexpr _cso_info_t()noexcept{}
			constexpr _cso_info_t(const _cso_info_t&a)noexcept{
				copy_assign[sizeof(_cso_info_t)](cast_to_data(this),cast_to_data(&a));
			}
			pop_msvc_warning();
			force_inline constexpr void operator=(const _cso_info_t&a)noexcept{
				copy_assign[sizeof(_cso_info_t)](cast_to_data(this),cast_to_data(&a));
			}
			force_inline ~_cso_info_t()noexcept{}
		}_cso_info{};
		//_cso_flags用于标识不同的cso情况
		mutable struct _cso_flags_t{
			bool _cso_flag=0;
			bool _str_cso_flag=0;
		}_cso_flags;

		//非cso情况下的成员宏，表示一个指向string data的智能指针
		#define _m _cso_info._mptr

		//BLOCK: 对成员宏`_m`的生命周期手动管理的函数族

		//结束成员宏`_m`的生命周期
		force_inline constexpr void _ncso_destruct_mptr()const noexcept{destruct(&_m);}
		//开始成员宏`_m`的生命周期
		force_inline constexpr void _ncso_construct_mptr()const noexcept{construct<ptr_t>[&_m]();}
		//以特定初始值开始成员宏`_m`的生命周期
		force_inline constexpr void _ncso_construct_mptr(ptr_t p)const noexcept{construct<ptr_t>[&_m](p);}

		//END_BLOCK

		//BLOCK: cso情况判断函数族
		[[nodiscard]]force_inline bool _in_cso()const noexcept{return _cso_flags._cso_flag;}
		[[nodiscard]]force_inline bool _in_str_cso()const noexcept{return _in_cso() && _cso_flags._str_cso_flag;}
		[[nodiscard]]force_inline bool _in_chr_cso()const noexcept{return _in_cso() && !_cso_flags._str_cso_flag;}
		//END_BLOCK
		//BLOCK: cso情况设定函数族
		force_inline constexpr void _set_str_cso()const noexcept{_cso_flags._cso_flag=1;_cso_flags._str_cso_flag=1;}
		force_inline constexpr void _set_chr_cso()const noexcept{_cso_flags._cso_flag=1;_cso_flags._str_cso_flag=0;}
		force_inline constexpr void _set_not_cso()const noexcept{_cso_flags._cso_flag=0;}
		//END_BLOCK

		//BLOCK: cso情况下的信息获取函数族
		[[nodiscard]]force_inline const char_T* _get_cso_data()const noexcept{return _in_str_cso()?_cso_info._str->str():&_cso_info._ch;}
		[[nodiscard]]force_inline size_t _get_cso_size()const noexcept{return _in_str_cso()?_cso_info._str->size():1;}
		[[nodiscard]]force_inline hash_t _get_cso_hash()const noexcept{return _in_str_cso()?hash(_get_cso_constexpr_str()):hash(_cso_info._ch);}
		[[nodiscard]]force_inline constexpr_str_t& _get_cso_constexpr_str()const noexcept{return *_cso_info._str;}
		//END_BLOCK

		//BLOCK: cso情况管理函数族
		force_inline constexpr void _cso_init(constexpr_str_t&str)noexcept{_set_str_cso();_cso_info._str=&str;}
		force_inline constexpr void _cso_reinit(constexpr_str_t&str)noexcept{if(!_in_cso())_ncso_destruct_mptr();_cso_init(str);}
		force_inline constexpr void _cso_init(char_T ch)noexcept{_set_chr_cso();_cso_info._ch=ch;}
		force_inline constexpr void _cso_reinit(char_T ch)noexcept{if(!_in_cso())_ncso_destruct_mptr();_cso_init(ch);}
		force_inline void _cso_fin(bool need_write)const noexcept{
			if(_in_str_cso()&&!need_write)
				_ncso_construct_mptr(get<constexpr_string_data_t<char_T>>(*_cso_info._str));
			else{
				auto str=string_view_t{_get_cso_data(),_get_cso_size()};
				_ncso_construct_mptr(get<comn_string_data_t<char_T>>(str));
			}
			_set_not_cso();
		}
		force_inline void _cso_fin(ptr_t p)noexcept{
			_set_not_cso();
			_ncso_construct_mptr(p);
		}
		//END_BLOCK

		//BLOCK: 已知需要拷贝cso全部内容，判断是否值得结束cso的检查
		static force_inline constexpr bool the_size_worth_to_end_cso(size_t size)noexcept{
			constexpr auto max_size=max(sizeof(comn_string_data_t<char_T>)*2/sizeof(char_T),1u);
			return size>=max_size;
		}
		static force_inline void full_copy_cso_check(const string_t&str)noexcept{
			if(the_size_worth_to_end_cso(str.size()))
				str._cso_check();
		}
		//END_BLOCK

		//若cso，结束它
		force_inline void _cso_check(bool need_write=0)const noexcept{
			if(_in_cso())
				_cso_fin(need_write);
		}

		//便利用，内部使用的构造函数
		force_inline string_t(ptr_t str)noexcept{_ncso_construct_mptr(str);}
		//无论是否在cso中，都保证可以获得一个ptr
		[[nodiscard]]force_inline ptr_t ptr_copy()const noexcept{
			_cso_check();
			return _m;
		}
	public:
		//swap的内部实现
		void swap_with(this_t& a)noexcept{
			if(_in_cso()||a._in_cso()){
				swap(_cso_info,a._cso_info);
				swap(_cso_flags,a._cso_flags);
			}
			else
				swap(_m,a._m);
		}

		//BLOCK: 构造函数
		constexpr string_t()noexcept:string_t(empty_constexpr_str_of<char_T>){}
		constexpr string_t(constexpr_str_t&str)noexcept{_cso_init(str);}
		string_t(string_view_t str)noexcept{_ncso_construct_mptr(get<comn_string_data_t<char_T>>(str));}
		string_t(const_string_ptr_t str)noexcept:string_t(string_view_t(str)){}
		constexpr string_t(char_T ch)noexcept{_cso_init(ch);}
		string_t(const string_t& str)noexcept{
			if(str._in_cso()){
				_cso_info=str._cso_info;
				_cso_flags=str._cso_flags;
			}
			else
				_ncso_construct_mptr(str._m);
		}
		string_t(string_t&& str)noexcept:string_t(){
			swap_with(str);
		}
		string_t(size_t size,char_T ch)noexcept{_ncso_construct_mptr(get<same_value_compress_string_data_t<char_T>>(size,ch));}
		string_t(char_T ch,size_t size)noexcept requires(type_info<size_t>!=type_info<char_T>):string_t(size,ch){}

		string_t(size_t size)noexcept{_ncso_construct_mptr(get<comn_string_data_t<char_T>>(size));}
		//END_BLOCK
		//析构函数
		~string_t()noexcept{if(!_in_cso())_ncso_destruct_mptr();}

		//BLOCK: 赋值操作符
		string_t& operator=(const string_t& str)&noexcept{re_construct[this](str);return*this;}
		string_t& operator=(string_t&& str)&noexcept{swap_with(str);return*this;}
		constexpr string_t& operator=(constexpr_str_t&str)&noexcept{_cso_reinit(str);return*this;}
		constexpr string_t& operator=(char_T ch)&noexcept{_cso_reinit(ch);return*this;}
		//END_BLOCK

		//BLOCK: 字符串相加操作符
		[[nodiscard]]string_t operator+(const string_t& str)const noexcept{
			full_copy_cso_check(str);
			if(str._in_cso())
				return operator+(str.to_string_view_t());
			else
				return ptr_copy()->apply_str_to_end(str._m);
		}
		[[nodiscard]]string_t operator+(string_view_t str)const noexcept{
			return ptr_copy()->apply_str_to_end(str);
		}
		[[nodiscard]]string_t operator+(const_string_ptr_t str)const noexcept{
			return *this+string_view_t(str);
		}
		friend [[nodiscard]]string_t operator+(string_view_t str1,const string_t& str2)noexcept{
			return str2.ptr_copy()->apply_str_to_begin(str1);
		}
		friend [[nodiscard]]string_t operator+(const_string_ptr_t str1,const string_t& str2)noexcept{
			return string_view_t(str1)+str2;
		}
		friend [[nodiscard]]string_t operator+(char_T ch,const string_t& str)noexcept{
			return string_view_t{&ch,1}+str;
		}

		string_t& operator+=(const string_t&str)&noexcept{
			push_back(str);
			return *this;
		}
		string_t& operator+=(string_view_t str)&noexcept{
			push_back(str);
			return *this;
		}
		string_t& operator+=(const_string_ptr_t str)&noexcept{
			return *this+=string_view_t(str);
		}
		string_t& operator+=(char_T ch)&noexcept{
			return *this += string_view_t{&ch,1};
		}
		template<typename U>
		[[nodiscard]]string_t&& operator+(U&& b)&&noexcept_as(*this+=b) requires was_not_an_ill_form(*this+=b){		  //对右值的operator+优化为operator+=
			*this+=b;
			return move(*this);
		}
		//END_BLOCK

		//获取string占用的内存大小
		float_size_t memory_cost()const noexcept{
			if(_in_cso())
				return 0;
			else
				return _m->get_memory_cost();
		}
	public:
		//BLOCK: 比较运算符
		[[nodiscard]]constexpr auto operator<=>(const string_t& a)const noexcept(compare.nothrow<char_T>){
			if(a._in_str_cso())
				return operator<=>(a._get_cso_constexpr_str());
			elseif(a._in_cso())
				return operator<=>(a.to_string_view_t());
			if(!_in_cso())
				return _m->compare_with(a._m);
			elseif(_in_str_cso())
				return compare.reverse(a<=>_get_cso_constexpr_str());
			else
				return compare.reverse(a<=>to_string_view_t());
		}
		[[nodiscard]]constexpr auto operator==(const string_t& a)const noexcept(equal.nothrow<char_T>){
			if(a._in_str_cso())
				return operator==(a._get_cso_constexpr_str());
			elseif(a._in_cso())
				return operator==(a.to_string_view_t());
			if(!_in_cso())
				return _m->equal_with(a._m);
			elseif(_in_str_cso())
				return a==_get_cso_constexpr_str();
			else
				return a==to_string_view_t();
		}
		[[nodiscard]]constexpr auto operator<=>(string_view_t a)const noexcept(compare.nothrow<char_T>){
			if(_in_cso())
				return compare(data(),a.begin(),size());
			else
				return _m->compare_with(a);
		}
		[[nodiscard]]constexpr auto operator==(string_view_t a)const noexcept(equal.nothrow<char_T>){
			if(_in_cso())
				return equal(data(),a.begin(),size());
			else
				return _m->equal_with(a);
		}
		[[nodiscard]]constexpr auto operator<=>(constexpr_str_t&a)const noexcept(compare.nothrow<char_T>){
			if(_in_cso() && data()==a.str())//同起始优化
				return strong_ordering::equivalent;
			auto tmp=operator<=>((string_view_t&)a);
			if(tmp==0)
				remove_const(this)->_cso_reinit(a);
			return tmp;
		}
		[[nodiscard]]constexpr auto operator==(constexpr_str_t&a)const noexcept(equal.nothrow<char_T>){
			if(_in_cso() && data()==a.str())//同起始优化
				return true;
			const auto tmp=operator==((string_view_t&)a);
			if(tmp)
				remove_const(this)->_cso_reinit(a);
			return tmp;
		}
		[[nodiscard]]constexpr auto operator<=>(const_string_ptr_t a)const noexcept(compare.nothrow<char_T>){
			if(_in_cso())
				return compare(data(),size(),a,end_by_zero);
			else
				return _m->compare_with(a);
		}
		[[nodiscard]]constexpr auto operator==(const_string_ptr_t a)const noexcept(equal.nothrow<char_T>){
			if(_in_cso())
				return equal(data(),size(),a,end_by_zero);
			else
				return _m->equal_with(a);
		}
		//END_BLOCK
	private:
		[[nodiscard]]string_ptr_t unique_c_str()noexcept{ _cso_check(1);return _m->get_unique_c_str(_m); }
	public:
		[[nodiscard]]char_T	arec(size_t index)noexcept{
			if(_in_cso())
				return _get_cso_data()[index];
			else
				return _m->arec(index);
		}
		void	arec_set(size_t index,char_T a)noexcept{ _cso_check(1);return _m->arec_set(index,a,_m); }

		class arec_t: non_copyable,non_moveable{
			string_t* _to;
			size_t	  _index;

			friend class string_t;
		public:
			arec_t(string_t* to,size_t index)noexcept:_to(to),_index(index){}
			arec_t(special_init_t,const arec_t&ref)noexcept:_to(ref._to),_index(ref._index){}
			[[nodiscard]]operator char_T()const&&noexcept{ return _to->arec(_index); }
			arec_t&&	 operator=(char_T a)&&noexcept{
				_to->arec_set(_index,a);
				return move(*this);
			}
			arec_t&&	 operator=(const arec_t&&ch)&&noexcept{ return move(*this).operator=(move(ch).operator char_T()); }
		private:
			[[nodiscard]]char_T*		get_address()noexcept{ return _to->unique_c_str()+_index; }
			[[nodiscard]]const char_T*	get_address()const noexcept{ return (add_const(_to))->c_str()+_index; }
		public:
			[[nodiscard]]char_T*		operator&()&&noexcept{ return get_address(); }
			[[nodiscard]]const char_T*	operator&()const&&noexcept{ return get_address(); }
			#line 346 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/defs.hpp"
			template<class text_ostream_T> requires(type_info<text_ostream_T>.base_on<text_ostream_t<char_T>>)
			friend auto& operator<<(text_ostream_T& os,arec_t&& ch)noexcept(noexcept_text_ostream_class<text_ostream_T>){
				return os << move(ch).operator char_T();
			}
			template<class text_istream_T> requires(type_info<text_istream_T>.base_on<text_istream_t<char_T>>)
			friend auto& operator>>(text_istream_T& is,arec_t&& ch)noexcept(noexcept_text_istream_class<text_istream_T>){
				char_T ach;is >> ach;
				move(ch)=ach;
				return is;
			}
		};

		[[nodiscard]]arec_t		  operator[](size_t index)noexcept{ return{this,index}; }
		[[nodiscard]]const arec_t operator[](size_t index)const noexcept{ return{remove_const(this),index}; }

		//front
		[[nodiscard]]arec_t		  front()noexcept{ return{this,0}; }
		[[nodiscard]]const arec_t front()const noexcept{ return{remove_const(this),0}; }
		//back
		[[nodiscard]]arec_t		  back()noexcept{ return{this,size()-1}; }
		[[nodiscard]]const arec_t back()const noexcept{ return{remove_const(this),size()-1}; }


		[[nodiscard]]string_t operator+(const arec_t&& ch)const noexcept{
			return *this+move(ch).operator char_T();
		}
		string_t& operator+=(const arec_t&& ch)&noexcept{
			return *this+=move(ch).operator char_T();
		}

		//floating arec.
	private:
		static constexpr bool floating_arec_result_able=was_not_an_ill_form(
			math::linear_interpolation::get_result(declvalue(size_t),
				 math::linear_interpolation::get_k(declvalue(char_T),declvalue(char_T)),
														   declvalue(float_t))
		);
		static auto floating_arec_result_type_helper()noexcept{
			if constexpr(floating_arec_result_able)
				return math::linear_interpolation::get_result(size_t{},
					 math::linear_interpolation::get_k(char_T{},char_T{}),
															   float_t{});
		}
		typedef decltype(floating_arec_result_type_helper()) floating_arec_result_type;
		static constexpr bool floating_arec_set_able=was_not_an_ill_form(
			math::linear_interpolation::get_reverse_result(
				 math::linear_interpolation::get_k(declvalue(char_T),declvalue(char_T)),
														   declvalue(float_t),declvalue(char_T))
		);
	public:
		static constexpr bool floating_arec_able=floating_arec_result_able||floating_arec_set_able;
		class floating_arec_t: non_copyable,non_moveable{
			string_t* _to;
			float_t	  _index;
			size_t	  _index_x1;
			size_t	  _index_x2;

			friend class string_t;
		public:
			static constexpr bool result_able=floating_arec_result_able;
			static constexpr bool set_able=floating_arec_set_able;

			floating_arec_t(string_t* to,float_t index)noexcept:_to(to),_index(index){
				_index_x1=static_cast<size_t>(index);
				_index_x2=_index_x1+1;
			}
			floating_arec_t(special_init_t,const floating_arec_t&ref)noexcept:_to(ref._to),_index(ref._index){}
			[[nodiscard]]operator floating_arec_result_type()const&&noexcept requires result_able{
				char_T y1=_to->arec(_index_x1);
				char_T y2=_to->arec(_index_x2);
				auto δx=_index-_index_x1;
				return math::linear_interpolation::get_result(y1,
							math::linear_interpolation::get_k(y1,y2),
														   			  δx);
			}
			floating_arec_t&& operator=(floating_arec_result_type a)&&noexcept requires set_able{
				char_T y1=_to->arec(_index_x1);
				char_T y2=_to->arec(_index_x2);
				auto k=math::linear_interpolation::get_k(y1,y2);
				auto δx1=_index-_index_x1;
				auto δx2=_index-_index_x2;
				y1=(char_T)math::linear_interpolation::get_reverse_result(k,δx1,a);
				y2=(char_T)math::linear_interpolation::get_reverse_result(k,δx2,a);
				_to->arec_set(_index_x1,y1);
				_to->arec_set(_index_x2,y2);
				return move(*this);
			}
		};
		[[nodiscard]]floating_arec_t operator[](float_t index)noexcept requires floating_arec_able{ return{this,index}; }
		[[nodiscard]]const floating_arec_t operator[](float_t index)const noexcept requires floating_arec_able{ return{remove_const(this),index}; }

		//泛型arec.
		template<typename T> requires ::std::is_arithmetic_v<T>
		[[nodiscard]]auto operator[](T index)noexcept{
			if constexpr(::std::is_floating_point_v<T>)
				return operator[](static_cast<float_t>(index));
			else
				return operator[](static_cast<size_t>(index));
		}
		template<typename T> requires ::std::is_arithmetic_v<T>
		[[nodiscard]]const auto operator[](T index)const noexcept{
			if constexpr(::std::is_floating_point_v<T>)
				return operator[](static_cast<float_t>(index));
			else
				return operator[](static_cast<size_t>(index));
		}

		[[nodiscard]]string_t substr(size_t begin,size_t size=npos)const noexcept{
			size=min(size,this->size()-begin);
			if(size){
				_cso_check();
				return _m->get_substr_data(begin,size);
			}
			else
				return{};
		}
		[[nodiscard]]const char_T*	data()const noexcept{ if(_in_cso())return _get_cso_data();else return _m->get_data(_m); }
		[[nodiscard]]char_T* writeable_data()noexcept{ return unique_c_str(); }
		[[nodiscard]]const_string_ptr_t 	c_str()const noexcept{ if(_in_cso())return _get_cso_data();else return _m->get_const_c_str(_m); }
		[[nodiscard]]string_ptr_t writeable_c_str()noexcept{ return unique_c_str(); }
		[[nodiscard]]size_t			size()const noexcept{ if(_in_cso())return _get_cso_size();else return _m->get_size(); }
		[[nodiscard]]explicit operator bool()const noexcept{ return size(); }
		[[nodiscard]]bool			empty()const noexcept{ return !size(); }
		[[nodiscard]]size_t			length()const noexcept{ return size(); }
		void resize(size_t nsize,char_T ch)noexcept{
			const auto size=this->size();
			if(size > nsize)
				*this=substr(0,nsize);
			elseif(size == nsize)
				return;
			elseif(size){
				_cso_check();
				_m=get<end_apply_string_data_t<char_T>>(_m,nsize-size,ch);
			}
			else
				*this=string_t{nsize,ch};
		}
		void resize(size_t nsize)noexcept{
			const auto size=this->size();
			if(size > nsize)
				*this=substr(0,nsize);
			elseif(size == nsize)
				return;
			elseif(size){
				_cso_check();
				_m=get<end_apply_string_data_t<char_T>>(_m,nsize-size);
			}
			else
				*this=string_t{nsize};
		}
		void clear()noexcept{ re_construct(this); }
	private:
		struct iterator_base_t{
			string_t* _to;
			ptrdiff_t _index;		//rend: -1，使用size_t也不是不可以（标准允许无符号整数溢出），但是operator<=>会出问题

			[[nodiscard]]constexpr iterator_base_t	get_before()const noexcept{ return{_to,_index-1}; }
			[[nodiscard]]constexpr iterator_base_t	get_next()const noexcept{ return{_to,_index+1}; }
			[[nodiscard]]arec_t						get_value()noexcept{ return (*_to)[_index]; }
			[[nodiscard]]const arec_t				get_value()const noexcept{ return (*add_const(_to))[_index]; }
			[[nodiscard]]char_T*					get_handle()noexcept{ return &get_value(); }
			[[nodiscard]]const char_T*				get_handle()const noexcept{ return &get_value(); }
			[[nodiscard]]constexpr bool operator==(const iterator_base_t& a)const noexcept{ return _to==a._to && _index==a._index; }
			[[nodiscard]]constexpr auto operator<=>(const iterator_base_t& a)const noexcept{ return _to==a._to ? _index<=>a._index : partial_ordering::unordered; }
		};
		[[nodiscard]]iterator_base_t get_iterator_data_at(ptrdiff_t index)const noexcept{ return iterator_base_t{(string_t*)this,index}; }
	public:
		typedef iterator_t<char_T,iterator_base_t>				iterator;
		typedef const_iterator_t<char_T,const iterator_base_t>	const_iterator;

		[[nodiscard]]iterator		get_iterator_at(ptrdiff_t index)noexcept{ return get_iterator_data_at(index); }
		[[nodiscard]]const_iterator get_iterator_at(ptrdiff_t index)const noexcept{ return get_iterator_data_at(index); }
		[[nodiscard]]iterator		begin()noexcept{ return get_iterator_at(0); }
		[[nodiscard]]const_iterator begin()const noexcept{ return get_iterator_at(0); }
		[[nodiscard]]const_iterator cbegin()const noexcept{ return begin(); }
		[[nodiscard]]iterator		end()noexcept{ return get_iterator_at(size()); }
		[[nodiscard]]const_iterator end()const noexcept{ return get_iterator_at(size()); }
		[[nodiscard]]const_iterator cend()const noexcept{ return end(); }

		typedef reverse_iterator_t<char_T,iterator_base_t>				reverse_iterator;
		typedef reverse_const_iterator_t<char_T,const iterator_base_t>	reverse_const_iterator;

		[[nodiscard]]reverse_iterator		get_reverse_iterator_at(ptrdiff_t index)noexcept{ return get_iterator_data_at(index); }
		[[nodiscard]]reverse_const_iterator get_reverse_iterator_at(ptrdiff_t index)const noexcept{ return get_iterator_data_at(index); }
		[[nodiscard]]reverse_iterator		rbegin()noexcept{ return get_reverse_iterator_at(size()-1); }
		[[nodiscard]]reverse_const_iterator rbegin()const noexcept{ return get_reverse_iterator_at(size()-1); }
		[[nodiscard]]reverse_const_iterator rcbegin()const noexcept{ return rbegin(); }
		[[nodiscard]]reverse_iterator		rend()noexcept{ return get_reverse_iterator_at(-1); }
		[[nodiscard]]reverse_const_iterator rend()const noexcept{ return get_reverse_iterator_at(-1); }
		[[nodiscard]]reverse_const_iterator rcend()const noexcept{ return rend(); }

		//自迭代器构造string
		string_t(const_iterator begin,const_iterator end)noexcept{
			const auto& beg = begin.get_base();
			const auto& ed	= end.get_base();
			if(beg._to!=ed._to)return;
			_ncso_construct_mptr(beg._to->substr(beg._index, ed._index - beg._index)._m);
		}
		//

		void push_back(const string_t& str)&noexcept{
			full_copy_cso_check(*this);
			full_copy_cso_check(str);
			if(_in_cso()&&!str._in_cso())
				_cso_fin(str._m->apply_str_to_begin(to_string_view_t()));
			elseif(str._in_cso())
				push_back(str.to_string_view_t());
			else{
				_cso_check();
				_m=_m->apply_str_to_end(str._m);
			}
		}
		void push_back(string_view_t str)&noexcept{ _cso_check();_m=_m->apply_str_to_end(str); }
		void push_back(char_T ch)&noexcept{ push_back(string_view_t{&ch,1}); }
		void push_back(const arec_t&& ch)&noexcept{ push_back(move(ch).operator char_T()); }
		void push_back(const_string_ptr_t str)&noexcept{ push_back(string_view_t(str)); }
		//
		void push_back(char_T ch,size_t count)&noexcept{
			if(count==0)return;
			_cso_check();
			string_t str{ch,count};
			_m=_m->apply_str_to_end(str._m);
		}
		void push_back(const arec_t&& ch,size_t count)&noexcept{
			push_back(move(ch).operator char_T(),count);
		}

		void push_front(const string_t& str)&noexcept{
			full_copy_cso_check(*this);
			full_copy_cso_check(str);
			if(_in_cso()&&!str._in_cso())
				_cso_fin(str._m->apply_str_to_end(to_string_view_t()));
			elseif(str._in_cso())
				push_front(str.to_string_view_t());
			else{
				_cso_check();
				_m=_m->apply_str_to_begin(str._m);
			}
		}
		void push_front(string_view_t str)&noexcept{ _cso_check();_m=_m->apply_str_to_begin(str); }
		void push_front(char_T ch)&noexcept{ push_front(string_view_t{&ch,1}); }
		void push_front(const arec_t&& ch)&noexcept{ push_front(move(ch).operator char_T()); }
		void push_front(const_string_ptr_t str)&noexcept{ push_front(string_view_t(str)); }
		//
		void push_front(char_T ch,size_t count)&noexcept{
			if(count==0)return;
			_cso_check();
			string_t str{ch,count};
			_m=_m->apply_str_to_begin(str._m);
		}
		void push_front(const arec_t&& ch,size_t count)&noexcept{
			push_front(move(ch).operator char_T(),count);
		}

		void remove_back(size_t size=1)noexcept{ _cso_check();_m=_m->do_remove_back(size); }
		void remove_front(size_t size=1)noexcept{ _cso_check();_m=_m->do_remove_front(size); }
		#define pop_function_nodiscard nodiscard("if you don't want to use the return value, use remove_back() or remove_front() instead to avoid unnecessary cost")
		[[pop_function_nodiscard]]string_t pop_back(size_t size)noexcept{ _cso_check();return _m->do_pop_back(size,_m); }
		[[pop_function_nodiscard]]string_t pop_front(size_t size)noexcept{ _cso_check();return _m->do_pop_front(size,_m); }
		[[pop_function_nodiscard]]char_T pop_back()noexcept{ return pop_back(1)[0]; }
		[[pop_function_nodiscard]]char_T pop_front()noexcept{ return pop_front(1)[0]; }
		#undef pop_function_nodiscard

		//

		[[nodiscard]]operator string_view_t()const&noexcept{ return string_view_t{data(),size()}; }
		[[nodiscard]]auto to_string_view_t()const&noexcept{ return operator string_view_t(); }
		[[nodiscard]]auto view()&noexcept{ return array_like_view_t<char_T>{writeable_data(),size()}; }
		[[nodiscard]]auto view()const&noexcept{ return array_like_view_t<const char_T>{data(),size()}; }
		[[nodiscard]]explicit operator hash_t()const noexcept{ return _in_cso()?_get_cso_hash():_m->get_hash(_m); }

		//
		static constexpr bool find_nothrow=equal.nothrow<char_T>;
		[[nodiscard]]size_t find(const char_T ch)const noexcept(find_nothrow){
			if(_in_cso()){
				if(_in_str_cso())
					return in_range_size_t(ch,_get_cso_constexpr_str());
				else//if(_in_cso())
					return _cso_info._ch==ch?0:npos;
			}
			return in_range_size_t(ch, to_string_view_t());
		}
		[[nodiscard]]size_t find(const char_T ch,size_t begin)const noexcept(find_nothrow){
			return in_range_size_t(ch, to_string_view_t().substr(begin));
		}
		[[nodiscard]]size_t reverse_find(const char_T ch)const noexcept(find_nothrow){
			if(_in_cso()){
				if(_in_str_cso())
					return in_range_but_reverse_size_t(ch,_get_cso_constexpr_str());
				else//if(_in_cso())
					return _cso_info._ch==ch?0:npos;
			}
			return in_range_but_reverse_size_t(ch, to_string_view_t());
		}
		[[nodiscard]]size_t find(string_view_t str,size_t begin=0)const noexcept(find_nothrow){
			return in_range_size_t(str, to_string_view_t().substr(begin));
		}
		[[nodiscard]]size_t reverse_find(string_view_t str)const noexcept(find_nothrow){
			return in_range_but_reverse_size_t(str, to_string_view_t());
		}
		[[nodiscard]]size_t find(constexpr_str_t&str,size_t begin=0)const noexcept(find_nothrow){
			return in_range_size_t(str, to_string_view_t().substr(begin));
		}
		[[nodiscard]]size_t reverse_find(constexpr_str_t&str)const noexcept(find_nothrow){
			return in_range_but_reverse_size_t(str, to_string_view_t());
		}
		[[nodiscard]]size_t find(const string_t&str,size_t begin=0)const noexcept(find_nothrow){
			if(str._in_cso()){
				if(str._in_str_cso())
					return find(str._get_cso_constexpr_str(),begin);
				else//if(str._in_cso())
					return find(str._cso_info._ch,begin);
			}
			auto result = str._m->get_match_pattern_from_self(str._m).match(to_string_view_t().substr(begin));
			if(result)
				return result - data();
			else
				return npos;
		}
		[[nodiscard]]size_t reverse_find(const string_t&str)const noexcept(find_nothrow){
			if(str._in_cso()){
				if(str._in_str_cso())
					return reverse_find(str._get_cso_constexpr_str());
				elseif(str._in_cso())
					return reverse_find(str._cso_info._ch);
			}
			auto result = str._m->get_reverse_match_pattern_from_self(str._m).match(to_string_view_t());
			if(result)
				return result - data();
			else
				return npos;
		}
		//
		[[nodiscard]]size_t find_first_of(string_view_t str)const noexcept(find_nothrow){
			return range_n::find_first_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_first_of(constexpr_str_t&str)const noexcept(find_nothrow){
			return range_n::find_first_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_first_of(const string_t&str)const noexcept(find_nothrow){
			if(str._in_cso()){
				if(str._in_str_cso())
					return find_first_of(str._get_cso_constexpr_str());
				elseif(str._in_cso())
					return find(str._cso_info._ch);
			}
			return find_first_of(str.to_string_view_t());
		}
		[[nodiscard]]size_t find_first_of(const_string_ptr_t str)const noexcept(find_nothrow){
			return find_first_of(string_view_t(str));
		}
		[[nodiscard]]size_t find_first_of(char_T ch)const noexcept(find_nothrow){
			return find(ch);
		}
		[[nodiscard]]size_t find_first_of(const arec_t&&ch)const noexcept(find_nothrow){
			return find(move(ch).operator char_T());
		}
		[[nodiscard]]size_t find_first_not_of(string_view_t str)const noexcept(find_nothrow){
			return range_n::find_first_not_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_first_not_of(constexpr_str_t&str)const noexcept(find_nothrow){
			return range_n::find_first_not_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_first_not_of(const string_t&str)const noexcept(find_nothrow){
			if(str._in_cso()){
				if(str._in_str_cso())
					return find_first_not_of(str._get_cso_constexpr_str());
				elseif(str._in_cso())
					return find_first_not_of(str.to_string_view_t());
			}
			return find_first_not_of(str.to_string_view_t());
		}
		[[nodiscard]]size_t find_first_not_of(const_string_ptr_t str)const noexcept(find_nothrow){
			return find_first_not_of(string_view_t(str));
		}
		[[nodiscard]]size_t find_first_not_of(char_T ch)const noexcept(find_nothrow){
			return find_first_not_of(string_view_t(ch));
		}
		[[nodiscard]]size_t find_first_not_of(const arec_t&&ch)const noexcept(find_nothrow){
			return find_first_not_of(string_view_t(move(ch).operator char_T()));
		}
		[[nodiscard]]size_t find_last_of(string_view_t str)const noexcept(find_nothrow){
			return range_n::find_last_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_last_of(constexpr_str_t&str)const noexcept(find_nothrow){
			return range_n::find_last_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_last_of(const string_t&str)const noexcept(find_nothrow){
			if(str._in_cso()){
				if(str._in_str_cso())
					return find_last_of(str._get_cso_constexpr_str());
				elseif(str._in_cso())
					return reverse_find(str._cso_info._ch);
			}
			return find_last_of(str.to_string_view_t());
		}
		[[nodiscard]]size_t find_last_of(const_string_ptr_t str)const noexcept(find_nothrow){
			return find_last_of(string_view_t(str));
		}
		[[nodiscard]]size_t find_last_of(char_T ch)const noexcept(find_nothrow){
			return reverse_find(ch);
		}
		[[nodiscard]]size_t find_last_of(const arec_t&&ch)const noexcept(find_nothrow){
			return reverse_find(move(ch).operator char_T());
		}
		[[nodiscard]]size_t find_last_not_of(string_view_t str)const noexcept(find_nothrow){
			return range_n::find_last_not_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_last_not_of(constexpr_str_t&str)const noexcept(find_nothrow){
			return range_n::find_last_not_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_last_not_of(const string_t&str)const noexcept(find_nothrow){
			if(str._in_cso()){
				if(str._in_str_cso())
					return find_last_not_of(str._get_cso_constexpr_str());
				elseif(str._in_cso())
					return find_last_not_of(str.to_string_view_t());
			}
			return find_last_not_of(str.to_string_view_t());
		}
		[[nodiscard]]size_t find_last_not_of(const_string_ptr_t str)const noexcept(find_nothrow){
			return find_last_not_of(string_view_t(str));
		}
		[[nodiscard]]size_t find_last_not_of(char_T ch)const noexcept(find_nothrow){
			return find_last_not_of(string_view_t{&ch,1});
		}
		[[nodiscard]]size_t find_last_not_of(const arec_t&&ch)const noexcept(find_nothrow){
			return find_last_not_of(move(ch).operator char_T());
		}

		//

		[[nodiscard]]string_t arec(size_t index,char_T delimiter)const{
			auto pos=find(delimiter);
			auto end=find(delimiter,pos);
			while(index--){
				pos=end;
				end=find(delimiter,pos);
			}
			return substr(pos,end-pos);
		}
		[[nodiscard]]string_t arec(size_t index,string_view_t delimiter_str)const{
			auto pos=find(delimiter_str);
			auto end=find(delimiter_str,pos);
			while(index--){
				pos=end;
				end=find(delimiter_str,pos);
			}
			return substr(pos,end-pos);
		}
		[[nodiscard]]string_t arec(size_t index,const string_t&delimiter_str)const{
			auto pos=find(delimiter_str);
			auto end=find(delimiter_str,pos);
			while(index--){
				pos=end;
				end=find(delimiter_str,pos);
			}
			return substr(pos,end-pos);
		}
		[[nodiscard]]string_t arec(size_t index,constexpr_str_t&delimiter_str)const{
			auto pos=find(delimiter_str);
			auto end=find(delimiter_str,pos);
			while(index--){
				pos=end;
				end=find(delimiter_str,pos);
			}
			return substr(pos,end-pos);
		}

		//

		void erase(size_t pos,size_t size=1)&noexcept{
			_cso_check();_m=_m->do_erase(pos,size);
		}
		void insert(size_t pos,const string_t& str)&noexcept{
			_cso_check();
			full_copy_cso_check(str);
			if(str._in_cso())
				_m=_m->do_insert(pos,str.to_string_view_t());
			else
				_m=_m->do_insert(pos,str);
		}
		void insert(size_t pos,string_view_t str)&noexcept{
			_cso_check();_m=_m->do_insert(pos,str);
		}
		void insert(size_t pos,const_string_ptr_t str)&noexcept{
			insert(pos,string_view_t(str));
		}
		void insert(size_t pos,char_T ch)&noexcept{
			insert(pos,string_view_t{&ch,1});
		}

		//

		//contains
		constexpr bool contains(string_view_t str)const noexcept{
			return find(str) != npos;
		}
		constexpr bool contains(constexpr_str_t&str)const noexcept{
			return find(str) != npos;
		}
		constexpr bool contains(const string_t&str)const noexcept{
			return find(str) != npos;
		}
		constexpr bool contains(char_T ch)const noexcept{
			return find(ch) != npos;
		}
		constexpr bool contains(const_string_ptr_t str)const noexcept{
			return find(str) != npos;
		}

		//starts_with
		constexpr bool starts_with(string_view_t str)const noexcept{
			if(size()<str.size())
				return false;
			return substr(0,str.size()) == str;
		}
		constexpr bool starts_with(constexpr_str_t&str)const noexcept{
			if(size()<str.size())
				return false;
			return substr(0,str.size()) == str;
		}
		constexpr bool starts_with(const string_t&str)const noexcept{
			if(size()<str.size())
				return false;
			if(str._in_chr_cso())
				return starts_with(str._cso_info._ch);
			else
				return substr(0,str.size()) == str;
		}
		constexpr bool starts_with(char_T ch)const noexcept{
			if(size()<1)
				return false;
			return operator[](0) == ch;
		}
		constexpr bool starts_with(const_string_ptr_t str)const noexcept{
			return starts_with(string_view_t{str});
		}

		//ends_with
		constexpr bool ends_with(string_view_t str)const noexcept{
			if(size()<str.size())
				return false;
			return substr(size()-str.size()) == str;
		}
		constexpr bool ends_with(constexpr_str_t&str)const noexcept{
			if(size()<str.size())
				return false;
			return substr(size()-str.size()) == str;
		}
		constexpr bool ends_with(const string_t&str)const noexcept{
			if(size()<str.size())
				return false;
			if(str._in_chr_cso())
				return ends_with(str._cso_info._ch);
			else
				return substr(size()-str.size()) == str;
		}
		constexpr bool ends_with(char_T ch)const noexcept{
			if(size()<1)
				return false;
			return operator[](size()-1) == ch;
		}
		constexpr bool ends_with(char_T ch,size_t count)const noexcept{
			if(size() < count)
				return false;
			return find_last_not_of(ch) <= size()-count;
		}
		constexpr bool ends_with(const_string_ptr_t str)const noexcept{
			return ends_with(string_view_t{str});
		}

		this_t& append(size_t size,char_T ch)noexcept{
			return *this+=string_t{size,ch};
		}

		//pre_allocate
		void pre_alloc_before_begin(size_t size)noexcept{
			_cso_check();
			_m=_m->pre_alloc_before_begin(size);
		}
		void pre_alloc_after_end(size_t size)noexcept{
			_cso_check();
			_m=_m->pre_alloc_after_end(size);
		}

		#line 936 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/defs.hpp"
		//replace
		//TODO: 右值版replace
		this_t replace(size_t pos,size_t size,const string_t& str)const noexcept{
			return substr(0,pos)+str+substr(pos+size);
		}
		this_t replace(char_T ch,char_T ch2)const noexcept{
			this_t ret;
			size_t pos=0;
			floop{
				auto pos2=find(ch,pos);
				if(pos2==npos)
					break;
				ret+=substr(pos,pos2-pos)+ch2;
				pos=pos2+1;
			}
			ret+=substr(pos);
			return ret;
		}
		this_t replace(char_T ch,const string_t& str)const noexcept{
			this_t ret;
			size_t pos=0;
			floop{
				auto pos2=find(ch,pos);
				if(pos2==npos)
					break;
				ret+=substr(pos,pos2-pos)+str;
				pos=pos2+1;
			}
			ret+=substr(pos);
			return ret;
		}
		this_t replace(const string_t& str1,const string_t& str2)const noexcept{
			this_t ret;
			size_t pos=0;
			floop{
				auto pos2=find(str1,pos);
				if(pos2==npos)
					break;
				ret+=substr(pos,pos2-pos)+str2;
				pos=pos2+str1.size();
			}
			ret+=substr(pos);
			return ret;
		}

		//iostream
		template<class text_ostream_T> requires(type_info<text_ostream_T>.base_on<text_ostream_t<char_T>>)
		friend auto& operator<<(text_ostream_T& os,const string_t& str)noexcept(noexcept_text_ostream_class<text_ostream_T>){
			if(str._in_cso())
				os<<str.to_string_view_t();
			else{
				push_and_disable_msvc_warning(26447);//nothrow警告diss
				str._m->do_output(os);
				pop_msvc_warning();
			}
			return os;
		}
		template<class text_istream_T> requires(type_info<text_istream_T>.base_on<text_istream_t<char_T>>)
		friend auto& operator>>(text_istream_T& is,string_t& str)noexcept(noexcept_text_istream_class<text_istream_T>){
			str.clear();
			using namespace char_set;
			while(isspace(is.peek()))
				is.get();
			while(!is.is_end()&&!isspace(is.peek()))
				str+=is.get();
			return is;
		}
		template<class text_istream_T> requires(type_info<text_istream_T>.base_on<text_istream_t<char_T>>)
		friend auto& getline(text_istream_T& is,string_t& str)noexcept(noexcept_text_istream_class<text_istream_T>){
			str.clear();
			using namespace char_set;
			while(isspace(is.peek()))
				is.get();
			while(!is.is_end()&&is.peek()!='\r'&&is.peek()!='\n')
				str+=is.get();
			is>>endline;//处理结尾
			return is;
		}
		#undef _m
	};

	//推导指引
	template<class char_T>
	string_t(const char_T*) -> string_t<char_T>;
	template<class char_T>
	string_t(char_T*) -> string_t<char_T>;

	//string的swap特化
	template<typename T>
	inline void swap(string_t<T>& a,string_t<T>& b)noexcept{ a.swap_with(b); }

	//other iostream
	template<typename char_T,typename traits>
	inline auto& operator<<(::std::basic_ostream<char_T,traits>& os,const string_t<char_T>& str)noexcept{
		typedef ::std::basic_ostream<char_T,traits> stream_t;
		typedef stream_t::traits_type	 traits_t;
		typename stream_t::iostate		 state = stream_t::goodbit;

		size_t size = str.size();
		push_and_disable_msvc_warning(26494);//未初始化警告diss
		size_t pad;
		if(os.width() <= 0 || static_cast<size_t>(os.width()) <= size)
			pad = 0;
		else
			pad = static_cast<size_t>(os.width()) - size;
		pop_msvc_warning();

		const typename stream_t::sentry isok(os);

		if(!isok)
			state |= stream_t::badbit;
		else {
			try {
				if((os.flags() & stream_t::adjustfield) != stream_t::left){
					for(; 0 < pad; --pad){// pad on left
						if(traits_t::eq_int_type(traits_t::eof(), os.rdbuf()->sputc(os.fill()))){
							state |= stream_t::badbit;// insertion failed, quit
							break;
						}
					}
				}
				if(state == stream_t::goodbit){
					stream_n::std_ostream_wrap wrap(os);
					wrap<<str;
				}
				if(os.fail())
					state |= stream_t::badbit;
				else{
					for(; 0 < pad; --pad){// pad on right
						if(traits_t::eq_int_type(traits_t::eof(), os.rdbuf()->sputc(os.fill()))){
							state |= stream_t::badbit;// insertion failed, quit
							break;
						}
					}
				}
				os.width(0);
			}
			catch(...){
				os.setstate(stream_t::badbit, true);
				return os;
			}
		}
		os.setstate(state);
		return os;
	}
	template<typename char_T,typename traits>
	inline auto& operator>>(::std::basic_istream<char_T,traits>& is,string_t<char_T>& str)noexcept{
		stream_n::std_istream_wrap wrap{is};
		wrap>>str;
		return is;
	}

	//array like支持
	template<class T>
	[[nodiscard]]inline auto size_of_array_like(const string_t<remove_cv<T>>& a)noexcept{ return a.size(); }
	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(string_t<remove_cv<T>>& a)noexcept{ return a.c_str(); }
	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(const string_t<remove_cv<T>>& a)noexcept{ return a.c_str(); }

	//typedef
	typedef string_t<char_t>string;
}
using string_n::string_t;
using string_n::string;

//file_end

	#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
}
//strings
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/str_code_convert.hpp"
//str_code_convert.hpp
#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/str_code_convert.hpp"
#if !defined(ELC_APIS_str_code_convert)
	#define ELC_APIS_str_code_convert
	#include <cuchar>
	#include <clocale>
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
//default_data_type.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
namespace elc{
	/*ELC内部string统一采用char_t宽字符，使用setlocale(LC_ALL,"en_US.utf8")下的UTF编码。*/
	typedef char32_t char_t;
	/*c_string表示*/
	typedef char_t* string_ptr_t;
	/*c_string表示*/
	typedef const char_t* const_string_ptr_t;
	/*ELC内部钦定int_t类型*/
	typedef int64_t int_t;
	/*ELC内部钦定uint_t类型*/
	typedef uint64_t uint_t;
	/*ELC内部钦定float_t类型*/
	typedef double float_t;
	/*ELC内部钦定float_size_t类型，用以描述内存大小的浮点状况*/
	typedef long double float_size_t;
}

//file_end

	#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/str_code_convert.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
//string
//at namespace ::
/*@
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"

//file_end

	#line 40 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/str_code_convert.hpp"
	namespace elc::APIs::str_code_convert{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

		#line 42 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/str_code_convert.hpp"

		using namespace ::elc::defs;//get def

		[[nodiscard]]inline string_t<char> to_char_str(string_view_t<char_t> a)noexcept{
			string_t<char>aret;
			::std::mbstate_t stat{};
			push_and_disable_msvc_warning(26494)//未初始化警告diss
			char r[MB_LEN_MAX];
			ptrdiff_t s;
			pop_msvc_warning();
			for(auto c:a){
				s=::std::c32rtomb(r,c,&stat);
				if(s < 0)//-1
					die_with(locale::str::code_convert_error);
				aret+=string_view_t<char>{(char*)r,note::size((size_t)s)};
			}
			return aret;
		}
		[[nodiscard]]inline string_t<char_t> to_char_t_str(string_view_t<char> a)noexcept{
			string_t<char_t>aret;
			::std::mbstate_t stat{};
			push_and_disable_msvc_warning(26494);//未初始化警告diss
			char_t c;
			ptrdiff_t s;
			pop_msvc_warning();
			auto i=a.cbegin(),e=a.cend();
			while(i!=e){
				s=::std::mbrtoc32(&c,i,MB_LEN_MAX,&stat);
				if(s < 0)//-3 或 -1
					die_with(locale::str::code_convert_error);
				i+=s;
				aret+=c;
			}
			return aret;
		}

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

		#line 79 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/str_code_convert.hpp"
	}
	namespace elc::defs{
		using namespace elc::APIs::str_code_convert;
	}
#endif

//file_end

#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 43 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/literal.hpp"
//literal.hpp
//at namespace elc::defs
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/literal.hpp"
namespace string_n{
	template<constexpr_str_n::constexpr_str_t_literal_helper str_helper>
	inline constexpr string operator""_elc_string()noexcept{
		return string(constexpr_str_n::operator""_constexpr_str<str_helper>());
	}
}
using string_n::operator""_elc_string;

//file_end

	#line 45 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"

	#if defined(ELC_TEST_ON)
	namespace string_part_test{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_test.hpp"
//_test.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_test.hpp"
inline void test(){
	ELC_TEST_EVENTNAME("string部分测试");
	{
		{
			string_t a=es"";
			stest_accert(a.size()==0);
			a=es"asd";
			stest_accert(a.size()==3);
			a=es"asd"+a;
			stest_accert(a.size()==6);
			a+=es"asd";
			stest_accert(es"asd"+a==es"asdasdasdasd");
			a[1]=ec('e');
			stest_accert(a.substr(0,3)==es"aed");
			stest_accert(a.substr(3).size()==6);
			stest_accert(a[2]==ec('d'));
			a.clear();
			stest_accert(a.size()==0);
			a.resize(3,ec('d'));
			stest_accert(a==es"ddd");
			for(const char_t&c:a)
				stest_accert(c==ec('d'));
			a=es"abc";
			stest_accert(a.begin()==a.cbegin());
			stest_accert(*a.begin()==ec('a'));
			stest_accert(a.begin()<=a.cend());
			stest_accert(*a.rbegin()==ec('c'));
			stest_accert(a.rbegin()<=a.rend());
			stest_accert(a.rbegin()==a.end()-1);
			a.push_back(es"as");
			a.push_front(ec('p'));
			stest_accert(a == es"pabcas");
			a.erase(1,3);
			a.erase(1);
			stest_accert(a == es"ps");
			stest_accert(a.pop_front() == ec('p'));
			stest_accert(a.pop_back() == ec('s'));
			stest_accert(a.size() == 0);
			a=es"abc";
			stest_accert(a.pop_back(2) == es"bc");
			stest_accert(a.size() == 1);
			a.push_front(es"wqer");
			stest_accert(a==es"wqera");
			a.insert(2,es"123");
			a.insert(0,es"123");
			a.insert(a.size(),es"123");
			stest_accert(a[2] == ec('3'));
			a[5]=ec('6');
			a[6]=ec('6');
			a[7]=ec('6');
			a[8]=ec('6');
			stest_accert(a == es"123wq6666ra123");
			for(char_t& c: a.view())
				c ='7';
			stest_accert(a == es"77777777777777");
		}
		{
			using namespace elc;
			using elc::defs::hash;
			auto a = es"ab"_elc_string;//constexpr_string_data_t
			stest_accert(hash(a) == hash(string_view(es"ab")));
			string b = es"ab";//comn_string_data_t
			stest_accert(hash(b) == hash(string_view(es"ab")));
			stest_accert(b.memory_cost() > a.memory_cost());
			a += b;//sum_string_data_t -> constexpr_string_data_t
				   //				   -> comn_string_data_t
			stest_accert(hash(a) == hash(string_view(es"abab")));
			a.insert(1, 'c');//inserted_string_data_t -> sum_string_data_t
			stest_accert(hash(a) == hash(string_view(es"acbab")));
			a.erase(2, 3);//erased_string_data_t -> inserted_string_data_t
			stest_accert(hash(a) == hash(string_view(es"ac")));
			a.push_back(es"123");//end_apply_string_data_t -> erased_string_data_t
			stest_accert(hash(a) == hash(string_view(es"ac123")));
			a.push_front(es"123");//head_apply_string_data_t -> end_apply_string_data_t
			stest_accert(hash(a) == hash(string_view(es"123ac123")));
		}
	}
	check_memory_lack();
}
inline void test_log_out(){
}
inline void test_end(){
}

//file_end

		#line 49 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
	}
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 53 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
}
namespace elc{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_export.hpp"
//_export.hpp
//at namespace elc
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_export.hpp"
#define export using defs::
export string_t;
export string;
export string_view_t;
export string_view;
export operator""_elc_string;
export operator""_constexpr_str;
#undef export

//file_end

	#line 56 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
}
#if defined(ELC_BASE_STREAM)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"
//type_name_test_output.hpp
//at namespace ::
//multi when ELC_STRING & ELC_BASE_STREAM
#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"
#if !defined(ELC_multi_type_name_test_output)//pls skip define check as this part is muti
#define ELC_multi_type_name_test_output
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"

	namespace stream_n{
		//typename output only for text_ostream_t<char_t>
		template<text_ostream stream_T>
		decltype(auto)operator<<(stream_T&&stream,const type_name_t&name)noexcept(noexcept_text_ostream<stream_T>){
			return stream << to_char_t_str(name);
		}
		//output type_info
		template<text_ostream stream_T>
		decltype(auto)operator<<(stream_T&&stream,const base_type_info_t&info)noexcept(noexcept_text_ostream<stream_T>){
			return stream << info.get_name();
		}
		//output ::std::type_info
		template<text_ostream stream_T>
		decltype(auto)operator<<(stream_T&&stream,const ::std::type_info&info)noexcept(noexcept_text_ostream<stream_T>){
			return stream << type_name_t{info.name()};
		}
	}

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 55 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"
}
#endif

//file_end

	#line 59 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
#endif
#if defined(ELC_CORE)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"
//string_arec_as_value.hpp
//at namespace ::
//multi when ELC_STRING & ELC_CORE
#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"
#if !defined(ELC_multi_string_arec_as_value)//pls skip define check as this part is muti
#define ELC_multi_string_arec_as_value
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"

	namespace string_n{
		template<class char_T>
		value arec_as_value(string_t<char_T>&str,const value index){
			size_t i=size_t(use_as<int_t>(index));
			if(!i)
				i=size_t(use_as<uint_t>(index));
			struct arec_data_t final:instance_struct<arec_data_t>
			,value::base_data_t{
				typename string_t<char_T>::arec_t _m;
				arec_data_t(string_t<char_T>&str,size_t index)noexcept:_m(&str,index){};
				arec_data_t(const arec_data_t&ref)noexcept:_m(special_init,ref._m){}
				virtual ~arec_data_t()noexcept override final=default;

				virtual void be_set(ptr a)noexcept override final{move(_m)=use_as<char_T>(a);}
				[[nodiscard]]virtual ptr get_value()noexcept override final{return core::make_binary_node_from<char_T>(move(_m));}
				[[nodiscard]]virtual base_data_t*copy()const noexcept override final{return get<arec_data_t>(*this);}
				[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<arec_data_t>;}
			};
			return get<arec_data_t>(str,i);
		}
	}

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 59 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"
}
#endif

//file_end

	#line 62 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
#endif

//file_end

	#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
#endif

//file_end

	#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/namespace"
	#define ELC_NAMESPACE
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_body.hpp"
//_body.hpp
//at namespace ::
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_body.hpp"
#if defined(ELC_TEST)
	#error "this part cannot be tested."
#endif
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic push
	#pragma GCC diagnostic warning "-Wall"//开启所有警告
	#pragma GCC diagnostic ignored "-Wmissing-template-keyword"//忽略模板警告
#endif
#if defined(_MSC_VER)
	//#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__)) //不再使用因为其不确定的作用域
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	//#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER>=1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/defs.hpp"
//defs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/defs.hpp"
namespace core{
	template<>
	distinctive inline map_t<ptr,string> long_term_binary_node_storager<string>{};
}
namespace namespace_n{
	distinctive inline struct namespace_t{
		ptr _namespace_root;
		weak_ptr _namespace_now;
		value get_symbol_type_map(ptr thenamespace){
			return (*thenamespace)[es".symbol_type_map"];
		}
		namespace_t()noexcept{
			_namespace_root = get<common_node>();
			auto&nmsp		= *_namespace_root;
			_namespace_now  = &nmsp;
			push_and_disable_msvc_warning(26447);//may throw警告diss
			nmsp[es".."]	 = the_void;
			nmsp[es"."]		 = nmsp;
			nmsp[es"t"]		 = t;
			nmsp[es"nil"]	 = nil;
			nmsp[es"void"]	 = the_void;
			value nmsptm	 = get_symbol_type_map(&nmsp);
			nmsptm			 = get<common_node>();
			nmsptm[es"void"] = es"void";
			pop_msvc_warning();
		}
		ptr get_symbol_namespace(const value index){
			ptr namespace_now_p = _namespace_now;
			while(namespace_now_p && !(*namespace_now_p)[index] && !get_symbol_type_map(namespace_now_p)[index])
				namespace_now_p = (*namespace_now_p)[es".."];
			return namespace_now_p;
		}
		ptr get_symbol_namespace(auto&& index){ return get_symbol_namespace(as_value(index)); }
		bool has_symbol(const value index){
			auto nmsp=get_symbol_namespace(index);
			if((*nmsp)[index] || get_symbol_type_map(nmsp)[index])
				return true;
			return false;
		}
		bool has_symbol(auto&& index){ return has_symbol(as_value(index)); }
		value get_symbol(const value index){
			return (*get_symbol_namespace(index))[index];
		}
		value get_symbol(auto&& index){ return get_symbol(as_value(index)); }
		value get_symbol_type(const value index){
			return get_symbol_type_map(get_symbol_namespace(index))[index];
		}
		value get_symbol_type(auto&& index){ return get_symbol_type(as_value(index)); }

		void inter_namespace(const value namespace_name){
			_namespace_now = get_symbol(namespace_name);
		}
		void inter_namespace(auto&& index){ inter_namespace(as_value(index)); }

		void leave_namespace(){ inter_namespace(es".."); }
	}names{};
}

//file_end

	#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_body.hpp"

	#if defined(ELC_TEST_ON)
	namespace namespace_part_test{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_test.hpp"
//_test.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_test.hpp"
inline void test(){
	ELC_TEST_EVENTNAME("namespace部分测试");
}
inline void test_log_out(){
}
inline void test_end{
}

//file_end

		#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_body.hpp"
	}
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
//#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(__GNUC__)
	#pragma GCC diagnostic pop
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 45 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_body.hpp"
}
namespace elc{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_export.hpp"
//_export.hpp
//at namespace elc
#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_export.hpp"
#define export using defs::
export namespace_n::names;
#undef export

//file_end

	#line 48 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_body.hpp"
}

//file_end

	#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/namespace"
#endif

//file_end

