#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/namespace"
//namespace
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/namespace"
#if !defined(ELC_NAMESPACE)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/core"
//core
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/core"
#if !defined(ELC_CORE)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
//base
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
#if !defined(ELC_BASE)
	//原base的一小部分，但由于过于底层，底层到API定义都需要使用。。
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
//base_defs
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#if !defined(ELC_BASE_DEFS)
	#define __builtin_is_my_dick_still_there() true
	#include <cstddef>//nullptr_t
	#include <cstdlib>//exit、size_t
	#include <new>//operator delete、launder
	#include <algorithm>//max、min
	#include <type_traits>//enable_if等
	#include <typeinfo>//RTTI
	#include <cmath>//sqrt
	#include <cfenv>//rounding
	#include <ctime>//time
	#include <ranges>
	#define ELC_BASE_DEFS
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
//_body.hpp
//at namespace ::
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//include default_data_type：基础数据类型定义
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
//default_data_type.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace elc{
	/*ELC内部string统一采用char_t宽字符，使用setlocale(LC_ALL,"en_US.utf8")下的UTF编码。*/
	typedef char32_t char_t;
	/*c_string表示*/
	typedef char_t* string_ptr_t;
	/*c_string表示*/
	typedef const char_t* const_string_ptr_t;
	/*ELC内部钦定int_t类型*/
	typedef int64_t int_t;
	/*ELC内部钦定uint_t类型*/
	typedef uint64_t uint_t;
	/*ELC内部钦定float_t类型*/
	typedef double float_t;
	/*ELC内部钦定float_size_t类型，用以描述内存大小的浮点状况*/
	typedef long double float_size_t;
}

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
//_body.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#if !defined(ELC_WARNING_LEVEL)
	#define ELC_WARNING_LEVEL 4
#endif

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

	#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"

	namespace basic_environment{
		/// 每个bit（不是字节）的可能性
		/// 为什么c艹委员会不定义这个？
		constexpr size_t BIT_POSSIBILITY=2;
		/*! 给定大小的无符号整数类型 */
		template<size_t size>
		using unsigned_specific_size_t=decltype(lambda(){
			#define TYPE_MAPPER(type) if constexpr(size == sizeof(type))return (type)0;else
			#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
//unsigned_mapper.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
TYPE_MAPPER(uint8_t)
TYPE_MAPPER(uint16_t)
TYPE_MAPPER(uint32_t)
TYPE_MAPPER(uint64_t)
TYPE_MAPPER(uintmax_t)
TYPE_MAPPER(size_t)
TYPE_MAPPER(unsigned char)
TYPE_MAPPER(unsigned short)
TYPE_MAPPER(unsigned int)
TYPE_MAPPER(unsigned long)
TYPE_MAPPER(unsigned long long)

//file_end

			#line 19 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
			#undef TYPE_MAPPER
			{}
		}());
		//这里的定义不能使用basedefs中的type_info，所以得重新造一个小轮子
		struct type_uniquer_t{
			constexpr bool operator==(const type_uniquer_t&other)const noexcept{return this==&other;}
		};
		template<class T>
		inline constexpr type_uniquer_t type_uniquer{};
		//任意类型转算数类型
		inline constexpr struct to_arithmetic_t{
			template<class T,class type>
			//由于::std::is_convertible_v的歧义性质，使用requires表达式辅助推断type是否为实际支持的类型
			//由于requires表达式的强制性质，使用::std::is_convertible_v辅助推断隐式转换是否可行
			static inline constexpr bool is_convertible=std::is_convertible_v<T,type> && requires{declvalue(T).operator type();};
			template<class T>
			static inline constexpr bool r_able_helper()noexcept{
				#define TYPE_MAPPER(type) if constexpr(is_convertible<T,type>)return true;else
				#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
//float_mapper.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
//float_mapper.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
TYPE_MAPPER(float)
TYPE_MAPPER(double)
TYPE_MAPPER(long double)

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
//signed_mapper.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
TYPE_MAPPER(int8_t)
TYPE_MAPPER(int16_t)
TYPE_MAPPER(int32_t)
TYPE_MAPPER(int64_t)
TYPE_MAPPER(intmax_t)
TYPE_MAPPER(ptrdiff_t)
TYPE_MAPPER(char)
TYPE_MAPPER(short)
TYPE_MAPPER(int)
TYPE_MAPPER(long)
TYPE_MAPPER(long long)

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
//unsigned_mapper.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
TYPE_MAPPER(uint8_t)
TYPE_MAPPER(uint16_t)
TYPE_MAPPER(uint32_t)
TYPE_MAPPER(uint64_t)
TYPE_MAPPER(uintmax_t)
TYPE_MAPPER(size_t)
TYPE_MAPPER(unsigned char)
TYPE_MAPPER(unsigned short)
TYPE_MAPPER(unsigned int)
TYPE_MAPPER(unsigned long)
TYPE_MAPPER(unsigned long long)

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"

//file_end

				#line 38 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
				#undef TYPE_MAPPER
				return false;
			}
			template<class T>
			static force_inline constexpr auto to_arithmetic_base(T&&v)noexcept{
				#define TYPE_MAPPER(type) if constexpr(r_able_helper<T>()&&is_convertible<T,type>)return (type)v;else
				#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
//float_mapper.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
//float_mapper.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
TYPE_MAPPER(float)
TYPE_MAPPER(double)
TYPE_MAPPER(long double)

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
//signed_mapper.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
TYPE_MAPPER(int8_t)
TYPE_MAPPER(int16_t)
TYPE_MAPPER(int32_t)
TYPE_MAPPER(int64_t)
TYPE_MAPPER(intmax_t)
TYPE_MAPPER(ptrdiff_t)
TYPE_MAPPER(char)
TYPE_MAPPER(short)
TYPE_MAPPER(int)
TYPE_MAPPER(long)
TYPE_MAPPER(long long)

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
//unsigned_mapper.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
TYPE_MAPPER(uint8_t)
TYPE_MAPPER(uint16_t)
TYPE_MAPPER(uint32_t)
TYPE_MAPPER(uint64_t)
TYPE_MAPPER(uintmax_t)
TYPE_MAPPER(size_t)
TYPE_MAPPER(unsigned char)
TYPE_MAPPER(unsigned short)
TYPE_MAPPER(unsigned int)
TYPE_MAPPER(unsigned long)
TYPE_MAPPER(unsigned long long)

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"

//file_end

				#line 45 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
				#undef TYPE_MAPPER
				{}
			}
			template<class T>
			static inline constexpr size_t get_arithmetic_muti_convertible_count()noexcept{
				typedef decltype(to_arithmetic_base(declvalue(T))) my_type;
				push_and_disable_msvc_warning(26496);//未初始化警告diss
				size_t muti_convertible_count=0;
				pop_msvc_warning();
				#define TYPE_MAPPER(type) \
				if constexpr(type_uniquer<my_type>!=type_uniquer<type> && is_convertible<T,type>)\
					muti_convertible_count++;
				#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
//float_mapper.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/float_mapper.hpp"
//float_mapper.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
TYPE_MAPPER(float)
TYPE_MAPPER(double)
TYPE_MAPPER(long double)

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/signed_mapper.hpp"
//signed_mapper.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
TYPE_MAPPER(int8_t)
TYPE_MAPPER(int16_t)
TYPE_MAPPER(int32_t)
TYPE_MAPPER(int64_t)
TYPE_MAPPER(intmax_t)
TYPE_MAPPER(ptrdiff_t)
TYPE_MAPPER(char)
TYPE_MAPPER(short)
TYPE_MAPPER(int)
TYPE_MAPPER(long)
TYPE_MAPPER(long long)

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/unsigned_mapper.hpp"
//unsigned_mapper.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
TYPE_MAPPER(uint8_t)
TYPE_MAPPER(uint16_t)
TYPE_MAPPER(uint32_t)
TYPE_MAPPER(uint64_t)
TYPE_MAPPER(uintmax_t)
TYPE_MAPPER(size_t)
TYPE_MAPPER(unsigned char)
TYPE_MAPPER(unsigned short)
TYPE_MAPPER(unsigned int)
TYPE_MAPPER(unsigned long)
TYPE_MAPPER(unsigned long long)

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/arithmetic_mapper/all_mapper.hpp"

//file_end

				#line 58 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
				#undef TYPE_MAPPER
				return muti_convertible_count;
			}
			template<class T>
			static inline constexpr bool convertible_unique_helper()noexcept{
				return get_arithmetic_muti_convertible_count<T>()==0;
			}
			template<class T>
			static inline constexpr bool able_helper()noexcept{
				if constexpr(r_able_helper<T>())
					return convertible_unique_helper<T>();
				else
					return false;
			}
			template<class T>
			static inline constexpr bool able = able_helper<T>();
			//nothrow
			template<class T>
			static inline constexpr bool nothrow_helper()noexcept{
				if constexpr(able<T>){
					typedef decltype(to_arithmetic_base(declvalue(T))) my_type;
					return ::std::is_nothrow_convertible_v<T,my_type>;
				}
				else
					return false;
			}
			template<class T>
			static inline constexpr bool nothrow = nothrow_helper<T>();
			//算数类型转任意类型
			template<class T> requires(able<T>)
			force_inline constexpr auto operator()(T&&v)const noexcept(nothrow<T>){
				return to_arithmetic_base(::std::forward<T>(v));
			}
		}to_arithmetic{};
		//判断wchar_t是否和char_t相同
		inline constexpr bool wchar_t_same_as_char_t=sizeof(wchar_t)==sizeof(char_t);
		//判断wchar_t是否和char16_t相同
		inline constexpr bool wchar_t_same_as_char16_t=sizeof(wchar_t)==sizeof(char16_t);
	}
	using basic_environment::BIT_POSSIBILITY;
	using basic_environment::unsigned_specific_size_t;
	using basic_environment::to_arithmetic;
	using basic_environment::wchar_t_same_as_char_t;
	using basic_environment::wchar_t_same_as_char16_t;

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

	#line 104 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/basic_environment/_body.hpp"
}

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
namespace elc::defs{ //在elc::defs中定义内容
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"

	namespace base{}
	using namespace base;//导出内容：defs内的名称空间只起到大体名称分组的作用，不进行名称阻拦

	//内存泄露检测
	#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	namespace memory{
		inline void check_memory_lack()noexcept;
		inline struct distinctive memory_lack_checker_t{
			~memory_lack_checker_t(){
				check_memory_lack();
			}
		}memory_lack_checker{};
	}
	#endif

	namespace base{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
//_body.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//恭喜你找到elc内大部分语法糖所在地
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/template_helper.hpp"
//template_helper.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*!
宏辅助,用以补全元编程错误宏template_error的内容.
*/
template<class T>
constexpr bool template_error_helper=1000-7==114514;//w.
/*!
宏辅助,用以补全元编程错误宏template_warning的内容.
*/
template<class T,class U>
[[deprecated("this was a template warning."),nodiscard]]
inline auto template_warning_helper(U&&a)noexcept{return 0;}

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/using_std.hpp"
//using_std.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//从std中导入一些名称.
//这不比博人传燃?
using ::std::byte;
using ::std::size_t;
using ::std::uintmax_t;
using ::std::intmax_t;

using ::std::forward;
using ::std::addressof;
using ::std::swap;
/*
如何不用中间变量swap两个值？
方法一：
a=a+b
b=a-b
a=a-b
方法二：
a^=b^=a^=b
道理我都懂，可是还是用中间变量快些
XD
更多方法欢迎补充
*/

template<class T>
using remove_cvref= ::std::remove_cvref_t<T>;
template<class T>
using remove_cv= ::std::remove_cv_t<T>;
template<class T>
using remove_ref= ::std::remove_reference_t<T>;
template<bool B,class T,class F>
using conditional= ::std::conditional_t<B,T,F>;
//
using ::std::partial_ordering;
using ::std::weak_ordering;
using ::std::strong_ordering;

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/concept.hpp"
//concept.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//template<typename T,template<typename>constexpr bool name>
//concept as_concept=name<T>;

//file_end

#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/magic_number.hpp"
//magic_number.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace magic_number{
	/*! 黄金分割比
		数理逻辑不应通过强奸感性来定义审美.
		我们应当遵从物体的自身结构,辅助线仅能在这基础上起到梳理作用,并不能以此作为创作起点来表达情感,它仅存于外部世界,无法到达内心.
		黄金分割并不万能.
	*/
	constexpr auto gold=0.61803398874989484820458683436563811772030917980576286213544862270526046281890244970720720418939113748475408807538689175212663386222353693179318006076672635443338908659593958290563832266131992829026788067520876689250171169620703222104321626954862629631361443814975870122034080588795445474924618569536486444924104432077134494704956584678850987433944221254487706647809158846074998871240076521705751797883416625624940758906970400028121042762177111777805315317141011704666599146697987317613560067087480710131795236894275219484353056783002287856997829778347845878228911097625003026961561700250464338243776486102838312683303724292675263116533924731671112115881863851331620384005222165791286675294654906811317159934323597349498509040947621322298101726107059611645629909816290555208524790352406020172799747175342777592778625619432082750513121815628551222480939471234145170223735805772786160086883829523045926478780178899219902707769038953219681986151437803149974110692608867429622675756052317277752035361393621076738937645560606059216589466759551900400555908950229530942312482355212212415444006470340565734797663972394949946584578873039623090375033993856210242369025138680414577995698122445747178034173126453220416397232134044449487302315417676893752103068737880344170093954409627955898678723209512426893557309704509595684401755519881921802064052905518934947592600734852282101088194644544222318891319294689622002301443770269923007803085261180754519288770502109684249362713592518760777884665836150238913493333122310533923213624319263728910670503399282265263556209029798642472759772565508615487543574826471814145127000602389016207773224499435308899909501680328112194320481964387675863314798571911397815397807476150772211750826945863932045652098969855567814106968372884058746103378105444390943683583581381131168993855576975484149144534150912954070050194775486163075422641729394680367319805861833918328599130396072014455950449779212076124785645916160837059498786006970189409886400764436170933417270919143365013715;//精度2000(然而只是double而已.)

	/*! 每次扩容后的空间与原空间为这样的比值可以最小化时空负担
		是的,以一种较为艺术的比值.
	*/
	constexpr auto gold_of_resize=gold+1;//精度2000——大概

	/*! 圆周率. */
	constexpr auto pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317675238467481846766940513200056812714526356082778577134275778960917363717872146844090122495343014654958537105079227968925892354201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859502445945534690830264252230825334468503526193118817101000313783875288658753320838142061717766914730359825349042875546873115956286388235378759375195778185778053217122680661300192787661119590921642019893809525720106548586327886593615338182796823030195203530185296899577362259941389124972177528347913151557485724245415069595082953311686172785588907509838175463746493931925506040092770167113900984882401285836160356370766010471018194295559619894676783744944825537977472684710404753464620804668425906949129331367702898915210475216205696602405803815019351125338243003558764024749647326391419927260426992279678235478163600934172164121992458631503028618297455570674983850549458858692699569092721079750930295532116534498720275596023648066549911988183479775356636980742654252786255181841757467289097777279380008164706001614524919217321721477235014144197356854816136115735255213347574184946843852332390739414333454776241686251898356948556209921922218427255025425688767179049460165346680498862723279178608578438382796797668145410095388378636095068006422512520511739298489608412848862694560424196528502221066118630674427862203919494504712371378696095636437191728746776465757396241389086583264599581339047802759009;//精度2000

	/*! 自然对数的底数. */
	constexpr auto e =	2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642742746639193200305992181741359662904357290033429526059563073813232862794349076323382988075319525101901157383418793070215408914993488416750924476146066808226480016847741185374234544243710753907774499206955170276183860626133138458300075204493382656029760673711320070932870912744374704723069697720931014169283681902551510865746377211125238978442505695369677078544996996794686445490598793163688923009879312773617821542499922957635148220826989519366803318252886939849646510582093923982948879332036250944311730123819706841614039701983767932068328237646480429531180232878250981945581530175671736133206981125099618188159304169035159888851934580727386673858942287922849989208680582574927961048419844436346324496848756023362482704197862320900216099023530436994184914631409343173814364054625315209618369088870701676839642437814059271456354906130310720851038375051011574770417189861068739696552126715468895703503540212340784981933432106817012100562788023519303322474501585390473041995777709350366041699732972508868769664035557071622684471625607988265178713419512466520198918006308407507245458379639351364421067750539471789004518357551541252235905906872648786357525419112888773717663748602766063496035367947026923229718683277173932361920077745221262475186983349515101986426988784717193966497690708252174233656627259284406204302141137199227852699846988477023238238400556555178890876613601304770984386116870523105531491625172837327286760072481729876375698163354150746088386636406934704372066886512756882661497307886570156850169186474885416791545965072342877306998537139043002665307839877638503238182155355973235306860430106757608389086270498418885951380910304235957824951439885901131858358406674723702971497850841458530857813391562707603563907639473114554958322669457024941398316343323789759556808568362972538679132750555425244919435891284050452269538121791319145135009938463117740179715122837854601160359554028644059;//精度2000

	constexpr auto god=72;/// 神已死,神万岁.

	/*! 无符号位的对应类型 */
	template<typename T>
	using to_unsigned_t = decltype(lambda{
		if constexpr(::std::is_unsigned_v<T>||::std::is_floating_point_v<T>)
			return T();
		else
			return::std::make_unsigned_t<T>();
	}());
	/*! 符号位查询 */
	template<typename T> requires ::std::is_arithmetic_v<T>
	[[nodiscard]]force_inline constexpr bool is_negative(T x)noexcept{
		if constexpr(::std::is_signed_v<T>){
			if constexpr(::std::is_floating_point_v<T>)
				return ::std::signbit(x);
			else
				return x<0;
		}
		else
			return false;
	}
	/*!符号位设置 */
	template<typename T> requires ::std::is_arithmetic_v<T>
	[[nodiscard]]force_inline constexpr T copy_as_negative(auto x,bool negative=1)noexcept{
		if constexpr(::std::is_signed_v<decltype(x)>){
			if constexpr(::std::is_floating_point_v<decltype(x)>)
				return(T)::std::copysign(x,negative?-1:1);
			else
				return(T)negative?T{}-x:x;
		}
		else
			return x;
	}
	[[nodiscard]]force_inline constexpr auto copy_as_negative(auto x,bool negative=1)noexcept{
		return copy_as_negative<decltype(x)>(x,negative);
	}
	[[nodiscard]]force_inline constexpr auto copy_as_not_negative(auto x)noexcept{
		return copy_as_negative(x,false);
	}
	/*! 任意算数类型安全转型(ub避免.). */
	template<typename T,typename U> requires ::std::is_arithmetic_v<U>
	[[nodiscard]]force_inline constexpr T safe_arithmetic_cast(U x)noexcept{
		if constexpr(::std::is_floating_point_v<U> && ::std::is_unsigned_v<T>)
			return (T)(intmax_t)x;
		else
			return (T)x;
	}
	/*! 任意算数类型转size_t */
	template<typename T> requires ::std::is_arithmetic_v<T>
	[[nodiscard]]force_inline constexpr size_t to_size_t(T x)noexcept{
		return safe_arithmetic_cast<size_t>(x);
	}
	/*! 任意算数类型转uintmax_t */
	template<typename T> requires ::std::is_arithmetic_v<T>
	[[nodiscard]]force_inline constexpr uintmax_t to_uintmax_t(T x)noexcept{
		return safe_arithmetic_cast<uintmax_t>(x);
	}
	/*! 求余 */
	template<typename T1,typename T2> requires ::std::is_arithmetic_v<T1> and ::std::is_arithmetic_v<T2>
	[[nodiscard]]force_inline constexpr auto mod(T1 a,T2 b){
		if constexpr(::std::is_floating_point_v<T1>||::std::is_floating_point_v<T2>)
			return ::std::fmod(a,b);
		else
			return a%b;
	}
	/*! 设置浮点舍入 */
	template<typename T>
	force_inline constexpr void set_rounding(int mode){
		if constexpr(::std::is_floating_point_v<T>)
			::std::fesetround(mode);
	}
	/*!获取浮点舍入 */
	template<typename T>
	[[nodiscard]]force_inline constexpr int get_rounding(){
		if constexpr(::std::is_floating_point_v<T>)
			return ::std::fegetround();
		else
			return 0;
	}
	/*! 设置并自动恢复浮点舍入 */
	template<typename T>
	struct rounding_auto_setter{
		int old_rounding;
		rounding_auto_setter(int new_rounding){
			old_rounding=get_rounding<T>();
			set_rounding<T>(new_rounding);
		}
		~rounding_auto_setter(){
			set_rounding<T>(old_rounding);
		}
	};
	/// 位操作：循环左移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotl_nomod(const T v,const auto R)noexcept;
	#define rot_base(opt,antiopt) static_cast<T>(static_cast<T>(v opt r) | static_cast<T>(v antiopt (d - r)))
	/// 位操作：循环右移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotr_nomod(const T v,const auto r)noexcept{
		constexpr auto d = ::std::numeric_limits<T>::digits;
		if constexpr(::std::is_unsigned_v<decltype(r)>){
			if(r)
				return rot_base(>>,<<);
			else
				return v;
		}
		else{
			if(r>0)
				return rot_base(>>,<<);
			elseif(r==0)
				return v;
			else//r<0
				return rotl_nomod(v,0-r);
		}
	}
	/// 位操作：循环左移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotl_nomod(const T v,const auto r)noexcept{
		constexpr auto d = ::std::numeric_limits<T>::digits;
		if constexpr(::std::is_unsigned_v<decltype(r)>){
			if(r)
				return rot_base(<<,>>);
			else
				return v;
		}
		else{
			if(r>0)
				return rot_base(<<,>>);
			elseif(r==0)
				return v;
			else//r<0
				return rotr_nomod(v,0-r);
		}
	}
	#undef rot_base
	/// 位操作：循环右移
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotr(const T v,const auto R)noexcept{
		constexpr auto d = ::std::numeric_limits<T>::digits;
		const auto r = mod(R,d);
		return rotr_nomod(v,r);
	}
	/// 位操作：循环左移
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotl(const T v,const auto R)noexcept{
		constexpr auto d = ::std::numeric_limits<T>::digits;
		const auto r = mod(R,d);
		return rotl_nomod(v,r);
	}
	template<class T> requires ::std::is_arithmetic_v<T>
	class rot_iterator{
		static constexpr auto rot_offset_npos = ::std::numeric_limits<T>::digits;//d
		size_t _offset;
	public:
		force_inline constexpr rot_iterator(size_t offset)noexcept:_offset(offset%rot_offset_npos){}
		force_inline constexpr rot_iterator&operator++()noexcept{
			_offset++;
			if(_offset==rot_offset_npos)
				_offset=0;
			return*this;
		}
		force_inline constexpr rot_iterator&operator--()noexcept{
			if(_offset==0)
				_offset=rot_offset_npos;
			_offset--;
			return*this;
		}
		force_inline constexpr rot_iterator operator++(int)noexcept{
			rot_iterator tmp(*this);
			operator++();
			return tmp;
		}
		force_inline constexpr rot_iterator operator--(int)noexcept{
			rot_iterator tmp(*this);
			operator--();
			return tmp;
		}
		[[nodiscard]]force_inline constexpr size_t value()const noexcept{
			return _offset;
		}
	};
	/// 位操作：循环左移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotl_nomod(const T v,const rot_iterator<T>&r)noexcept{
		return rotl_nomod(v,r.value());
	}
	/// 位操作：循环右移（无mod）
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotr_nomod(const T v,const rot_iterator<T>&r)noexcept{
		return rotr_nomod(v,r.value());
	}
	/// 位操作：循环左移
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotl(const T v,const rot_iterator<T>&r)noexcept{
		return rotl_nomod(v,r);
	}
	/// 位操作：循环右移
	/// 不使用std版本而是自己写的原因：std版本右操作数只能是int而不能是size_t或别的，标准会傻逼
	template<class T> requires ::std::is_unsigned_v<T>
	[[nodiscard]]force_inline constexpr auto rotr(const T v,const rot_iterator<T>&r)noexcept{
		return rotr_nomod(v,r);
	}
	//abs
	template<class T> requires ::std::is_arithmetic_v<T>
	[[nodiscard]]force_inline constexpr auto abs(const T v)noexcept{
		if constexpr(::std::is_signed_v<T>)
			return v>=0?v:-v;
		else
			return v;
	}
	//feq
	template<class T> requires ::std::is_arithmetic_v<T>
	[[nodiscard]]force_inline constexpr bool feq(const T a,const T b)noexcept{
		return abs(a-b)<=::std::numeric_limits<T>::epsilon();
	}
	//isNaN
	template<class T> requires ::std::is_arithmetic_v<T>
	[[nodiscard]]force_inline constexpr bool isNaN(const T v)noexcept{
		if constexpr(::std::is_floating_point_v<T>)
			return v!=v;
		else
			return false;
	}
	//sub
	template<class T1,class T2> requires was_not_an_ill_form(declvalue(T1)-declvalue(T2))
	[[nodiscard]]force_inline constexpr auto sub(const T1 a,const T2 b)noexcept{
		if constexpr(::std::is_arithmetic_v<T1>&&::std::is_arithmetic_v<T2>){
			if constexpr(::std::is_floating_point_v<T1>||::std::is_floating_point_v<T2>)
				return a-b;
			else{
				using signedT = ::std::make_signed_t<::std::common_type_t<T1,T2,signed char>>;
				return static_cast<signedT>(a)-static_cast<signedT>(b);
			}
		}
		else
			return a-b;
	}
	//exp
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<class T> requires ::std::is_floating_point_v<T>
	[[nodiscard]]force_inline constexpr T exp(const T v)noexcept{
		if in_consteval{
			typedef decltype(::std::exp(v)) RT;
			auto exp_impl = recursive_lambda(RT x,RT sum,RT n,size_t i,RT t)noexcept -> RT{
				const auto epsilon=sum+t/n;
				if(feq(sum,epsilon))
					return sum;
				else
					return self_recursion(x,epsilon,n*i,i+1,t*x);
			};
			auto exp_impl_caller = get_recursive_lambda_caller(exp_impl);
			return exp_impl_caller(RT{v},RT{1},RT{1},2,RT{v});
		}
		else
			return ::std::exp(v);
	}
	//log
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<class T> requires ::std::is_arithmetic_v<T>
	[[nodiscard]]force_inline constexpr auto log(const T a)noexcept{
		if in_consteval{
			typedef decltype(::std::log(a)) RT;
			auto log_impl = recursive_lambda(const RT x,const RT y)noexcept -> RT{
				auto log_iter = lambda(RT x,RT y)noexcept{
					const auto exp_y = exp(y);
					return y + T{2}*(x-exp_y)/(x+exp_y);
				};
				return RT(feq(y,log_iter(x,y)) ? y : self_recursion(x,log_iter(x,y)));
			};
			auto log_impl_caller = get_recursive_lambda_caller(log_impl);
			return log_impl_caller((RT)a,RT{0});
		}
		else
			return ::std::log(a);
	}
	template<class T,class U> requires ::std::is_arithmetic_v<T> && ::std::is_arithmetic_v<U>
	[[nodiscard]]force_inline constexpr auto log(const T a,const U b)noexcept{
		return log(a)/log(b);
	}
	//pow
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<class T,class U> requires (::std::is_arithmetic_v<T> && ::std::is_arithmetic_v<U>)
	[[nodiscard]]force_inline constexpr auto pow(const T a,const U b)noexcept{
		if in_consteval{
			typedef decltype(::std::pow(a,b)) RT;
			return RT(exp(b*log(a)));
		}
		else
			return ::std::pow(a,b);
	}
	//trunc
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<class T> requires ::std::is_floating_point_v<T>
	[[nodiscard]]force_inline constexpr auto trunc(const T v)noexcept{
		if in_consteval{
			typedef decltype(::std::trunc(v)) RT;
			return static_cast<RT>((intmax_t)v);
		}
		else
			return ::std::trunc(v);
	}
	//ceil
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<class T> requires ::std::is_floating_point_v<T>
	[[nodiscard]]force_inline constexpr auto ceil(const T v)noexcept{
		if in_consteval{
			typedef decltype(::std::ceil(v)) RT;
			auto ceil_impl = lambda(T x, T y)noexcept{
				return feq(x,y) ? y : y+T{1};
			};
			return v<0 ? -static_cast<T>(to_uintmax_t(-v)) : ceil_impl(v,static_cast<T>(to_uintmax_t(v)));
		}
		else
			return ::std::ceil(v);
	}
	//sqrt
	//不使用std版本而是自己写的原因：std版本不是constexpr，标准会傻逼
	template<class T> requires ::std::is_arithmetic_v<T>
	[[nodiscard]]force_inline constexpr auto sqrt(const T v)noexcept{
		if in_consteval{
			typedef decltype(::std::sqrt(v)) RT;
			auto sqrt_impl = recursive_lambda(const RT x,const RT curr,const RT prev)noexcept -> RT{
				return feq(curr,prev) ? curr : self_recursion(x,(curr+x/curr)/RT{2},curr);
			};
			auto sqrt_impl_caller = get_recursive_lambda_caller(sqrt_impl);
			if(v >= 0 && v < ::std::numeric_limits<RT>::infinity())
				return sqrt_impl_caller((RT)v,(RT)v,(RT)0);
			else
				return ::std::numeric_limits<RT>::quiet_NaN();
		}
		else
			return ::std::sqrt(v);
	}

	/*! 判断某数是否是素数,无预先检查以供其他素数相关函数快速调用. */
	template<class T> requires ::std::is_arithmetic_v<T>
	[[nodiscard]]inline constexpr bool is_prime_num_no_pre_check(T a)noexcept{
		/*
		应某人的要求补注释(都是主人的任务罢了.).
		建议先看有预先检查的部分以便理解思路.
		*/
		T b=safe_arithmetic_cast<T>(sqrt(a));//若一个数可以分解为两因数之积,其中一个因数必定≤其开方:反指数式减少遍历范围.
		/*
		接下来:
		设要判定的数n(6x±1的缩写).
		测试数可以看为6i-1 6i 6i+1 6i+2 6i+3 6i+4的其中之一,同样以6为周期.
		对于测试数的整个周期,其中:
			如果n能被6i 6i+2 6i+4整除:则n要是偶数,但±1,排除.
			如果n能被6i+3整除:则n要是3倍数,但±1,排除.
		综上,循环中只要考虑6i±1的情况.
		所以以5起始,前进6(自然选择号,前进4!),逐次判断0与+2.
		虽然很想写成以6为起始逐次判断±1的对称格式但是这样会加重时空负担.(不甘心.....)
		*/
		for(T c=5;c<=b;c+=6)//遍历判断是否能被因数分解——不会有人看不懂吧?
			if((!mod(a,c))||(!mod(a,(c+2))))
				return false;
		/*
		最后,为什么是6?
		就结论来说,此数值选择最常出现的两因数(除0或1外.)之积可以最大程度减少时间占用.
		所以虽然更喜欢7/8/9之类的数不过使用6收益最大.
		要不是这样早就写成7了.
		*/
		return true;
	}
	/*! 判断某数是否是素数 */
	template<class T> requires ::std::is_arithmetic_v<T>
	[[nodiscard]]inline constexpr bool is_prime_num(T a)noexcept{
		if constexpr(::std::is_floating_point_v<T>)
			if(a != ceil(a))
				return false;
		a=abs(a);

		if(a<4)
			return true;//1和0也是prime,我不管.
		/*
		当x≥1,那么≥5的自然数如下:
		6x-1 6x 6x+1 6x+2 6x+3 6x+4
		6(x+1)-1 6(x+1) 6(x+1)+1 ... //这已经是下一周期了.

		考虑单个周期:
		6x+2 6x+3 6x+4 是 2(3x+1) 3(2x+1) 2(3x+2),排除.
		6x,排除.
		那么,只用考虑6x±1是否是prime.
		*/
		if(mod(mod(a,6)-1,4))
			return false;
		/*
		因为no_pre_check判定没有考虑到≤5的数,所以本函数第一个if进行判定补全.
		*/
		return is_prime_num_no_pre_check(a);
	}
	/// 求大于或等于某数的素数
	template<class T> requires ::std::is_arithmetic_v<T>
	[[nodiscard]]inline constexpr T get_prime_num_big_or_eq_than(T a)noexcept{
		if constexpr(::std::is_floating_point_v<T>)
			a=ceil(a);
		a=abs(a);
		if(a<4)return a;
		//将a转换为6x-1的形式.
		{
			T b=mod(a,6);
			if(b==1 && is_prime_num_no_pre_check(a))return a;
			a+=b?5-b:1;
		}
		//循环判断.
		for(;;a+=6)
			if(is_prime_num_no_pre_check(a))return a;
			elseif(is_prime_num_no_pre_check(a+2))return a+2;
	}
	/// 求大于某数的素数
	template<class T> requires ::std::is_arithmetic_v<T>
	[[nodiscard]]inline constexpr T get_prime_num_big_than(T a)noexcept{
		return get_prime_num_big_or_eq_than(a+1);
	}
	push_and_disable_msvc_warning(26467);//gold_of_resize永远为正数
	/// 已知当前array的size，求下一个合适的提前分配大小
	[[nodiscard]]inline constexpr size_t get_next_gold_size_to_resize_for_array(size_t size)noexcept{
		/*
		每次扩容后的空间与原空间比大致为gold of resize可以最小化时空负担.
		*/
		return size_t(size*gold_of_resize);
	}
	/// 已知当前hash table的size，求下一个合适的桶大小
	[[nodiscard]]inline constexpr size_t get_next_gold_size_to_resize_for_hash(size_t size)noexcept{
		/*
		素数大小的桶数可以使hash table中的每个桶尽可能活跃.
		每次扩容后的空间与原空间比大致为gold of resize可以最小化时空负担.
		*/
		return size_t(get_prime_num_big_or_eq_than(size*gold_of_resize));
	}
	pop_msvc_warning();

	/// 线性插值.
	namespace linear_interpolation{
		[[nodiscard]]inline constexpr auto get_k(auto y1,auto y2,auto δx)noexcept{
			auto δy=sub(y2,y1);
			auto k=δy/δx;
			return k;
		}
		[[nodiscard]]inline constexpr auto get_k(auto y1,auto y2)noexcept{
			return get_k(y1,y2,1.0);
		}
		[[nodiscard]]inline constexpr auto get_result(auto y1,auto k,auto δx)noexcept{
			auto diff=k*δx;
			return y1+diff;
		}
		[[nodiscard]]inline constexpr auto get_reverse_result(auto k,auto δx,auto y)noexcept{
			auto diff=k*δx;
			return y-diff;
		}
	}
}
using magic_number::to_unsigned_t;
using magic_number::is_negative;
using magic_number::copy_as_negative;
using magic_number::copy_as_not_negative;
using magic_number::to_size_t;
using magic_number::mod;
using magic_number::set_rounding;
using magic_number::get_rounding;
using magic_number::rounding_auto_setter;
using magic_number::rotl;
using magic_number::rotr;
using magic_number::rotl_nomod;
using magic_number::rotr_nomod;
using magic_number::rot_iterator;
using magic_number::isNaN;
using magic_number::abs;
using magic_number::exp;
using magic_number::log;
using magic_number::pow;
using magic_number::ceil;
using magic_number::sqrt;
using magic_number::trunc;
using magic_number::is_prime_num;
using magic_number::get_prime_num_big_or_eq_than;
using magic_number::get_prime_num_big_than;
using magic_number::get_next_gold_size_to_resize_for_array;
using magic_number::get_next_gold_size_to_resize_for_hash;

//file_end

#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/other.hpp"
//other.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
class empty_type{};

template<typename T,typename U>
inline auto&assign(T&&a,U&&b)noexcept_as(a=b){//为绕过条件内赋值时の警告而使用
	a=b;
	return a;
}

//fucking nodiscard.
constexpr struct discard_t{
	template<typename T>
	force_inline constexpr void operator=(T&&)const noexcept{}
	template<typename T>
	force_inline constexpr void operator()(T&&)const noexcept{}
}discard{};

template<typename T>
inline void just_a_use(T&&){}

template<typename T>
distinctive inline T const_default_value_of{};//?

enable_adl(the_destroy);
template<typename T>
static void destroy(T*a)noexcept{
	if constexpr(was_not_an_ill_form(the_destroy(a)))
		the_destroy(a);
	else
		template_error("Please overload the function the_destroy in the namespace where this type is defined.");
}

//file_end

#line 15 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/cast.hpp"
//cast.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
push_and_disable_msvc_warning(
	26491//down_cast警告diss
	26466//down_cast警告diss
	26492//const_cast警告diss
);
/// 对值追加const
template<typename T>
force_inline constexpr const T add_const(T a)noexcept{return a;}
/// 对引用追加const
template<typename T>
force_inline constexpr const T&add_const(T&a)noexcept{return a;}
/// 对引用移除const
template<typename T>
force_inline constexpr T&remove_const(const T&a)noexcept{return const_cast<T&>(a);}
/// 对指针追加const
template<typename T>
force_inline constexpr const T*add_const(T*a)noexcept{return a;}
/// 对指针移除const
template<typename T>
force_inline constexpr T*remove_const(const T*a)noexcept{return const_cast<T*>(a);}
/// 对指针移除const
template<typename T>
force_inline constexpr T*launder_remove_const(const T*a)noexcept{return ::std::launder(remove_const(a));}
/// 向下转型至
template<typename T,typename U>
force_inline constexpr T down_cast(U a)noexcept{return static_cast<T>(a);}
pop_msvc_warning();

//file_end

#line 17 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/special_flags.hpp"
//special_flag.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

/// 快捷定义特殊类型的constexpr
#define defspecflag(name)\
constexpr struct name##_t{} name{}

/// 引用计数从不为0的构造
defspecflag(never_ref_num_zero);
/// 特殊构造
defspecflag(special_init);
/// 预分配内存
defspecflag(pre_alloc);

#undef defspecflag

//file_end

#line 18 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/non_Xable.hpp"
//non_Xable.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/// 禁止复制赋值
struct non_copy_assign_able{
	constexpr non_copy_assign_able()noexcept=default;
	constexpr non_copy_assign_able(const non_copy_assign_able&)noexcept=default;
	constexpr non_copy_assign_able(non_copy_assign_able&&)noexcept=default;
	constexpr non_copy_assign_able& operator=(const non_copy_assign_able&)&noexcept=delete;
	constexpr non_copy_assign_able& operator=(non_copy_assign_able&&)&noexcept=default;
};
/// 禁止移动赋值
struct non_move_assign_able{
	constexpr non_move_assign_able()noexcept=default;
	constexpr non_move_assign_able(const non_move_assign_able&)noexcept=default;
	constexpr non_move_assign_able(non_move_assign_able&&)noexcept=default;
	constexpr non_move_assign_able& operator=(const non_move_assign_able&)&noexcept=default;
	constexpr non_move_assign_able& operator=(non_move_assign_able&&)&noexcept=delete;
};

/// 禁止默认合成的赋值
struct non_default_assign_able:non_copy_assign_able,non_move_assign_able{};


/// 禁止复制构造
struct non_copy_construct_able{
	constexpr non_copy_construct_able()=default;
	constexpr non_copy_construct_able(const non_copy_construct_able&)=delete;
	constexpr non_copy_construct_able(non_copy_construct_able&&)=default;
	constexpr non_copy_construct_able& operator=(const non_copy_construct_able&)&noexcept=default;
	constexpr non_copy_construct_able& operator=(non_copy_construct_able&&)&noexcept=default;
};
/// 禁止移动构造
struct non_move_construct_able{
	constexpr non_move_construct_able()=default;
	constexpr non_move_construct_able(const non_move_construct_able&)=default;
	constexpr non_move_construct_able(non_move_construct_able&&)=delete;
	constexpr non_move_construct_able& operator=(const non_move_construct_able&)&noexcept=default;
	constexpr non_move_construct_able& operator=(non_move_construct_able&&)&noexcept=default;
};

/// 禁止默认合成的构造
struct non_default_construct_able:non_copy_construct_able,non_move_construct_able{
	constexpr non_default_construct_able()=delete;
};

/// 禁止默认合成的复制
struct non_copyable:non_copy_assign_able,non_copy_construct_able{};
/// 禁止默认合成的移动
struct non_moveable:non_move_assign_able,non_move_construct_able{};

//file_end

#line 19 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/attribute.hpp"
//attribute.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<class T,typename attribute_name>
struct attribute{
protected:
	template<class U,special_attribute_t another_attribute_name>
	friend U*get_handle(attribute<U,another_attribute_name>*)noexcept;
	force_inline constexpr T*get_handle()noexcept{return down_cast<T*>(down_cast<attribute_name*>(this));}

	template<class U,special_attribute_t another_attribute_name>
	friend const U*get_handle(const attribute<U,another_attribute_name>*)noexcept;
	force_inline constexpr const T*get_handle()const noexcept{return down_cast<const T*>(down_cast<const attribute_name*>(this));}
};
template<class T,special_attribute_t attribute_name>
force_inline T*get_handle(attribute<T,attribute_name>*a)noexcept{return a->get_handle();}
template<class T,special_attribute_t attribute_name>
force_inline const T*get_handle(const attribute<T,attribute_name>*a)noexcept{return a->get_handle();}

template<class T,common_attribute_t attribute_name>
force_inline T* get_handle(attribute<T,attribute_name<T>>*a)noexcept{return get_handle<T,attribute_name<T>>(a);}
template<class T,common_attribute_t attribute_name>
force_inline const T* get_handle(const attribute<T,attribute_name<T>>*a)noexcept{return get_handle<T,attribute_name<T>>(a);}

template<special_attribute_t attribute_name,class T>
force_inline auto attribute_ptr_cast(T*ptr)noexcept{
	return static_cast<attribute_name*>(ptr);
}
template<special_attribute_t attribute_name,class T>
force_inline auto attribute_ptr_cast(const T* ptr)noexcept{
	return static_cast<const attribute_name*>(ptr);
}
template<common_attribute_t attribute_name,class T>
force_inline auto attribute_ptr_cast(T*ptr)noexcept{
	return attribute_ptr_cast<attribute_name<remove_cvref<T>>>(ptr);
}

template<special_attribute_t attribute_name,class T>
force_inline auto& attribute_cast(T&t)noexcept{
	return*attribute_ptr_cast<attribute_name>(&t);
}
template<common_attribute_t attribute_name,class T>
force_inline auto& attribute_cast(T&t)noexcept{
	return*attribute_ptr_cast<attribute_name>(&t);
}

template<special_attribute_t... attribute_names>
struct special_attribute_pack:virtual attribute_names...{
	/*兼容用*/
	template<class T>
	struct on_type:special_attribute_pack<attribute_names>...{};
};
template<common_attribute_t... attribute_names>
struct common_attribute_pack{
	template<class T>
	struct on_type:attribute_names<T>...{};
};

//file_end

#line 20 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/special_attribute.hpp"
//special_attribute.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
def_common_attribute_with_nothing(never_in_array);
def_special_attribute_with_nothing(build_by_get_only);

//file_end

#line 21 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/type_info.hpp"
//type_info.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
struct type_name_t;/// 自动重整类型名并在析构时释放重整结果，对于gcc和clang的傻逼实现
struct base_type_info_t{
private:
	struct type_id_t{
		const ::std::type_info* _m;

		constexpr type_id_t(const ::std::type_info&a)noexcept:_m(&a){}
		constexpr type_id_t(const type_id_t&a)noexcept=default;
		[[nodiscard]]type_name_t get_name()const noexcept;//定义于type_name.hpp
		[[nodiscard]]size_t get_hash()const noexcept{
			return _m->hash_code();
		}
		[[nodiscard]]bool operator==(const type_id_t&a)const noexcept{return *_m==*a._m;}
	};

	type_id_t _tid;
public:
	constexpr base_type_info_t(const ::std::type_info&a)noexcept:_tid(a){}
	constexpr base_type_info_t(const base_type_info_t&)noexcept=default;
	[[nodiscard]]type_name_t get_name()const noexcept;//定义于type_name.hpp
	[[nodiscard]]size_t get_hash()const noexcept{
		return _tid.get_hash();
	}
	[[nodiscard]]bool operator==(const base_type_info_t&a)const noexcept{return _tid==a._tid;}
	[[nodiscard]]bool operator==(const ::std::type_info&a)const noexcept{return _tid==type_id_t(a);}
};
template<class T>
struct type_info_t{
	typedef T type;

	template<class U>
	static constexpr bool same_as=::std::is_same_v<T,U>;
	template<class U>
	static constexpr bool not_same_as=!same_as<U>;
	template<class U>
	static constexpr bool base_on=::std::is_convertible_v<remove_cvref<T>*,remove_cvref<U>*>;
	template<class U>
	static constexpr bool not_base_on=!base_on<U>;

	template<class U>
	static constexpr bool can_convert_to=::std::is_convertible_v<T,U>;
	template<class U>
	static constexpr bool can_t_convert_to=!can_convert_to<U>;
	template<class U>
	static constexpr bool can_nothrow_convert_to=::std::is_nothrow_convertible_v<T,U>;
	template<class U>
	static constexpr bool can_t_nothrow_convert_to=!can_nothrow_convert_to<U>;

	/*
	//没有重载变量模板一说
	template<typename attribute_name>
	static constexpr bool has_attribute=has_attribute_helper<attribute_name>();
	template<typename attribute_name>
	static constexpr bool not_has_attribute=!has_attribute(attribute_name);
	*/
	template<special_attribute_t attribute_name>
	static constexpr bool has_attribute_helper(){
		return base_on<attribute_name>;
	}
	template<common_attribute_t attribute_name>
	static constexpr bool has_attribute_helper(){
		return has_attribute_helper<attribute_name<remove_cvref<T>>>();
	}
	template<special_attribute_t attribute_name>
	static constexpr bool not_has_has_attribute_helper(){
		return!has_attribute_helper<attribute_name>();
	}
	template<common_attribute_t attribute_name>
	static constexpr bool not_has_has_attribute_helper(){
		return!has_attribute_helper<attribute_name>();
	}

	// defed at defs.
	// #define has_attribute(...) has_attribute_helper<__VA_ARGS__>()
	// #define not_has_attribute(...) not_has_has_attribute_helper<__VA_ARGS__>()

	template<common_attribute_t... common_attribute_names>
	struct with_common_attribute:common_attribute_pack<common_attribute_names...>::template_name on_type<T>{
		template<special_attribute_t... special_attribute_names>
		struct and_special_attribute:
			common_attribute_pack<common_attribute_names...>::template_name on_type<T>,
			special_attribute_pack<special_attribute_names...>::template_name on_type<T>
			{};
	};
	template<special_attribute_t... special_attribute_names>
	struct with_special_attribute:special_attribute_pack<special_attribute_names...>::template_name on_type<T>{
		template<common_attribute_t... common_attribute_names>
		struct and_common_attribute:
			special_attribute_pack<special_attribute_names...>::template_name on_type<T>,
			common_attribute_pack<common_attribute_names...>::template_name on_type<T>
			{};
	};

	constexpr type_info_t()noexcept{}
	constexpr type_info_t(const type_info_t&)noexcept=default;
	[[nodiscard]]constexpr operator base_type_info_t()const noexcept{return base_type_info_t(typeid(T));}
	[[nodiscard]]constexpr bool operator==(const ::std::type_info&a)const noexcept{return base_type_info_t(*this)==base_type_info_t(a);}
	[[nodiscard]]type_name_t get_name()const noexcept;//定义于type_name.hpp
	[[nodiscard]]size_t get_hash()const noexcept{
		return base_type_info_t(*this).get_hash();
	}
};

template<class T>
constexpr type_info_t<T>type_info{};

template<class T>
[[nodiscard]]constexpr bool operator==(const type_info_t<T>&,const type_info_t<T>&){return true;}
template<class T,class U>
[[nodiscard]]constexpr bool operator==(const type_info_t<T>&,const type_info_t<U>&){return false;}

/*
template<class T,class U>
consteval auto operator?:(auto a,const type_info_t<T>&b,const type_info_t<U>&c){
	if(a)
		return b;
	else
		if(!a)
			return c;
		else
			return b && c;
	else
		return void();
}
*/

//file_end

#line 22 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/min_max.hpp"
//min_max.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*!
获取几个参数中的最小值或某类型能表示的最小值.
用法:
	min.able<T1,T2...> -> bool T...等类型能否获得参数最小值.
	min.get_limit_able<T> -> bool 能否获得T类型能表示的最小值.
	min(v1,v2...) -> auto 获取v...的最小值.
	min(type_info<T>) -> auto 获取T能表示的最小值.
*/
constexpr struct min_t{
	template<class...Args>
	static constexpr bool able=was_not_an_ill_form(::std::min(declvalue(Args)...));

	template<typename T>
	static constexpr bool get_limit_able=was_not_an_ill_form(::std::numeric_limits<T>::min());

	template<class...Args> requires able<Args...>
	[[nodiscard]]constexpr auto operator()(Args&&...rest)const noexcept{
		return ::std::min(forward<Args>(rest)...);
	}
	template<class T> requires able<::std::initializer_list<T>>
	[[nodiscard]]constexpr auto operator()(::std::initializer_list<T>l)const noexcept{
		return ::std::min(l);
	}
	template<typename T> requires get_limit_able<T>
	[[nodiscard]]constexpr auto operator()(type_info_t<T>)const noexcept{
		return ::std::numeric_limits<T>::min();
	}
}min{};
/*!
获取几个参数中的最大值或某类型能表示的最大值.
用法:
	max.able<T1,T2...> -> bool T...等类型能否获得参数最大值.
	max.get_limit_able<T> -> bool 能否获得T类型能表示的最大值.
	max(v1,v2...) -> auto 获取v...的最大值.
	max(type_info<T>) -> auto 获取T能表示的最大值.
*/
constexpr struct max_t{
	template<class...Args>
	static constexpr bool able=was_not_an_ill_form(::std::max(declvalue(Args)...));

	template<typename T>
	static constexpr bool get_limit_able=was_not_an_ill_form(::std::numeric_limits<T>::max());

	template<class...Args> requires able<Args...>
	[[nodiscard]]constexpr auto operator()(Args&&...rest)const noexcept{
		return ::std::max(forward<Args>(rest)...);
	}
	template<class T> requires able<::std::initializer_list<T>>
	[[nodiscard]]constexpr auto operator()(::std::initializer_list<T>l)const noexcept{
		return ::std::max(l);
	}
	template<typename T> requires get_limit_able<T>
	[[nodiscard]]constexpr auto operator()(type_info_t<T>)const noexcept{
		return ::std::numeric_limits<T>::max();
	}
}max{};

//file_end

#line 23 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/null_ptr.hpp"
//null_ptr.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace null_ptr_n{
	/*!
	提醒子类定义者重载get_null_ptr.
	*/
	special_attribute_t can_t_use_default_null_ptr{};

	/*!
	可不重载get_null_ptr
	在此类ref_able或weak_ref_able时，意味着使用者**保证**所有指向此类的实例的ptr都不可为null_ptr
	否则将内存访问错误
	*/
	special_attribute_t force_use_default_null_ptr:can_t_use_default_null_ptr{};

	enable_adl(the_get_null_ptr);
	template<typename T>
	[[nodiscard]]constexpr auto get_null_ptr()noexcept{
		suppress_msvc_warning(26462)//貌似msvc在这里有bug
		constexpr auto null_as_T = static_cast<T*>(nullptr);
		if constexpr(was_not_an_ill_form(the_get_null_ptr(null_as_T)))
			return the_get_null_ptr(null_as_T);
		elseif constexpr(type_info<T>.has_attribute(can_t_use_default_null_ptr)&&type_info<T>.not_has_attribute(force_use_default_null_ptr)){
			template_error("please overload the function the_get_null_ptr in the namespace where this type is defined.");
			return null_as_T;
		}
		else
			return null_as_T;
	}


	/*!
	字面量null_ptr，如同nullptr使用即可.
	*/
	constexpr struct null_ptr_t{
		template<typename T>
		[[nodiscard]]constexpr_as(get_null_ptr<remove_cvref<T>>())auto base_get()const noexcept{return get_null_ptr<remove_cvref<T>>();}
		template<typename T>
		[[nodiscard]]constexpr_as(base_get<T>())operator T*()const noexcept{return down_cast<T*>(base_get<T>());}
		//constexpr operator decltype(nullptr)()const noexcept{return nullptr;}//提醒接口设计者注意null_ptr的重载版本.
	}null_ptr{};

	template<typename T,typename U=decltype(*null_ptr.base_get<T>())>
	[[nodiscard]]auto operator==(T*a,null_ptr_t)noexcept{
		return null_ptr.base_get<T>()==static_cast<const remove_ref<U>*>(add_const(a));
	}
}
using null_ptr_n::can_t_use_default_null_ptr;
using null_ptr_n::force_use_default_null_ptr;
using null_ptr_n::null_ptr;
typedef decltype(null_ptr) null_ptr_t;
typedef decltype(nullptr) nullptr_t;

//file_end

#line 24 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/compare.hpp"
//compare.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//end_by_zero_t
/*!
用于标志某一数据串以0结尾
*/
inline constexpr struct end_by_zero_t{}end_by_zero;
//just_an_part_t
/*!
用于标志某一数据串并没有完结
*/
inline constexpr struct just_an_part_t{}just_an_part;
//equal：值相等.
/*!
	相等比较任意支持比较的类型或其数组——简易封装.
	用法:
	判断两值是否可比较。
	equal.able<类型1,类型2（可选，默认为类型1）>		->	bool
	判断将两者进行比较时是否会抛出异常。
	equal.nothrow<类型,类型2（可选，默认为类型1）>		->	bool

	equal(T1,T2)										->	auto

	equal(T1[N1],T2[N2])								->	bool
	equal(T1*,size1,T2*,size2)							->	bool
	equal(T1*,T2*,size)									->	bool
	equal(T1*,size1,T2*,end_by_zero)					->	bool
	equal(T1*,end_by_zero,T2*,size)						->	bool
	equal(T1*,end_by_zero,T2*,end_by_zero)				->	bool
*/
constexpr struct equal_t{
	template<class T,class U=T>
	static constexpr bool able= was_not_an_ill_form(declvalue(T)==declvalue(U));
	template<class T,class U=T>
	static constexpr bool nothrow= was_not_an_ill_form_and_noexcept(declvalue(T)==declvalue(U));

	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T&&a,U&&b)const noexcept(nothrow<T,U>){
		return a==b;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,U*b,size_t size)const noexcept(nothrow<T,U>){
		while(size--){
			if(*(a++)!=*(b++))
				return false;
		}
		return true;
	}
	template<typename T,typename U,size_t N1,size_t N2>
	[[nodiscard]]constexpr bool operator()(T(&a)[N1],U(&b)[N2])const noexcept(nothrow<T,U>){
		if constexpr(N1==N2)
			return operator()(a,b,N1);
		else{
			template_warning("N1!=N2");
			return false;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,size_t size1,U*b,size_t size2)const noexcept(nothrow<T,U>){
		if(size1==size2)
			return operator()(a,b,size1);
		else
			return false;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,size_t size1,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		while(size1--){
			if(*a!=*b || *b==U{0})
				return false;
			a++;
			b++;
		}
		return *b==U{0};
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,end_by_zero_t,U*b,size_t size2)const noexcept(nothrow<T,U>){
		return operator()(b,size2,a,end_by_zero);
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,end_by_zero_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		floop{
			if(*a!=*b)
				return false;
			if(*a==T{0})
				return true;
			a++;
			b++;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr bool operator()(T*a,size_t size1,just_an_part_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		while(size1--){
			if(*a!=*b || *b==U{0})
				return false;
			a++;
			b++;
		}
		return true;
	}
}equal{};

//eq：同一对象
template<typename T>
[[nodiscard]]constexpr auto is_eq(T&&a,T&&b)noexcept_as(&a==&b){
	return &a==&b;
}
template<typename T>
[[nodiscard]]constexpr auto is_not_eq(T&&a,T&&b)noexcept_as(!is_eq(a,b)){
	return!is_eq(a,b);
}

//compare：三路比较
/*!
	若大小相同则以字典序三路比较任意支持比较的类型或其数组,并在 <=> 不可用时以 < 和 == 为后备.
	用法:
	判断两者是否可真的进行三路比较。
	compare.r_able<类型1,类型2(可选，默认与1相同)>				->	bool
	判断两者是否可进行compare操作。
	compare.able<类型1,类型2(可选，默认与1相同)>				->	bool
	判断将两者进行三路比较是否会抛出异常。
	compare.nothrow<类型1,类型2（可选，默认与1相同）>			->	bool

	compare(T1,T2)
	compare(T1[N1],T2[N2])
	compare(T1*,size1,T2*,size2)
	compare(T1*,T2*,size)
	返回类型语义上是三路比较的结果类型,具体类型视情况而定.

	以字典序进行三路比较。
	compare.lexicographical(T1,T2)
	compare.lexicographical(T1[N1],T2[N2])
	compare.lexicographical(T1*,size1,T2*,size2)
	compare.lexicographical(T1*,T2*,size)
	返回类型语义上是三路比较的结果类型,具体类型视情况而定.

	翻转三路比较的结果类型。
	compare.reverse(order)
	返回对应结果类型的反义，与零相等或无法比较时则返回其本身。
*/
constexpr struct compare_t{
	template<class T,class U=T>
	static constexpr bool r_able= was_not_an_ill_form(declvalue(T)<=>declvalue(U));

	template<class T,class U=T>
	static constexpr bool able= r_able<T,U> ||
								was_not_an_ill_form(
														declvalue(T)==declvalue(U),
														declvalue(T)<declvalue(U),
														declvalue(U)<declvalue(T)
													);
	template<class T,class U=T>
	static constexpr bool nothrow= was_not_an_ill_form_and_noexcept(declvalue(T)<=>declvalue(U)) ||
								   was_not_an_ill_form_and_noexcept(
														declvalue(T)==declvalue(U),
														declvalue(T)<declvalue(U),
														declvalue(U)<declvalue(T)
													);


	template<class T,class U>
	[[nodiscard]]static constexpr auto base_call(T&&a,U&&b)noexcept(nothrow<T,U>){
		//在 <=> 不可用时以 < 和 == 为后备，优于直接 <=>
		if constexpr(r_able<T,U>)
			return a<=>b;
		else return a == b	? partial_ordering::equivalent	:
					a < b	? partial_ordering::less		:
					b < a	? partial_ordering::greater		:
							  partial_ordering::unordered	;
	}

	template<class T,class U=T>
	using type=decltype(base_call(declvalue(T),declvalue(U)));

	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T&&a,U&&b)const noexcept(nothrow<T,U>){
		return base_call(a,b);
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,U*b,size_t size)const noexcept(nothrow<T,U>){
		while(size--){
			if(auto tmp=base_call(*(a++),*(b++)); tmp!=0)
				return tmp;
		}
		return strong_ordering::equivalent;
	}
	template<typename T,typename U,size_t N1,size_t N2>
	[[nodiscard]]constexpr auto operator()(T(&a)[N1],U(&b)[N2])const noexcept(nothrow<T,U>){
		if constexpr(N1==N2)
			return operator()(a,b,N1);
		else{
			template_warning("N1!=N2");
			return N1<=>N2;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,size_t size1,U*b,size_t size2)const noexcept(nothrow<T,U>){
		type<T,U> tmp=size1<=>size2;
		if(tmp!=0)
			return tmp;
		else
			return operator()(a,b,size1);
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,size_t size1,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		type<T,U> tmp=strong_ordering::equivalent;
		while(size1--){
			if(*b==U{0})
				return strong_ordering::greater;
			if(tmp==0)
				tmp=base_call(*a,*b);
			a++;
			b++;
		}
		return *b==U{0}?tmp:strong_ordering::less;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,end_by_zero_t,U*b,size_t size2)const noexcept(nothrow<T,U>){
		type<T,U> tmp=strong_ordering::equivalent;
		while(size2--){
			if(*a==T{0})
				return strong_ordering::less;
			if(tmp==0)
				tmp=base_call(*a,*b);
			a++;
			b++;
		}
		return *b==U{0}?tmp:strong_ordering::less;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,end_by_zero_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		type<T,U> tmp=strong_ordering::equivalent;
		floop{
			if(*a==T{0})
				return *b==U{0}?tmp:strong_ordering::less;
			if(tmp==0)
				tmp=base_call(*a,*b);
			a++;
			b++;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto operator()(T*a,size_t size1,just_an_part_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		type<T,U> tmp=strong_ordering::equivalent;
		while(size1--){
			if(*b==U{0})
				return strong_ordering::greater;
			if(tmp==0)
				tmp=base_call(*a,*b);
			a++;
			b++;
		}
		return tmp;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,size_t size1,U*b,size_t size2)const noexcept(nothrow<T,U>){
		if(auto tmp=operator()(a,b,min(size1,size2)); tmp!=0)
			return tmp;
		else
			return size1<=>size2;
	}
	template<typename T,typename U,size_t N1,size_t N2>
	[[nodiscard]]constexpr auto lexicographical(T(&a)[N1],U(&b)[N2])const noexcept(nothrow<T,U>){
		return lexicographical(a,N1,b,N2);
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,size_t size1,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		while(size1--){
			if(*b==U{0})
				return strong_ordering::greater;
			if(auto tmp=base_call(*a,*b); tmp!=0)
				return tmp;
			a++;
			b++;
		}
		return *b==U{0}?strong_ordering::equivalent:
						strong_ordering::less;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,end_by_zero_t,U*b,size_t size2)const noexcept(nothrow<T,U>){
		while(size2--){
			if(*a==T{0})
				return strong_ordering::less;
			if(auto tmp=base_call(*a,*b); tmp!=0)
				return tmp;
			a++;
			b++;
		}
		return *b==U{0}?strong_ordering::equivalent:
						strong_ordering::less;
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,end_by_zero_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		floop{
			if(*a==T{0})
				return *b==U{0}?strong_ordering::equivalent:
								strong_ordering::less;
			if(auto tmp=base_call(*a,*b); tmp!=0)
				return tmp;
			a++;
			b++;
		}
	}
	template<typename T,typename U>
	[[nodiscard]]constexpr auto lexicographical(T*a,size_t size1,just_an_part_t,U*b,end_by_zero_t)const noexcept(nothrow<T,U>){
		while(size1--){
			if(*b==U{0})
				return strong_ordering::greater;
			if(auto tmp=base_call(*a,*b); tmp!=0)
				return tmp;
			a++;
			b++;
		}
		return strong_ordering::equivalent;
	}
	//
	[[nodiscard]]constexpr auto reverse(partial_ordering odr)const noexcept{
		if(odr==partial_ordering::greater)
			return partial_ordering::less;
		elseif(odr==partial_ordering::less)
			return partial_ordering::greater;
		else
			return odr;
	}
	[[nodiscard]]constexpr auto reverse(weak_ordering odr)const noexcept{
		if(odr==weak_ordering::greater)
			return weak_ordering::less;
		elseif(odr==weak_ordering::less)
			return weak_ordering::greater;
		else
			return odr;
	}
	[[nodiscard]]constexpr auto reverse(strong_ordering odr)const noexcept{
		if(odr==strong_ordering::greater)
			return strong_ordering::less;
		elseif(odr==strong_ordering::less)
			return strong_ordering::greater;
		else
			return odr;
	}
}compare{};

//file_end

#line 25 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/note.hpp"
//note.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace note_n{
	#define def_note(name)\
	template<typename T>\
	struct name##_t{\
		T value;\
		force_inline constexpr name##_t(T a)noexcept:value(a){}\
		template<class U>\
		force_inline constexpr name##_t(name##_t<U>a)noexcept:value(a.value){}\
		force_inline constexpr operator T()noexcept{return value;}\
		force_inline constexpr T operator()()noexcept{return value;}\
	};\
	template<typename T>\
	constexpr name##_t<T>name(T v){return{v};}

	def_note(from);
	def_note(to);
	def_note(size);

	#undef def_note
	constexpr struct fail_t{}fail{};
}
namespace note=note_n;

//file_end

#line 26 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/array_like.hpp"
//array_like.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace array_like_n{
	template<class T>
	[[nodiscard]]inline constexpr size_t size_of_array_like(T&&)noexcept{return 1;}
	template<class T,size_t N>
	[[nodiscard]]inline constexpr size_t size_of_array_like(T(&)[N])noexcept{return N;}
	template<class T>
	[[nodiscard]]inline size_t size_of_array_like(::std::initializer_list<T>&a)noexcept{return a.size();}

	template<class T>
	[[nodiscard]]inline constexpr auto begin_of_array_like(T&&a)noexcept{return addressof(a);}
	template<class T,size_t N>
	[[nodiscard]]inline constexpr auto begin_of_array_like(T(&a)[N])noexcept{return addressof(a[0]);}
	template<class T>
	[[nodiscard]]inline const T* begin_of_array_like(::std::initializer_list<T>&a)noexcept{return a.begin();}

	template<class T>
	[[nodiscard]]inline auto end_of_array_like(T&&a)noexcept{return begin_of_array_like(a)+size_of_array_like(a);}

	template<class T>
	constexpr bool is_array_like=was_not_an_ill_form_with_parameter(
									(T v){
										begin_of_array_like(v);
										size_of_array_like(v);
									}
								);

	template<class T>
	constexpr bool is_signal_value_for_array_like=type_info<remove_cvref<decltype(*begin_of_array_like(declvalue(T)))>> == type_info<T>;
	template<class T>
	constexpr bool is_not_signal_value_for_array_like=!is_signal_value_for_array_like<T>;

	template<class T,class U>
	constexpr bool is_array_like_for=was_not_an_ill_form_with_parameter(
										(U v){
											begin_of_array_like<T>(v);
											size_of_array_like<T>(v);
										}
									);

	template<class T>
	struct array_like_view_t{
		typedef T* iterator;
		typedef const T* const_iterator;
		typedef array_like_view_t<T>this_t;
	private:
		T*_begin=nullptr;
		size_t _size=0;
	public:
		constexpr explicit array_like_view_t(T*a,size_t b)noexcept:_begin(a),_size(b){}
		template<class U> requires is_array_like_for<T,U>
		explicit constexpr_as_auto array_like_view_t(U&&a)noexcept_as(begin_of_array_like<T>(a),size_of_array_like<T>(a)):array_like_view_t(begin_of_array_like<T>(a),size_of_array_like<T>(a)){}
		constexpr array_like_view_t(const this_t&)noexcept=default;

		void swap_with(this_t&b)noexcept_as(swap(_begin,b._begin),swap(_size,b._size)){
			swap(_begin,b._begin);
			swap(_size,b._size);
		}

		[[nodiscard]]constexpr const_iterator data()const noexcept{return _begin;}
		[[nodiscard]]constexpr size_t size()const noexcept{return _size;}

		[[nodiscard]]constexpr iterator begin()noexcept requires(type_info<iterator>!=type_info<const_iterator>){return _begin;}
		[[nodiscard]]constexpr iterator end()noexcept requires(type_info<iterator>!=type_info<const_iterator>){return begin()+size();}
		[[nodiscard]]constexpr const_iterator begin()const noexcept{return _begin;}
		[[nodiscard]]constexpr const_iterator end()const noexcept{return begin()+size();}

		[[nodiscard]]constexpr const_iterator cbegin()const noexcept{return remove_const(this)->begin();}
		[[nodiscard]]constexpr const_iterator cend()const noexcept{return remove_const(this)->end();}

		[[nodiscard]]constexpr T&front()noexcept{return _begin[0];}
		[[nodiscard]]constexpr const T&front()const noexcept{return _begin[0];}
		[[nodiscard]]constexpr T&back()noexcept{return _begin[size()-1];}
		[[nodiscard]]constexpr const T&back()const noexcept{return _begin[size()-1];}

		[[nodiscard]]constexpr bool empty()const noexcept{return size();}

		[[nodiscard]]constexpr T&operator[](size_t pos)noexcept{return begin()[pos];}
		[[nodiscard]]constexpr const T&operator[](size_t pos)const noexcept{return remove_const(*this)[pos];}

		[[nodiscard]]constexpr auto operator<=>(this_t a)noexcept(compare.nothrow<T>){
			return compare(_begin,_size,a._begin,a._size);
		}
		[[nodiscard]]constexpr auto operator==(this_t a)noexcept(equal.nothrow<T>){
			return equal(_begin,_size,a._begin,a._size);
		}
	};
	template<typename T>
	struct array_end_by_zero_t:array_like_view_t<T>{
		typedef array_like_view_t<T>base_t;
		using base_t::base_t;

		[[nodiscard]]constexpr static size_t get_length_of(T*ptr)noexcept{
			if(*ptr)return get_length_of(ptr+1)+1;
			else return 0;
		}

		constexpr array_end_by_zero_t(T*ptr)noexcept:base_t(ptr,get_length_of(ptr)){}
	};

	template<class T>
	[[nodiscard]]inline constexpr T* begin_of_array_like(array_like_view_t<T>&a)noexcept requires(type_info<T>!=type_info<const T>){return a.begin();}
	template<class T>
	[[nodiscard]]inline constexpr auto begin_of_array_like(const array_like_view_t<T>&a)noexcept{return a.begin();}
	template<class T>
	[[nodiscard]]inline constexpr T* begin_of_array_like(array_like_view_t<remove_cv<T>>&a)noexcept{return a.begin();}
	template<class T>
	[[nodiscard]]inline constexpr size_t size_of_array_like(const array_like_view_t<T>&a)noexcept{return a.size();}
}
using array_like_n::size_of_array_like;
using array_like_n::begin_of_array_like;
using array_like_n::end_of_array_like;
using array_like_n::is_array_like;
using array_like_n::is_signal_value_for_array_like;
using array_like_n::is_not_signal_value_for_array_like;
using array_like_n::is_array_like_for;
using array_like_n::array_like_view_t;
using array_like_n::array_end_by_zero_t;

//file_end

#line 27 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/data.hpp"
//data.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*!
	每个T的可能性大小
*/
template<class T> requires ::std::is_integral_v<T>
constexpr size_t number_of_possible_values_per=uintmax_t(max(type_info<::std::make_unsigned_t<T>>))+1;

/*!
	功能: byte* 类型数据转换为 T&，不进行任何检查
	用法: data_cast<T>(byte*) -> T&
*/
template<class T>
[[nodiscard]]force_inline constexpr T&data_cast(byte*p)noexcept{return*reinterpret_cast<T*>(p);}
template<class T>
[[nodiscard]]force_inline constexpr T&launder_data_cast(byte*p)noexcept{return*::std::launder(data_cast<T>(p));}
/*!
	功能: byte* 类型数据转换为 T*，不进行任何检查
	用法: data_ptr_cast<T>(byte*) -> T*
*/
template<class T>
[[nodiscard]]force_inline constexpr T*data_ptr_cast(byte*p)noexcept{return reinterpret_cast<T*>(p);}
template<class T>
[[nodiscard]]force_inline constexpr T*launder_data_ptr_cast(byte*p)noexcept{return ::std::launder(data_ptr_cast<T>(p));}
/*!
	功能: T* 指针转换为 byte*，不进行任何检查
	用法: cast_to_data(T*) -> byte*
*/
template<class T>
[[nodiscard]]force_inline constexpr byte*cast_to_data(T*p)noexcept{return reinterpret_cast<byte*>(p);}
template<class T>
[[nodiscard]]force_inline constexpr byte*launder_cast_to_data(T*p)noexcept{return ::std::launder(cast_to_data(p));}
/*!
	功能: const T* 指针转换为 const byte*，不进行任何检查
	用法: cast_to_data(const T*) -> const byte*
*/
template<class T>
[[nodiscard]]force_inline constexpr const byte*cast_to_data(const T*p)noexcept{return reinterpret_cast<const byte*>(p);}
template<class T>
[[nodiscard]]force_inline constexpr const byte*launder_cast_to_data(const T*p)noexcept{return ::std::launder(cast_to_data(p));}
/*!
	功能: T& 转换为 U&，不进行任何检查
	用法: union_cast<U>(T&) -> U&
*/
template<class U,class T>
[[nodiscard]]force_inline constexpr U&union_cast(T&t)noexcept{return*reinterpret_cast<U*>(&t);}
template<class U,class T>
[[nodiscard]]force_inline constexpr U&launder_union_cast(T&t)noexcept{return*::std::launder(union_cast<U>(t));}

/*!
	功能: data_block辅助变量模板，接受数个类型并表现为其中的最大对齐值
*/
template<class...Ts>
inline constexpr size_t max_align_of=max({alignof(Ts)...});
/*!
	功能: data_block辅助变量模板，接受数个类型并表现为其中的最大大小值
*/
template<class...Ts>
inline constexpr size_t max_size_of=max({sizeof(Ts)...});
/*!
	功能: data_block类模板,接受多个类型参数,实例化为内含最大体积最大对齐要求的byte数组的结构体
			data_block -> byte*
	用法: data_block<T1,T2,...>value;
*/
template<class...Ts>
struct data_block:non_copy_construct_able,non_move_construct_able{
	static constexpr size_t size=max_size_of<Ts...>;
	static constexpr size_t align=max_align_of<Ts...>;
	push_and_disable_msvc_warning(4324);
	alignas(align)byte _data[size];
	pop_msvc_warning();

	push_and_disable_msvc_warning(26495);
	force_inline constexpr data_block()noexcept{
		if in_consteval
			for(size_t i=0;i<size;++i)
				_data[i]=byte{};
	};
	template<class T> requires(sizeof(T)<=size&&alignof(T)<=align)
	force_inline constexpr data_block(T&&t)noexcept{
		data_cast<T>(_data)=forward<T>(t);
		if constexpr(sizeof(T)<size)
			if in_consteval
				for(size_t i=sizeof(T);i<size;++i)
					_data[i]=byte{};
	}
	pop_msvc_warning();
	force_inline constexpr operator byte*()noexcept{return _data;}
	force_inline constexpr operator const byte*()const noexcept{return _data;}
	template<class T> requires(sizeof(T)<=size&&alignof(T)<=align)
	force_inline constexpr auto&operator=(T&&t)noexcept{
		return data_cast<remove_cvref<T>>(_data)=forward<T>(t);
	}
	//begin & end
	force_inline constexpr byte*begin()noexcept{return _data;}
	force_inline constexpr byte*end()noexcept{return _data+size;}
	force_inline constexpr const byte*begin()const noexcept{return _data;}
	force_inline constexpr const byte*end()const noexcept{return _data+size;}
};
/*!
	功能: data_block辅助类模板，接受一个size_t描述对齐大小的类型模板
*/
template<class...Ts>
struct alignas(max_align_of<Ts...>)align_as_t{};

/*!
	功能: data_view类模板,接受一个类型参数，提供对byte数组的访问和遍历
	用法: data_view<T>value{&value};
*/
template<class T>
struct data_view:array_like_view_t<byte>{
	using array_like_view_t<byte>::array_like_view_t;
	constexpr data_view(T*p)noexcept:array_like_view_t<byte>{cast_to_data(p),sizeof(T)}{}
};
template<class T>
struct data_view<const T>:array_like_view_t<const byte>{
	using array_like_view_t<const byte>::array_like_view_t;
	constexpr data_view(const T*p)noexcept:array_like_view_t<const byte>{cast_to_data(p),sizeof(T)}{}
};

/*!
	功能: 比较两个类实例在内存中的内容是否相同
	用法: full_equal_in_byte(const T&a,const T&b) -> bool
*/
template<class T>
[[nodiscard]]constexpr bool full_equal_in_byte(const T&a,const T&b)noexcept{
	return equal(cast_to_data(&a),cast_to_data(&b),sizeof(T));
}

//file_end

#line 28 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/pointer.hpp"
//pointer.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

enable_adl(the_pointer_to_bool);
/// 指针转bool的重载接口，允许类对此进行自定义
/// elc内部的指针转bool应当视情况使用默认配置或此重载接口
template<typename T>
[[nodiscard]]constexpr auto pointer_to_bool(T*a)noexcept{
	if constexpr(was_not_an_ill_form(the_pointer_to_bool(a)))
		return the_pointer_to_bool(a);
	else
		return null_ptr!=a;
}

enable_adl(the_pointer_equal);
/// 指针比较的重载接口，允许类对此进行自定义
/// elc内部的指针比较应当视情况使用默认配置或此重载接口
template<typename T>
[[nodiscard]]constexpr auto pointer_equal(T*a,T*b)noexcept{
	if constexpr(was_not_an_ill_form(the_pointer_equal(a,b)))
		return the_pointer_equal(a,b);
	else
		return a==b;
}

/// 判断类型是否为指针
template<class T>
inline constexpr bool is_pointer= ::std::is_pointer_v<T>;
/// 未知类型指针
typedef void*pointer;
/// 未知类型指针，不可写
typedef const void*const_pointer;

/// 获取两个指针的偏移
[[nodiscard]]constexpr ptrdiff_t get_off_set(note::from_t<const_pointer>a,note::to_t<const_pointer>b)noexcept{
	return cast_to_data(b())-cast_to_data(a());//b-a == c
}
/// 应用偏移
template<class T>
[[nodiscard]]constexpr auto apply_off_set(T*a,ptrdiff_t c)noexcept{
	return cast_to_data(a)+c;//a+c == b
}
/// 反向应用偏移
template<class T>
[[nodiscard]]constexpr auto unapply_off_set(T*b,ptrdiff_t c)noexcept{
	return cast_to_data(b)-c;//b-c == a
}

//file_end

#line 29 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/hash.hpp"
//hash.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace hash_n{
	typedef size_t hash_base_t;
	struct hash_value_t{
		hash_base_t _value;
		constexpr hash_base_t operator%(auto&&a)const noexcept{
			return _value%a;
		}
		constexpr bool operator==(const hash_value_t&a)const noexcept{
			return _value==a._value;
		}
	};
	struct unstable_hash_value_t:hash_value_t{
		unstable_hash_value_t(const hash_value_t&a)noexcept:hash_value_t(a){}
	};

	template<class T>
	inline constexpr bool is_unstable_hash = type_info<T const>.can_convert_to<unstable_hash_value_t>;
	template<class T>
	inline constexpr bool is_fundamental_hash = ::std::is_fundamental_v<T>;

	enable_adl(the_pointer_hash);
	/*!
	Computes the hash value of a pointer.

	@param a The pointer to hash.

	@returns The hash value of the pointer.
	*/
	template<class T>
	[[nodiscard]]inline constexpr hash_value_t pointer_hash(T*a)noexcept{
		if constexpr(was_not_an_ill_form(the_pointer_hash(a)))
			return the_pointer_hash(a);
		else
			return{hash_base_t(a)};
	}

	inline struct hash_t{
	private:
		template<class T>
		[[nodiscard]]static inline constexpr bool nothrow_helper()noexcept{
			if constexpr(is_pointer<T>)
				return noexcept(pointer_hash(declvalue(const T&)));
			elseif constexpr(is_fundamental_hash<T>)
				return noexcept(hash_value_t{hash_base_t(declvalue(const T&))});
			elseif constexpr(is_unstable_hash<T>)
				return noexcept(unstable_hash_value_t(declvalue(const T&)));
			elseif constexpr(was_not_an_ill_form(declvalue(const T&).hash()))
				return noexcept(declvalue(const T&).hash());
			elseif constexpr(was_not_an_ill_form(hash_value_t(declvalue(const T&))))
				return noexcept(hash_value_t(declvalue(const T&)));
			elseif constexpr(type_info<remove_cv<T>> == type_info<base_type_info_t>)
				return true;
			else
				return false;
		}
	public:
		template<class T>
		static constexpr bool nothrow=nothrow_helper<T>();
	private:
		template<class T>
		[[nodiscard]]static inline constexpr bool able_helper()noexcept{
			if constexpr(is_pointer<T>)
				return true;
			elseif constexpr(is_fundamental_hash<T>)
				return true;
			elseif constexpr(is_unstable_hash<T>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(const T&).hash()))
				return true;
			elseif constexpr(was_not_an_ill_form(hash_value_t(declvalue(const T&))))
				return true;
			elseif constexpr(type_info<remove_cv<T>> == type_info<base_type_info_t>)
				return true;
			else
				return false;
		}
	public:
		template<class T>
		static constexpr bool able=able_helper<T>();

		#define hash operator()

		/*!
		Computes the hash value of `nothing`.

		@returns The hash value of `nothing`.
		*/
		[[nodiscard]]inline constexpr hash_value_t hash(nothing)const noexcept{
			return{hash_base_t(nothing)};
		}
		/*!
		Computes the hash value of a base_type_info_t object.

		@param a The base_type_info_t object to hash.

		@returns The hash value of the object.
		*/
		[[nodiscard]]inline hash_value_t hash(const base_type_info_t&a)const noexcept{
			return{a.get_hash()};
		}
		/*!
		Computes the hash value of a value.

		@param a The value to hash.

		@returns The hash value of the value.
		*/
		template<class T> requires able<T>
		[[nodiscard]]constexpr_as_auto inline auto hash(const T&a)const noexcept(nothrow<T>){
			#undef hash
			if constexpr(is_pointer<T>)
				return pointer_hash(a);
			elseif constexpr(is_fundamental_hash<T>)
				return hash_value_t{hash_base_t(a)};
			elseif constexpr(is_unstable_hash<T>)
				return unstable_hash_value_t(a);
			elseif constexpr(was_not_an_ill_form(declvalue(const T&).hash()))
				return a.hash();
			elseif constexpr(was_not_an_ill_form(hash_value_t(declvalue(const T&))))
				return hash_value_t(a);
			else{
				template_error("Please overload the function hash in the namespace where this type is defined.");
				return hash_value_t{};
			}
			#define hash operator()
		}
		/*!
		Computes the hash of a value in the base type.

		@param a The value to hash.

		@returns The hash of the value in the base type.
		*/
		template<class T>
		[[nodiscard]]constexpr_as_auto inline hash_base_t get_hash_in_base_type(const T&a)const noexcept(nothrow<T>){
			return hash(a)._value;
		}
		/*!
		从某个起始点算起的hash

		@param before The hashed value before this hash.
		@param before_size The size of the hashed value before this hash.
		@param a The sequence of values.
		@param size The number of values in the sequence.

		@returns The hash value of the sequence.
		*/
		template<class T>
		[[nodiscard]]force_inline constexpr hash_value_t with_calculated_before(hash_value_t before,size_t before_size,const T*a,size_t size)const noexcept{
			hash_base_t aret=before._value;
			rot_iterator<decltype(aret)>rotl_offset = before_size+size;
			while(size--){
				aret ^= rotl(get_hash_in_base_type(a[size]),rotl_offset);
				rotl_offset--;
			}
			return{aret};
		}
		/*!
		计算此hash重复N次的数组的hash结果

		@param value The hash value to repeat.
		@param size The number of times to repeat the hash value.

		@returns The repeated hash value.
		*/
		[[nodiscard]]force_inline constexpr hash_value_t repeat_times(hash_value_t value,size_t size)const noexcept{
			hash_base_t aret=0;
			{
				//优化.
				//关於此,咱确信咱发现一种美妙的证法来保证这个优化不影响结果,但可惜凋可怜的脑容量不足以让他看懂.
				constexpr size_t bit_range_max=bitnum_of(hash_base_t);
				constexpr hash_base_t void_hash{nothing};
				suppress_msvc_warning(26475)//强制转换警告diss.
				constexpr hash_base_t npos_hash{hash_base_t(-1)};
				constexpr size_t bitnumof_void=bit_range_max*BIT_POSSIBILITY;

				size=size%bitnumof_void;
				if(value._value==0 || size==0)
					return{void_hash};
				if(size >= bit_range_max){
					const bool is_npos = ::std::popcount(value._value)%BIT_POSSIBILITY;
					aret = is_npos?npos_hash:void_hash;
					size-=bit_range_max;
				}
				if(!size)
					return{aret};
			}
			rot_iterator<decltype(aret)>rotl_offset = size;
			while(size--){
				aret ^= rotl(value._value,rotl_offset);
				rotl_offset--;
			}
			return{aret};
		}
		/*!
		计算此hash重复N次的数组的hash结果

		@param value The hash value to repeat.
		@param size The number of times to repeat the hash value.

		@returns The repeated hash value.
		*/
		template<class T>
		[[nodiscard]]force_inline constexpr hash_value_t repeat_times(T&&value,size_t size)const noexcept{
			return repeat_times(hash(value),size);
		}
		/*!
		Computes the hash value of an array of elements.

		@param a The array of elements.
		@param size The size of the array.

		@returns The hash value of the array.
		*/
		template<class T>
		[[nodiscard]]inline constexpr hash_value_t hash(const T*a,size_t size)const noexcept(nothrow<const T>){
			return with_calculated_before(hash(nothing),0,a,size);
		}
		/*!
		合并两个数据段的hash结果，好似计算这两个数据段合并后的hash结果一般

		@param before The first hash value.
		@param before_size The size of the first hash value.
		@param after The second hash value.
		@param after_size The size of the second hash value.

		@returns The merged hash value.
		*/
		[[nodiscard]]force_inline hash_value_t merge_array_hash_results(
			hash_value_t before,size_t before_size,hash_value_t after,[[maybe_unused]]size_t after_size
		)const noexcept{
			return{before._value^(rotl(after._value,before_size))};
		}
		/*!
		计算一个 array_like_view_t<T> 对象的哈希值。
		@param a array_like_view_t<T> 对象。

		@returns array_like_view_t<T> 对象的哈希值。
		*/
		template<class T> requires is_not_signal_value_for_array_like<T>
		[[nodiscard]]inline constexpr hash_value_t hash(const array_like_view_t<T>a)const noexcept(nothrow<T>){
			return hash(a.begin(),a.size());
		}
		/*!
		计算一个 array_like_view_t<T> 对象的哈希值，并在哈希值之前进行计算。

		@param before 用来作为计算基础的哈希值。
		@param before_size 用来作为计算基础的哈希值的大小。
		@param a 要计算哈希值的 array_like_view_t<T> 对象。

		@returns array_like_view_t<T> 对象的哈希值。
		*/
		template<class T> requires is_not_signal_value_for_array_like<T>
		[[nodiscard]]inline constexpr hash_value_t with_calculated_before(hash_value_t before,size_t before_size,const array_like_view_t<T>a)const noexcept{
			return with_calculated_before(before,before_size,a.begin(),a.size());
		}

		#undef hash

	}hash{};
}
typedef hash_n::hash_value_t hash_t;
typedef hash_n::unstable_hash_value_t unstable_hash_t;
using hash_n::is_unstable_hash;
using hash_n::is_fundamental_hash;
using hash_n::hash;

//file_end

#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/range.hpp"
//range.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace range_n{
	//  range_t
	/// 用以表示某类型的数值范围，仅可表示闭区间
	template<typename T>
	struct range_t{
		T _begin,_end;
		//_begin<=_end
		constexpr range_t(const T begin,const T end):_begin(begin),_end(end){}
		constexpr range_t(note::from_t<const T>begin,note::to_t<const T>end):_begin(begin),_end(end+1){}
		constexpr range_t(note::to_t<const T>end,note::from_t<const T>begin):_begin(begin),_end(end+1){}
		constexpr range_t(const T begin,note::size_t<const T>size):_begin(begin),_end(begin+size()){}
		constexpr range_t(const T begin,note::size_t<size_t>size):_begin(begin),_end(begin+size()){}

		constexpr size_t size()noexcept{return _end-_begin;}
		constexpr auto end()noexcept{return _end;}
		constexpr auto begin()noexcept{return _begin;}
		constexpr auto end()const noexcept{return _end;}
		constexpr auto begin()const noexcept{return _begin;}

		template <class U> requires(type_info<T>.can_convert_to<U>)
		constexpr operator range_t<U>()const noexcept(type_info<T>.can_nothrow_convert_to<U>){
			return{_begin,_end};
		}
	};

	template<class T>
	[[nodiscard]]inline auto size_of_array_like(range_t<T*>&a)noexcept{return a.size();}
	template<class T>
	[[nodiscard]]inline auto size_of_array_like(range_t<const T*>&a)noexcept{return a.size();}

	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(range_t<T*>&a)noexcept{return a.begin();}
	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(range_t<const T*>&a)noexcept{return a.begin();}

	//  in_range
	/// 判断一个值是否在某个范围内
	template<typename T>
	[[nodiscard]]constexpr bool in_range(T pattern,const range_t<T>range)noexcept_as(bool(declvalue(T)>=declvalue(const T) && declvalue(T)<=declvalue(const T))){//算术类型或指针
		return bool(pattern>=range.begin() && pattern<range.end());
	}
	//  in_range
	/// 判断一个指针是否在某个byte指针范围内
	template<typename T>
	[[nodiscard]]constexpr bool in_range(T*pattern,const range_t<byte*>range)noexcept{
		return cast_to_data(pattern)>=range.begin() && cast_to_data(pattern)<range.end();
	}
	//  match_pattern
	/// sunday算法表头，用以实施头起始的快速子串匹配算法
	/// 大部分情况下应当编译时预构建或对运行时生成的实例进行缓存
	template<typename T>
	struct match_pattern{
		array_like_view_t<T>_pattern;
		typedef unsigned char index_type;

		size_t skip_table[number_of_possible_values_per<index_type>]{};

		static constexpr index_type get_index_of(T&ch)noexcept{
			return index_type(hash(ch) % number_of_possible_values_per<index_type>);
		}
		constexpr void build_table(const array_like_view_t<T>&pattern)noexcept{
			const size_t m=pattern.size();
			if(!m)
				return;
			for(size_t i=0;i<number_of_possible_values_per<index_type>;i++)
				skip_table[i]=m+1;
			for(size_t i=0;i<m;i++)
				skip_table[get_index_of(pattern[i])]=m-i;
		}
		constexpr match_pattern(const array_like_view_t<T>&pattern)noexcept:_pattern(pattern){
			build_table(_pattern);
		}
		[[nodiscard]]constexpr T* match(const array_like_view_t<T>&range)const noexcept{
			size_t off_set=0;
			size_t matching_off_set=1;

			floop{
				matching_off_set=1;
				while(_pattern.end()[0-matching_off_set]==range.begin()[off_set+_pattern.size()-matching_off_set])
					if(matching_off_set==_pattern.size())
						return addressof(range.begin()[off_set]);
					else
						matching_off_set++;
				if(off_set+_pattern.size() >= range.size())
					return nullptr;
				off_set+=skip_table[get_index_of(range.begin()[off_set+_pattern.size()])];
			}
		}
	};
	//  reverse_match_pattern
	/// 反向Sunday算法表头，用以实施尾起始的快速子串匹配算法
	/// 大部分情况下应当编译时预构建或对运行时生成的实例进行缓存
	template<typename T>
	struct reverse_match_pattern{
		array_like_view_t<T>_pattern;
		typedef unsigned char index_type;

		size_t skip_table[number_of_possible_values_per<index_type>]{};

		static constexpr index_type get_index_of(T&ch)noexcept{
			return index_type(hash(ch) % number_of_possible_values_per<index_type>);
		}
		constexpr void build_table(const array_like_view_t<T>&pattern)noexcept{
			const size_t m=pattern.size();
			if(!m)
				return;
			for(size_t i=0;i<number_of_possible_values_per<index_type>;i++)
				skip_table[i]=m+1;
			for(size_t i=0;i<m-1;i++)
				skip_table[get_index_of(pattern[i])]=i;
		}
		constexpr reverse_match_pattern(const array_like_view_t<T>&pattern)noexcept:_pattern(pattern){
			build_table(_pattern);
		}
		[[nodiscard]]constexpr T* match(const array_like_view_t<T>&range)const noexcept{
			size_t off_set=0;
			size_t matching_off_set=0;

			floop{
				matching_off_set=0;
				while(_pattern.begin()[matching_off_set]==range.end()[0-(off_set+_pattern.size()-matching_off_set)])
					if(matching_off_set==_pattern.size()-1)
						return addressof(range.end()[0-(off_set+_pattern.size())]);
					else
						matching_off_set++;
				if(off_set+_pattern.size() >= range.size())
					return nullptr;
				off_set+=skip_table[get_index_of(range.end()[0-(off_set+_pattern.size()+1)])];
				off_set++;
			}
		}
	};
	suppress_msvc_warning(26475)//强制转换警告diss
	//  npos
	/// 用以指定不存在的位置
	static constexpr size_t npos = size_t(-1);
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* in_range(const remove_cvref<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range){
			if(i==pattern)
				return addressof(i);
		}
		return nullptr;
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_size_t(const remove_cvref<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* in_range_but_reverse(const remove_cvref<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range|::std::views::reverse){
			if(i==pattern)
				return addressof(i);
		}
		return nullptr;
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_but_reverse_size_t(const remove_cvref<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range_but_reverse(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// 若成功找到匹配的数据串，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard,deprecated("cache match_pattern and don't waste it")]]
	constexpr T* in_range(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		match_pattern tmp=pattern;
		return tmp.match(range);
	}
	/// 若成功找到匹配的数据串，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	//  反向数据串匹配by steve02081504.
	/// 若成功找到匹配的数据串，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard,deprecated("cache match_pattern and don't waste it")]]
	constexpr T* in_range_but_reverse(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		reverse_match_pattern tmp = pattern;
		return tmp.match(range);
	}
	/// 若成功找到匹配的数据串，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_but_reverse_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range_but_reverse(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}

	//  bitmark_for_finds
	/// bitmark提供了一种快速进行四种泛搜索的实现，前提是构建中的pattern中的每一项的usigned表示都在一个字节（表长）内。
	/// 若bitmark构建失败，程序应当使用正在进行的泛搜索的朴素实现版本。
	template<typename T>
	struct bitmark_for_finds {
		typedef unsigned char index_type;
		bool _bitmark[number_of_possible_values_per<index_type>]{};

		bitmark_for_finds()noexcept=default;
		[[nodiscard]]constexpr bool mark(const array_like_view_t<T>&pattern)noexcept{
			if constexpr(number_of_possible_values_per<T> > number_of_possible_values_per<index_type>){
				for(auto& i: pattern){
					if(::std::make_unsigned_t<T>(i) >= number_of_possible_values_per<index_type>)
						return false;
					_bitmark[index_type(i)] = true;
				}
			}
			else{
				for(auto& i: pattern)
					_bitmark[index_type(i)] = true;
			}
			return true;
		}
		[[nodiscard]]constexpr bool operator[](T&index)const noexcept{
			if constexpr(number_of_possible_values_per<T> > number_of_possible_values_per<index_type>)
				if(::std::make_unsigned_t<T>(index) >= number_of_possible_values_per<index_type>)
					return false;
			return _bitmark[index_type(index)];
		}
	};
	/// find_first_of的bitmark实现
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_of_bitmark(const bitmark_for_finds<T>&mark,const array_like_view_t<T>&range){
		for(auto&i : range){
			if(mark[i])
				return addressof(i);
		}
		return nullptr;
	}
	/// find_first_of的朴素实现
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* base_find_first_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range){
			if(in_range(i,pattern))
				return addressof(i);
		}
		return nullptr;
	}
	//  find_first_of
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		if constexpr(::std::is_integral_v<T>){
			bitmark_for_finds<T> mark;
			if(mark.mark(pattern))
				return find_first_of_bitmark(mark,range);
		}
		return base_find_first_of(pattern,range);
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_first_of_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_first_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// find_last_of的bitmark实现
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_of_bitmark(const bitmark_for_finds<T>&mark,const array_like_view_t<T>&range){
		for(auto& i: range|::std::views::reverse){
			if(mark[i])
				return addressof(i);
		}
	}
	/// find_last_of的朴素实现
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* base_find_last_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range|::std::views::reverse){
			if(in_range(i,pattern))
				return addressof(i);
		}
		return nullptr;
	}
	//  find_last_of
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		if constexpr(::std::is_integral_v<T>){
			bitmark_for_finds<T> mark;
			if(mark.mark(pattern))
				return find_last_of_bitmark(mark,range);
		}
		return base_find_last_of(pattern,range);
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_last_of_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_last_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// find_first_not_of的bitmark实现
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_not_of_bitmark(const bitmark_for_finds<T>&mark,const array_like_view_t<T>&range){
		for(auto& i: range){
			if(!mark[i])
				return addressof(i);
		}
		return nullptr;
	}
	/// find_first_not_of的朴素实现
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* base_find_first_not_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range){
			if(!in_range(i,pattern))
				return addressof(i);
		}
		return nullptr;
	}
	//  find_first_not_of
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_not_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		if constexpr(::std::is_integral_v<T>){
			bitmark_for_finds<T> mark;
			if(mark.mark(pattern))
				return find_first_not_of_bitmark(mark,range);
		}
		return base_find_first_not_of(pattern,range);
	}
	/// 若成功找到不匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_first_not_of_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_first_not_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
	/// find_last_not_of的bitmark实现
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of_bitmark(const bitmark_for_finds<T>&mark,const array_like_view_t<T>&range){
		for(auto& i: range|::std::views::reverse){
			if(!mark[i])
				return addressof(i);
		}
		return nullptr;
	}
	/// find_last_not_of的朴素实现
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* base_find_last_not_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		for(auto&i : range|::std::views::reverse){
			if(!in_range(i,pattern))
				return addressof(i);
		}
		return nullptr;
	}
	//  bitmark_for_quick_unindex
	/// bitmark提供了一种快速进行反索引的实现，前提是构建中的pattern中的每一项的usigned表示都在一个字节（表长）内。
	/// 若bitmark构建失败，程序应当使用正在进行的反索引的朴素实现版本。
	template<typename T>
	struct bitmark_for_quick_unindex {
		typedef unsigned char index_type;
		size_t _bitmark[number_of_possible_values_per<index_type>]{};

		constexpr void bitmark_data_initer(size_t init_to)noexcept{
			for(auto& i:_bitmark)
				i=init_to;
		}

		bitmark_for_quick_unindex()noexcept=default;
		[[nodiscard]]constexpr bool mark(const array_like_view_t<T>&pattern)noexcept{
			bitmark_data_initer(npos);
			#define failed bitmark_data_initer(npos),false
			if constexpr(number_of_possible_values_per<T> > number_of_possible_values_per<index_type>){
				size_t i=0;
				const size_t end=pattern.size();
				while(i<end){
					auto&ch=pattern[i];
					if(::std::make_unsigned_t<T>(ch) >= number_of_possible_values_per<index_type>)
						return failed;
					auto&index=_bitmark[index_type(ch)];
					if(index!=npos)
						return failed;
					index=i;
					i++;
				}
			}
			else{
				size_t i=0;
				const size_t end=pattern.size();
				while(i<end){
					auto&ch=pattern[i];
					auto&index=_bitmark[index_type(ch)];
					if(index!=npos)
						return failed;
					index=i;
					i++;
				}
			}
			#undef failed
			return true;
		}
		[[nodiscard]]constexpr size_t operator[](T&index)const noexcept{
			if constexpr(number_of_possible_values_per<T> > number_of_possible_values_per<index_type>)
				if(::std::make_unsigned_t<T>(index) >= number_of_possible_values_per<index_type>)
					return npos;
			return _bitmark[index_type(index)];
		}
	};
	//  find_last_not_of
	/// 若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		if constexpr(::std::is_integral_v<T>){
			bitmark_for_finds<T> mark;
			if(mark.mark(pattern))
				return find_last_not_of_bitmark(mark,range);
		}
		return base_find_last_not_of(pattern,range);
	}
	/// 若成功找到不匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_last_not_of_size_t(const array_like_view_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_last_not_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
}
using range_n::range_t;
using range_n::in_range;
using range_n::in_range_size_t;
using range_n::in_range_but_reverse;
using range_n::in_range_but_reverse_size_t;
using range_n::find_first_of;
using range_n::find_last_of;
using range_n::find_first_not_of;
using range_n::find_last_not_of;

//file_end

#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/string_view.hpp"
//string_view.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//仅是声明
namespace constexpr_str_n {
	template<typename char_T>
	struct constexpr_str_t;
}
using constexpr_str_n::constexpr_str_t;
//重载range操作
//仅是声明以及size_t包装
namespace range_n {
	template<typename T>
	[[nodiscard]]constexpr T* in_range(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* in_range_but_reverse(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_but_reverse_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = in_range_but_reverse(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* find_first_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_first_of_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_first_of(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* find_last_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_last_of_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_last_of(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* find_first_not_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到不匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t find_first_not_of_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_first_not_of(pattern, range);
		if(result)
			return result - range.data();
		else
			return npos;
	}
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range);
	//若成功找到不匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of_size_t(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		auto result = find_last_not_of(pattern,range);
		if(result)
			return result - range.begin();
		else
			return npos;
	}
}
//开始定义
namespace string_view_n{
	/// array_like_view_t的特化类型，表明这是字符串
	template<typename char_T>
	struct string_view_t:array_like_view_t<const char_T>{
		static constexpr size_t npos=range_n::npos;
		typedef array_like_view_t<const char_T> base_t;
		typedef char_T*string_ptr_t;
		typedef const char_T*const_string_ptr_t;
		//构造函数
		using base_t::base_t;
		constexpr string_view_t(const_string_ptr_t str)noexcept:string_view_t(array_end_by_zero_t<const char_T>(str)){}
		//成员函数
		[[nodiscard]]constexpr const char_T*str()const noexcept{return base_t::cbegin();}
		[[nodiscard]]constexpr const char_T*data()const noexcept{return base_t::cbegin();}
		[[nodiscard]]constexpr operator const char_T*()const noexcept{return str();}
		//substr
		[[nodiscard]]constexpr string_view_t substr(size_t pos,size_t len)const noexcept{
			return string_view_t(base_t::cbegin()+pos,len);
		}
		[[nodiscard]]constexpr string_view_t substr(size_t pos)const noexcept{
			return string_view_t(base_t::cbegin()+pos,base_t::size()-pos);
		}
		[[nodiscard]]constexpr string_view_t substr(size_t pos,const char_T*end)const noexcept{
			return string_view_t(base_t::cbegin()+pos,end-base_t::cbegin());
		}
		[[nodiscard]]constexpr string_view_t substr(const char_T*begin,size_t len)const noexcept{
			return string_view_t(begin,len);
		}
		[[nodiscard]]constexpr string_view_t substr(const char_T*begin)const noexcept{
			return string_view_t(begin,base_t::cend()-begin);
		}
		[[nodiscard]]constexpr string_view_t substr(const char_T*begin,const char_T*end)const noexcept{
			return string_view_t(begin,end-begin);
		}
		//find
		[[nodiscard]]constexpr size_t find(const char_T ch)const{
			return in_range_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t reverse_find(const char_T ch)const{
			return in_range_but_reverse_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t find(string_view_t str)const{
			return in_range_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t reverse_find(string_view_t str)const{
			return in_range_but_reverse_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find(const constexpr_str_t<char_T>&str)const{
			return in_range_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t reverse_find(const constexpr_str_t<char_T>&str)const{
			return in_range_but_reverse_size_t(str, *this);
		}
		//others by range_n::find_last_of_size_t etc
		[[nodiscard]]constexpr size_t find_first_of(const char_T ch)const{
			return range_n::find_first_of_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t find_last_of(const char_T ch)const{
			return range_n::find_last_of_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t find_first_not_of(const char_T ch)const{
			return range_n::find_first_not_of_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t find_last_not_of(const char_T ch)const{
			return range_n::find_last_not_of_size_t(ch, *this);
		}
		[[nodiscard]]constexpr size_t find_first_of(string_view_t str)const{
			return range_n::find_first_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_last_of(string_view_t str)const{
			return range_n::find_last_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_first_not_of(string_view_t str)const{
			return range_n::find_first_not_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_last_not_of(string_view_t str)const{
			return range_n::find_last_not_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_first_of(const constexpr_str_t<char_T>&str)const{
			return range_n::find_first_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_last_of(const constexpr_str_t<char_T>&str)const{
			return range_n::find_last_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_first_not_of(const constexpr_str_t<char_T>&str)const{
			return range_n::find_first_not_of_size_t(str, *this);
		}
		[[nodiscard]]constexpr size_t find_last_not_of(const constexpr_str_t<char_T>&str)const{
			return range_n::find_last_not_of_size_t(str, *this);
		}
	};
	typedef string_view_t<char_t>string_view;
}
using string_view_n::string_view_t;
using string_view_n::string_view;

//file_end

#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/type_name.hpp"
//type_name.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
struct type_name_t:string_view_t<char>{
	//对于gcc和clang，这个类型有一个malloced的char*，以便于在析构时释放
	//一切源于abi::__cxa_demangle
	//对于msvc，这个类型析构时不需要做任何事情
	typedef string_view_t<char> base_t;
	/// 重整器包装
	static base_t demangle(const char*original_name)noexcept{
		push_and_disable_msvc_warning(26494);//未初始化警告diss
		size_t len;
		const char*demangled_name;
		pop_msvc_warning();
		#if defined(__clang__)||defined(__GNUC__)
			//gcc和clang
			//使用abi::__cxa_demangle重整
			int status;
			demangled_name=::abi::__cxa_demangle(original_name,nullptr,&len,&status);
			if(status!=0){
				demangled_name=original_name;
				len=::std::strlen(original_name);
				::std::free((void*)demangled_name);
			}
		#else
			//msvc
			//不需要重整
			demangled_name=original_name;
			len=::std::strlen(original_name);
		#endif
		return base_t{demangled_name,len};
	}
	/// 复制重整结果
	static base_t copy_demangle(base_t demangled_name)noexcept{
		#if defined(__clang__)||defined(__GNUC__)
			//gcc和clang
			//需要复制重整结果（用malloced的char*）
			char*copyed_name=(char*)::std::malloc(demangled_name.size()+1);
			if(copyed_name==nullptr)
				return base_t{nullptr,0};
			::std::memcpy(copyed_name,demangled_name.data(),demangled_name.size());
			copyed_name[demangled_name.size()]='\0';
			return base_t{copyed_name,demangled_name.size()};
		#else
			//msvc
			//不需要复制重整结果
			return demangled_name;
		#endif
	}
	/// 构造函数
	type_name_t(const char*original_name)noexcept:base_t(demangle(original_name)){}
	/// 复制构造函数
	type_name_t(const type_name_t&other)noexcept:base_t(copy_demangle(other)){}
	/// 移动构造函数（swap）
	type_name_t(type_name_t&&other)noexcept:base_t(nullptr,0){
		swap_with(other);
	}
	/// 析构函数
	~type_name_t()noexcept{
		#if defined(__clang__)||defined(__GNUC__)
			//gcc和clang
			//需要释放malloced的char*
			::std::free((void*)begin());
		#endif
	}
};
[[nodiscard]]inline type_name_t base_type_info_t::get_name()const noexcept{
	return _tid.get_name();
}
[[nodiscard]]inline type_name_t base_type_info_t::type_id_t::get_name()const noexcept{
	return _m->name();
}
template<typename T>
[[nodiscard]]inline type_name_t type_info_t<T>::get_name()const noexcept{
	return base_type_info_t(*this).get_name();
}

//file_end

#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/constexpr_str.hpp"
//constexpr_str.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace constexpr_str_n{
	/// constexpr_str_t的退化类型，表明这是常量字符串，但没有可用的额外信息
	template<typename char_T>
	struct constexpr_str_view_t:string_view_t<char_T>{
		typedef string_view_t<char_T> base_t;
		using base_t::base_t;
		using base_t::string_ptr_t;
		using base_t::const_string_ptr_t;
		constexpr_str_view_t(const_string_ptr_t str)noexcept=delete;
		//成员函数
		[[nodiscard]]constexpr const_string_ptr_t str()const noexcept{return base_t::cbegin();}
		[[nodiscard]]constexpr const_string_ptr_t data()const noexcept{return base_t::cbegin();}
		[[nodiscard]]constexpr operator const_string_ptr_t ()const noexcept{return str();}
		//substr
		[[nodiscard]]constexpr constexpr_str_view_t substr(size_t pos,size_t len)const noexcept{
			return base_t::substr(pos,len);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(size_t pos)const noexcept{
			return base_t::substr(pos);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(size_t pos,const char_T*end)const noexcept{
			return base_t::substr(pos,end);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(const char_T*begin,size_t len)const noexcept{
			return base_t::substr(begin,len);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(const char_T*begin)const noexcept{
			return base_t::substr(begin);
		}
		[[nodiscard]]constexpr constexpr_str_view_t substr(const char_T*begin,const char_T*end)const noexcept{
			return base_t::substr(begin,end);
		}
	};
	/// 告知其他elc库接口这是编译时常量字符串，并提供编译时计算好的内容，包括但不限于hash、bmh头、bitmark等，用于加速库操作
	template<typename char_T>
	struct constexpr_str_t:constexpr_str_view_t<char_T>{
		typedef constexpr_str_view_t<char_T> base_t;
		typedef char_T*string_ptr_t;
		typedef const char_T*const_string_ptr_t;
		hash_t hash_result;
		range_n::match_pattern<const char_T> match_pattern;
		range_n::reverse_match_pattern<const char_T> reverse_match_pattern;
		range_n::bitmark_for_finds<const char_T> bitmark_for_finds;
		range_n::bitmark_for_quick_unindex<const char_T> bitmark_for_unindex;
		bool is_bitmark_workable;
		bool is_bitmark_for_unindex_workable=0;
		constexpr constexpr_str_t(const_string_ptr_t str, size_t size):
			base_t(str, size),
			hash_result(defs::hash(str, size)),
			match_pattern(array_like_view_t<const char_T>{str, size}),
			reverse_match_pattern(array_like_view_t<const char_T>{str, size}){
				is_bitmark_workable = bitmark_for_finds.mark(*this);
				if(is_bitmark_workable)
					is_bitmark_for_unindex_workable=bitmark_for_unindex.mark(*this);
			}
		constexpr constexpr_str_t(const_string_ptr_t str):constexpr_str_t(str,array_end_by_zero_t::get_length_of(str)){}
		[[nodiscard]]constexpr hash_t hash()const noexcept{return hash_result;}
	};
	template<class char_T,size_t N>
	struct constexpr_str_t_literal_helper{
		typedef char_T*string_ptr_t;
		typedef const char_T*const_string_ptr_t;
		const_string_ptr_t _array_begin;
		constexpr constexpr_str_t_literal_helper(const char_T(&str)[N])noexcept{
			_array_begin=str;
		}
		[[nodiscard]]constexpr auto get_constexpr_str_t()const noexcept{
			return constexpr_str_t{_array_begin,N-1};
		}
	};
	template<constexpr_str_t_literal_helper v>
	struct literal_result_provider {
		distinctive static constexpr auto value = v.get_constexpr_str_t();
	};
	//别问，问就是傻逼c++
	/// 告知其他elc库接口这是编译时常量字符串，并提供编译时计算好的内容，包括但不限于hash、bmh头、bitmark等，用于加速库操作
	template<constexpr_str_t_literal_helper str_helper>
	[[nodiscard]]inline consteval auto& operator ""_constexpr_str()noexcept{
		return literal_result_provider<str_helper>::value;
	}
	/// 空字串常量且str或begin会指向一个0终止字符串（而不是nullptr），便于安全初始化
	template<class char_T>
	distinctive inline constexpr auto empty_constexpr_str_of = constexpr_str_t(&const_default_value_of<char_T>,0);
};
using constexpr_str_n::constexpr_str_view_t;
using constexpr_str_n::constexpr_str_t;
using constexpr_str_n::empty_constexpr_str_of;
using constexpr_str_n::operator ""_constexpr_str;

//重载range操作
namespace range_n {
	template<typename T>
	[[nodiscard]]constexpr T* in_range(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		return pattern.match_pattern.match(range);
	}
	template<typename T>
	[[nodiscard]]constexpr T* in_range_but_reverse(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		return pattern.reverse_match_pattern.match(range);
	}
	//find_first_of
	//若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		if(pattern.is_bitmark_workable)
			return find_first_of_bitmark(pattern.bitmark_for_finds,range);
		else
			return find_first_of((const constexpr_str_view_t<T>&)pattern,range);
	}
	//find_last_of
	//若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		if(pattern.is_bitmark_workable)
			return find_last_of_bitmark(pattern.bitmark_for_finds,range);
		else
			return find_last_of((const constexpr_str_view_t<T>&)pattern,range);
	}
	//find_first_not_of
	//若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_first_not_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		if(pattern.is_bitmark_workable)
			return find_first_not_of_bitmark(pattern.bitmark_for_finds,range);
		else
			return find_first_not_of((const constexpr_str_view_t<T>&)pattern,range);
	}
	//find_last_not_of
	//若成功找到不匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr T* find_last_not_of(const constexpr_str_t<T>&pattern,const array_like_view_t<T>&range){
		if(pattern.is_bitmark_workable)
			return find_last_not_of_bitmark(pattern.bitmark_for_finds,range);
		else
			return find_last_not_of((const constexpr_str_view_t<T>&)pattern,range);
	}

	// 单字匹配相关

	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr const T* in_range(const remove_cvref<T>&pattern,const constexpr_str_t<T>&range){
		if(range.is_bitmark_for_unindex_workable){
			auto result = range.bitmark_for_unindex[pattern];
			return result==range_n::npos?nullptr:range.begin()+result;
		}
		else
			return in_range(pattern,(const constexpr_str_view_t<T>&)range);
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_size_t(const remove_cvref<T>&pattern,const constexpr_str_t<T>&range){
		if(range.is_bitmark_for_unindex_workable)
			return range.bitmark_for_unindex[pattern];
		else
			return in_range_size_t(pattern,(const constexpr_str_view_t<T>&)range);
	}
	/// 若成功找到匹配的数据项，返回其开头，若未找到，返回nullptr
	template<typename T>
	[[nodiscard]]constexpr const T* in_range_but_reverse(const remove_cvref<T>&pattern,const constexpr_str_t<T>&range){
		if(range.is_bitmark_for_unindex_workable){
			auto result = range.bitmark_for_unindex[pattern];
			return result==range_n::npos?nullptr:range.begin()+result;
		}
		else
			return in_range_but_reverse(pattern,(const constexpr_str_view_t<T>&)range);
	}
	/// 若成功找到匹配的数据项，返回其距离开头的步数，若未找到，返回npos
	template<typename T>
	[[nodiscard]]constexpr size_t in_range_but_reverse_size_t(const remove_cvref<T>&pattern,const constexpr_str_t<T>&range){
		if(range.is_bitmark_for_unindex_workable)
			return range.bitmark_for_unindex[pattern];
		else
			return in_range_but_reverse_size_t(pattern,(const constexpr_str_view_t<T>&)range);
	}
};
using range_n::in_range;
using range_n::in_range_size_t;
using range_n::in_range_but_reverse;
using range_n::in_range_but_reverse_size_t;
using range_n::find_first_of;
using range_n::find_last_of;
using range_n::find_first_not_of;
using range_n::find_last_not_of;

//file_end

#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/logical_bool.hpp"
//logic.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

/*! 混沌布尔值。
	允许输出介于真假之间的内容的布尔值。
	混沌布尔值会有五个可能的值，分别为true,false,neither,either。unknown视为不合法。
	用在if与while中时，true，either被判定为真，其与均为假。
	用法：
	logical_bool(bool)		输出logical_bool,将布尔值转换为混沌布尔值。
	bool(logical_bool)		输出bool，将混沌布尔值转化为布尔值。
	允许与或非运算：输出结果仍然为混沌布尔值,参与运算的值如果有unknown则均输出unknown.
	允许判定相等，输出结果为混沌布尔值,参与运算的值如果有unknown则均输出unknown，否则仅有true和false两个合法值。
*/
/*
	在 虚伪 的 信 念 之 前 - 他 们 将 三 元 论 视 为 真理
	所 有 的 东西 都 是 三 部 分 。
	从 那里 ， 他 们 终于 获得 了 答案 。
*/
struct logical_bool{
private:
	[[no_unique_address]]bool _is_true;
	[[no_unique_address]]bool _is_false;
	[[no_unique_address]]bool _is_unknown;
public:
	constexpr logical_bool(special_init_t,bool is_true,bool is_false,bool is_unknown=0)noexcept:_is_true(is_true),_is_false(is_false),_is_unknown(is_unknown){}
	constexpr logical_bool(bool a)noexcept:_is_true(a),_is_false(!a),_is_unknown(0){}
	constexpr logical_bool(const logical_bool&)noexcept=default;
	constexpr logical_bool&operator=(const logical_bool&)&noexcept=default;
	constexpr explicit operator bool()const noexcept{return _is_true && !_is_unknown;}
	constexpr logical_bool operator!()const noexcept{
		logical_bool aret=*this;
		swap(aret._is_true,aret._is_false);
		return aret;
	}
	friend logical_bool operator&&(logical_bool a,logical_bool b)noexcept{
		return logical_bool{special_init,a._is_true && b._is_true,a._is_false || b._is_false,a._is_unknown || b._is_unknown};
	}
	friend logical_bool operator||(logical_bool a,logical_bool b)noexcept{
		return logical_bool{special_init,a._is_true || b._is_true,a._is_false && b._is_false,a._is_unknown || b._is_unknown};
	}
	friend logical_bool operator==(logical_bool a,logical_bool b)noexcept{
		logical_bool aret(a._is_true == b._is_true && a._is_false == b._is_false);
		aret._is_unknown = a._is_unknown || b._is_unknown;
		return aret;
	}
};
constexpr logical_bool neither{special_init,0,0},either{special_init,1,1},unknown{special_init,0,0,1};

//file_end

#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/zero.hpp"
//zero.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*!
没什么用的语法糖,等价于字面量0.
*/
constexpr struct zero_t{
	template<class T> requires(type_info<decltype(0)>.can_convert_to<T>)
	operator T()const noexcept(type_info<decltype(0)>.can_nothrow_convert_to<T>){return 0;}
}zero{};

/*!
Returns true if all bytes in the input are zero.

@param a The input value.

@returns True if all bytes in the input are zero.
*/
template<class T>
inline constexpr bool is_all_byte_zero(T&&a)noexcept{
	const byte*ptr=cast_to_data(addressof(a));
	const byte*end=ptr+sizeof(a);
	while(ptr!=end)
		if((unsigned char)(*ptr++))
			return false;
	return true;
}

//file_end

#line 36 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/count_able.hpp"
//count_able.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<class T>
[[nodiscard]]inline size_t the_number_of(type_info_t<T>)noexcept;
template<class T>
struct count_able:is_common_attribute(count_able){
private:
	friend size_t the_number_of<T>(type_info_t<T>)noexcept;
	static size_t _number;
public:
	count_able()noexcept{_number++;}
	~count_able()noexcept{_number--;}
};
template<class T>
[[nodiscard]]inline size_t the_number_of(type_info_t<T>)noexcept{
	if constexpr(type_info<T>.not_has_attribute(count_able))
		template_error("hey.");
	return count_able<T>::_number;
}

//file_end

#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/invoke.hpp"
//invoke.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename T>
struct invoke_t{
	/*!
	Determines if a type is invocable.

	@tparam T The type to check.
	@tparam Args The types of the arguments to the type.

	@returns True if the type is invocable, false otherwise.
	*/
	template<class...Args>
	static constexpr bool able= ::std::is_invocable_v<T,Args...>;
	/*!
	Determines if a type is invocable and nothrow.

	@tparam T The type to check.
	@tparam Args The types of the arguments to the type.

	@returns True if the type is nothrow invocable, false otherwise.
	*/
	template<class...Args>
	static constexpr bool nothrow= ::std::is_nothrow_invocable_v<T,Args...>;

	//和期待类型
	template<class Ret_t>
	struct with_return_type_t{
		template<class...Args>
		static constexpr bool able= ::std::is_invocable_r_v<Ret_t,T,Args...>;
		template<class...Args>
		static constexpr bool nothrow= ::std::is_nothrow_invocable_r_v<Ret_t,T,Args...>;

		/*!
		A function that returns a lambda that applies a function to a value.

		@param rest The arguments to the function.

		@returns A lambda that applies the function to a value.
		*/
		template<class...Args> requires able<Args...>
		decltype(auto)_as(Args&&...rest)const noexcept(nothrow<Args...>){//invoke<T>.with_return_type<Ret_t>._as(...)
			return lambda_with_catch(rest...)(const T&a)noexcept(nothrow<Args...>){return a(forward<Args>(rest)...);};
		}
	};
	template<class Ret_t>
	static constexpr with_return_type_t<Ret_t>with_return_type{};
	
	/*!
	A function that returns a lambda that applies a function to a value.

	@param rest The arguments to the function.

	@returns A lambda that applies the function to a value.
	*/
	template<class...Args> requires able<Args...>
	decltype(auto)_as(Args&&...rest)const noexcept(nothrow<Args...>){//invoke<T>._as(...)
		return lambda_with_catch(rest...)(const T&a)noexcept(nothrow<Args...>){return a(forward<Args>(rest)...);};
	}
};
template<typename T>
constexpr invoke_t<T>invoke{};

//file_end

#line 38 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/maybe_fail_reference.hpp"
//maybe_fail_reference.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename T>
class maybe_fail_reference{
	T*_ref_to;
public:
	constexpr maybe_fail_reference(T&a)noexcept:_ref_to(&a){}
	constexpr maybe_fail_reference(const maybe_fail_reference&)=default;
	constexpr maybe_fail_reference(note::fail_t)noexcept:_ref_to(nullptr){}

	[[nodiscard]]bool not_fail()noexcept{return _ref_to;}
	[[nodiscard]]bool fail()noexcept{return!not_fail();}
	T&get_ref()noexcept{return*_ref_to;}
};

//file_end

#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/rand.hpp"
//rand.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base_defs文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace rand_n{
	typedef uint_t seed_type;//考虑到通用性以便于跨平台通用的seed，不可以使用uintmax_t
	namespace linear_congruential_arguments_n{
		//type
		template<class T>
		using rand_value_type=unsigned_specific_size_t<min(2*sizeof(T),sizeof(seed_type))>;

		//m
		template<class T>
		[[nodiscard]]force_inline constexpr auto get_modulus_of(){
			//由于rand_value_type一定是无符号整数，所以max(type_info<rand_value_type>)+1等价于pow(BIT_POSSIBILITY,bitnum_of(rand_value_type))
			//同时可以简化编译期计算
			//若rand_value_type的max超出了当前环境支持的最宽uint最大值，它会在编译期合乎标准的溢出到0
			return uintmax_t(max(type_info<rand_value_type<T>>))+1;
		}
		//a
		[[nodiscard]]inline constexpr size_t get_multiplier_by_modulus(auto m){
			if(m==0)m-=4;//考虑到m可能溢出到0，此时对m进行约等计算
			//https://en.wikipedia.org/wiki/Linear_congruential_generator#Period_length
			size_t a_off_1=1;
			/*
				`a - 1` is divisible by all prime factors of m
			*/
			{
				//get all prime factors of BIT_POSSIBILITY as modulus always is a power of BIT_POSSIBILITY
				size_t prime_test	= BIT_POSSIBILITY;
				size_t prime_tester = 2;
				while(prime_test!=1){
					if(prime_test%prime_tester==0){
						prime_test /= prime_tester;
						if(a_off_1 % prime_tester)
							a_off_1 *= prime_tester;
						//reset prime_test
						prime_tester=2;
					}
					else
						prime_tester=get_prime_num_big_than(prime_tester);
				}
			}
			/*
				`a - 1` is divisible by 4 if m is divisible by 4.
			*/
			while(m%4==0 && a_off_1%4!=0)
				a_off_1*=2;
			/*
				`a - 1` should not be any more divisible by prime factors of m
				`a - 1` should not small than sqrt(m)
			*/
			{
				const auto sqrt_m = sqrt(m);
				do
					a_off_1 *= get_prime_num_big_than(a_off_1);
				while(a_off_1 < sqrt_m);
			}
			//return a
			return a_off_1+1;
		}
		template<class T>
		[[nodiscard]]force_inline constexpr size_t get_multiplier_of(){
			return get_multiplier_by_modulus(get_modulus_of<T>());
		}
		//c
		[[nodiscard]]force_inline constexpr size_t get_increment_by_modulus([[maybe_unused]]auto m){
			//https://en.wikipedia.org/wiki/Linear_congruential_generator#Period_length
			/*
				`c` and `m` are coprime.
			*/
			return 1;
		}
		template<class T>
		[[nodiscard]]force_inline constexpr size_t get_increment_of(){
			return get_increment_by_modulus(get_modulus_of<T>());
		}
	}

	//decl
	template<class T>
	struct rand_t;

	distinctive inline struct rand_seed_t{
	private:
		seed_type			   _seed, _seed_origin;
		static constexpr auto  εντροπία_bitnum = CHAR_BIT;
		static constexpr auto  εντροπία_num = size_t(pow(BIT_POSSIBILITY, εντροπία_bitnum));
		static constexpr auto  εντροπία_size = εντροπία_num * sizeof(seed_type);
		byte _εντροπία_data[εντροπία_size];

		static inline constexpr void sowing_seed_one_step(seed_type&seed)noexcept{seed=13*seed+7;}
	public:
		[[nodiscard]]inline constexpr seed_type get_origin()const noexcept{return _seed_origin;}
		inline constexpr void set(seed_type seed)noexcept{
			_seed					= seed;
			_seed_origin			= seed;
			constexpr auto half_bitnum = bitnum_of(seed_type)/2;
			static_assert(εντροπία_num>=bitnum_of(seed_type));
			for(size_t i=εντροπία_num;i--;){
				auto& cache = data_ptr_cast<seed_type>(_εντροπία_data)[i];
				cache		= _seed^(_seed >> half_bitnum);
				sowing_seed_one_step(_seed);
			}
		}
		void set_by_time()noexcept{this->set(seed_type(::std::time(nullptr)));}
		constexpr rand_seed_t(seed_type seed=magic_number::god)noexcept{this->set(seed);}
		constexpr rand_seed_t(const rand_seed_t&other)noexcept{
			_seed					= other._seed;
			_seed_origin			= other._seed_origin;
			if in_consteval
				for(size_t i=εντροπία_size;i--;)
					_εντροπία_data[i]	= other._εντροπία_data[i];
			else
				::std::memcpy(_εντροπία_data, other._εντροπία_data, εντροπία_size);
		}
	private:
		//friend
		template<class T>
		friend struct rand_t;

		template<typename T> requires(sizeof(seed_type)/2 >= sizeof(T))
		[[nodiscard]]force_inline constexpr auto base_gen_randbit()noexcept{
			using namespace linear_congruential_arguments_n;
			typedef unsigned_specific_size_t<sizeof(T)>		result_type;
			typedef unsigned_specific_size_t<2*sizeof(T)>	rand_value_type;
			constexpr auto	 multiplier	 = get_multiplier_of<seed_type>();
			constexpr auto	 increment	 = get_increment_of<seed_type>();
			constexpr size_t half_bitnum = bitnum_of(result_type);
			//
			const auto old_seed = _seed;
			_seed = multiplier*_seed+increment;
			//
			constexpr auto cut_seed_bitnum = bitnum_of(seed_type)-bitnum_of(rand_value_type);
			const auto new_result = rand_value_type(_seed>>cut_seed_bitnum);
			const auto old_result_base = rand_value_type(old_seed>>cut_seed_bitnum);
			//
			const auto		  result_base	= result_type(new_result >> half_bitnum);
			const auto		  rot_offset	= result_type(old_result_base >> half_bitnum);
			constexpr auto	  εντροπία_max	= εντροπία_size/sizeof(result_type);
			auto&			  xor_value		= data_ptr_cast<result_type>(_εντροπία_data)[rot_offset % εντροπία_max];
			const result_type result		= rotl(result_base, rot_offset) ^ xor_value;
			//
			xor_value = result;
			return result;
		}
		template<typename T> requires(sizeof(seed_type)/2 >= sizeof(T))
		[[nodiscard]]force_inline constexpr T gen_randbit()noexcept{
			typedef unsigned_specific_size_t<sizeof(T)> result_type;
			alignas(max_align_of<T,result_type>)result_type aret=base_gen_randbit<result_type>();
			return union_cast<T>(aret);
		}
		//为了加速而进行特化，这不影响通用性并且大多数时候能节省2ns左右（将内存访问转为位操作）
		template<typename T> requires(sizeof(seed_type) == sizeof(T))
		[[nodiscard]]force_inline constexpr T gen_randbit()noexcept{
			typedef unsigned_specific_size_t<sizeof(T)> result_type;
			typedef unsigned_specific_size_t<sizeof(T)/2> sand_type;
			alignas(max_align_of<T,result_type>)result_type aret=result_type(gen_randbit<sand_type>())<<bitnum_of(sand_type);
			aret|=result_type(gen_randbit<sand_type>());
			return union_cast<T>(aret);
		}

		template<size_t sand_size,size_t size>
		[[nodiscard]]force_inline constexpr void gen_randbit_with_sand_size_to_pointer(byte*to)noexcept{
			typedef unsigned_specific_size_t<sand_size> sand_type;
			constexpr size_t sand_num = size/sand_size;
			if constexpr(sand_num)
				for(size_t i=sand_num;i--;to+=sand_size)
					data_cast<sand_type>(to)=gen_randbit<sand_type>();
			if constexpr(size%sand_size)
				gen_randbit_with_sand_size_to_pointer<sand_size/BIT_POSSIBILITY,size%sand_size>(to);
		}
		template<typename T> requires(sizeof(seed_type)/2 < sizeof(T) && sizeof(seed_type) != sizeof(T))//避免与加速特化重叠
		[[nodiscard]]force_inline constexpr T gen_randbit()noexcept{
			data_block<T,align_as_t<seed_type>>aret;
			gen_randbit_with_sand_size_to_pointer<sizeof(seed_type),sizeof(T)>(aret);
			return data_cast<T>(aret);
		}
	}rand_seed{};

	struct base_rand_t{
	protected:
		typedef base_rand_t this_t;
		rand_seed_t& _seed;
	public:
		constexpr base_rand_t(rand_seed_t&seed)noexcept:_seed(seed){}
		constexpr base_rand_t(const this_t&other)noexcept=default;
		constexpr base_rand_t(this_t&&other)noexcept=default;
		//delete operator=
		this_t& operator=(const this_t&other)=delete;
		this_t& operator=(this_t&&other)=delete;
	};
	template<class T>
	struct rand_t:base_rand_t{
		static constexpr bool able=::std::is_trivially_constructible_v<T>;
		static constexpr bool nothrow=able;
	private:
		typedef rand_t<T> this_t;
		typedef base_rand_t base_t;
	public:
		using base_t::base_t;
		[[nodiscard]]static force_inline constexpr this_t with_seed(rand_seed_t&seed)noexcept{return this_t(seed);}
		//rand
		[[nodiscard]]force_inline T operator()()const noexcept{return _seed.gen_randbit<T>();}
		//浮点特供：[0,1)和[0,1]
		/// [0,1)
		[[nodiscard]]force_inline constexpr T between_0_and_1_exclusive()const noexcept requires(::std::is_floating_point_v<T>){
			T base=T(_seed.gen_randbit<unsigned_specific_size_t<sizeof(T)>>());
			constexpr size_t div_times=bitnum_of(base);
			constexpr auto div_num=pow(BIT_POSSIBILITY,div_times);
			return T(base/div_num);
		}
		/// [0,1]
		[[nodiscard]]force_inline constexpr T between_0_and_1_inclusive()const noexcept requires(::std::is_floating_point_v<T>){
			auto rnd=_seed.gen_randbit<unsigned_specific_size_t<sizeof(T)>>();
			//考虑到浮点数总会使用一些位来表示指数，取rnd的最低位来表示rand到1.0或以上的概率也不会影响到结果
			const bool is_one=rnd&1;rnd>>=1;
			if(is_one)return rnd==0?1:between_0_and_1_inclusive();//若rnd!=0，为了概率均匀需要reroll
			T base=T(rnd);
			constexpr size_t div_times=bitnum_of(base)-1;//取了一位来表示是否为1
			constexpr auto div_num=pow(BIT_POSSIBILITY,div_times);
			return T(base/div_num);
		}
		//not nan.
		[[nodiscard]]force_inline constexpr T not_NaN()const noexcept{
			T num;
			do num=_seed.gen_randbit<T>();while(isNaN(num));
			return num;
		}
		//between
	private:
		struct between_integral_t{
		private:
			rand_seed_t& _seed;
			T _min,_diff;
			size_t _bitnum;
		public:
			constexpr between_integral_t(rand_seed_t&seed,T amin,T amax)noexcept:_seed(seed),_min(amin),_diff(amax-amin){
				for(_bitnum=1;_diff>>_bitnum;_bitnum++);
			}
			[[nodiscard]]force_inline T operator()()const noexcept{return inclusive();}
			[[nodiscard]]force_inline operator T()const noexcept{return operator()();}
			[[nodiscard]]force_inline T exclusive()const noexcept{
				T ret;
				do ret=_seed.gen_randbit<T>()&(T{1}<<_bitnum)-1;while(ret>=_diff);
				return ret+_min;
			}
			[[nodiscard]]force_inline T inclusive()const noexcept{
				T ret;
				do ret=_seed.gen_randbit<T>()&(T{1}<<_bitnum)-1;while(ret>_diff);
				return ret+_min;
			}
		};
		struct between_floating_t{
		private:
			rand_seed_t& _seed;
			T _min,_diff;
		public:
			constexpr between_floating_t(rand_seed_t&seed,T amin,T amax)noexcept:_seed(seed),_min(amin),_diff(amax-amin){}
			[[nodiscard]]force_inline T operator()()const noexcept{return inclusive();}
			[[nodiscard]]force_inline operator T()const noexcept{return operator()();}
			[[nodiscard]]force_inline T exclusive()const noexcept{
				return _min+rand_t<T>{_seed}.between_0_and_1_exclusive()*_diff;
			}
			[[nodiscard]]force_inline T inclusive()const noexcept{
				return _min+rand_t<T>{_seed}.between_0_and_1_inclusive()*_diff;
			}
		};
	public:
		[[nodiscard]]force_inline constexpr auto between(T amin,T amax)const noexcept requires ::std::is_arithmetic_v<T>{
			#define args _seed,min(amax,amin),max(amax,amin)
			if constexpr(::std::is_integral_v<T>)
				return between_integral_t(args);
			else
				return between_floating_t(args);
			#undef args
		}
	};
	//bool rand
	template<>struct rand_t<bool>:base_rand_t{
		static constexpr bool able=true;
		static constexpr bool nothrow=true;
	private:
		typedef bool T;
		typedef rand_t<T> this_t;
		typedef base_rand_t base_t;
	public:
		using base_t::base_t;
		[[nodiscard]]static force_inline constexpr this_t with_seed(rand_seed_t&seed)noexcept{return this_t(seed);}
		[[nodiscard]]force_inline T operator()()const noexcept{
			return _seed.gen_randbit<unsigned char>()&unsigned char{1};
		}
	};
	template<class T>
	constexpr rand_t<T>rand{rand_seed};
}
using rand_n::rand;
using rand_n::rand_seed;

//file_end

#line 41 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/base_defs/_body.hpp"

//file_end

		#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
	}

	//由于vcruntime的type_info在全局定义,这里需要额外声明使用base::type_info.
	#if defined(_VCRUNTIME_H)
		using base::type_info;
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 39 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_defs/_body.hpp"
}

//file_end

	#line 23 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#endif

//file_end

	#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
	#include <cstring>//memcpy、memmove
	#include <atomic>//atomic
	#if defined(ELC_TEST_ON)
		#include <ctime>//time
	#endif
	#define ELC_BASE
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
//_body.hpp
//at namespace ::
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if defined(ELC_TEST)//若已包含elc/test则报错：其应在此文件后被包含
	#error "this part cannot be tested."
#endif

//include APIs：elc中可能根据编译环境而修改的底层函数
//using at memory/alloc
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"
//alloc.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*
APIs说明
elc依赖的基础函数.
调整这些,实现快速移植,快速优化与行为自定义.
*/
#if !defined(ELC_APIS_alloc)
	#define ELC_APIS_alloc
	#if defined(ELC_MEMORY_ALLOC_LOCATION_RECORD)
		#include <stacktrace>//for operate_source_location
	#endif
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/decl_system_type.hpp"
//decl_system_type.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//copy&rewrite from steve02081504/steve.h
#define linux 2
#define windows 3
#define other 4
#if defined(__linux)||defined(__linux__)||defined(__gnu_linux__)
	#define SYSTEM_TYPE linux
#elif defined(_WIN32)||defined(__MINGW32__)||defined(__CYGWIN__)
	#define SYSTEM_TYPE windows
#else
	#define SYSTEM_TYPE other
#endif
#define ERROR_MSG_UNABLE_OS "Unable OS,edit this file on your own or contact ELC's producers."

//file_end

	#line 18 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"
	#if SYSTEM_TYPE == windows
		#if defined(_DEBUG)
			#include <crtdbg.h>
		#else
			#include <malloc.h>
		#endif
	#else
		#include <cstdlib>
	#endif
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
//base_defs
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#line 24 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"

//file_end

	#line 28 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"
	/// @brief alloc相关基础函数
	namespace elc::APIs::alloc{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

		#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"

		using namespace ::elc::defs;//remove_const||byte
		#if SYSTEM_TYPE != windows
			//overhead
			#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc/default_method/overhead.hpp"
//overhead.hpp
//at namespace elc::APIs::alloc
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace overhead_n{
	using namespace ::elc::defs;
	constexpr size_t overhead_get_align(size_t align)noexcept{
		return max(align,alignof(size_t));//保证最高对齐需求
	}
	constexpr size_t overhead_get_offset_value(size_t align)noexcept{
		align=overhead_get_align(align);
		return (size_t(sizeof(size_t)/align)+bool(sizeof(size_t)%align))*align;//等同于sizeof(size_t)-sizeof(size_t)%align+(sizeof(size_t)%align?align:0)
		//暨，偏移量既要大于sizeof(size_t)以装下overhead，又要是align的整数倍以保证T实例的对齐被满足
	}
	constexpr size_t correct_size(size_t size,size_t align)noexcept{
		return size+overhead_get_offset_value(align);
	}
	constexpr size_t correct_align(size_t align)noexcept{
		return overhead_get_align(align);
	}
	inline pointer correct_pointer(pointer a,size_t align){
		return apply_off_set(a,overhead_get_offset_value(align));
	}
	inline pointer recorrect_pointer(pointer a,size_t align){
		return unapply_off_set(a,overhead_get_offset_value(align));
	}
	inline const_pointer recorrect_pointer(const_pointer a, size_t align){
		return unapply_off_set(a,overhead_get_offset_value(align));
	}
	inline void set_overhead(pointer a,size_t size){
		*reinterpret_cast<size_t*>(a)=size;
	}
	inline size_t get_overhead(const_pointer a){
		return*reinterpret_cast<const size_t*>(a);
	}
}

//file_end

			#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"
		#endif
		//operate_source_location & source_location_guard
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc/debug_info/source_location_guard.hpp"
//source_location_guard.hpp
//at namespace elc::APIs::alloc
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if defined(_MSC_VER)
	#if defined(ELC_MEMORY_ALLOC_LOCATION_RECORD)
		#pragma detect_mismatch("ELC_MEMORY_ALLOC_LOCATION_RECORD","true")
	#else
		#pragma detect_mismatch("ELC_MEMORY_ALLOC_LOCATION_RECORD","false")
	#endif
#endif
#if defined(ELC_MEMORY_ALLOC_LOCATION_RECORD)
	distinctive inline ::std::stacktrace_entry operate_source_frame;
	distinctive inline struct source_location_info_t{
		const char*_file=nullptr;
		uint_least32_t _line=0;
		const char*file()noexcept{
			if(!_file){
				try{
					static ::std::string file_cache;
					file_cache=operate_source_frame.source_file();
					_file=file_cache.c_str();
				}
				catch(...){
				}
			}
			return _file;
		}
		uint_least32_t line()noexcept{
			if(!_line){
				try{
					_line=operate_source_frame.source_line();
				}
				catch(...){
				}
			}
			return _line;
		}
		void clear()noexcept{
			_file=nullptr;
			_line=0;
		}
	}operate_source_location;
	struct source_location_guard{
		bool _is_set=false;
		source_location_guard(size_t lookup=0)noexcept{
			if(!operate_source_frame){
				::std::stacktrace stack = ::std::stacktrace::current(/*skip*/lookup+2,/*max_depth*/1);
				if(stack.size()){
					operate_source_frame = stack[0];
					_is_set				 = true;
				}
			}
		}
		~source_location_guard()noexcept{
			if(_is_set){
				operate_source_frame = ::std::stacktrace_entry{};
				operate_source_location.clear();
			}
		}
	};
#else
	struct source_location_guard{
		constexpr source_location_guard([[maybe_unused]]size_t lookup=0)noexcept{}
	};
	distinctive inline struct source_location_info_t{
		constexpr const char*file()noexcept{return nullptr;}
		constexpr uint_least32_t line()noexcept{return 0;}
	}operate_source_location;
#endif

//file_end

		#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"

		//BLOCK: Counting memory allocations
		#if defined(_MSC_VER)
			#if defined(ELC_TEST_COUNT_MEMORY_ALLOC)
				#pragma detect_mismatch("ELC_TEST_COUNT_MEMORY_ALLOC","true")
			#else
				#pragma detect_mismatch("ELC_TEST_COUNT_MEMORY_ALLOC","false")
			#endif
		#endif

		#if defined(ELC_TEST_COUNT_MEMORY_ALLOC)
			[[nodiscard]]inline size_t get_size_of_alloc(const byte*p,size_t align)noexcept;
			namespace count_info{
				distinctive inline size_t alloc_count=0;
				distinctive inline size_t free_count=0;
				distinctive inline size_t alloc_size=0;
				distinctive inline size_t free_size=0;
				distinctive inline size_t memory_using=0;
				distinctive inline size_t memory_using_max=0;
				inline void update_memory_using(ptrdiff_t diff)noexcept{
					memory_using+=diff;
					if(memory_using>memory_using_max)
						memory_using_max=memory_using;
				}
				inline void clear()noexcept{
					alloc_count=0;
					free_count=0;
					alloc_size=0;
					free_size=0;
					memory_using=0;
					memory_using_max=0;
				}
			}
		#endif
		//BLOCK_END

		/*!
		aligned_alloc 内存分配函数，需提供对齐需求
		return空指针被允许
		size被保证不为0
		*/
		[[nodiscard]]inline byte*aligned_alloc(size_t align,size_t size)noexcept{
			void* aret;//返回值放这里

			#if SYSTEM_TYPE == windows
				#if defined(_DEBUG)
					aret = _aligned_malloc_dbg(size,align,operate_source_location.file(),operate_source_location.line());
				#else
					aret = _aligned_malloc(size,align);
				#endif
			#else
				using namespace overhead_n;
				void*tmp=::std::aligned_alloc(correct_align(align),correct_size(size,align));
				if(tmp){
					set_overhead(tmp,size);
					aret = correct_pointer(tmp,align);
				}
				else
					aret = nullptr;
			#endif

			#if defined(ELC_TEST_COUNT_MEMORY_ALLOC)
				if(aret){
					count_info::alloc_count++;
					count_info::alloc_size+=size;
					count_info::update_memory_using(size);
				}
			#endif

			return(byte*)aret;
		}
		/*!
		realloc 重新规划分配的大小
		return空指针被允许，但ptr值必须保持有效以保证gc后再次realloc有效
		new_size被保证不为0
		align维持不变
		但只允许在扩大数据块时可选的移动数据块
		*/
		[[nodiscard]]inline byte*realloc(byte*ptr,size_t nsize,[[maybe_unused]]size_t align)noexcept{
			#if defined(ELC_TEST_COUNT_MEMORY_ALLOC)
				const auto osize=get_size_of_alloc(ptr,align);
			#endif
			void* aret;//返回值放这里

			#if SYSTEM_TYPE == windows
				#if defined(_DEBUG)
					aret = _aligned_realloc_dbg(ptr,nsize,align,operate_source_location.file(),operate_source_location.line());
				#else
					aret = _aligned_realloc(ptr,nsize,align);
				#endif
			#else
				using namespace overhead_n;
				void*tmp=::std::realloc(recorrect_pointer(ptr,align),correct_size(nsize,align));
				if(tmp){
					set_overhead(tmp,nsize);
					aret = correct_pointer(tmp,align);
				}
				else
					aret = nullptr;
			#endif

			#if defined(ELC_TEST_COUNT_MEMORY_ALLOC)
				if(aret){
					count_info::alloc_size+=nsize-osize;
					count_info::update_memory_using(nsize-osize);
				}
			#endif

			return(byte*)aret;
		}
		/*!
		free 释放所分配的内存
		传入需获取大小的数据块起始点与对齐
		*/
		inline void free(byte*p,[[maybe_unused]]size_t align)noexcept{
			#if defined(ELC_TEST_COUNT_MEMORY_ALLOC)
				const auto size=get_size_of_alloc(p,align);
				count_info::free_count++;
				count_info::free_size+=size;
				count_info::update_memory_using(-ptrdiff_t(size));
			#endif

			#if SYSTEM_TYPE == windows
				#if defined(_DEBUG)
					_aligned_free_dbg(p);
				#else
					_aligned_free(p);
				#endif
			#else
				using namespace overhead_n;
				::std::free(recorrect_pointer(p,align));
			#endif
		}
		/*!
		get_size_of_alloc 获取数据块的大小
		传入需获取大小的数据块起始点与对齐
		*/
		[[nodiscard]]inline size_t get_size_of_alloc(const byte*p,[[maybe_unused]]size_t align)noexcept{
			#if SYSTEM_TYPE == windows
				#if defined(_DEBUG)
					return _aligned_msize_dbg(remove_const(p),align,0);
				#else
					return _aligned_msize(remove_const(p),align,0);
				#endif
			#else
				using namespace overhead_n;
				return get_overhead(recorrect_pointer(p,align));
			#endif
		}

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

		#line 188 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"
	}
	//
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/undef_decl_system_type.hpp"
//undef_decl_system_type.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//copy&rewrite from steve02081504/evest.h
#undef linux
#undef windows
#undef other
#undef SYSTEM_TYPE
#undef ERROR_MSG_UNABLE_OS

//file_end

	#line 191 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/alloc.hpp"
#endif

//file_end

#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
//using at memory/gc
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"
//die.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*
APIs说明
elc依赖的基础函数.
调整这些,实现快速移植,快速优化与行为自定义.
*/
#if !defined(ELC_APIS_die)
	#define ELC_APIS_die
	#include <cuchar>
	#include <clocale>
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
//default_data_type.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace elc{
	/*ELC内部string统一采用char_t宽字符，使用setlocale(LC_ALL,"en_US.utf8")下的UTF编码。*/
	typedef char32_t char_t;
	/*c_string表示*/
	typedef char_t* string_ptr_t;
	/*c_string表示*/
	typedef const char_t* const_string_ptr_t;
	/*ELC内部钦定int_t类型*/
	typedef int64_t int_t;
	/*ELC内部钦定uint_t类型*/
	typedef uint64_t uint_t;
	/*ELC内部钦定float_t类型*/
	typedef double float_t;
	/*ELC内部钦定float_size_t类型，用以描述内存大小的浮点状况*/
	typedef long double float_size_t;
}

//file_end

	#line 17 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/char_set.hpp"
//char_set.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*
APIs说明
elc依赖的基础函数.
调整这些,实现快速移植,快速优化与行为自定义.
*/
#if !defined(ELC_APIS_char_set)
	#define ELC_APIS_char_set
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/decl_system_type.hpp"
//decl_system_type.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//copy&rewrite from steve02081504/steve.h
#define linux 2
#define windows 3
#define other 4
#if defined(__linux)||defined(__linux__)||defined(__gnu_linux__)
	#define SYSTEM_TYPE linux
#elif defined(_WIN32)||defined(__MINGW32__)||defined(__CYGWIN__)
	#define SYSTEM_TYPE windows
#else
	#define SYSTEM_TYPE other
#endif
#define ERROR_MSG_UNABLE_OS "Unable OS,edit this file on your own or contact ELC's producers."

//file_end

	#line 15 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/char_set.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
//base_defs
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#line 24 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"

//file_end

	#line 16 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/char_set.hpp"
	/// @brief 文字编码相关函数
	namespace elc::APIs::char_set{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

		#line 19 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/char_set.hpp"

		using namespace ::elc::defs;//string_view_t
		typedef string_view_t<char8_t>string_view_u8_t;
		typedef string_view_t<char16_t>string_view_u16_t;
		typedef string_view_t<char32_t>string_view_u32_t;

		inline constexpr size_t utf16_to_utf8_code_size=2;
		inline constexpr size_t utf32_to_utf8_code_size = 4;
		inline constexpr size_t utf32_to_utf16_code_size = 2;

		using range_n::npos;
		inline namespace convert_impl {
			inline constexpr size_t decode_utf8(char32_t *out, const char8_t *in, size_t in_size_max)noexcept{
				push_and_disable_msvc_warning(26494);//未初始化警告diss
				char8_t code1, code2, code3, code4;
				pop_msvc_warning();
				code1 = *in++;
				if(code1 < 0x80){ /* 1-byte sequence */
					*out = code1;
					return 1;
				}
				elseif(code1 < 0xC2)
					return npos;
				elseif(code1 < 0xE0){ /* 2-byte sequence */
					if(in_size_max < 2)
						return npos;
					code2 = *in++;
					if((code2 & 0xC0) != 0x80)
						return npos;
					*out = (code1 << 6) + code2 - 0x3080;
					return 2;
				}
				elseif(code1 < 0xF0){ /* 3-byte sequence */
					if(in_size_max < 3)
						return npos;
					code2 = *in++;
					if((code2 & 0xC0) != 0x80)
						return npos;
					if(code1 == 0xE0 && code2 < 0xA0)
						return npos;
					code3 = *in++;
					if((code3 & 0xC0) != 0x80)
						return npos;
					*out = (code1 << 12) + (code2 << 6) + code3 - 0xE2080;
					return 3;
				}
				elseif(code1 < 0xF5){ /* 4-byte sequence */
					if(in_size_max < 4)
						return npos;
					code2 = *in++;
					if((code2 & 0xC0) != 0x80)
						return npos;
					if(code1 == 0xF0 && code2 < 0x90)
						return npos;
					if(code1 == 0xF4 && code2 >= 0x90)
						return npos;
					code3 = *in++;
					if((code3 & 0xC0) != 0x80)
						return npos;
					code4 = *in++;
					if((code4 & 0xC0) != 0x80)
						return npos;
					*out = (code1 << 18) + (code2 << 12) + (code3 << 6) + code4 - 0x3C82080;
					return 4;
				}
				else
					return npos;
			}
			inline constexpr size_t get_decode_utf8_size(const char8_t* in)noexcept{
				if(*in < 0x80) /* 1-byte sequence */
					return 1;
				elseif(*in < 0xC2)
					return npos;
				elseif(*in < 0xE0) /* 2-byte sequence */
					return 2;
				elseif(*in < 0xF0) /* 3-byte sequence */
					return 3;
				elseif(*in < 0xF5) /* 4-byte sequence */
					return 4;
				else
					return npos;
			}
			inline constexpr size_t decode_utf16(char32_t *out, const char16_t *in, size_t in_size_max)noexcept{
				const char16_t code1 = *in++;
				if(code1 >= 0xD800 && code1 < 0xDC00){ /* surrogate pair */
					if(in_size_max < 2)
						return npos;
					const char16_t code2 = *in++;
					if(code2 >= 0xDC00 && code2 < 0xE000){
						*out = (code1 << 10) + code2 - 0x35FDC00;
						return 2;
					}
					return npos;
				}
				*out = code1;
				return 1;
			}
			inline constexpr size_t get_decode_utf16_size(const char16_t* in)noexcept{
				if(*in >= 0xD800 && *in < 0xDC00) /* surrogate pair */
					return 2;
				else
					return 1;
			}
			inline constexpr size_t encode_utf8(char8_t *out, char32_t in)noexcept{
				if(in < 0x80){
					*out++ = (char8_t)in;
					return 1;
				}
				elseif(in < 0x800){
					*out++ = char8_t((in >> 6) + 0xC0);
					*out++ = char8_t((in & 0x3F) + 0x80);
					return 2;
				}
				elseif(in < 0x10000){
					*out++ = char8_t((in >> 12) + 0xE0);
					*out++ = ((in >> 6) & 0x3F) + 0x80;
					*out++ = (in & 0x3F) + 0x80;
					return 3;
				}
				elseif(in < 0x110000){
					*out++ = char8_t((in >> 18) + 0xF0);
					*out++ = ((in >> 12) & 0x3F) + 0x80;
					*out++ = ((in >> 6) & 0x3F) + 0x80;
					*out++ = (in & 0x3F) + 0x80;
					return 4;
				}
				return npos;
			}
			inline constexpr size_t get_encode_utf8_size(char32_t in)noexcept{
				if(in < 0x80)
					return 1;
				elseif(in < 0x800)
					return 2;
				elseif(in < 0x10000)
					return 3;
				elseif(in < 0x110000)
					return 4;
				else
					return npos;
			}
			inline constexpr size_t encode_utf16(char16_t *out, char32_t in)noexcept{
				if(in < 0x10000){
					*out++ = char16_t(in);
					return 1;
				}
				elseif(in < 0x110000){
					*out++ = char16_t((in >> 10) + 0xD7C0);
					*out++ = (in & 0x3FF) + 0xDC00;
					return 2;
				}
				return npos;
			}
			inline constexpr size_t get_encode_utf16_size(char32_t in)noexcept{
				if(in < 0x10000)
					return 1;
				elseif(in < 0x110000)
					return 2;
				else
					return npos;
			}
		}
		template<typename in_char_t, typename out_char_t>
		struct code_convert_result {
			bool _success;
			string_view_t<in_char_t> _processed_input;
			string_view_t<out_char_t> _processed_output;
		public:
			inline constexpr code_convert_result(bool success, string_view_t<in_char_t> processed_input, string_view_t<out_char_t> processed_output)noexcept:_success(success),_processed_input(processed_input),_processed_output(processed_output){}
			inline constexpr bool success()const noexcept{ return _success; }
			inline constexpr string_view_t<in_char_t> processed_input()const noexcept{ return _processed_input; }
			inline constexpr string_view_t<out_char_t> processed_output()const noexcept{ return _processed_output; }
			inline constexpr explicit operator bool()const noexcept{ return success(); }
		};
		inline constexpr auto get_utf8_to_utf16_size(const char8_t *in, size_t len)noexcept{
			size_t out_size = 0;
			const auto end = in + len;
			while(in < end){
				char32_t code;
				const auto size = decode_utf8(&code, in, end - in);
				if(size == npos)
					return npos;
				const auto tmp = get_encode_utf16_size(code);
				if(tmp == npos)
					return npos;
				out_size += tmp;
				in += size;
			}
		}
		inline constexpr auto get_utf8_to_utf16_size(string_view_u8_t in)noexcept{
			return get_utf8_to_utf16_size(in.data(), in.size());
		}
		inline constexpr auto utf8_to_utf16(char16_t *out, const char8_t *in, size_t len)noexcept{
			const auto end = in + len;
			push_and_disable_msvc_warning(26494);//未初始化警告diss
			char32_t code;
			pop_msvc_warning();
			//for return
			const auto out_start = out;
			const auto in_start = in;
			auto result_builder = [&](bool success)noexcept{
				return code_convert_result<char8_t, char16_t>(success, string_view_t<char8_t>(in_start, in - in_start), string_view_t<char16_t>(out_start, out - out_start));
			};
			while(in < end){
				const auto size = decode_utf8(&code, in, end - in);
				if(size == npos)
					return result_builder(false);
				auto tmp = encode_utf16(out, code);
				if(tmp == npos)
					return result_builder(false);
				out += tmp;
				in += size;
			}
			return result_builder(true);
		}
		inline constexpr auto utf8_to_utf16(char16_t *out, string_view_u8_t in)noexcept{
			return utf8_to_utf16(out, in.data(), in.size());
		}
		inline constexpr auto get_utf8_to_utf32_size(const char8_t *in, size_t len)noexcept{
			size_t out_size = 0;
			const auto end = in + len;
			while(in < end){
				const auto tmp = get_decode_utf8_size(in);
				if(tmp == npos)
					return npos;
				in += tmp;
				out_size++;
			}
			return out_size;
		}
		inline constexpr auto get_utf8_to_utf32_size(string_view_u8_t in)noexcept{
			return get_utf8_to_utf32_size(in.data(), in.size());
		}
		inline constexpr auto utf8_to_utf32(char32_t *out, const char8_t *in, size_t len)noexcept{
			const auto end = in + len;
			push_and_disable_msvc_warning(26494);//未初始化警告diss
			char32_t code;
			pop_msvc_warning();
			//for return
			const auto out_start = out;
			const auto in_start = in;
			auto result_builder = [&](bool success)noexcept{
				return code_convert_result<char8_t, char32_t>(success, string_view_t<char8_t>(in_start, in - in_start), string_view_t<char32_t>(out_start, out - out_start));
			};
			while(in < end){
				const auto size = decode_utf8(&code, in, end - in);
				if(size == npos)
					return result_builder(false);
				*out++ = code;
				in += size;
			}
			return result_builder(true);
		}
		inline constexpr auto utf8_to_utf32(char32_t *out, string_view_u8_t in)noexcept{
			return utf8_to_utf32(out, in.data(), in.size());
		}
		inline constexpr auto get_utf16_to_utf8_size(const char16_t *in, size_t len)noexcept{
			size_t out_size = 0;
			const auto end = in + len;
			while(in < end){
				char32_t code;
				const auto size = decode_utf16(&code, in, end - in);
				if(size == npos)
					return npos;
				const auto tmp = get_encode_utf8_size(code);
				if(tmp == npos)
					return npos;
				out_size += tmp;
				in += size;
			}
			return out_size;
		}
		inline constexpr auto get_utf16_to_utf8_size(string_view_u16_t in)noexcept{
			return get_utf16_to_utf8_size(in.data(), in.size());
		}
		inline constexpr auto utf16_to_utf8(char8_t *out, const char16_t *in, size_t len)noexcept{
			const auto end = in + len;
			push_and_disable_msvc_warning(26494);//未初始化警告diss
			char32_t code;
			pop_msvc_warning();
			//for return
			const auto out_start = out;
			const auto in_start = in;
			auto result_builder = [&](bool success)noexcept{
				return code_convert_result<char16_t, char8_t>(success, string_view_t<char16_t>(in_start, in - in_start), string_view_t<char8_t>(out_start, out - out_start));
			};
			while(in < end){
				const auto size = decode_utf16(&code, in, end - in);
				if(size == npos)
					return result_builder(false);
				auto tmp = encode_utf8(out, code);
				if(tmp == npos)
					return result_builder(false);
				out += tmp;
				in += size;
			}
			return result_builder(true);
		}
		inline constexpr auto utf16_to_utf8(char8_t *out, string_view_u16_t in)noexcept{
			return utf16_to_utf8(out, in.data(), in.size());
		}
		inline constexpr auto get_utf16_to_utf32_size(const char16_t *in, size_t len)noexcept{
			size_t out_size = 0;
			const auto end = in + len;
			while(in < end){
				char32_t code;
				const auto size = decode_utf16(&code, in, end - in);
				if(size == npos)
					return npos;
				in += size;
				out_size++;
			}
			return out_size;
		}
		inline constexpr auto get_utf16_to_utf32_size(string_view_u16_t in)noexcept{
			return get_utf16_to_utf32_size(in.data(), in.size());
		}
		inline constexpr auto utf16_to_utf32(char32_t *out, const char16_t *in, size_t len)noexcept{
			const auto end = in + len;
			//for return
			const auto out_start = out;
			const auto in_start = in;
			auto result_builder = [&](bool success)noexcept{
				return code_convert_result<char16_t, char32_t>(success, string_view_t<char16_t>(in_start, in - in_start), string_view_t<char32_t>(out_start, out - out_start));
			};
			while(in < end){
				char32_t code;
				const auto size = decode_utf16(&code, in, end - in);
				if(size == npos)
					return result_builder(false);
				*out++ = code;
				in += size;
			}
			return result_builder(true);
		}
		inline constexpr auto utf16_to_utf32(char32_t *out, string_view_u16_t in)noexcept{
			return utf16_to_utf32(out, in.data(), in.size());
		}
		inline constexpr auto get_utf32_to_utf8_size(const char32_t *in, size_t len)noexcept{
			size_t out_size = 0;
			const auto end = in + len;
			while(in < end){
				const auto tmp = get_encode_utf8_size(*in);
				if(tmp == npos)
					return npos;
				out_size += tmp;
				++in;
			}
			return out_size;
		}
		inline constexpr auto get_utf32_to_utf8_size(string_view_u32_t in)noexcept{
			return get_utf32_to_utf8_size(in.data(), in.size());
		}
		inline constexpr auto utf32_to_utf8(char8_t *out, const char32_t *in, size_t len)noexcept{
			const auto end = in + len;
			//for return
			const auto out_start = out;
			const auto in_start = in;
			auto result_builder = [&](bool success)noexcept{
				return code_convert_result<char32_t, char8_t>(success, string_view_t<char32_t>(in_start, in - in_start), string_view_t<char8_t>(out_start, out - out_start));
			};
			while(in < end){
				auto tmp = encode_utf8(out, *in);
				if(tmp == npos)
					return result_builder(false);
				out += tmp;
				++in;
			}
			return result_builder(true);
		}
		inline constexpr auto utf32_to_utf8(char8_t *out, string_view_u32_t in)noexcept{
			return utf32_to_utf8(out, in.data(), in.size());
		}
		inline constexpr auto get_utf32_to_utf16_size(const char32_t *in, size_t len)noexcept{
			size_t out_size = 0;
			const auto end = in + len;
			while(in < end){
				const auto tmp = get_encode_utf16_size(*in);
				if(tmp == npos)
					return npos;
				out_size += tmp;
				++in;
			}
			return out_size;
		}
		inline constexpr auto get_utf32_to_utf16_size(string_view_u32_t in)noexcept{
			return get_utf32_to_utf16_size(in.data(), in.size());
		}
		inline constexpr auto utf32_to_utf16(char16_t *out, const char32_t *in, size_t len)noexcept{
			const auto end = in + len;
			//for return
			const auto out_start = out;
			const auto in_start = in;
			auto result_builder = [&](bool success)noexcept{
				return code_convert_result<char32_t, char16_t>(success, string_view_t<char32_t>(in_start, in - in_start), string_view_t<char16_t>(out_start, out - out_start));
			};
			while(in < end){
				auto tmp = encode_utf16(out, *in);
				if(tmp == npos)
					return result_builder(false);
				out += tmp;
				++in;
			}
			return result_builder(true);
		}
		inline constexpr auto utf32_to_utf16(char16_t *out, string_view_u32_t in)noexcept{
			return utf32_to_utf16(out, in.data(), in.size());
		}
		inline constexpr auto utf32_to_utf8(char32_t ch, char8_t *out)noexcept{
			return utf32_to_utf8(out, &ch, 1);
		}
		inline constexpr auto utf32_to_utf16(char32_t ch, char16_t *out)noexcept{
			return utf32_to_utf16(out, &ch, 1);
		}
		inline constexpr auto utf16_to_utf8(char16_t ch, char8_t *out)noexcept{
			return utf16_to_utf8(out, &ch, 1);
		}
		inline constexpr void utf16_to_utf32(char32_t *out, char16_t in)noexcept=delete;
		inline constexpr void utf8_to_utf16(char16_t *out, char8_t in)noexcept=delete;

		//

		//utf32 to utf32 for compatible
		inline constexpr auto utf32_to_utf32(char32_t *out, const char32_t *in, size_t len)noexcept{
			const auto end = in + len;
			//for return
			const auto out_start = out;
			const auto in_start = in;
			auto result_builder = [&](bool success)noexcept{
				return code_convert_result<char32_t, char32_t>(success, string_view_t<char32_t>(in_start, in - in_start), string_view_t<char32_t>(out_start, out - out_start));
			};
			while(in < end){
				*out++ = *in++;
			}
			return result_builder(true);
		}
		inline constexpr auto utf32_to_utf32(char32_t *out, string_view_u32_t in)noexcept{
			return utf32_to_utf32(out, in.data(), in.size());
		}
		inline constexpr auto utf32_to_utf32(char32_t ch, char32_t *out)noexcept{
			return utf32_to_utf32(out, &ch, 1);
		}

		//utf32 to auto
		force_inline constexpr auto utf32_to_auto(char32_t *out, const char32_t *in, size_t len)noexcept{
			return utf32_to_utf32(out, in, len);
		}
		force_inline constexpr auto utf32_to_auto(char16_t *out, const char32_t *in, size_t len)noexcept{
			return utf32_to_utf16(out, in, len);
		}
		force_inline constexpr auto utf32_to_auto(char8_t *out, const char32_t *in, size_t len)noexcept{
			return utf32_to_utf8(out, in, len);
		}
		force_inline constexpr auto utf32_to_auto(char32_t *out, string_view_u32_t in)noexcept{
			return utf32_to_utf32(out, in.data(), in.size());
		}
		force_inline constexpr auto utf32_to_auto(char16_t *out, string_view_u32_t in)noexcept{
			return utf32_to_utf16(out, in.data(), in.size());
		}
		force_inline constexpr auto utf32_to_auto(char8_t *out, string_view_u32_t in)noexcept{
			return utf32_to_utf8(out, in.data(), in.size());
		}
		force_inline constexpr auto utf32_to_auto(char32_t ch, char32_t *out)noexcept{
			return utf32_to_utf32(out, &ch, 1);
		}
		force_inline constexpr auto utf32_to_auto(char32_t ch, char16_t *out)noexcept{
			return utf32_to_utf16(out, &ch, 1);
		}
		force_inline constexpr auto utf32_to_auto(char32_t ch, char8_t *out)noexcept{
			return utf32_to_utf8(out, &ch, 1);
		}

		//auto to utf32
		force_inline constexpr auto auto_to_utf32(char32_t *out, const char32_t *in, size_t len)noexcept{
			return utf32_to_utf32(out, in, len);
		}
		force_inline constexpr auto auto_to_utf32(char32_t *out, const char16_t *in, size_t len)noexcept{
			return utf16_to_utf32(out, in, len);
		}
		force_inline constexpr auto auto_to_utf32(char32_t *out, const char8_t *in, size_t len)noexcept{
			return utf8_to_utf32(out, in, len);
		}
		force_inline constexpr auto auto_to_utf32(char32_t *out, string_view_u32_t in)noexcept{
			return utf32_to_utf32(out, in.data(), in.size());
		}
		force_inline constexpr auto auto_to_utf32(char32_t *out, string_view_u16_t in)noexcept{
			return utf16_to_utf32(out, in.data(), in.size());
		}
		force_inline constexpr auto auto_to_utf32(char32_t *out, string_view_u8_t in)noexcept{
			return utf8_to_utf32(out, in.data(), in.size());
		}
		force_inline constexpr auto auto_to_utf32(char32_t ch, char32_t *out)noexcept{
			return utf32_to_utf32(out, &ch, 1);
		}
		force_inline constexpr auto auto_to_utf32(char16_t ch, char32_t *out)noexcept{
			return utf16_to_utf32(out, &ch, 1);
		}
		force_inline constexpr auto auto_to_utf32(char8_t ch, char32_t *out)noexcept{
			return utf8_to_utf32(out, &ch, 1);
		}
		
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

		#line 520 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/char_set.hpp"
	}
	//
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/undef_decl_system_type.hpp"
//undef_decl_system_type.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//copy&rewrite from steve02081504/evest.h
#undef linux
#undef windows
#undef other
#undef SYSTEM_TYPE
#undef ERROR_MSG_UNABLE_OS

//file_end

	#line 523 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/char_set.hpp"
#endif

//file_end

	#line 18 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/decl_system_type.hpp"
//decl_system_type.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//copy&rewrite from steve02081504/steve.h
#define linux 2
#define windows 3
#define other 4
#if defined(__linux)||defined(__linux__)||defined(__gnu_linux__)
	#define SYSTEM_TYPE linux
#elif defined(_WIN32)||defined(__MINGW32__)||defined(__CYGWIN__)
	#define SYSTEM_TYPE windows
#else
	#define SYSTEM_TYPE other
#endif
#define ERROR_MSG_UNABLE_OS "Unable OS,edit this file on your own or contact ELC's producers."

//file_end

	#line 19 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"
	#if SYSTEM_TYPE == windows
		#define NOMINMAX
		#include <Windows.h>
		#include <debugapi.h>
	#endif
	/// @brief 终止报错相关基础函数
	namespace elc::APIs::die{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

		#line 27 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"

		using namespace elc::defs;

		struct die_state{
			#if SYSTEM_TYPE == windows
				HANDLE hConsole;
				//text_color
				WORD text_color;
			#elif SYSTEM_TYPE == linux
				//nothing
			#endif
		};

		void Init_die_state(die_state&state)noexcept{
			#if SYSTEM_TYPE == windows
				state.hConsole=GetStdHandle(STD_ERROR_HANDLE);
				//chenge color to red
				CONSOLE_SCREEN_BUFFER_INFO csbi;
				GetConsoleScreenBufferInfo(state.hConsole,&csbi);
				state.text_color=csbi.wAttributes;
				SetConsoleTextAttribute(state.hConsole,FOREGROUND_RED);
			#elif SYSTEM_TYPE == linux
				//chenge color to red
				fputs("\033[31m",stderr);
			#endif
		}

		void ConsoleLog(const die_state&state,string_view_t<char> str)noexcept{
			#if SYSTEM_TYPE == windows
				WriteConsoleA(state.hConsole,str.data(),(DWORD)str.size(),nullptr,nullptr);
			#elif SYSTEM_TYPE == linux
				fputs(str.data(),stderr);
			#endif
		}
		void ConsoleLog(const die_state&state,string_view_t<wchar_t> str)noexcept{
			#if SYSTEM_TYPE == windows
				WriteConsoleW(state.hConsole,str.data(),(DWORD)str.size(),nullptr,nullptr);
			#elif SYSTEM_TYPE == linux
				fputws(str.data(),stderr);
			#endif
		}
		void ConsoleLogEnd(const die_state&state)noexcept{
			#if SYSTEM_TYPE == windows
				FlushFileBuffers(state.hConsole);
				//chenge color back
				SetConsoleTextAttribute(state.hConsole,state.text_color);
			#elif SYSTEM_TYPE == linux
				fflush(stderr);
				//chenge color back
				fputs("\033[0m",stderr);
			#endif
		}

		/// @brief 终止整个程序并可能的触发断点或输出错误信息
		[[noreturn]]inline void die()noexcept{
			#if SYSTEM_TYPE == windows
				if(IsDebuggerPresent())
					__debugbreak();
			#endif
			#if defined(_WINMAIN_)
				::MessageBoxW(NULL,L"elc died.",NULL,MB_ICONERROR);
			#endif
			die_state state;
			Init_die_state(state);
			ConsoleLog(state,"elc died.\n");
			ConsoleLogEnd(state);
			::std::abort();
		}
		/// @brief 同 die() ，但是有详细的错误信息
		/// @param err_msg 错误信息
		[[noreturn]]inline void die_with(string_view err_msg)noexcept{
			#if SYSTEM_TYPE == windows
				if(IsDebuggerPresent())
					__debugbreak();
			#endif
			if(err_msg){
				if constexpr(wchar_t_same_as_char16_t){
					push_and_disable_msvc_warning(26494);//未初始化警告diss
					wchar_t err_msg_in_wchar[2048];
					pop_msvc_warning();
					const auto size=char_set::utf32_to_utf16((char16_t*)err_msg_in_wchar,err_msg).processed_output().size();
					err_msg_in_wchar[size]=L'\0';
					#if defined(_WINMAIN_)
						::MessageBoxW(NULL,err_msg_in_wchar,NULL,MB_ICONERROR);
					#endif
					die_state state;
					Init_die_state(state);
					ConsoleLog(state,L"elc died because:\n");
					ConsoleLog(state,err_msg_in_wchar);
					ConsoleLog(state,L"\n");
					ConsoleLogEnd(state);
				}
				elseif constexpr(wchar_t_same_as_char_t){
					const string_view_t<wchar_t> err_msg_in_wchar{(const wchar_t*)err_msg.data(),err_msg.size()};
					#if defined(_WINMAIN_)
						::MessageBoxW(NULL,err_msg_in_wchar.data(),NULL,MB_ICONERROR);
					#endif
					die_state state;
					Init_die_state(state);
					ConsoleLog(state,L"elc died because:\n");
					ConsoleLog(state,err_msg_in_wchar);
					ConsoleLog(state,L"\n");
					ConsoleLogEnd(state);
				}
				else{
					::std::mbstate_t stat{};
					push_and_disable_msvc_warning(26494);//未初始化警告diss
					char err_msg_in_char[2048];
					char* err_msg_write = err_msg_in_char;
					size_t s;
					pop_msvc_warning();
					for(auto c:err_msg){
						s = ::std::c32rtomb(err_msg_write, c, &stat);
						push_and_disable_msvc_warning(26475)//强转警告diss
						if(s == range_n::npos)
							die();
						pop_msvc_warning();
						err_msg_write += s;
					}
					*err_msg_write = '\0';
					#if defined(_WINMAIN_)
						::MessageBoxA(NULL,err_msg_in_char,NULL,MB_ICONERROR);
					#endif
					die_state state;
					Init_die_state(state);
					ConsoleLog(state,"elc died because:\n");
					ConsoleLog(state,err_msg_in_char);
					ConsoleLog(state,"\n");
					ConsoleLogEnd(state);
				}
			}
			else
				die();
			::std::abort();
		}

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

		#line 164 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"
	}
	//
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/_tools/undef_decl_system_type.hpp"
//undef_decl_system_type.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//copy&rewrite from steve02081504/evest.h
#undef linux
#undef windows
#undef other
#undef SYSTEM_TYPE
#undef ERROR_MSG_UNABLE_OS

//file_end

	#line 167 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/die.hpp"

	namespace elc::defs{
		using elc::APIs::die::die;
		using elc::APIs::die::die_with;
	}
#endif

//file_end

#line 15 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
//include locale：自然语言相关的字符串
//strings
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
//using.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*
locale说明
elc使用的字符串.
调整这些,实现快速本地化.
*/
#if !defined(ELC_LOCALE)
	#define ELC_LOCALE
	#include <locale>
	//
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
//default_data_type.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace elc{
	/*ELC内部string统一采用char_t宽字符，使用setlocale(LC_ALL,"en_US.utf8")下的UTF编码。*/
	typedef char32_t char_t;
	/*c_string表示*/
	typedef char_t* string_ptr_t;
	/*c_string表示*/
	typedef const char_t* const_string_ptr_t;
	/*ELC内部钦定int_t类型*/
	typedef int64_t int_t;
	/*ELC内部钦定uint_t类型*/
	typedef uint64_t uint_t;
	/*ELC内部钦定float_t类型*/
	typedef double float_t;
	/*ELC内部钦定float_size_t类型，用以描述内存大小的浮点状况*/
	typedef long double float_size_t;
}

//file_end

	#line 17 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/_char.hpp"
//_char.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace elc::defs::locale{
	inline const ::std::locale default_locale{"en_US.utf8"};
	namespace char_n{
		template <class charT> bool isspace (charT c){ return isspace (c,default_locale); }
		template <class charT> bool isprint (charT c){ return isprint (c,default_locale); }
		template <class charT> bool iscntrl (charT c){ return iscntrl (c,default_locale); }
		template <class charT> bool isupper (charT c){ return isupper (c,default_locale); }
		template <class charT> bool islower (charT c){ return islower (c,default_locale); }
		template <class charT> bool isalpha (charT c){ return isalpha (c,default_locale); }
		template <class charT> bool isdigit (charT c){ return isdigit (c,default_locale); }
		template <class charT> bool ispunct (charT c){ return ispunct (c,default_locale); }
		template <class charT> bool isxdigit(charT c){ return isxdigit(c,default_locale); }
		template <class charT> bool isalnum (charT c){ return isalnum (c,default_locale); }
		template <class charT> bool isgraph (charT c){ return isgraph (c,default_locale); }
		template <class charT> charT toupper(charT c){ return toupper (c,default_locale); }
		template <class charT> charT tolower(charT c){ return tolower (c,default_locale); }
	}
}

//file_end

	#line 18 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	//
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
//base_defs
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"
#line 24 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_defs"

//file_end

	#line 20 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	//
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

	#line 22 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/zh_cn.hpp"
//zh_cn.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*
locale说明
elc使用的字符串.
调整这些,实现快速本地化.
*/
namespace elc::defs::locale::func{

}
namespace elc::defs::locale::str{
	inline namespace gc{
		inline constexpr auto gc_fail=es"gc失败"_constexpr_str;
		inline constexpr auto empty_gc_method=es"gc方法为空时gc被调用"_constexpr_str;
	}
	inline namespace code_convert{
		inline constexpr auto setlocale_error=es"setlocale出错"_constexpr_str;
		inline constexpr auto code_convert_error=es"编码转换出错"_constexpr_str;
	}
	inline namespace lib_load{
		inline constexpr auto null_lib=es"访问null处的lib对象"_constexpr_str;
	}
	inline namespace exception{
		inline constexpr auto unknow_error=es"未知错误"_constexpr_str;
		inline constexpr auto core_runtime_internal_helper_leak=es"未知错误"_constexpr_str;
	}
	inline namespace base_read{
		inline constexpr auto ending_of_expr_beyond_expectations=es"表达式的结尾超出预期"_constexpr_str;
		inline constexpr auto expr_incomplete=es"表达式未完成"_constexpr_str;
		inline constexpr auto symbol_is_undefined=es"此符号未定义"_constexpr_str;
		inline constexpr auto expr_too_outrageous=es"表达式过于离谱"_constexpr_str;
	}
	inline namespace package_symbol_loader{
		inline constexpr auto load_failed=es"无法加载的package_symbol_loader"_constexpr_str;
		inline constexpr auto load_interface_failed=es"package_symbol_loader缺失load_interface"_constexpr_str;
	}
	inline namespace streams{
		inline constexpr auto stream_read_error=es"流读取错误"_constexpr_str;
		inline constexpr auto stream_write_error=es"流写入错误"_constexpr_str;
	}
	inline namespace die{
		//TODO
	}
}

//file_end

	#line 23 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

	#line 24 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
	//
#endif

//file_end

#line 17 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"

namespace elc::defs{ //在elc::defs中定义内容
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 20 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"

	namespace memory{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace lifetime_n{
	class copy_t;

	class move_t;
	//

	template<class T>
	class construct_t;
	template<class T,class...Args>
	constexpr bool construct_able=::std::is_constructible_v<T,Args...>;
	template<class T,class...Args>
	constexpr bool construct_nothrow=::std::is_nothrow_constructible_v<T,Args...>;
	template<class T,class...Args>
	constexpr bool construct_trivial=::std::is_trivially_constructible_v<T,Args...>;

	class destruct_t;
	template<class T>
	constexpr bool destruct_able=::std::is_destructible_v<T>;
	template<class T>
	constexpr bool destruct_nothrow=::std::is_nothrow_destructible_v<T>;
	template<class T>
	constexpr bool destruct_trivial=::std::is_trivially_destructible_v<T>;
	//

	class copy_construct_t;
	template<class T>
	constexpr bool copy_construct_able=::std::is_copy_constructible_v<T>;
	template<class T>
	constexpr bool copy_construct_nothrow=::std::is_nothrow_copy_constructible_v<T>;
	template<class T>
	constexpr bool copy_construct_trivial=::std::is_trivially_copy_constructible_v<T>;

	class move_construct_t;
	template<class T>
	constexpr bool move_construct_able=::std::is_move_constructible_v<T>;
	template<class T>
	constexpr bool move_construct_nothrow=::std::is_nothrow_move_constructible_v<T>;
	template<class T>
	constexpr bool move_construct_trivial=::std::is_trivially_move_constructible_v<T>;
	//

	class copy_assign_t;
	template<class T>
	constexpr bool copy_assign_able=::std::is_copy_assignable_v<T>;
	template<class T>
	constexpr bool copy_assign_nothrow=::std::is_nothrow_copy_assignable_v<T>;
	template<class T>
	constexpr bool copy_assign_trivial=::std::is_trivially_copy_assignable_v<T>;

	class move_assign_t;
	template<class T>
	constexpr bool move_assign_able=::std::is_move_assignable_v<T>;
	template<class T>
	constexpr bool move_assign_nothrow=::std::is_nothrow_move_assignable_v<T>;
	template<class T>
	constexpr bool move_assign_trivial=::std::is_trivially_move_assignable_v<T>;
	//

	template<class T> requires(::std::is_trivially_copyable_v<T>)
	force_inline T* super_speed_trivial_copy_from_one(T*to,const T&value,size_t size)noexcept{
		if constexpr(sizeof(T)==sizeof(unsigned char))
			::std::memset((unsigned char*)to,(unsigned char)value,size);
		elseif constexpr(sizeof(T)==sizeof(wchar_t))
			::std::wmemset((wchar_t*)to,(wchar_t)value,size);
		else
			if(is_all_byte_zero(value))
				::std::memset(to,zero,size*sizeof(T));
			else
				::std::fill_n(to,size,value);
		return to;
	}
	template<class T> requires(::std::is_trivially_copyable_v<T>)
	force_inline T* super_speed_trivial_copy_from_one(T*to,const T&value)noexcept{
		if constexpr(sizeof(T)>=sizeof(::std::max_align_t))
			if(is_all_byte_zero(value))
				::std::memset(to,zero,sizeof(T));
			else
				*to=value;
		else
			*to=value;
		return to;
	}

	/*!
	所有的construct_t实例都派生于此
	*/
	struct base_construct_t{};
	/*!
	用于构造实例
	用法详见变量模板construct
	*/
	template<typename T>
	struct construct_t:base_construct_t{
		typedef base_construct_t base_t;
		template<class...Args>
		static constexpr bool able=construct_able<T,Args...>;
		template<class...Args>
		static constexpr bool nothrow=construct_nothrow<T,Args...>;
		template<class...Args>
		static constexpr bool trivial=construct_trivial<T,Args...>;

		template<class...Args> requires able<Args...>
		[[nodiscard]]force_inline T operator()(Args&&...rest)const noexcept(nothrow<Args...>){
			return T(forward<Args>(rest)...);
		}
		struct array_construct_t{
			T*_to;
			size_t _size;
			constexpr void never_in_array_check()const noexcept{
				if constexpr(type_info<T>.has_attribute(never_in_array))
					template_error("You can\'t construct an array for never_in_array type.");
			}
			template<class...Args> requires able<Args...>
			force_inline void base_call(Args&&...rest)const noexcept(nothrow<Args...>){
				auto tmp=_size;
				while(tmp--)new(_to+tmp)T(forward<Args>(rest)...);
			}
			template<class...Args> requires able<Args...>
			force_inline T* operator()(Args&&...rest)const noexcept(nothrow<Args...>){
				never_in_array_check();
				base_call(forward<Args>(rest)...);
				return _to;
			}
			//复制构造速度优化
			force_inline T* operator()(const T&v)const noexcept(nothrow<const T&>)requires able<const T&>{
				never_in_array_check();
				if constexpr(trivial<const T&> && ::std::is_trivially_copyable_v<T>)
					super_speed_trivial_copy_from_one(_to,v,_size);
				else
					base_call(forward<const T&>(v));
				return _to;
			}
			//默认构造逻辑优化
			force_inline T* operator()()const noexcept(nothrow<>)requires able<>{
				never_in_array_check();
				if constexpr(!trivial<>)
					base_call();
				return _to;
			}
		};
		struct placement_construct_t{
			T*_to;
			template<class...Args> requires able<Args...>
			force_inline void base_call(Args&&...rest)const noexcept(nothrow<Args...>){
				new(_to)T(forward<Args>(rest)...);
			}
			template<class...Args> requires able<Args...>
			force_inline T* operator()(Args&&...rest)const noexcept(nothrow<Args...>){
				base_call(forward<Args>(rest)...);
				return _to;
			}
			//复制构造速度优化
			force_inline T* operator()(const T&v)const noexcept(nothrow<const T&>)requires able<const T&>{
				if constexpr(trivial<const T&> && ::std::is_trivially_copyable_v<T>)
					super_speed_trivial_copy_from_one(_to,v);
				else
					base_call(forward<const T&>(v));
				return _to;
			}
			//默认构造逻辑优化
			force_inline T* operator()()const noexcept(nothrow<>)requires able<>{
				if constexpr(!trivial<>)
					base_call();
				return _to;
			}
			[[nodiscard]]force_inline constexpr array_construct_t operator[](size_t size)const noexcept{return{_to,size};}
		};
		[[nodiscard]]force_inline constexpr placement_construct_t operator[](T*p)const noexcept{return{p};}
	};
	/*!
	constexpr变量模板，用于构造实例
	用法：
	construct<类型>.able<构造参数类型>		->	bool
	construct<类型>.nothrow<构造参数类型>	->	bool
	construct<T>(参数)						->	T		（以参数构建T类型实例）

	construct<T>[T*ptr](参数)				->	T*		（以参数在ptr地址处构建T类型实例，返回ptr）
	construct<T>[T*ptr][size_t size](参数)	->	T*		（以参数在ptr地址处构建size个T类型实例，返回ptr）
	*/
	template<typename T>
	constexpr construct_t<T>construct{};

	/*!
	用于销毁实例
	用法：
	destruct.able<类型>		->	bool
	destruct.nothrow<类型>	->	bool

	destruct(T*ptr)					-> void		（在ptr地址处析构T类型实例，T可为数组）
	destruct[size_t size](T*ptr)	-> void		（析构以ptr地址起始共size个T类型实例，T可为数组）
	*/
	constexpr struct destruct_t{
		template<class T>
		static constexpr bool able=destruct_able<T>;
		template<class T>
		static constexpr bool nothrow=destruct_nothrow<T>;
		template<class T>
		static constexpr bool trivial=destruct_trivial<T>;

		template<class T> requires able<T>
		static force_inline void base_call([[maybe_unused]]T*to)noexcept(nothrow<T>){
			if constexpr(!trivial<T>)
				if constexpr(::std::is_array_v<T>)
					for(auto&i : *to)
						base_call(addressof(i));
				else
					push_and_disable_msvc_warning(26457)
					to->~T();
					pop_msvc_warning()
		}

		template<class T> requires able<T>
		static void base_call([[maybe_unused]]T*begin,[[maybe_unused]]size_t size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
			if constexpr(!trivial<T>)
				while(size--)base_call(begin+size);
		}

		template<class T> requires able<T>
		force_inline void operator()(T*begin)const noexcept(nothrow<T>){
			base_call(begin);
		}

		struct array_destruct_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline void operator()(T*begin)const noexcept(nothrow<T>){
				base_call(begin,_size);
			}
		};

		[[nodiscard]]force_inline constexpr array_destruct_t operator[](size_t size)const noexcept{return{size};}

		struct not_t{};
		/*适用于unget(this,not destruct);*/
		force_inline constexpr not_t operator!()const noexcept{return not_t{};}
	}destruct{};

	/*!
	用于重新构造实例：先摧毁，再原地构建
	用法：
	re_construct.able<类型>		->	bool
	re_construct.nothrow<类型>	->	bool

	re_construct(T*ptr)						->	T*		（以无参数在ptr地址处重新构建T类型实例，返回ptr）
	re_construct[T*ptr](参数)				->	T*		（以参数在ptr地址处重新构建T类型实例，返回ptr）
	re_construct[T*ptr][size_t size](参数)	->	T*		（以参数在ptr地址处重新构建size个T类型实例，返回ptr）
	常见用法：
	re_construct(this)
	*/
	constexpr struct re_construct_t{
		template<class T,class...Args>
		static constexpr bool able=destruct.able<T>&&construct<T>.able<Args...>;
		template<class T,class...Args>
		static constexpr bool nothrow=destruct.nothrow<T>&&construct<T>.nothrow<Args...>;
		template<class T,class...Args>
		static constexpr bool trivial=destruct.trivial<T>&&construct<T>.trivial<Args...>;

		template<class T> requires able<T>
		force_inline T* operator()(T*to)const noexcept(nothrow<T>){
			destruct(to);
			construct<T>[to]();
			return to;
		}
		template<class T>
		struct array_re_construct_t{
			T*_to;
			size_t _size;
			template<class...Args> requires able<T,Args...>
			T* operator()(Args&&...rest)const noexcept(nothrow<T,Args...>){
				if constexpr(type_info<T>.has_attribute(never_in_array))
					template_error("You cannot perform array operations on never_in_array type.");
				destruct[_size](_to);
				construct<T>[_to][_size](forward<Args>(rest)...);
				return _to;
			}
		};
		template<class T>
		struct placement_re_construct_t{
			T*_to;
			template<class...Args> requires able<T,Args...>
			T* operator()(Args&&...rest)const noexcept(nothrow<T,Args...>){
				destruct(_to);
				construct<T>[_to](forward<Args>(rest)...);
				return _to;
			}
			[[nodiscard]]force_inline constexpr array_re_construct_t<T> operator[](size_t size)const noexcept{return{_to,size};}
		};
		template<class T>
		[[nodiscard]]force_inline constexpr placement_re_construct_t<T> operator[](T*p)const noexcept{return{p};}
	}re_construct;

	constexpr struct copy_construct_t{
		template<class T>
		static constexpr bool r_able=copy_construct_able<T>?
									 copy_construct_trivial<T>||!(construct<T>.trivial<>&&copy_assign_trivial<T>)
									 :false;//trivial操作优先考虑
		template<class T>
		static constexpr bool able=r_able<T>?true:(construct<T>.able<>&&copy_assign_able<T>);
		template<class T>
		static constexpr bool nothrow=r_able<T>?copy_construct_nothrow<T>:
										(construct<T>.nothrow<>&&copy_assign_nothrow<T>);
		template<class T>
		static constexpr bool trivial=r_able<T>?copy_construct_trivial<T>:
										(construct<T>.trivial<>&&copy_assign_trivial<T>);

		template<class T> requires able<T>
		static T*base_call(T*to,const T*from)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				return reinterpret_cast<T*>(::std::memcpy(to,add_const(from),sizeof(T)));
			else{
				if constexpr(r_able<T>)
					new(to)T(*from);
				else{
					construct<T>[to]();
					*to=*from;
				}
				return to;
			}
		}

		template<class T> requires able<T>
		static T*base_call(T*to,const T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				return reinterpret_cast<T*>(::std::memcpy(to,add_const(from),sizeof(T)*size));
			else{
				while(size--)
					base_call(to+size,from+size);
				return to;
			}
		}

		template<class T> requires able<T>
		force_inline T*operator()(T*to,const T*from)const noexcept(nothrow<T>)
		{return base_call(to,from);}

		template<class T> requires able<T>
		force_inline T*operator()(note::to_t<T*>to,note::from_t<const T*>from)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		template<class T> requires able<T>
		force_inline T*operator()(note::from_t<const T*>from,note::to_t<T*>to)const noexcept(nothrow<T>)
		{return base_call(to(),from());}


		template<class T> requires able<T>
		force_inline T*operator()(T*to,const T*from,size_t size)const noexcept(nothrow<T>)
		{return base_call(to,from,size);}

		template<class T> requires able<T>
		force_inline T*operator()(note::to_t<T*>to,note::from_t<const T*>from,size_t size)const noexcept(nothrow<T>)
		{return base_call(to(),from(),size);}

		template<class T> requires able<T>
		force_inline T*operator()(note::from_t<const T*>from,note::to_t<T*>to,size_t size)const noexcept(nothrow<T>)
		{return base_call(to(),from(),size);}

		template<class T> requires able<T>
		static T*base_call(T*to,const T&from)noexcept(nothrow<T>){
			if constexpr(r_able<T>)
				construct<T>[to](from);
			else{
				construct<T>[to]();
				*to=from;
			}
			return to;
		}

		template<class T> requires able<T>
		static T*base_call(T*to,const T&from,size_t size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
			if constexpr(::std::is_trivially_copyable_v<T>)
				super_speed_trivial_copy_from_one(to,from,size);
			else
				while(size--)
					base_call(to+size,from);
			return to;
		}

		template<class T> requires able<T>
		force_inline T*operator()(T*to,const T&from)const noexcept(nothrow<T>)
		{return base_call(to,from);}

		struct array_copy_construct_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,const T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(T*to,const T&from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<const T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<const T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
		};
		[[nodiscard]]force_inline constexpr array_copy_construct_t operator[](size_t a)const noexcept{return{a};}
	}copy_construct{};

	constexpr struct move_construct_t{
		template<class T>
		static constexpr bool r_able=move_construct_able<T>?
									 move_construct_trivial<T>||!copy_construct.trivial<T>
									 :false;//trivial操作优先考虑
		template<class T>
		static constexpr bool able=r_able<T>?true:copy_construct.able<T>;
		template<class T>
		static constexpr bool nothrow=r_able<T>?move_construct_nothrow<T>:
												copy_construct.nothrow<T>;
		template<class T>
		static constexpr bool trivial=r_able<T>?move_construct_trivial<T>:
												copy_construct.trivial<T>;

		template<class T> requires able<T>
		static T*base_call(T*to,T*from)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				return reinterpret_cast<T*>(::std::memcpy(to,add_const(from),sizeof(T)));
			else{
				if constexpr(r_able<T>){
					construct<T>[to](::std::move(*from));
					return to;
				}else
					return copy_construct(to,from);
			}
		}
		template<class T> requires able<T>
		static T*base_call(T*to,T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
			if constexpr(trivial<T>)
				return reinterpret_cast<T*>(::std::memcpy(to,add_const(from),sizeof(T)*size));
			else{
				if constexpr(r_able<T>){
					while(size--)
						construct<T>[to+size](::std::move(from[size]));
					return to;
				}else
					return copy_construct[size](to,from);
			}
		}

		template<class T> requires able<T>
		force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>)
		{return base_call(to,from);}

		template<class T> requires able<T>
		force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		template<class T> requires able<T>
		force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		struct array_move_construct_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
		};
		[[nodiscard]]force_inline constexpr array_move_construct_t operator[](size_t a)const noexcept{return{a};}
	}move_construct{};

	constexpr struct move_t{
		template<class T>
		static constexpr bool able=move_construct.able<T>&&destruct.able<T>;
		template<class T>
		static constexpr bool nothrow=move_construct.nothrow<T>&&destruct.nothrow<T>;
		template<class T>
		static constexpr bool trivial=move_construct.trivial<T>&&destruct.trivial<T>;

		template<class T> requires able<T>
		static T*base_call(T*to,T*from)noexcept(nothrow<T>){
			move_construct(to,from);
			destruct(from);
			return to;
		}
		template<class T> requires able<T>
		static T*base_call(T*to,T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
			move_construct[size](to,from);
			destruct[size](from);
			return to;
		}

		template<class T> requires able<T>
		force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>)
		{return base_call(to,from);}

		template<class T> requires able<T>
		force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		template<class T> requires able<T>
		force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>)
		{return base_call(to(),from());}

		struct array_move_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
		};
		[[nodiscard]]force_inline constexpr array_move_t operator[](size_t a)const noexcept{return{a};}

		//特殊使用
		template<class T>
		[[nodiscard]]constexpr remove_ref<T>&& operator()(T&&a)const noexcept{
			return static_cast<remove_ref<T>&&>(a);
		}
	}move{};

	constexpr struct copy_t{
		//特殊使用
		//UF
		template<class T> requires(copy_construct.able<T>)
		[[nodiscard]]constexpr T operator()(const T&a)const noexcept{
			return copy_construct<T>(a);
		}
	}copy{};

	constexpr struct copy_assign_t{
		template<class T>
		static constexpr bool r_able=copy_assign_able<T>?
									 copy_assign_trivial<T>||!(copy_construct_trivial<T>&&destruct.trivial<T>)
									 :false;//trivial操作优先考虑
		template<class T>
		static constexpr bool able=r_able<T>?true:(copy_construct_able<T>&&destruct.able<T>);
		template<class T>
		static constexpr bool nothrow=r_able<T>?copy_assign_nothrow<T>:
											(copy_construct_nothrow<T>&&destruct.nothrow<T>);
		template<class T>
		static constexpr bool trivial=r_able<T>?copy_assign_trivial<T>:
											(copy_construct_trivial<T>&&destruct.trivial<T>);

		template<class T> requires able<T>
		static T& base_call(T&a,const T&b)noexcept(nothrow<T>){
			if constexpr(r_able<T>)
				a=b;
			else{
				destruct(&a);
				construct<T>[&a](b);
			}
			return a;
		}
		template<class T> requires able<T>
		static T* base_call(T*to,const T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				::std::memcpy(to,add_const(from),size*sizeof(T));
			else
				while(size--)
					base_call(to[size],from[size]);
			return to;
		}
		template<class T> requires able<T>
		static T* base_call(T* to,const T& from,size_t size)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				super_speed_trivial_copy_from_one(to,from,size);
			else
				while(size--)
					base_call(to[size],from);
			return to;
		}

		template<class T> requires able<T>
		force_inline T& operator()(T&a,const T&b)const noexcept(nothrow<T>){
			return base_call(a,b);
		}

		struct array_copy_assign_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,const T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<const T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<const T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(const T&from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return base_call(to(),from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,const T&from)const noexcept(nothrow<T>){
				return base_call(to(),from,_size);
			}
		};
		[[nodiscard]]force_inline constexpr array_copy_assign_t operator[](size_t a)const noexcept{return{a};}
	}copy_assign{};

	constexpr struct move_assign_t{
		template<class T>
		static constexpr bool r_able=move_assign_able<T>;
		template<class T>
		static constexpr bool able=r_able<T>?true:copy_assign.able<T>;
		template<class T>
		static constexpr bool nothrow=r_able<T>?move_assign_nothrow<T>:copy_assign.nothrow<T>;
		template<class T>
		static constexpr bool trivial=r_able<T>?move_assign_trivial<T>:copy_assign.trivial<T>;

		template<class T> requires able<T>
		static T& base_call(T&a,T&&b)noexcept(nothrow<T>){
			if constexpr(r_able<T>)
				a=move(b);
			else
				copy_assign(a,b);
			return a;
		}
		template<class T> requires able<T>
		static T* base_call(T*to,T*from,size_t size)noexcept(nothrow<T>){
			if constexpr(trivial<T>)
				::std::memcpy(to,add_const(from),size*sizeof(T));
			else
				while(size--)
					base_call(to[size],from[size]);
			return to;
		}

		template<class T> requires able<T>
		force_inline T& operator()(T&a,T&b)const noexcept(nothrow<T>){
			return base_call(a,move(b));
		}

		struct array_move_assign_t{
			size_t _size;
			template<class T> requires able<T>
			force_inline T*operator()(T*to,T*from)const noexcept(nothrow<T>){
				return base_call(to,from,_size);
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::to_t<T*>to,note::from_t<T*>from)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
			template<class T> requires able<T>
			force_inline T*operator()(note::from_t<T*>from,note::to_t<T*>to)const noexcept(nothrow<T>){
				return operator()(to(),from());
			}
		};
		[[nodiscard]]force_inline constexpr array_move_assign_t operator[](size_t a)const noexcept{return{a};}
	}move_assign{};
}

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_export.hpp"
//_export.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using lifetime_n::
export construct;
export destruct;
export re_construct;
export copy_assign;
export move_assign;
export move;
export copy;
export copy_construct;
export move_construct;
#undef export

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_test.hpp"
//_test.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace lifetime_n{
	//BLOCK:for debug
	inline void test(){
		ELC_TEST_EVENTNAME("lifetime部分测试");
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
	//BLOCK_END
}

//file_end

	#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/lifetime/_body.hpp"
#endif

//file_end

		#line 23 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
	}
	namespace base{
		//依赖lifetime
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/_body.hpp"
//_body.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//D?
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/flag.hpp"
//flag.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*
表示flag是否被设置的enum字面量.
*/
enum class flag_set_type:bool{seted=true,not_set=false};
using enum flag_set_type;
/*
bool的简易包装以表示『是否被设置』,无法使用operator=,因为不应如此.
*/
class flag{
	bool _m;
public:
	constexpr explicit flag(flag_set_type a=not_set)noexcept:_m(bool(a)){}
	[[nodiscard]]explicit operator bool()const noexcept{return _m;}
	flag(flag&a)noexcept:_m((bool)a){}
	flag(flag&&a)noexcept:_m((bool)a){}
	inline void operator=(flag&)&noexcept=delete;
	inline void operator=(flag&&)&noexcept=delete;
	inline void set()noexcept{_m=true;}
	inline void unset()noexcept{_m=false;}
};

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/mark_type.hpp"
//mark_type.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*
表明是否被标记的enum字面量.
*/
enum class mark_type:bool{marked=true,not_mark=false};
using enum mark_type;
/*
用于gc的可达性分析的普通模板式elc属性.
*/
template<typename T>
class mark_able:non_copyable,non_moveable{
	mutable flag _m;
public:
	constexpr explicit mark_able(mark_type a=not_mark)noexcept:_m(a==not_mark?not_set:seted){};
	inline void mark()const noexcept{_m.set();}
	inline void unmark()const noexcept{_m.unset();}
	[[nodiscard]]bool was_marked()const noexcept{return(bool)_m;}
};

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/iterator.hpp"
//iterator.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace iterator_n{
	using namespace memory;//copy_assign、move_assign
	template<typename base_t_w>
	struct reverse_base_t{
		typedef reverse_base_t<base_t_w> this_t;
		typedef remove_cv<base_t_w> base_t_rw;
		base_t_rw _m;
		template<typename build_base_t_T> requires(construct<base_t_rw>.able<build_base_t_T>)
		constexpr reverse_base_t(build_base_t_T&& a)noexcept(construct<base_t_rw>.nothrow<build_base_t_T>):_m(a){}
		[[nodiscard]]auto get_before()noexcept_as(declvalue(base_t_w).get_next()){ return ((base_t_w&)_m).get_next(); }
		[[nodiscard]]auto get_next()noexcept_as(declvalue(base_t_w).get_before()){ return ((base_t_w&)_m).get_before(); }
		[[nodiscard]]auto get_handle()noexcept_as(declvalue(base_t_w).get_handle()){ return ((base_t_w&)_m).get_handle(); }
	};
	template<typename base_t> requires(compare.able<base_t>)
	[[nodiscard]]auto operator<=>(const reverse_base_t<base_t>&a,const reverse_base_t<base_t>&b)noexcept(compare.nothrow<base_t>){
		return compare((const base_t&)b._m,(const base_t&)a._m);
	}
	template<typename base_t,typename T> requires(compare.able<T,base_t> && type_info<remove_cvref<T>> != type_info<reverse_base_t<base_t>::base_t_rw>)
	[[nodiscard]]auto operator<=>(const reverse_base_t<base_t>& a,T&& b)noexcept(compare.nothrow<T,base_t>){
		return compare(b,(const base_t&)a._m);
	}
	template<typename base_t,typename T> requires(compare.able<base_t,T> && type_info<remove_cvref<T>> != type_info<reverse_base_t<base_t>::base_t_rw>)
	[[nodiscard]]auto operator<=>(T&& a,const reverse_base_t<base_t>& b)noexcept(compare.nothrow<base_t,T>){
		return compare((const base_t&)b._m,a);
	}
	template<typename base_t,typename T> requires(equal.able<T,base_t>)
	[[nodiscard]]auto operator==(const reverse_base_t<base_t>& a,T&& b)noexcept(equal.nothrow<T,base_t>){
		return equal(b,(const base_t&)a._m);
	}
	template<typename base_t,typename T> requires(equal.able<base_t,T>)
	[[nodiscard]]auto operator==(T&& a,const reverse_base_t<base_t>& b)noexcept(equal.nothrow<base_t,T>){
		return equal((const base_t&)b._m,a);
	}

	template<typename value_t,typename base_t_w>
	class same_base_t{
		template<typename,typename>
		friend class same_base_t;
	protected:
		typedef same_base_t<value_t,base_t_w>this_t;
		typedef remove_cv<base_t_w> base_t_rw;
		//
		mutable base_t_rw _m;
		//
		[[nodiscard]]static constexpr bool is_handle_getter_noexcept()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_handle()))
				return noexcept(declvalue(base_t_w)->get_handle());
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_handle()))
				return noexcept(declvalue(base_t_w).get_handle());
		}
		[[nodiscard]]inline value_t*handle_getter()const noexcept(is_handle_getter_noexcept()){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return ((base_t_w)_m);
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_handle()))
				return ((base_t_w)_m)->get_handle();
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_handle()))
				return ((base_t_w)_m).get_handle();
		}
		//
		[[nodiscard]]static constexpr bool is_value_getter_noexcept()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_value()))
				return noexcept(declvalue(base_t_w)->get_value());
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_value()))
				return noexcept(declvalue(base_t_w).get_value());
		}

		[[nodiscard]]static constexpr auto value_type_getter()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return type_info<decltype(*((base_t_w)_m))>;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_value()))
				return type_info<decltype(((base_t_w)_m)->get_value())>;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_value()))
				return type_info<decltype(((base_t_w)_m).get_value())>;
			else
				return type_info<decltype(*declvalue(value_t*))>;
		}
		typedef decltype(value_type_getter())::template_name type value_type;

		[[nodiscard]]inline value_type value_getter()const noexcept(is_handle_getter_noexcept()){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return *((base_t_w)_m);
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_value()))
				return ((base_t_w)_m)->get_value();
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_value()))
				return ((base_t_w)_m).get_value();
			else
				return *handle_getter();
		}
		//
		[[nodiscard]]static constexpr bool is_next_getter_noexcept()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_next()))
				return noexcept(declvalue(base_t_w)->get_next());
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_next()))
				return noexcept(declvalue(base_t_w).get_next());
		}
		[[nodiscard]]inline base_t_w next_getter()const noexcept(is_next_getter_noexcept()){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return ((base_t_w)_m)+1;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_next()))
				return ((base_t_w)_m)->get_next();
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_next()))
				return ((base_t_w)_m).get_next();
		}
		//
		[[nodiscard]]static constexpr bool is_before_getter_noexcept()noexcept{
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return true;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_before()))
				return noexcept(declvalue(base_t_w)->get_before());
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_before()))
				return noexcept(declvalue(base_t_w).get_before());
		}
		[[nodiscard]]inline base_t_w before_getter()const noexcept(is_before_getter_noexcept()){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return ((base_t_w)_m)-1;
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w)->get_before()))
				return ((base_t_w)_m)->get_before();
			elseif constexpr(was_not_an_ill_form(declvalue(base_t_w).get_before()))
				return ((base_t_w)_m).get_before();
		}
	public:
		constexpr void swap_with(this_t&a)noexcept_as(swap(declvalue(base_t_rw&),declvalue(base_t_rw&))){swap(_m,a._m);}
		//
		constexpr same_base_t()noexcept=default;
		template<typename build_base_t_T> requires(construct<base_t_rw>.able<build_base_t_T>)
		constexpr same_base_t(build_base_t_T&&a)noexcept(construct<base_t_rw>.nothrow<build_base_t_T>):_m(a){}
		constexpr same_base_t(const this_t&a)noexcept(construct<base_t_rw>.nothrow<const base_t_rw>):_m(a._m){}
		constexpr same_base_t(this_t&&a)noexcept_as(declvalue(this_t).swap_with(a)){swap_with(a);}
		template<typename other_T,typename other_base_t> requires(construct<base_t_rw>.able<other_base_t>)
		constexpr same_base_t(const same_base_t<other_T,other_base_t>&a)noexcept(construct<base_t_rw>.nothrow<other_base_t>):_m(a._m){}
		~same_base_t()noexcept(destruct.nothrow<base_t_rw>)=default;
		[[nodiscard]]constexpr bool		  operator==(const this_t& a)const noexcept_as(declvalue(base_t_rw) == declvalue(base_t_rw)){ return _m == a._m; }
		[[nodiscard]]constexpr value_t*   operator->()noexcept(is_handle_getter_noexcept()){ return handle_getter(); }
		[[nodiscard]]constexpr value_type operator*()noexcept_as(is_value_getter_noexcept()){ return value_getter(); }
		[[nodiscard]]constexpr			  operator value_t*()noexcept_as(declvalue(this_t).operator->()){ return operator->(); }
		[[nodiscard]]constexpr bool		  operator==(value_t* a)const noexcept(is_handle_getter_noexcept()&&noexcept(pointer_equal(declvalue(value_t*),declvalue(value_t*)))){ return pointer_equal(handle_getter(),a); }
		template<typename other_value_t,typename other_base_t_w> requires(equal.able<base_t_rw,other_base_t_w>)
		[[nodiscard]]constexpr bool operator==(const same_base_t<other_value_t,other_base_t_w>& a)const noexcept(equal.nothrow<base_t_rw,other_base_t_w>){
			return equal(_m,a._m);
		}
		template<typename other_value_t,typename other_base_t_w>
		[[nodiscard]]constexpr auto operator<=>(const same_base_t<other_value_t,other_base_t_w>& a)const noexcept(compare.nothrow<base_t_rw,other_base_t_w>){
			if constexpr(compare.able<base_t_rw,other_base_t_w>)
				return compare(_m,a._m);
		}
	};
	template<typename value_t,typename base_t_w>
	inline void swap(same_base_t<value_t,base_t_w>&a,same_base_t<value_t,base_t_w>&b)noexcept_as(a.swap_with(b))
	{a.swap_with(b);}

	template<typename value_t,typename base_t_w>
	struct base_iterator_t:same_base_t<value_t,base_t_w>{
		typedef base_iterator_t<value_t,base_t_w> this_t;
		typedef same_base_t<value_t,base_t_w> base_t;
	protected:
		using base_t::is_before_getter_noexcept;
		using base_t::is_next_getter_noexcept;
		using base_t::before_getter;
		using base_t::next_getter;
		typedef remove_cv<base_t_w> base_t_rw;
	public:
		using base_t::base_t;
		constexpr this_t&operator=(const base_t_rw&a)&noexcept(copy_assign.nothrow<base_t_rw>){copy_assign(base_t::_m,a);return*this;}
		constexpr this_t&operator=(base_t_rw&&a)&noexcept(move_assign.nothrow<base_t_rw>){move_assign(base_t::_m,a);return*this;}
		constexpr this_t&operator++()&noexcept(is_next_getter_noexcept()){return*this=next_getter();}
		constexpr this_t&operator--()&noexcept(is_before_getter_noexcept()){return*this=before_getter();}
		constexpr this_t operator++(int)&noexcept_as(this_t(++declvalue(this_t&))){auto a=*this;operator++();return a;}
		constexpr this_t operator--(int)&noexcept_as(this_t(--declvalue(this_t&))){auto a=*this;operator--();return a;}
		constexpr this_t operator+(ptrdiff_t num)const noexcept_as(this_t(--declvalue(this_t&)),++declvalue(this_t&)){
			if constexpr(type_info<::std::remove_pointer_t<base_t_w>> == type_info<value_t>)
				return base_t::_m+num;
			else{
				auto a=*this;
				if(num>0)
					while(num--)
						++a;
				else
					while(num++)
						--a;
				return a;
			}
		}
		constexpr this_t operator-(ptrdiff_t num)const noexcept_as(declvalue(this_t&)+0){ return *this+(-num); }
	};
	template<typename value_t,typename base_t_w>
	base_iterator_t(base_iterator_t<value_t,base_t_w>) -> base_iterator_t<value_t,base_t_w>;
	template<typename value_t,typename base_t_w>
	base_iterator_t(value_t*) -> base_iterator_t<value_t,base_t_w>;

	template<typename value_t,typename base_t_w=value_t*>
	using iterator_t = base_iterator_t<remove_cvref<value_t>,base_t_w>;
	template<typename value_t,typename base_t_w=const value_t*>
	using const_iterator_t = base_iterator_t<const remove_cvref<value_t>,base_t_w>;
	template<typename value_t,typename base_t_w=value_t*>
	using reverse_iterator_t = base_iterator_t<remove_cvref<value_t>,reverse_base_t<base_t_w>>;
	template<typename value_t,typename base_t_w=const value_t*>
	using reverse_const_iterator_t = base_iterator_t<const remove_cvref<value_t>,reverse_base_t<base_t_w>>;
}
using iterator_n::base_iterator_t;
using iterator_n::iterator_t;
using iterator_n::const_iterator_t;
using iterator_n::reverse_iterator_t;
using iterator_n::reverse_const_iterator_t;

//file_end

#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/list.hpp"
//list.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//copy from old ELC
template<typename T>
class list_t;
/*
common attribute,表明这是对于list_t可加入的cons.
*/
template<typename T>
struct cons_t:non_copyable,non_moveable,is_common_attribute(cons_t){
	typedef cons_t<T> this_t;
private:
	friend list_t<T>;
	friend iterator_t<T,this_t*>::base_t;
	typedef attribute<T,this_t> attribute_t;

	mutable this_t*_before;//为了在析构时修改前一项的next，勿删
	mutable this_t*_next;

	[[nodiscard]]this_t*get_before()noexcept{return _before;}
	[[nodiscard]]this_t*get_next()noexcept{return _next;}

	constexpr cons_t(this_t*a,this_t*b):_before(a),_next(b){}

	constexpr void set_before(this_t*a){
		_before=a;
		a->_next=this;
	}
	constexpr void set_next(this_t*a){
		_next=a;
		a->_before=this;
	}
	constexpr void insert_to_before(this_t*a){
		set_before(a->_before);
		set_next(a);
	}
	constexpr void bind_with(this_t*a)noexcept{
		set_next(a);
		set_before(a);
	}
	constexpr void remove_from_list()noexcept{
		_before->set_next(_next);
	}
	[[nodiscard]]constexpr T*get_handle(){
		return attribute_t::get_handle();
	}
public:
	constexpr cons_t()=default;
	~cons_t(){
		remove_from_list();
	}
};
/*
T类型的有序双向list.
方法有:
constexpr void add(cons_t<T>*a)noexcept;
constexpr iterator begin()noexcept;
constexpr iterator end()noexcept;
constexpr iterator head()noexcept;
constexpr bool empty()const noexcept;
*/
template<typename T>
struct list_t{
	typedef list_t<T> this_t;
	typedef cons_t<T> cons;
	typedef iterator_t<T,cons*>iterator;
private:
	cons _begin,_end;
public:
	constexpr list_t()noexcept{_begin.bind_with(&_end);}
	inline constexpr void add(cons*a)noexcept{
		a->insert_to_before(&_end);
	}
	[[nodiscard]]constexpr iterator begin()noexcept{return _begin.get_next();}//这叫头迭代器
	[[nodiscard]]constexpr iterator end()noexcept{return&_end;}//这叫超尾迭代器
	[[nodiscard]]constexpr iterator head()noexcept{return&_begin;}//。。。。这个大概就是超头迭代器了😂
	[[nodiscard]]constexpr bool empty()const noexcept{return _begin.get_next()==&_end;}
};

//file_end

#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/function_base.hpp"
//function_base.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace function_base_n{
	#if !defined(_MSC_VER)
	template<typename>
	struct function_type_getter_helper{};

	template<typename Ret_t,typename T,typename...Args_t,bool nothrow>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)noexcept(nothrow)>
	{using type=Ret_t(Args_t...)noexcept(nothrow);};

	template<typename Ret_t,typename T,typename...Args_t,bool nothrow>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)&noexcept(nothrow)>
	{using type=Ret_t(Args_t...)noexcept(nothrow);};

	template<typename Ret_t,typename T,typename...Args_t,bool nothrow>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const noexcept(nothrow)>
	{using type=Ret_t(Args_t...)noexcept(nothrow);};

	template<typename Ret_t,typename T,typename...Args_t,bool nothrow>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const&noexcept(nothrow)>
	{using type=Ret_t(Args_t...)noexcept(nothrow);};

	template<typename T>
	[[nodiscard]]constexpr auto function_type_getter_conditional_helper()noexcept{
		if constexpr(::std::is_function_v<T>)
			return type_info<T>;
		elseif constexpr(is_pointer<T> && ::std::is_function_v<::std::remove_pointer_t<T>>)//不支持多级函数指针：懒得写（其实挺简单的），而且function_t若支持多级函数指针的推导指引会很不安全
			return function_type_getter_conditional_helper<::std::remove_pointer_t<T>>();
		else
			return type_info<type_name function_type_getter_helper<decltype(&T::operator())>::type>;
	}
	template<typename T>
	struct function_type_getter{
		typedef decltype(function_type_getter_conditional_helper<T>())::template_name type type;
	};

	/*
	获取一个callable类型的“函数类型”
	如T(int)返回char，其函数类型便是char(int)
	*/
	template<typename T>
	using get_function_type=function_type_getter<T>::type;

	/*
	用处：容纳一个callable类型（除过函数类型，但可以是其指针）并提供operator()
	小包装工具，能在意想不到的地方发挥效果（比如要额外携带数据的callable类型定义！见"../../lib_loader/lib_loader.hpp"）
	*/
	template<class T,class Func_t=get_function_type<T>>
	class function_data_wrapper_t;
	template<class T,bool nothrow,class Ret_t,class...Args_t>
	struct function_data_wrapper_t<T,Ret_t(Args_t...)noexcept(nothrow)>{
		static_assert(!::std::is_function_v<T>);

		T _value;

		function_data_wrapper_t(T a)noexcept(construct<T>.nothrow<T>):_value(a){}
		~function_data_wrapper_t()noexcept(destruct.nothrow<T>)=default;
		Ret_t operator()(Args_t...args)noexcept(nothrow || invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>){
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		Ret_t operator()(Args_t...args)const noexcept(nothrow || invoke<const T>.with_return_type<Ret_t>.nothrow<Args_t...>){
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		[[nodiscard]]auto&get_data()noexcept{return _value;}
	};
	#else
	//MSVC，我滴垃圾堆
	template<typename>
	struct function_type_getter_helper{};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)>
	{using type=Ret_t(Args_t...);};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)&>
	{using type=Ret_t(Args_t...);};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const>
	{using type=Ret_t(Args_t...);};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const&>
	{using type=Ret_t(Args_t...);};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)noexcept>
	{using type=Ret_t(Args_t...)noexcept;};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)&noexcept>
	{using type=Ret_t(Args_t...)noexcept;};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const noexcept>
	{using type=Ret_t(Args_t...)noexcept;};

	template<typename Ret_t,typename T,typename...Args_t>
	struct function_type_getter_helper<Ret_t(T::*)(Args_t...)const&noexcept>
	{using type=Ret_t(Args_t...)noexcept;};

	template<typename T>
	[[nodiscard]]constexpr auto function_type_getter_conditional_helper()noexcept{
		if constexpr(::std::is_function_v<T>)
			return type_info<T>;
		elseif constexpr(is_pointer<T> && ::std::is_function_v<::std::remove_pointer_t<T>>)//不支持多级函数指针：懒得写（其实挺简单的），而且function_t若支持多级函数指针的推导指引会很不安全
			return function_type_getter_conditional_helper<::std::remove_pointer_t<T>>();
		else
			return type_info<type_name function_type_getter_helper<decltype(&T::operator())>::type>;
	}
	template<typename T>
	struct function_type_getter{
		typedef decltype(function_type_getter_conditional_helper<T>())::template_name type type;
	};

	/*
	获取一个callable类型的“函数类型”
	如T(int)返回char，其函数类型便是char(int)
	*/
	template<typename T>
	using get_function_type=function_type_getter<T>::type;

	/*
	用处：容纳一个callable类型（除过函数类型，但可以是其指针）并提供operator()
	小包装工具，能在意想不到的地方发挥效果（比如要额外携带数据的callable类型定义！见"../../lib_loader/lib_loader.hpp"）
	*/
	template<class T,class Func_t=get_function_type<T>>
	class function_data_wrapper_t;
	template<class T,class Ret_t,class...Args_t>
	struct function_data_wrapper_t<T,Ret_t(Args_t...)noexcept>{
		static_assert(!::std::is_function_v<T>);

		T _value;

		function_data_wrapper_t(T a)noexcept(construct<T>.nothrow<T>):_value(a){}
		~function_data_wrapper_t()noexcept(destruct.nothrow<T>)=default;
		Ret_t operator()(Args_t...args)noexcept{
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>)
				template_warning("this T may throw an exception.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		Ret_t operator()(Args_t...args)const noexcept{
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>)
				template_warning("this T may throw an exception.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		[[nodiscard]]auto&get_data()noexcept{return _value;}
	};
	/*
	用处：容纳一个callable类型（除过函数类型，但可以是其指针）并提供operator()
	小包装工具，能在意想不到的地方发挥效果（比如要额外携带数据的callable类型定义！见"../../lib_loader/lib_loader.hpp"）
	*/
	template<class T,class Ret_t,class...Args_t>
	struct function_data_wrapper_t<T,Ret_t(Args_t...)>{
		static_assert(!::std::is_function_v<T>);

		T _value;

		function_data_wrapper_t(T a)noexcept(construct<T>.nothrow<T>):_value(a){}
		~function_data_wrapper_t()noexcept(destruct.nothrow<T>)=default;
		Ret_t operator()(Args_t...args)noexcept(invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>){
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		Ret_t operator()(Args_t...args)const noexcept(invoke<const T>.with_return_type<Ret_t>.nothrow<Args_t...>){
			//BLOCK:constexpr checks
			if constexpr(!invoke<T>.able<Args_t...>)
				template_error("this T can\'t becall as args.");
			if constexpr(!invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				template_error("the return type of T was wrong.");
			//BLOCK_END
			if constexpr(type_info<Ret_t> != type_info<void>)
				return _value(forward<Args_t>(args)...);
			else
				_value(forward<Args_t>(args)...);
		}
		[[nodiscard]]auto&get_data()noexcept{return _value;}
		[[nodiscard]]const auto&get_data()const noexcept{return _value;}
	};
	#endif
}
using function_base_n::get_function_type;
using function_base_n::function_data_wrapper_t;

//file_end

#line 16 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/tools/_body.hpp"

//file_end

		#line 26 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
	}

	namespace memory{
		//依赖list
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/// @brief 提供gc定义
namespace gc_n{
	/// @brief 当alloc失败时调用此函数
	void gc_for_alloc()noexcept;
}
/// @brief 底层内存管理泛用类型的模板定义
namespace alloc_n{
	using ::elc::defs::memory::gc_n::gc_for_alloc;

	//允许自定义对象的alloc/free/realloc/get_size_of_alloc方法：为pool留的后门（大概）
	//这里是缺省时的默认方法定义
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/default_method/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory::alloc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace default_method{
	//BLOCK:for debug
	#if defined(_MSC_VER)
		#if defined(ELC_TEST_CHECK_MEMORY_LACK)
			#pragma detect_mismatch("ELC_TEST_CHECK_MEMORY_LACK","true")
		#else
			#pragma detect_mismatch("ELC_TEST_CHECK_MEMORY_LACK","false")
		#endif
	#endif

	/*!
	Reallocates a block of memory.

	@param ptr The pointer to the block of memory to reallocate.
	@param nsize The new size of the block of memory.
	@param align The alignment of the block of memory.

	@returns The new pointer to the block of memory.
	*/
	[[nodiscard]]inline byte*base_realloc(byte*ptr,size_t nsize,size_t align)noexcept{
		byte*p=::elc::APIs::alloc::realloc(ptr,nsize,align);
		#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
			if(nsize==0)
				stest_uneventlog(ptr);
			if(p){
				ELC_TEST_EVENTNAME("base_realloc调用");
				if(p!=ptr)
					stest_uneventlog(ptr);
				stest_eventlog(p);
			}
		#endif
		return p;
	}
	/*!
	Allocates aligned memory.

	@param align The alignment of the memory.
	@param size The size of the memory.

	@returns A pointer to the allocated memory.
	*/
	[[nodiscard]]inline byte*base_aligned_alloc(size_t align,size_t size)noexcept{
		byte*p=::elc::APIs::alloc::aligned_alloc(align,size);
		#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
			if(p){
				ELC_TEST_EVENTNAME("base_aligned_alloc调用");
				stest_eventlog(p);
			}
		#endif
		return p;
	}
	/*!
	Frees a pointer allocated by base_alloc.

	@param p The pointer to free.
	@param align The alignment of the pointer.
	*/
	inline void base_free(byte*p,size_t align)noexcept{
		//传入需释放的数据块起始点与大小（字节）
		#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
			auto tmp=stest_geteventlistfromlog(p);
			if(!tmp){
				stest_putsf(L"释放了已释放或未分配指针%p，当前的事件记录如下：",p);
				stest_printeventlist(stderr,stest_geteventlist());
				stest_wait();
				return;
			}else{
				stest_deleteevent(tmp);
				stest_uneventlog(p);
			}
		#endif
		::elc::APIs::alloc::free(p,align);
	}
	/*!
	Computes the size of an allocation.

	@param arg The pointer to the start of the allocation.
	@param align The alignment of the allocation.

	@returns The size of the allocation.
	*/
	inline size_t base_get_size_of_alloc(const byte*arg, size_t align)noexcept{
		//arg保证不与null_ptr相等
		const auto tmp= ::elc::APIs::alloc::get_size_of_alloc(arg,align);
		return tmp;
	}
	//BLOCK_END

	template<typename T>
	inline void*alloc_method(type_info_t<T>)noexcept{
		//return空指针被允许，会引起gc_for_alloc
		return ::std::assume_aligned<alignof(T)>(base_aligned_alloc(alignof(T),sizeof(T)));
	}
	template<typename T>
	inline void*alloc_method(type_info_t<T>,size_t size)noexcept{
		//return空指针被允许，会引起gc_for_alloc
		//size被保证不为0
		if constexpr(type_info<T>.has_attribute(never_in_array))
			template_error("You cannot perform array operations on never_in_array type.");
		return ::std::assume_aligned<alignof(T)>(base_aligned_alloc(alignof(T),sizeof(T)*size));
	}
	template<typename T>
	inline size_t get_size_of_alloc_method(const T*arg)noexcept{
		//arg保证不与null_ptr相等
		return base_get_size_of_alloc(cast_to_data(arg),alignof(T))/sizeof(T);
	}
	template<typename T>
	inline void free_method(T*arg)noexcept{
		base_free(cast_to_data(arg),alignof(T));
	}
	template<typename T>
	inline void*realloc_method(T*ptr,size_t new_size)noexcept{
		//return空指针被允许，会引起gc_for_alloc，但ptr值必须保持有效以保证gc_for_alloc后再次realloc有效
		//new_size被保证不为0
		//align维持不变
		//但只允许在扩大数据块时可选的移动数据块
		if constexpr(type_info<T>.has_attribute(never_in_array))
			template_error("You cannot perform array operations on never_in_array type.");
		return reinterpret_cast<T*>(base_realloc(cast_to_data(ptr),sizeof(T)*new_size,alignof(T)));
	}
}

//file_end

	#line 20 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/defs.hpp"

	enable_adl(the_alloc_method);
	template<typename T>
	inline void*alloc_method(type_info_t<T>)noexcept{
		//return空指针被允许，会引起gc_for_alloc
		if constexpr(was_not_an_ill_form(the_alloc_method(type_info<T>)))
			return the_alloc_method(type_info<T>);
		else
			return default_method::alloc_method(type_info<T>);
	}
	template<typename T>
	inline void*alloc_method(type_info_t<T>,size_t size)noexcept{
		//return空指针被允许，会引起gc_for_alloc
		//size被保证不为0
		if constexpr(was_not_an_ill_form(the_alloc_method(type_info<T>,size)))
			return the_alloc_method(type_info<T>,size);
		else
			return default_method::alloc_method(type_info<T>,size);
	}
	enable_adl(the_get_size_of_alloc_method);
	template<typename T>
	inline size_t get_size_of_alloc_method(const T*arg)noexcept{
		//arg保证不与null_ptr相等
		if constexpr(was_not_an_ill_form(the_get_size_of_alloc_method(arg)))
			return the_get_size_of_alloc_method(arg);
		else
			return default_method::get_size_of_alloc_method(arg);
	}
	enable_adl(the_free_method);
	template<typename T>
	inline void free_method(T*arg)noexcept{
		if constexpr(was_not_an_ill_form(the_free_method(arg)))
			the_free_method(arg);
		else
			default_method::free_method(arg);
	}
	enable_adl(the_realloc_method);
	template<typename T>
	inline void*realloc_method(T*ptr,size_t new_size)noexcept{
		//return空指针被允许，会引起gc_for_alloc，但ptr值必须保持有效以保证gc_for_alloc后再次realloc有效
		//new_size被保证不为0
		//align维持不变
		//但只允许在扩大数据块时可选的移动数据块
		if constexpr(was_not_an_ill_form(the_realloc_method(ptr,new_size)))
			return the_realloc_method(ptr,new_size);
		else
			return default_method::realloc_method(ptr,new_size);
	}

	/// @brief 所有alloc_t的基类
	/// @details 尽管意义不明，但这个类就是在这里
	struct base_alloc_t{};

	/// @brief 用于对特定类型进行alloc的类
	/// @warning 这个类不会对内存进行初始化，如需要进行new like操作，请使用 get_t
	template<class T>
	struct alloc_t:base_alloc_t{
		typedef base_alloc_t base_t;
		[[nodiscard]]static T*base_call()noexcept{
			void*tmp;
			while(!assign(tmp,alloc_method(type_info<T>)))gc_for_alloc();
			return reinterpret_cast<T*>(tmp);
		}
		[[nodiscard]]static T*base_call(size_t size)noexcept{
			const APIs::alloc::source_location_guard slg{1};
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You can\'t alloc an array for never_in_array type.");
			if(size){//null_ptr不一定等价于nullptr，请勿删除本行
				void*tmp;
				while(!assign(tmp,alloc_method(type_info<T>,size)))gc_for_alloc();
				return reinterpret_cast<T*>(tmp);
			}else return null_ptr;
		}
		[[nodiscard]]/*static*/force_inline T*operator()()const noexcept{return base_call();}
		[[nodiscard]]/*static*/force_inline T*operator()(size_t size)const noexcept{return base_call(size);}
		struct alloc_array_t{
			size_t _size;
			[[nodiscard]]force_inline T*operator()()const noexcept{return base_call(_size);}
		};
		[[nodiscard]]force_inline constexpr alloc_array_t operator[](size_t a)const noexcept{return{a};}
	};
	/// @brief 用于对特定类型进行alloc的类实例
	/// @see alloc_t
	/// @warning 不会对内存进行初始化，如需要进行new like操作，请使用 get_t
	template<class T>
	constexpr alloc_t<T>alloc{};

	/// @brief 用于对特定类型进行free
	/// @warning 这个类不会对类实例进行析构，如需要进行new like操作，请使用 get_t & unget_t
	constexpr struct free_t{
		typedef free_t base_t;
		template<class T>
		static void base_call(T*p)noexcept{
			const APIs::alloc::source_location_guard slg{1};
			if(p!=null_ptr)//null_ptr不一定等价于nullptr，请勿删除本行
				free_method(p);
		}
		template<class T>
		/*static*/force_inline void operator()(T*p)const noexcept{base_call(p);}
	}free{};

	/// @brief 用于对特定类型进行realloc
	/// @warning 这个类不会对类实例进行移动函数调用，也不会创造或结束生命周期，如需要进行new like操作，请使用 get_resize_t
	constexpr struct realloc_t{
		typedef realloc_t base_t;
		template<class T>
		static void base_call(T*&ptr,size_t nsize)noexcept{
			const APIs::alloc::source_location_guard slg{1};
			if constexpr(type_info<T>.has_attribute(never_in_array))
				template_error("You cannot perform array operations on never_in_array type.");
				//template_warning("For never_in_array type,realloc will free ptr when new_size=0 else do nothing.");
			if(nsize){//null_ptr不一定等价于nullptr，请勿删除本行
				if constexpr(type_info<T>.not_has_attribute(never_in_array))
					if(ptr!=null_ptr){//null_ptr不一定等价于nullptr，请勿删除本行
						void*tmp;
						while(!assign(tmp,realloc_method(ptr,nsize)))gc_for_alloc();
						ptr=reinterpret_cast<T*>(tmp);
					}else
						ptr=alloc<T>(nsize);
			}else{
				free(ptr);
				ptr=null_ptr;
			}
		}
		template<class T>
		/*static*/force_inline void operator()(T*&ptr,size_t nsize)const noexcept{
			base_call(ptr,nsize);
		}
		struct realloc_array_t{
			size_t _size;
			template<class T>
			[[nodiscard]]force_inline T*operator()(T*&ptr)const noexcept{return base_call(ptr,_size);}
		};
		[[nodiscard]]force_inline constexpr realloc_array_t operator[](size_t a)const noexcept{return{a};}
	}realloc{};

	/// @brief 用于自特定类型的内存分配结果获取分配大小
	/// 对于null_ptr，返回0
	/// 对于单个对象的分配，返回1
	constexpr struct get_size_of_alloc_t{
		template<typename T>
		static constexpr bool able=true;
		template<typename T>
		static constexpr bool nothrow=noexcept(get_size_of_alloc_method(declvalue(const T*)));

		template<typename T> requires able<T>
		static size_t base_call(const T*arg)noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg{1};
			if(arg==null_ptr)
				return 0;
			return get_size_of_alloc_method(arg);
		}

		template<typename T> requires able<T>
		force_inline size_t operator()(const T*arg)const noexcept(nothrow<T>){
			return base_call(arg);
		}
	}get_size_of_alloc{};

	/// @brief 对于特定类型的内存分配结果，获取分配大小并复制一份同样大小的内存
	/// @warning 这个类不会对类实例进行复制函数调用，也不会创造或结束生命周期，如需要进行new like操作，请使用 copy_get_t
	constexpr struct copy_alloc_t{
		template<typename T>
		static constexpr bool able=true;
		template<typename T>
		static constexpr bool nothrow=get_size_of_alloc.nothrow<T>;

		template<typename T> requires able<T>
		static T*base_call(const T*arg)noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg{1};
			return alloc<T>(get_size_of_alloc(arg));
		}

		template<typename T> requires able<T>
		force_inline T*operator()(const T*arg)const noexcept(nothrow<T>){
			return base_call(arg);
		}
	}copy_alloc{};
}

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_export.hpp"
//_export.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using alloc_n::
export alloc;
export free;
export realloc;
export get_size_of_alloc;
export copy_alloc;
#undef export

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_body.hpp"
#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_test.hpp"
//_test.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*!
Checks for memory leaks.
*/
inline void check_memory_lack()noexcept{
	stest_mapeventlogwith(lambda(const void*p,steventlist*a)noexcept{
		stest_putsf(L"内存泄露于%p,分配自:",p);
		stest_printeventlist(stdout,stest_copyeventlist(a));
		//alloc_n::base_free(remove_const(p));
		//stest_puts(L"已释放");
		stest_wait();
	});
}
#if defined(ELC_TEST_ON)
	namespace alloc_n{
		//BLOCK:for debug
		inline void test(){
			ELC_TEST_EVENTNAME("alloc部分测试");
			rand_seed.set_by_time();
			for(int i=rand<int>()%100+40;i--;){
				int*p=alloc<int>(50);
				p[0]=72;
				stest_accert(get_size_of_alloc(p)==50);
				p[49]=rand<int>();
				p[19]=666;
				realloc(p,20);
				stest_accert(get_size_of_alloc(p)==20);
				stest_accert(p[19]==666);
				stest_accert(p[0]==72);
				free(p);
			}
			check_memory_lack();
		}
		inline void test_log_out(){
		}
		inline void test_end(){
		}
		//BLOCK_END
	}
#endif

//file_end

	#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/alloc/_body.hpp"
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace abstract_base_n{
	/*
	ELC的虚基类模块，适用于unget
	处理虚基类到实例类的偏移与模板实例化差异
	原理：
		虚函数间接调用以从base_t&转为T&
		运行时计算偏移以从T*转换base_t*
	用法：is_common_attribute
	*/
	common_attribute_t abstract_base;
}
namespace get_n{
	using abstract_base_n::abstract_base;
	//struct build_by_get_only{};已定义于 "../../base_defs/special_attribute.hpp"

	/*!
	向后减小数据块大小并转移原有实例的生命周期，但并不析构旧的实例

	@param arg 原有数据块
	@param to_size 新的数据块大小
	*/
	template<typename T>
	void alloc_size_cut(T*&arg,size_t to_size)noexcept{
		realloc(arg,to_size);
	}
	/*!
	向后扩大数据块大小并转移原有实例的生命周期，但并不构造新的实例

	@param arg 原有数据块
	@param to_size 新的数据块大小
	*/
	template<typename T>
	void alloc_size_grow(T*&arg,size_t to_size)noexcept(move.trivial<T> or move.nothrow<T>){
		if constexpr(move.trivial<T>)
			realloc(arg,to_size);
		else{
			T*tmp=alloc<T>(to_size);
			const auto from_size=get_size_of_alloc(arg);
			if constexpr(!move.nothrow<T>){
				template_warning("the move of T was not noexcept,this may cause memory lack.");
				try{
					move[from_size](note::from(arg),note::to(tmp));
				}catch(...){
					free(tmp);
					throw;
				}
			}else{
				move[from_size](note::from(arg),note::to(tmp));
			}
			free(arg);
			arg=tmp;
		}
	}
	/*!
	在指定位置插入未初始化数据块并转移原有实例的生命周期，但并不构造新的实例

	@param arg 原有数据块
	@param insert_pos 插入位置
	@param insert_size 插入大小
	*/
	template<typename T>
	void alloc_size_grow_with_insert_uninitialized_data(T*&arg,size_t insert_pos,size_t insert_size)noexcept(move.trivial<T> or move.nothrow<T>){
		const auto from_size=get_size_of_alloc(arg);
		const auto to_size=from_size+insert_size;
		const auto size_before_insert=insert_pos;
		const auto size_after_insert=from_size-insert_pos;
		if constexpr(move.trivial<T>){
			realloc(arg,to_size);
			memmove(arg+size_before_insert+insert_size,arg+size_before_insert,size_after_insert*sizeof(T));
		}
		else{
			T*tmp=alloc<T>(to_size);
			if constexpr(!move.nothrow<T>){
				template_warning("the move of T was not noexcept,this may cause memory lack.");
				try{
					move[size_before_insert](note::from(arg),note::to(tmp));
					move[size_after_insert](note::from(arg+insert_pos),note::to(tmp+insert_pos+insert_size));
				}catch(...){
					free(tmp);
					throw;
				}
			}else{
				move[size_before_insert](note::from(arg),note::to(tmp));
				move[size_after_insert](note::from(arg+insert_pos),note::to(tmp+insert_pos+insert_size));
			}
			free(arg);
			arg=tmp;
		}
	}
	/*!
	在指定位置插入未初始化数据块并转移原有实例的生命周期，但并不构造新的实例
	若有多余的大小，追加到末尾

	@param arg 原有数据块
	@param to_size 新的数据块大小
	@param insert_pos 插入位置
	@param insert_size 插入大小

	@returns 多余的大小
	*/
	template<typename T>
	size_t alloc_size_grow_with_insert_uninitialized_data(T*&arg,size_t to_size,size_t insert_pos,size_t insert_size)noexcept(move.trivial<T> or move.nothrow<T>){
		const auto from_size=get_size_of_alloc(arg);
		const auto size_before_insert=insert_pos;
		const auto size_after_insert=from_size-insert_pos;
		if constexpr(move.trivial<T>){
			realloc(arg,to_size);
			memmove(arg+size_before_insert+insert_size,arg+size_before_insert,size_after_insert*sizeof(T));
		}
		else{
			T*tmp=alloc<T>(to_size);
			if constexpr(!move.nothrow<T>){
				template_warning("the move of T was not noexcept,this may cause memory lack.");
				try{
					move[size_before_insert](note::from(arg),note::to(tmp));
					move[size_after_insert](note::from(arg+insert_pos),note::to(tmp+insert_pos+insert_size));
				}catch(...){
					free(tmp);
					throw;
				}
			}else{
				move[size_before_insert](note::from(arg),note::to(tmp));
				move[size_after_insert](note::from(arg+insert_pos),note::to(tmp+insert_pos+insert_size));
			}
			free(arg);
			arg=tmp;
		}
		return to_size-from_size-insert_size;
	}
	/*!
	向前减小数据块大小并转移原有实例的生命周期，但并不析构旧的实例

	@param arg 原有数据块
	@param to_size 新的数据块大小
	*/
	template<typename T>
	void forward_alloc_size_cut(T*&arg,size_t to_size)noexcept(move.trivial<T> or move.nothrow<T>){
		const auto from_size=get_size_of_alloc(arg);
		const auto cut_size=from_size-to_size;
		if constexpr(move.trivial<T>){
			::std::memmove(arg,add_const(arg+cut_size),to_size*sizeof(T));
			realloc(arg,to_size);
		}
		else{
			T*tmp=alloc<T>(to_size);
			if constexpr(!move.nothrow<T>){
				template_warning("the move of T was not noexcept,this may cause memory lack.");
				try{
					move[to_size](note::from(arg+cut_size),note::to(tmp));
				}catch(...){
					free(tmp);
					throw;
				}
			}else{
				move[to_size](note::from(arg+cut_size),note::to(tmp));
			}
			free(arg);
			arg=tmp;
		}
	}
	/*!
	向前扩大数据块大小并转移原有实例的生命周期，但并不构造新的实例

	@param arg 原有数据块
	@param to_size 新的数据块大小
	*/
	template<typename T>
	void forward_alloc_size_grow(T*&arg,size_t to_size)noexcept(move.trivial<T> or move.nothrow<T>){
		const auto from_size=get_size_of_alloc(arg);
		const auto grow_size=to_size-from_size;
		if constexpr(move.trivial<T>){
			realloc(arg,to_size);
			::std::memmove(arg+grow_size,add_const(arg),from_size*sizeof(T));
		}
		else{
			T*tmp=alloc<T>(to_size);
			if constexpr(!move.nothrow<T>){
				template_warning("the move of T was not noexcept,this may cause memory lack.");
				try{
					move[from_size](note::from(arg),note::to(tmp+grow_size));
				}catch(...){
					free(tmp);
					throw;
				}
			}else{
				move[from_size](note::from(arg),note::to(tmp+grow_size));
			}
			free(arg);
			arg=tmp;
		}
	}
	/*
	在指定位置插入未初始化数据块并转移原有实例的生命周期，但并不构造新的实例
	若有多余的大小，追加到前端
	返回多余的大小
	*/
	/*!
	在指定位置插入未初始化数据块并转移原有实例的生命周期，但并不构造新的实例
	若有多余的大小，追加到前端

	@param arg 原有数据块
	@param to_size 新的数据块大小
	@param insert_pos 插入位置
	@param insert_size 插入大小

	@returns 多余的大小
	*/
	template<typename T>
	size_t forward_alloc_size_grow_with_insert_uninitialized_data(T*&arg,size_t to_size,size_t insert_pos,size_t insert_size)noexcept(move.trivial<T> or move.nothrow<T>){
		const auto from_size=get_size_of_alloc(arg);
		const auto grow_size=to_size-from_size;
		const auto before_grow_size=grow_size-insert_size;
		const auto size_before_insert=insert_pos;
		const auto size_after_insert=from_size-insert_pos;
		if constexpr(move.trivial<T>){
			realloc(arg,to_size);
			const auto orogin_data_ptr=arg+before_grow_size;
			::std::memmove(orogin_data_ptr+size_before_insert+insert_size,arg+size_before_insert,size_after_insert*sizeof(T));
			::std::memmove(orogin_data_ptr,arg,size_before_insert*sizeof(T));
		}
		else{
			T*tmp=alloc<T>(to_size);
			if constexpr(!move.nothrow<T>){
				template_warning("the move of T was not noexcept,this may cause memory lack.");
				try{
					const auto orogin_data_ptr=tmp+before_grow_size;
					move[size_before_insert](note::from(arg),note::to(orogin_data_ptr));
					move[size_after_insert](note::from(arg+size_before_insert),note::to(orogin_data_ptr+size_before_insert+insert_size));
				}catch(...){
					free(tmp);
					throw;
				}
			}else{
				const auto orogin_data_ptr=tmp+before_grow_size;
				move[size_before_insert](note::from(arg),note::to(orogin_data_ptr));
				move[size_after_insert](note::from(arg+size_before_insert),note::to(orogin_data_ptr+size_before_insert+insert_size));
			}
			free(arg);
			arg=tmp;
		}
		return before_grow_size;
	}

	struct base_get_t{};
	template<typename T>
	struct get_t:base_get_t{
		typedef base_get_t base_t;
		template<class...Args>
		static constexpr bool able=construct<T>.able<Args...>&&destruct.able<T>;
		template<class...Args>
		static constexpr bool nothrow=construct<T>.nothrow<Args...>;

		/*!
		Constructs an object of type T.

		@param rest The arguments to pass to the constructor of T.

		@returns A pointer to the newly constructed object.
		*/
		template<class...Args> requires able<Args...>
		[[nodiscard]]T* operator()(Args&&...rest)const noexcept(nothrow<Args...>){
			const APIs::alloc::source_location_guard slg;
			return construct<T>[alloc<T>()](forward<Args>(rest)...);
		}

		/*!
		Allocates an array of T with the specified size.
		*/
		struct array_get_t{
			size_t _size;
			/*!
			Constructs an array of objects of type T.

			@param rest The arguments to pass to the constructor of T.

			@returns An array of objects of type T.
			*/
			template<class...Args> requires able<Args...>
			[[nodiscard]]T* operator()(Args&&...rest)const noexcept(nothrow<Args...>){
				const APIs::alloc::source_location_guard slg;
				if constexpr(type_info<T>.has_attribute(never_in_array))
					template_error("You can\'t get an array for never_in_array type.");
				return construct<T>[alloc<T>(_size)][_size](forward<Args>(rest)...);
			}
		};
		[[nodiscard]]constexpr array_get_t operator[](size_t size)const noexcept{return{size};}

		static constexpr struct as_array_t{
			template<typename U>
			static constexpr bool able=copy_construct.able<T>&&destruct.able<T>&&is_array_like_for<T,U>;
			template<typename U>
			static constexpr bool nothrow=copy_construct.nothrow<T>;

			[[nodiscard]]T* operator()(array_like_view_t<const T>a)const noexcept(nothrow<void>){
				const APIs::alloc::source_location_guard slg;
				if constexpr(type_info<T>.has_attribute(never_in_array))
					template_error("You can\'t get an array for never_in_array type.");
				auto size=a.size();
				auto aret=alloc<T>[size]();
				copy_construct[size](note::from(a.begin()),note::to(aret));
				return aret;
			}
		}as_array{};

		static constexpr struct apply_end_t{
			template<typename U>
			static constexpr bool able=copy_construct.able<T>&&move.able<T>&&is_array_like_for<T,U>;
			template<typename U>
			static constexpr bool nothrow=copy_construct.nothrow<T>&&move.nothrow<T>;

			T* operator()(note::to_t<T*&> to,array_like_view_t<const T>a)const noexcept(nothrow<void>){
				const APIs::alloc::source_location_guard slg;
				auto&ptr=to.value;
				auto from_size=get_size_of_alloc(ptr);
				auto a_size=a.size();
				alloc_size_grow(ptr,from_size+a_size);
				copy_construct[a_size](note::from(a.begin()),note::to(ptr+from_size));
				return ptr;
			}
			T* operator()(note::to_t<T*&> to,const T&a)const noexcept(nothrow<void>){
				const APIs::alloc::source_location_guard slg;
				auto&ptr=to.value;
				auto from_size=get_size_of_alloc(ptr);
				alloc_size_grow(ptr,from_size+1);
				copy_construct(note::from(&a),note::to(ptr+from_size));
				return ptr;
			}
			T* operator()(note::to_t<T*&> to,T&&a)const noexcept(nothrow<void>){
				const APIs::alloc::source_location_guard slg;
				auto&ptr=to.value;
				auto from_size=get_size_of_alloc(ptr);
				alloc_size_grow(ptr,from_size+1);
				move_construct(note::from(&a),note::to(ptr+from_size));
				return ptr;
			}
		}apply_end{};

		static constexpr struct remove_t{
			template<typename U>
			static constexpr bool able=destruct.able<T>&&move.able<T>&&is_array_like_for<T,U>;
			template<typename U>
			static constexpr bool nothrow=destruct.nothrow<T>&&move.nothrow<T>;

			bool operator()(array_like_view_t<const T>a,note::from_t<T*>from)const noexcept(nothrow<void>){
				const APIs::alloc::source_location_guard slg;
				auto ptr=from.value;
				auto from_size=get_size_of_alloc(ptr);
				T*ptr_to_a=in_range(a,{ptr,note::size(from_size)});
				auto a_size=a.size();
				if(!ptr_to_a)
					return false;

				destruct[a_size](ptr_to_a);
				move[(ptr+from_size)-(ptr_to_a+a_size)](note::from(ptr_to_a+a_size),note::to(ptr_to_a));
				alloc_size_cut(ptr,from_size-a_size);
				return true;
			}
		}remove{};
	};
	template<typename T>
	constexpr get_t<T>get{};


	constexpr struct unget_t{
		template<typename T>
		static constexpr bool able=destruct.able<T>;
		template<typename T>
		static constexpr bool nothrow=destruct.nothrow<T>;

		template<typename T> requires able<T>
		void operator()(T*a)const noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg;
			if(a!=null_ptr){
				if constexpr(type_info<T>.has_attribute(abstract_base))
					#if defined(_MSC_VER)
						[[gsl::suppress(f.6)]]
					#endif
					attribute_ptr_cast<abstract_base>(a)->abstract_method_unget_this();
				else{
					if constexpr(!destruct.nothrow<T>)
						template_warning("the destructer of T was not noexcept,this may cause memory lack.");
					if constexpr(type_info<T>.has_attribute(never_in_array))
						destruct(a);
					else
						destruct[get_size_of_alloc(a)](a);
					free(a);
				}
			}
		}
		/*适用于unget(this,not destruct);*/
		template<typename T> requires able<T>
		void operator()(T*a,decltype(destruct)::not_t)const noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg;
			free(a);
		}
	}unget{};

	constexpr struct get_resize_t{
		template<typename T>
		static constexpr bool able=construct<T>.able<>&&destruct.able<T>&&move.able<T>;
		template<typename T>
		static constexpr bool nothrow=type_info<T>.not_has_attribute(abstract_base)&&construct<T>.nothrow<>&&destruct.nothrow<T>&&move.nothrow<T>;

		template<typename T> requires able<T>
		static void base_call(T*&arg,const size_t to_size)noexcept(nothrow<T>){
			if constexpr(type_info<T>.has_attribute(never_in_array)){
				template_warning("For never_in_array type,get_resize will unget ptr when new_size=0 else do nothing.");
				if(to_size)
					return;
				unget(arg);
				arg=null_ptr;
			}elseif constexpr(type_info<T>.has_attribute(abstract_base)){
				arg=attribute_ptr_cast<abstract_base>(arg)->abstract_method_get_resize_this(to_size);
			}else{
				const size_t from_size=get_size_of_alloc(arg);
				if(from_size==to_size)
					return;
				elseif(from_size > to_size){
					destruct[from_size-to_size](arg+to_size);
					alloc_size_cut(arg,to_size);
				}elseif(from_size){
					alloc_size_grow(arg,to_size);
					construct<T>[arg+from_size][to_size-from_size]();
				}else
					arg=get<T>[to_size]();
			}
		}

		template<typename T> requires able<T>
		inline void operator()(T*&arg,size_t to_size)const noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg;
			base_call(arg,to_size);
		}
		template<typename T> requires able<T>
		[[nodiscard]]inline T* operator()(T*&&arg,size_t to_size)const noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg;
			base_call(arg,to_size);
			return arg;
		}

		static constexpr struct insert_t{
			template<typename T>
			static constexpr bool able=get_resize_t::able<T>;
			template<typename T>
			static constexpr bool nothrow=get_resize_t::nothrow<T>;
			template<typename T> requires(able<T> && construct<T>.able<>)
			void operator()(T*&arg,size_t insert_pos,size_t insert_size)const noexcept(nothrow<T>){
				if(insert_size){
					const APIs::alloc::source_location_guard slg;
					alloc_size_grow_with_insert_uninitialized_data(arg,insert_pos,insert_size);
					construct<T>[arg+insert_pos][insert_size]();
				}
			}
			template<typename T> requires(able<T> && copy_construct.able<T>)
			void operator()(T*&arg,size_t insert_pos,size_t insert_size,const T*insert_data)const noexcept(nothrow<T>){
				if(insert_size){
					const APIs::alloc::source_location_guard slg;
					alloc_size_grow_with_insert_uninitialized_data(arg,insert_pos,insert_size);
					copy_construct[insert_size](note::from(insert_data),note::to(arg+insert_pos));
				}
			}
		}insert{};
		static constexpr struct insert_resize_t{
			template<typename T>
			static constexpr bool able=get_resize_t::able<T>;
			template<typename T>
			static constexpr bool nothrow=get_resize_t::nothrow<T>;
			template<typename T> requires(able<T> && construct<T>.able<> && copy_construct.able<T>)
			void operator()(T*&arg,size_t insert_pos,size_t insert_size,const T*insert_data,size_t to_size)const noexcept(nothrow<T>){
				const APIs::alloc::source_location_guard slg;
				auto end_grow_size=alloc_size_grow_with_insert_uninitialized_data(arg,to_size,insert_pos,insert_size);
				copy_construct[insert_size](note::from(insert_data),note::to(arg+insert_pos));
				construct<T>[arg+to_size-end_grow_size][end_grow_size]();
			}
		}insert_with_resize{};
	}get_resize{};

	constexpr struct get_forward_resize_t{
		template<typename T>
		static constexpr bool able=construct<T>.able<>&&destruct.able<T>&&move.able<T>;
		template<typename T>
		static constexpr bool nothrow=type_info<T>.not_has_attribute(abstract_base)&&construct<T>.nothrow<>&&destruct.nothrow<T>&&move.nothrow<T>;

		template<typename T> requires able<T>
		static void base_call(T*&arg,const size_t to_size)noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg{1};
			if constexpr(type_info<T>.has_attribute(never_in_array)){
				template_warning("For never_in_array type,get_forward_resize will unget ptr when new_size=0 else do nothing.");
				if(to_size)
					return;
				unget(arg);
				arg=null_ptr;
			}elseif constexpr(type_info<T>.has_attribute(abstract_base)){
				arg=attribute_ptr_cast<abstract_base>(arg)->abstract_method_get_forward_resize_this(to_size);
			}else{
				const size_t from_size=get_size_of_alloc(arg);
				if(from_size==to_size)
					return;
				elseif(from_size > to_size){
					destruct[from_size-to_size](arg);
					forward_alloc_size_cut(arg,to_size);
				}elseif(from_size){
					forward_alloc_size_grow(arg,to_size);
					construct<T>[arg][to_size-from_size]();
				}else
					arg=get<T>[to_size]();
			}
		}

		template<typename T> requires able<T>
		inline void operator()(T*&arg,size_t to_size)const noexcept(nothrow<T>){
			base_call(arg,to_size);
		}
		template<typename T> requires able<T>
		[[nodiscard]]inline T* operator()(T*&&arg,size_t to_size)const noexcept(nothrow<T>){
			base_call(arg,to_size);
			return arg;
		}

		static constexpr struct insert_t{
			template<typename T>
			static constexpr bool able=get_resize_t::able<T>;
			template<typename T>
			static constexpr bool nothrow=get_resize_t::nothrow<T>;
			template<typename T> requires(able<T> && construct<T>.able<>)
			void operator()(T*&arg,size_t insert_pos,size_t insert_size)const noexcept(nothrow<T>){
				const APIs::alloc::source_location_guard slg;
				get_resize.insert(arg,insert_pos,insert_size);
			}
			template<typename T> requires(able<T> && copy_construct.able<T>)
			void operator()(T*&arg,size_t insert_pos,size_t insert_size,const T*insert_data)const noexcept(nothrow<T>){
				const APIs::alloc::source_location_guard slg;
				get_resize.insert(arg,insert_pos,insert_size,insert_data);
			}
		}insert{};
		static constexpr struct insert_resize_t{
			template<typename T>
			static constexpr bool able=get_resize_t::able<T>;
			template<typename T>
			static constexpr bool nothrow=get_resize_t::nothrow<T>;
			template<typename T> requires(able<T> && construct<T>.able<> && copy_construct.able<T>)
			void operator()(T*&arg,size_t insert_pos,size_t insert_size,const T*insert_data,size_t to_size)const noexcept(nothrow<T>){
				if(insert_size){
					const APIs::alloc::source_location_guard slg;
					auto before_grow_size=forward_alloc_size_grow_with_insert_uninitialized_data(arg,to_size,insert_pos,insert_size);
					const auto orogin_arg=arg+before_grow_size;
					copy_construct[insert_size](note::from(insert_data),note::to(orogin_arg+insert_pos));
					construct<T>[arg][before_grow_size]();
				}
			}
		}insert_with_resize{};
	}get_forward_resize{};

	constexpr struct get_size_of_get_t{
		template<typename T>
		static constexpr bool able=true;
		template<typename T>
		static constexpr bool nothrow=noexcept(get_size_of_alloc(declvalue(const T*)));

		template<typename T> requires able<T>
		static size_t base_call(const T*arg)noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg{1};
			return get_size_of_alloc(arg);
		}

		template<typename T> requires able<T>
		size_t operator()(const T*arg)const noexcept(nothrow<T>){
			return base_call(arg);
		}
	}get_size_of_get{};

	constexpr struct copy_get_t{
		template<typename T>
		static constexpr bool able=copy_construct.able<T> || type_info<T>.has_attribute(abstract_base);
		template<typename T>
		static constexpr bool nothrow=copy_construct.nothrow<T>;

		template<typename T> requires able<T>
		static T*base_call(const T*arg)noexcept(nothrow<T>){
			const APIs::alloc::source_location_guard slg{1};
			if constexpr(type_info<T>.has_attribute(abstract_base))
				return remove_const(attribute_ptr_cast<abstract_base>(arg))->abstract_method_copy_get_this();
			else
				return copy_construct(note::from(arg),note::to(copy_alloc(arg)),get_size_of_get(arg));
		}

		template<typename T> requires able<T>
		T*operator()(const T*arg)const noexcept(nothrow<T>){
			return base_call(arg);
		}
	}copy_get{};
}

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_export.hpp"
//_export.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using get_n::
export get;
export get_resize;
export get_forward_resize;
export unget;
export get_size_of_get;
export copy_get;
//export build_by_get_only;
#undef export

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_test.hpp"
//_test.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace get_n{
	//BLOCK:for debug
	inline void test(){
		ELC_TEST_EVENTNAME("get部分测试");
		{
			ste::tester::setzero();
			tester*p=get<tester>[50]();
			stest_accert(tester::getbuildtime()==50);
			get_resize(p,60);
			//destroytime:50(+50) cause move(move_construct&destruct).
			stest_accert(tester::getdestroytime()==50);
			stest_accert(tester::getbuildtime()==60);
			int i=0;
			do
				p[i]();//写入测试
			while(++i!=60);
			stest_accert(tester::getcalltime()==60);
			unget(p);
			//destroytime:110(+60) cause destruct.
			stest_accert(tester::getdestroytime()==110);
		}
		check_memory_lack();
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
	//BLOCK_END
}

//file_end

	#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/get/_body.hpp"
#endif

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//UF
namespace abstract_base_n{
	/*
	ELC的虚基类模块，适用于unget
	处理虚基类到实例类的偏移与模板实例化差异
	原理：
		虚函数间接调用以从base_t&转为T&
		运行时计算偏移以从T*转换base_t*
	用法：is_common_attribute
	*/
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/pointer_off_set.hpp"
//pointer_off_set.hpp
//at namespace elc::defs::memory::abstract_base_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline thread_local pointer base_ptr;
inline thread_local ptrdiff_t off_set;
distinctive inline void is_base_ptr(void*a)noexcept{base_ptr=a;}
distinctive inline void is_instance_ptr(void*a)noexcept{off_set=get_off_set(note::from(a),note::to(base_ptr));}
distinctive inline void*get_ptr_after_off_set(void*a)noexcept{return apply_off_set(a,off_set);}

//file_end

	#line 19 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/abstract_base_vtable.hpp"
//abstract_base_vtable.hpp
//at namespace elc::defs::memory::abstract_base_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
no_vtable_class abstract_base_vtable{
protected:
	virtual void* _abstract_method_copy_get_this()=0;
	virtual void* _abstract_method_get_resize_this(size_t size)=0;
	virtual void* _abstract_method_get_forward_resize_this(size_t size)=0;

	virtual void abstract_method_unget_this()=0;
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept=0;

	friend class get_n::unget_t;
	friend class get_n::get_resize_t;
	friend class get_n::get_size_of_get_t;
	friend class get_n::copy_get_t;
};

//file_end

	#line 20 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/abstract_base.hpp"
//abstract_base.hpp
//at namespace elc::defs::memory::abstract_base_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<class T>
no_vtable_class abstract_base:virtual public abstract_base_vtable{
	T* abstract_method_copy_get_this(){
		is_base_ptr(this);
		return reinterpret_cast<T*>(get_ptr_after_off_set(this->_abstract_method_copy_get_this()));
	}
	T* abstract_method_get_resize_this(size_t size){
		is_base_ptr(this);
		return reinterpret_cast<T*>(get_ptr_after_off_set(this->_abstract_method_get_resize_this(size)));
	}
	T* abstract_method_get_forward_resize_this(size_t size){
		is_base_ptr(this);
		return reinterpret_cast<T*>(get_ptr_after_off_set(this->_abstract_method_get_forward_resize_this(size)));
	}

	friend class get_n::unget_t;
	friend class get_n::get_resize_t;
	friend class get_n::get_size_of_get_t;
	friend class get_n::copy_get_t;
};

//file_end

	#line 21 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/instance_struct.hpp"
//instance_struct.hpp
//at namespace elc::defs::memory::abstract_base_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
push_and_disable_msvc_warning(26436);//无虚析构函数警告diss
template<class T>
class instance_struct:is_common_attribute(instance_struct),virtual public abstract_base_vtable{
protected:
	virtual void abstract_method_unget_this()noexcept_as(unget(get_handle(this)))override{unget(get_handle(this));}
	virtual void* _abstract_method_copy_get_this()noexcept(copy_get.able<T>?copy_get.nothrow<T>:1)override{
		if constexpr(copy_get.able<T>){
			is_instance_ptr(this);
			return copy_get(get_handle(this));
		}
		else{
			return get_handle(this);
		}
	}
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept(get_resize.able<T>?get_resize.nothrow<T>:1)override{
		if constexpr(get_resize.able<T>){
			is_instance_ptr(this);
			return get_resize(get_handle(this),size);
		}
		else{
			return get_handle(this);
		}
	}
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept(get_forward_resize.able<T>?get_forward_resize.nothrow<T>:1)override{
		if constexpr(get_forward_resize.able<T>){
			is_instance_ptr(this);
			return get_forward_resize(get_handle(this),size);
		}
		else{
			return get_handle(this);
		}
	}
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return get_size_of_get(get_handle(this));}
};
pop_msvc_warning();

//file_end

	#line 22 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"
}
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_export.hpp"
//_export.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using abstract_base_n::
export abstract_base;
export instance_struct;
#undef export

//file_end

#line 24 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/abstract_base/_body.hpp"

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"

//#include "pool/_body.hpp"//依赖list

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace others_n{
	template<typename T>
	struct replace_able;
}
using others_n::replace_able;
namespace ptr_n{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/ref_t.hpp"
//ref_t.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
typedef size_t link_num_t;
class ref_t:non_copyable,non_moveable{
	mutable link_num_t _ref_num=0;
public:
	constexpr ref_t()noexcept=default;
	constexpr explicit ref_t(never_ref_num_zero_t)noexcept:_ref_num(1){}
	inline constexpr void add_ref()const noexcept{_ref_num++;}
protected:
	[[nodiscard]]inline constexpr bool cut_ref()const noexcept{return!--_ref_num;}
public:
	inline constexpr void init_never_ref_num_zero()noexcept{add_ref();}
	[[nodiscard]]link_num_t link_num()const noexcept{return _ref_num;}
};

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/ref_base.hpp"
//ref_base.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
enable_adl(the_waiting_for_destroy);
template<typename T>
void waiting_for_destroy(T*a)noexcept{
	if constexpr(was_not_an_ill_form(the_waiting_for_destroy(a)))
		return the_waiting_for_destroy(a);
	else
		template_error("this function should not be instantiated,please overload the function the_waiting_for_destroy in the namespace where this type is defined.");
}
enable_adl(the_destroy_and_free);
template<typename T>
void destroy_and_free(T*a)noexcept{
	if constexpr(was_not_an_ill_form(the_destroy_and_free(a)))
		return the_destroy_and_free(a);
	elseif constexpr(type_info<T>.has_attribute(build_by_get_only)&&type_info<T>.has_attribute(never_in_array))
		unget(a);
	else
		template_error("please overload the function the_destroy_and_free in the namespace where this type is defined.");
}
//
common_attribute_t ref_able;
common_attribute_t weak_ref_able;

template<typename T>
constexpr bool was_ref_able=type_info<T>.has_attribute(ref_able);
template<typename T>
constexpr bool was_weak_ref_able=type_info<T>.has_attribute(weak_ref_able);

template<typename T>
[[nodiscard]]link_num_t get_ref_num(const T*a)noexcept{
	if constexpr(!was_ref_able<T>)
		template_error("hey.");
	return attribute_ptr_cast<const ref_able>(a)->link_num();
}
template<typename T>
[[nodiscard]]link_num_t get_weak_ref_num(const T*a)noexcept{
	if constexpr(!was_weak_ref_able<T>)
		template_error("hey.");
	return attribute_ptr_cast<const weak_ref_able>(a)->link_num();
}

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/ref_able.hpp"
//ref_able.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename T>
struct ref_able:ref_t,can_t_use_default_null_ptr,is_common_attribute(ref_able){
private:
	typedef ref_t base_t;
public:
	using base_t::base_t;
	inline void cut_ref()const noexcept{
		T*this_T=remove_const(get_handle(this));
		if(base_t::cut_ref())
			if constexpr(was_weak_ref_able<T>)
				if(get_weak_ref_num(this_T)!=0)
					waiting_for_destroy(this_T);
				else
					destroy_and_free(this_T);
			else
				destroy_and_free(this_T);
	}
};

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/weak_ref_able.hpp"
//weak_ref_able.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename T>
struct weak_ref_able:ref_t,can_t_use_default_null_ptr,is_common_attribute(weak_ref_able){
private:
	typedef ref_t base_t;
public:
	inline void cut_ref()const noexcept{
		if constexpr(!was_ref_able<T>)
			template_error("base on ref_able before base on weak_ref_able,please.");
		T*this_T=remove_const(get_handle(this));
		if(base_t::cut_ref())
			if(get_ref_num(this_T)==0)
				destroy_and_free(this_T);
	}
};

//file_end

#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ref/_body.hpp"

//file_end

	#line 15 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/defs.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/base_ptr_t.hpp"
//base_ptr_t.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//copy from old ELC & adepted.
template<class T>
struct same_ptr_p_t{
protected:
	mutable T*_to;
	explicit same_ptr_p_t(T*a)noexcept:_to(a){}
public:
	same_ptr_p_t(const same_ptr_p_t&)noexcept=default;
	[[nodiscard]]T*get()const noexcept{return _to;}
};
template<class T,typename ref_type>
struct same_ref_p_t:same_ptr_p_t<T>{
	using same_ptr_p_t<T>::_to;
	explicit same_ref_p_t(T*a)noexcept:same_ptr_p_t<T>(a){}
	explicit same_ref_p_t(const same_ptr_p_t<T>&a)noexcept:same_ptr_p_t<T>(a){}

	void swap_with(same_ref_p_t&a)noexcept{swap(_to,a._to);}

	static constexpr bool cut_nothrow=noexcept(declvalue(ref_type).cut_ref());
protected:
	static void cut_ref(T*a)noexcept(cut_nothrow){attribute_ptr_cast<ref_type>(a)->cut_ref();}
	static void add_ref(T*a)noexcept{attribute_ptr_cast<ref_type>(a)->add_ref();}

	void cut_ref()const noexcept_as(cut_ref(nullptr)){cut_ref(_to);}
	void add_ref()const noexcept{add_ref(_to);}
};

template<class T,typename ref_type>
inline void swap(same_ref_p_t<T,ref_type>&a,same_ref_p_t<T,ref_type>&b)noexcept{
	a.swap_with(b);
}

template<class T,typename ref_type,bool do_replace_check>
struct ptr_t:same_ref_p_t<T,ref_type>{
	typedef ptr_t<T,ref_type,do_replace_check>this_t;

	typedef same_ref_p_t<T,ref_type>base_t;
	typedef same_ref_p_t<T,ref_type>same_ref;
	typedef same_ptr_p_t<T>same_ptr;
	using base_t::cut_nothrow;
	using same_ref::add_ref;
	using same_ref::cut_ref;
	using same_ref::swap_with;
	using same_ptr::_to;

	explicit ptr_t(T*a,special_init_t)noexcept:same_ref(a){}
	constexpr ptr_t(T*a)noexcept:same_ref(a){add_ref();}
	ptr_t(const same_ptr&a)noexcept:same_ref(a){
		if constexpr(type_info<T>.has_attribute(weak_ref_able) && type_info<ref_type> == type_info<ref_able<remove_cv<T>>>)
			if(get_ref_num(_to))
				add_ref();
			else
				add_ref(_to=null_ptr);
		else
			add_ref();
	}
	ptr_t(const same_ref&a)noexcept:same_ref(a){add_ref();}
	ptr_t(const ptr_t&a)noexcept:ptr_t((same_ptr&)a){}
	ptr_t(const ptr_t<remove_cv<T>,ref_type,do_replace_check>&a)noexcept requires(type_info<remove_cv<T>>!=type_info<T>):ptr_t(a.get()){}
	ptr_t(ptr_t&&a)noexcept:ptr_t((same_ptr&)a){
		//为什么不默认构造后swap_with？
		/*
		直接构造：
			对目标进行addref
			移动对象析构（单次cutref）
			总耗费4
		默认构造后swap_with：
			对nullptr进行addref
			交换ptr值
			移动对象析构（单次cutref）
			总耗费6

		总结：多此一举
		*/
	}
	constexpr ptr_t(nullptr_t=nullptr)noexcept:ptr_t(null_ptr){}
	constexpr ptr_t(null_ptr_t)noexcept:ptr_t((T*)(null_ptr)){}
	~ptr_t()noexcept(cut_nothrow){cut_ref();}

	static constexpr bool reset_nothrow=cut_nothrow;
	void reset(T*a)const noexcept(reset_nothrow){auto tmp=_to;add_ref(_to=a);cut_ref(tmp);}
	void reset(nullptr_t=nullptr)const noexcept(reset_nothrow){reset(null_ptr);}
public:
	static constexpr bool replace_check_nothrow=(type_info<T>.not_has_attribute(replace_able))||reset_nothrow;
	inline void replace_check()const noexcept(replace_check_nothrow){
		if constexpr(do_replace_check&&type_info<remove_cvref<T>>.has_attribute(replace_able))
			if(attribute_ptr_cast<replace_able>(_to)->replaced())
				reset(attribute_ptr_cast<replace_able>(_to)->get_ptr());
	}
	inline void do_replace(T*p)noexcept(replace_check_nothrow&&reset_nothrow){
		if constexpr(type_info<remove_cvref<T>>.has_attribute(replace_able)){
			attribute_ptr_cast<replace_able>(_to)->be_replace_as(p);
			reset(p);
		}
	}
	template<typename ref_type_,bool do_replace_check_>
	inline void do_replace(const ptr_t<T,ref_type_,do_replace_check_>&p)noexcept(replace_check_nothrow&&reset_nothrow){
		do_replace(p.get());
	}
	static constexpr bool get_nothrow=replace_check_nothrow;
	[[nodiscard]]T*get()const noexcept(get_nothrow){
		replace_check();
		return base_t::get();
	}
	[[nodiscard]]bool unique()const noexcept{return attribute_ptr_cast<ref_able>(get())->link_num()==1;}
	[[nodiscard]]constexpr
	conditional<do_replace_check&&type_info<T>.has_attribute(replace_able),
				unstable_hash_t,hash_t> hash()const noexcept_as(elc::defs::hash(get())){//注意：当T可replace时，同一ptr的hash可能变动
		using elc::defs::hash;
		return hash(get());
	}

	[[nodiscard]]inline auto operator==(const T*a)const noexcept_as(pointer_equal(add_const(declvalue(const this_t&).get()),a)){
		return pointer_equal(add_const(get()),a);
	}
	[[nodiscard]]inline auto operator==(nullptr_t)const noexcept_as(operator==(null_ptr)){
		return operator==(null_ptr);
	}
	[[nodiscard]]inline auto operator==(null_ptr_t)const noexcept_as(operator==((T*)null_ptr)){
		return operator==((T*)null_ptr);
	}
	template<typename ref_type_,bool do_replace_check_>
	[[nodiscard]]inline auto operator==(const ptr_t<T,ref_type_,do_replace_check_>&b)const
	noexcept_as(pointer_equal(
			declvalue(const this_t&).get(),
			b.get())
	){
		return pointer_equal(get(),b.get());
	}
	template<typename ref_type_,bool do_replace_check_> requires(type_info<remove_cv<T>>!=type_info<T>)
	[[nodiscard]]inline auto operator==(const ptr_t<const T,ref_type_,do_replace_check_>&b)const
	noexcept_as(pointer_equal(
			declvalue(const this_t&).get(),
			b.get())
	){
		return pointer_equal(get(),b.get());
	}
	template<typename ref_type_,bool do_replace_check_> requires(type_info<remove_cv<T>>!=type_info<T>)
	[[nodiscard]]inline auto operator==(const ptr_t<remove_cv<T>,ref_type_,do_replace_check_>&b)const
	noexcept_as(pointer_equal(
			declvalue(const this_t&).get(),
			add_const(b.get()))
	){
		return pointer_equal(get(),add_const(b.get()));
	}
};

template<typename T_,typename T,typename ref_type,bool do_replace_check,enable_if(type_info<T_>.base_on<T>)>
[[nodiscard]]inline auto operator==(const T_*a,ptr_t<T,ref_type,do_replace_check>&b)noexcept_as(b.operator==(static_cast<const T*>(a))){
	return b.operator==(static_cast<const T*>(a));
}

template<typename T,typename T_> requires(equal.able<T,T_>)
[[nodiscard]]inline auto operator!=(T&&a,T_&&b)noexcept_as(!(a==b)){
	return !(a==b);
}

template<class T,typename ref_type,bool do_replace_check>
struct base_ptr_t:ptr_t<T,ref_type,do_replace_check>{
	static_assert(type_info<T>.base_on<ref_type>);
	typedef ptr_t<T,ref_type,do_replace_check>base_t;
	typedef base_ptr_t<T,ref_type,do_replace_check>this_t;
	using typename base_t::same_ref;
	using typename base_t::same_ptr;
	using base_t::reset;
	using base_t::get;
	using same_ref::swap_with;
	using same_ptr::_to;

	using base_t::get_nothrow;
	using base_t::reset_nothrow;

	using base_t::base_t;

	base_ptr_t(base_ptr_t&a)noexcept:base_t(a){}
	base_ptr_t(base_ptr_t&&a)noexcept:base_t(move(a)){}

	[[nodiscard]]T*operator->()const noexcept(get_nothrow){return get();}
	[[nodiscard]]T&operator*()const noexcept(get_nothrow){return*get();}
	[[nodiscard]]explicit operator bool()const noexcept(get_nothrow){return bool(pointer_to_bool(get()));}
	[[nodiscard]]auto operator!()const noexcept(get_nothrow){return!pointer_to_bool(get());}
	[[nodiscard]]explicit operator T*()const noexcept(get_nothrow){return get();}

	base_ptr_t&operator=(T*a)&noexcept(reset_nothrow){reset(a);return*this;}
	base_ptr_t&operator=(const same_ptr&a)&noexcept(reset_nothrow&&get_nothrow){reset(a.get());return*this;}
	base_ptr_t&operator=(const base_ptr_t&a)&noexcept(reset_nothrow&&get_nothrow){reset(a.get());return*this;}
	base_ptr_t&operator=(same_ref&&a)&noexcept{swap_with(a);return*this;}
	base_ptr_t&operator=(base_ptr_t&&a)&noexcept{swap_with(a);return*this;}
	base_ptr_t&operator=(null_ptr_t)&noexcept(reset_nothrow){return*this=(T*)null_ptr;}
	base_ptr_t&operator=(nullptr_t)&noexcept(reset_nothrow){return*this=null_ptr;}

private:
	static inline thread_local class for_delete_t{
		T*_m;
		friend class this_t;
		for_delete_t*operator()(T*a)noexcept{
			_m=a;
			return this;
		}
	public:
		static void operator delete(void*a)noexcept{}
		static void operator delete(for_delete_t*a,std::destroying_delete_t)noexcept_as(destroy(declvalue(T*))){
			destroy((a)->_m);
		}
	}for_delete{};
public:
	[[nodiscard]]explicit operator bool()noexcept(get_nothrow){return add_const(this)->operator bool();}
	[[nodiscard]]distinctive operator for_delete_t*()noexcept(get_nothrow){return for_delete(get());}

	template<typename...Args> requires(invoke<T>.able<Args...>)
	inline decltype(auto)operator()(Args&&... rest)noexcept(invoke<T>.nothrow<Args...>){return(operator*())(forward<Args>(rest)...);}
};

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/comn_ptr_t.hpp"
//comn_ptr_t.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename T>
using comn_ptr_t=base_ptr_t<T,ref_able<remove_cvref<T>>,true>;

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/weak_ptr_t.hpp"
//weak_ptr_t.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename T>
using weak_ptr_t=base_ptr_t<T,weak_ref_able<remove_cvref<T>>,true>;

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/nocheck_ptr_t.hpp"
//nocheck_ptr_t.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename T>
using nocheck_ptr_t=base_ptr_t<T,ref_able<remove_cvref<T>>,false>;

//file_end

#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/deduction_guides.hpp"
//deduction_guides.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<class T,common_attribute_t ref_type,bool has_check>
base_ptr_t(T*) -> base_ptr_t<remove_cvref<T>,ref_type<remove_cvref<T>>,has_check>;

template<class T,common_attribute_t ref_type,bool has_check>
base_ptr_t(same_ptr_p_t<T>) -> base_ptr_t<T,ref_type<remove_cvref<T>>,has_check>;

//file_end

#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/ptr/_body.hpp"

//file_end

	#line 16 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/defs.hpp"
}

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_export.hpp"
//_export.hpp
//at namespace elc
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using ptr_n::
export ref_able;
export weak_ref_able;
export base_ptr_t;
export comn_ptr_t;
export weak_ptr_t;
#undef export

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_test.hpp"
//_test.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace ptr_n{
	struct tester:type_info_t<tester>::template_name
		with_common_attribute<ref_able,weak_ref_able,never_in_array>,build_by_get_only{};
	void waiting_for_destroy(tester*)noexcept{}
	inline void test(){
		ELC_TEST_EVENTNAME("ptr部分测试");
		{
			comn_ptr_t a=get<tester>();
			weak_ptr_t b=a;
		}
		check_memory_lack();
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
}

//file_end

	#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/ptr/_body.hpp"
#endif

//file_end

#line 15 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"
//依赖list
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/other/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace others_n{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/other/replace_able.hpp"
//replace_able.hpp
//at namespace elc::defs::memory::others_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//此属性配合 "../ptr" 食用
template<typename T>
struct replace_able:non_copyable,non_moveable,is_common_attribute(replace_able){
private:
	mutable T*_m;
public:
	constexpr replace_able()noexcept:_m(get_handle(this)){}
	constexpr ~replace_able()noexcept{
		if(replaced())
			attribute_ptr_cast<ref_able>(_m)->cut_ref();
	}
	constexpr bool replaced()const noexcept{return _m!=get_handle(this);}
	constexpr T*get_ptr()const noexcept{
		if(!replaced())
			return _m;
		else
			return attribute_ptr_cast<replace_able>(_m)->get_ptr();
	}
	constexpr void be_replace_as(T*new_p)noexcept{
		if(replaced())
			attribute_ptr_cast<ref_able>(_m)->cut_ref();
		_m=new_p;
		if(replaced())
			attribute_ptr_cast<ref_able>(_m)->add_ref();
	}
	constexpr void be_replace_as(nullptr_t)noexcept{be_replace_as(null_ptr);}
};

//file_end

	#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/other/_body.hpp"
	//依赖list
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/other/can_map_all.hpp"
//can_map_all.hpp
//at namespace elc::defs::memory::others_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename T>
struct can_map_all:cons_t<can_map_all<T>>,is_common_attribute(can_map_all){
	typedef can_map_all<T> this_t;
private:
	distinctive static inline list_t<this_t> type_list;

	template<class,class func_t>
	friend inline void map_all_helper(func_t&&a);
public:
	constexpr can_map_all()noexcept{
		type_list.add(this);
	}
};
template<class T,class func_t>
inline void map_all_helper(func_t&&a){
	auto tmp=can_map_all<T>::type_list.begin();
	auto end=can_map_all<T>::type_list.end();
	while(tmp!=end)
		a(get_handle<T,can_map_all>(tmp++));
}
#define expr declvalue(func_t)(declvalue(T*))
template<class T,class func_t,enable_if(was_not_an_ill_form(expr))>
inline void map_all(func_t&&a)noexcept_as(expr){
	map_all_helper<T,func_t>(forward<func_t>(a));
}
#undef expr

//file_end

	#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/other/_body.hpp"
}

//file_end

#line 16 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"

//#include "gc/_body.hpp"//NOTE:gc不在此处定义，因为它依赖container

#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_test.hpp"
//_test.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline void test(){
	ELC_TEST_EVENTNAME("memory部分测试");
	alloc_n::test();
	lifetime_n::test();
	get_n::test();
	//pool_n::test();
}
inline void test_log_out(){
	alloc_n::test_log_out();
	lifetime_n::test_log_out();
	get_n::test_log_out();
	//pool_n::test_log_out();
}
inline void test_end(){
	alloc_n::test_end();
	lifetime_n::test_end();
	get_n::test_end();
	//pool_n::test_end();
}

//file_end

	#line 21 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/_body.hpp"
#endif

//file_end

		#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
	}
	using namespace memory;

	namespace container{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"
//_body.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_body.hpp"
//_body.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/defs.hpp"
//defs.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace array_n{
	template<typename T>
	class array_t{
		typedef array_t<T>this_t;
		T*_m;
		#if defined(DEBUG) || defined(_DEBUG)
			size_t _size_for_debug_view=0;
		#endif

		#if defined(DEBUG) || defined(_DEBUG)
		/*return{ptr,size};*/
		constexpr array_t(T*a,size_t s)noexcept:_m(a),_size_for_debug_view(s){}
		#else
		/*return{ptr};*/
		constexpr array_t(T*a)noexcept:_m(a){}
		#endif
		/*返回一个自身的副本*/
		[[nodiscard]]this_t copy()const noexcept(copy_get.nothrow<T>) requires(copy_get.able<T>){
			#if defined(DEBUG) || defined(_DEBUG)
				return{copy_get(_m),_size_for_debug_view};
			#else
				return{copy_get(_m)};
			#endif
		}
	public:
		void swap_with(this_t&a)noexcept{
			swap(_m,a._m);
			#if defined(DEBUG) || defined(_DEBUG)
				swap(_size_for_debug_view,a._size_for_debug_view);
			#endif
		}
	public:
		/*默认构造*/
		constexpr array_t()noexcept:_m(null_ptr){}
		/*
		构造size个T
		*/
		explicit array_t(note::size_t<size_t>size)noexcept(get<T>.nothrow<>){
			_m=get<T>[size.value]();
			#if defined(DEBUG) || defined(_DEBUG)
				_size_for_debug_view=size.value;
			#endif
		}
		explicit array_t(note::size_t<size_t>size,const T&elem)noexcept(get<T>.nothrow<>){
			_m=get<T>[size.value](elem);
			#if defined(DEBUG) || defined(_DEBUG)
				_size_for_debug_view=size.value;
			#endif
		}
		/*
		此重载适用于T[N]，std::init_list<T>以及range_t<const T*>
		*/
		//template<as_concept<get<T>.as_array.able> U>
		template<class U> requires(get<T>.as_array.able<U>)
		array_t(U&&a)noexcept(get<T>.as_array.nothrow<U>){
			_m=get<T>.as_array(forward<U>(a));
			#if defined(DEBUG) || defined(_DEBUG)
				_size_for_debug_view=size();
			#endif
		}

		//复制和移动函数
		array_t(const this_t&a)noexcept_as(declvalue(this_t).copy()):array_t(a.copy()){}
		this_t&operator=(const this_t&a)&noexcept_as(declvalue(this_t).copy()){
			return operator=(a.copy());
		}
		array_t(this_t&&a)noexcept:array_t(){swap_with(a);}
		this_t&operator=(this_t&&a)&noexcept{
			swap_with(a);
			return*this;
		}

		~array_t()noexcept(unget.nothrow<T>){
			unget(_m);
		}
		[[nodiscard]]size_t size()const noexcept{
			return get_size_of_get(_m);
		}
		[[nodiscard]]size_t size_in_byte()const noexcept{
			return size()*sizeof(T);
		}
		static constexpr bool resize_nothrow = get_resize.nothrow<T>;
		void resize(size_t size)noexcept(resize_nothrow){
			get_resize(_m,size);
			#if defined(DEBUG) || defined(_DEBUG)
				_size_for_debug_view=size;
			#endif
		}
		static constexpr bool forward_resize_nothrow = get_forward_resize.nothrow<T>;
		void forward_resize(size_t size)noexcept(forward_resize_nothrow){
			get_forward_resize(_m,size);
			#if defined(DEBUG) || defined(_DEBUG)
				_size_for_debug_view=size;
			#endif
		}
		static constexpr bool insert_nothrow = get_resize.insert.nothrow<T>;
		void insert(size_t index,size_t count)noexcept(insert_nothrow){
			get_resize.insert(_m,index,count);
			#if defined(DEBUG) || defined(_DEBUG)
				_size_for_debug_view+=count;
			#endif
		}
		void insert(size_t index,size_t count,const T*data)noexcept(insert_nothrow){
			get_resize.insert(_m,index,count,data);
			#if defined(DEBUG) || defined(_DEBUG)
				_size_for_debug_view+=count;
			#endif
		}
		void insert_with_resize(size_t index,size_t count,const T*data,size_t new_size)noexcept(insert_nothrow){
			get_resize.insert_with_resize(_m,index,count,data,new_size);
			#if defined(DEBUG) || defined(_DEBUG)
				_size_for_debug_view=new_size;
			#endif
		}
		static constexpr bool insert_with_forward_resize_nothrow = get_forward_resize.insert_with_resize.nothrow<T>;
		void insert_with_forward_resize(size_t index,size_t count,const T*data,size_t new_size)noexcept(insert_with_forward_resize_nothrow){
			get_forward_resize.insert_with_resize(_m,index,count,data,new_size);
			#if defined(DEBUG) || defined(_DEBUG)
				_size_for_debug_view=new_size;
			#endif
		}
		[[nodiscard]]bool empty()const{
			return _m==null_ptr;
		}
		void clear()noexcept(re_construct.nothrow<this_t>){
			re_construct(this);
		}
		[[nodiscard]]T&operator[](size_t pos)noexcept{return _m[pos];}
		[[nodiscard]]const T&operator[](size_t pos)const noexcept{return _m[pos];}
		[[nodiscard]]explicit operator hash_t()const noexcept(hash.nothrow<T>){return hash(_m,size());}
		[[nodiscard]]explicit operator T*()noexcept{return _m;}
		[[nodiscard]]explicit operator const T*()const noexcept{return _m;}

		typedef iterator_t<T>iterator;
		typedef const_iterator_t<T>const_iterator;

		[[nodiscard]]constexpr iterator get_iterator_at(size_t a)noexcept{
			return _m+a;
		}
		[[nodiscard]]constexpr const_iterator get_iterator_at(size_t a)const noexcept{
			return _m+a;
		}
		[[nodiscard]]constexpr iterator begin()noexcept{
			return get_iterator_at(zero);
		}
		[[nodiscard]]iterator end()noexcept{
			return get_iterator_at(size());
		}
		[[nodiscard]]constexpr const_iterator begin()const noexcept{
			return get_iterator_at(zero);
		}
		[[nodiscard]]const_iterator end()const noexcept{
			return get_iterator_at(size());
		}
		[[nodiscard]]const_iterator cbegin()const noexcept{
			return begin();
		}
		[[nodiscard]]const_iterator cend()const noexcept{
			return end();
		}

		[[nodiscard]]constexpr auto operator<=>(array_like_view_t<const T> a)const noexcept(compare.nothrow<array_like_view_t<T>>){
			return compare(array_like_view_t<const T>(*this),a);
		}
		[[nodiscard]]constexpr auto operator==(array_like_view_t<const T> a)const noexcept(equal.nothrow<array_like_view_t<T>>){
			return equal(array_like_view_t<const T>(*this),a);
		}
		[[nodiscard]]constexpr auto operator<=>(const this_t&a)const noexcept(compare.nothrow<array_like_view_t<T>>){
			return operator<=>(array_like_view_t<const T>(a));
		}
		[[nodiscard]]constexpr auto operator==(const this_t&a)const noexcept(equal.nothrow<array_like_view_t<T>>){
			return operator==(array_like_view_t<const T>(a));
		}

		#define expr declvalue(func_t)(declvalue(T&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each(func_t&&func)noexcept_as(expr){
			auto asize=size();
			while(asize--)
				func((*this)[asize]);
		}
		#undef expr

		#define expr declvalue(func_t)(declvalue(const T&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each(func_t&&func)const noexcept_as(expr){
			auto asize=size();
			while(asize--)
				func((*this)[asize]);
		}
		#undef expr

		void push_back(const T&a){
			get<T>.apply_end(note::to<T*&>(_m),a);
			#if defined(DEBUG) || defined(_DEBUG)
				_size_for_debug_view=size();
			#endif
		}
		void push_back(T&&a){
			get<T>.apply_end(note::to<T*&>(_m),move(a));
			#if defined(DEBUG) || defined(_DEBUG)
				_size_for_debug_view=size();
			#endif
		}
		void remove(T a){
			get<T>.remove(a,note::from(_m));
			#if defined(DEBUG) || defined(_DEBUG)
				_size_for_debug_view=size();
			#endif
		}
		//template<as_concept<get<T>.apply_end.able> U>
		template<class U,enable_if(get<T>.apply_end.able)>
		friend this_t&operator+=(this_t&a,U&&b)noexcept(get<T>.apply_end.nothrow<U>){
			get<T>.apply_end(note::to(a._m),b);
			return a;
		}
		friend this_t&operator+=(this_t&a,zero_t b)noexcept(get<T>.apply_end.nothrow<T>){
			return a+=T(0);
		}
		template<typename U>
		friend this_t operator+(const this_t&a,U&&b)noexcept_as(a.copy()+=b) requires was_not_an_ill_form(a.copy()+=b){
			return a.copy()+=b;
		}
		template<typename U>
		friend this_t operator+(U&&a,const this_t&b)noexcept_as(this_t(a)+=b) requires was_not_an_ill_form(this_t(a)+=b){
			return this_t(a)+=b;
		}

		template<typename U>
		this_t&& operator+(U&& b)&&noexcept_as(*this+=b) requires was_not_an_ill_form(*this+=b){//对右值的operator+优化为operator+=
			return *this+=b;
		}


		template<typename U>
		[[nodiscard]]iterator find(U&&a)noexcept requires was_not_an_ill_form(in_range(declvalue(this_t),a)){
			return in_range(*this,a);
		}
		template<typename U>
		[[nodiscard]]const_iterator find(U&&a)const noexcept requires was_not_an_ill_form(in_range(declvalue(this_t),a)){
			return in_range(*this,a);
		}
	};
	template<typename T>
	inline void swap(array_t<T>&a,array_t<T>&b)noexcept{a.swap_with(b);}

	template<class T>
	[[nodiscard]]inline auto size_of_array_like(const array_t<remove_cv<T>>&a)noexcept{return a.size();}
	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(array_t<remove_cv<T>>&a)noexcept{return(T*)a.begin();}
	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(const array_t<remove_cv<T>>&a)noexcept{return(const T*)a.begin();}
}

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/deduction_guides.hpp"
//deduction_guides.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace array_n{
	template <class T,class...U>
	array_t(T,U...) -> array_t<T>;
	template <class T>
	array_t(array_t<T>) -> array_t<T>;
}

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_export.hpp"
//_export.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using array_n::
export array_t;
#undef export

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_test.hpp"
//_test.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace array_n{
	//BLOCK:for debug
	inline void test(){
		ELC_TEST_EVENTNAME("array部分测试");
		{
			array_t<int>anarray;
			stest_accert(anarray.size()==0);
			anarray.resize(5);
			stest_accert(anarray.size()==5);
			anarray[2]=99;
			stest_accert(anarray[2]==99);
			anarray.resize(3);
			stest_accert(anarray[2]==99);
			anarray=anarray;
			swap(anarray,anarray);
		}
		check_memory_lack();
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
	//BLOCK_END
}

//file_end

	#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/array/_body.hpp"
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_body.hpp"
//_body.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/base_function_t.hpp"
//base_function_t.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace function_n{
	template<class T>
	class base_func_data_t;
	template<class Ret_t,class...Args_t>
	no_vtable_struct base_func_data_t<Ret_t(Args_t...)>:type_info_t<base_func_data_t<Ret_t(Args_t...)>>::template_name with_common_attribute<abstract_base,ref_able,never_in_array>,build_by_get_only{
		typedef base_func_data_t<Ret_t(Args_t...)>this_t;
		typedef comn_ptr_t<this_t>ptr_t;

		virtual ~base_func_data_t()=default;
		virtual Ret_t call(Args_t...)=0;
		//for equal:
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept=0;
		[[nodiscard]]virtual const void*get_data_begin()const noexcept=0;
		[[nodiscard]]virtual bool equal_with(const void*)const=0;
		[[noreturn]] virtual void throw_self_ptr()const=0;
		[[noreturn]] virtual void throw_self_ptr()=0;
		[[nodiscard]]bool operator==(const this_t&a)const{
			return this->get_type_info()==a.get_type_info()&&this->equal_with(a.get_data_begin());
		}
		template<typename T>
		[[nodiscard]]bool operator==(const T&a)const{
			return this->get_type_info()==type_info<T>&&this->equal_with(addressof(a));
		}
		typedef Ret_t(*func_ptr_t)(Args_t...);
		virtual func_ptr_t get_func_ptr()const noexcept{return nullptr;}
	};

	template<class T,class Func_t>
	class func_data_t;
	template<class T,class Ret_t,class...Args_t>
	struct func_data_t<T,Ret_t(Args_t...)>final:
	type_info_t<func_data_t<T,Ret_t(Args_t...)>>::template_name with_common_attribute<instance_struct>,
	base_func_data_t<Ret_t(Args_t...)>,function_data_wrapper_t<T,Ret_t(Args_t...)>{
		static_assert(!::std::is_function_v<T>);
		typedef base_func_data_t<Ret_t(Args_t...)>base_t;
		typedef func_data_t<T,Ret_t(Args_t...)>this_t;
		typedef function_data_wrapper_t<T,Ret_t(Args_t...)>data_t;
		typedef base_t::ptr_t ptr_t;
		typedef base_t::func_ptr_t func_ptr_t;

		[[nodiscard]]bool is_unique()const noexcept{return get_ref_num((base_t*)this)==1;}

		using data_t::data_t;
		virtual ~func_data_t()override=default;
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<T>;}
		[[nodiscard]]virtual const void*get_data_begin()const noexcept override final{return addressof(data_t::get_data());}
		[[noreturn]] virtual void throw_self_ptr()const override final{throw addressof(data_t::get_data());}
		[[noreturn]] virtual void throw_self_ptr()override final{throw addressof(data_t::get_data());}
		[[nodiscard]]virtual bool equal_with(const void*a)const noexcept(equal.able<T>?equal.nothrow<T>:true)override final{
			if constexpr(equal.able<T>)
				return data_t::get_data()==*remove_const(reinterpret_cast<const T*>(a));
			else
				return false;
		}
		[[nodiscard]]virtual Ret_t call(Args_t...args)noexcept(invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>)override final{
			return data_t::operator()(forward<Args_t>(args)...);
		}

		//func ptr convert
		virtual func_ptr_t get_func_ptr()const noexcept override final{
			if constexpr(type_info<const T>.can_convert_to<func_ptr_t>)
				return static_cast<func_ptr_t>(data_t::get_data());
			else
				return nullptr;
		}
	};

	template<class T>
	class default_func_data_t;
	template<class Ret_t,class...Args_t>
	struct default_func_data_t<Ret_t(Args_t...)>final:base_func_data_t<Ret_t(Args_t...)>,instance_struct<default_func_data_t<Ret_t(Args_t...)>>{
		typedef base_func_data_t<Ret_t(Args_t...)>base_t;
		typedef base_t::ptr_t ptr_t;

		virtual ~default_func_data_t()noexcept override final{}
		virtual Ret_t call(Args_t...)noexcept_as(Ret_t())override final{return Ret_t();}
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<void>;}
		[[nodiscard]]virtual const void*get_data_begin()const noexcept override final{return null_ptr;}//这玩意实际上用不到，艹
		[[noreturn]] virtual void throw_self_ptr()const override final{throw(const void*)null_ptr;}
		[[noreturn]] virtual void throw_self_ptr()override final{throw(void*)null_ptr;}
		[[nodiscard]]virtual bool equal_with(const void*)const noexcept override final{return true;}
	};
	template<class Ret_t,class...Args_t>
	distinctive inline default_func_data_t<Ret_t(Args_t...)>default_func_data{};

	template<class Ret_t,class...Args_t>
	[[nodiscard]]constexpr base_func_data_t<Ret_t(Args_t...)>*the_get_null_ptr(const base_func_data_t<Ret_t(Args_t...)>*)noexcept{
		return&default_func_data<Ret_t,Args_t...>;
	}

	template<class T>
	class function_data_saver_t;
	template<class Ret_t,class...Args_t>
	class function_data_saver_t<Ret_t(Args_t...)>{
	protected:
		typedef function_data_saver_t<Ret_t(Args_t...)>this_t;
		typedef base_func_data_t<Ret_t(Args_t...)> base_t_w;
		typedef comn_ptr_t<base_t_w>ptr_t;

		mutable ptr_t _m;
		void swap_with(this_t&a)noexcept{swap(_m,a._m);}
	public:
		function_data_saver_t()noexcept=default;
		function_data_saver_t(const this_t&a)noexcept:_m(a._m){}
		function_data_saver_t(this_t&&a)noexcept{swap_with(a);}
		[[nodiscard]]bool operator==(const this_t&a)const{
			return *_m==*(a._m);
		}
		template<typename T> requires(equal.able<base_t_w,T>)
		[[nodiscard]]bool operator==(T&&a)const noexcept(equal.nothrow<base_t_w,T>){
			return *_m==a;
		}
		template<typename T>
		[[nodiscard]]bool was_an()const noexcept{
			try{
				_m->throw_self_ptr();
			}
			catch(const T*p){
				return true;
			}
			catch(const void*){}
			return false;
		}
		template<typename T>
		[[nodiscard]]maybe_fail_reference<T> get_as()noexcept{
			try{
				_m->throw_self_ptr();
			}
			catch(T*p){
				return *p;
			}
			catch(void*){}
			return note::fail;
		}
		suppress_msvc_warning(26440)//nothrow警告diss
		void operator=(const this_t&a){_m=a._m;}
		Ret_t call(Args_t&&...rest)const{return _m->call(forward<Args_t>(rest)...);}
	};

	template<class T,bool promise_nothrow_at_destruct>
	class base_function_t;

	template<class T>
	struct is_function_t_helper {
		constexpr static bool value = false;
	};
	template<class T, bool promise_nothrow_at_destruct>
	struct is_function_t_helper<base_function_t<T, promise_nothrow_at_destruct>> {
		constexpr static bool value = true;
	};
	template<class T>
	constexpr static bool is_function_t = is_function_t_helper<T>::value;
	#if !defined(_MSC_VER)
	template<class Ret_t,class...Args_t,bool nothrow,bool promise_nothrow_at_destruct>
	struct base_function_t<Ret_t(Args_t...)noexcept(nothrow),promise_nothrow_at_destruct>:function_data_saver_t<Ret_t(Args_t...)>{
	protected:
		typedef function_data_saver_t<Ret_t(Args_t...)>base_t;
		typedef base_function_t<Ret_t(Args_t...)noexcept(nothrow),promise_nothrow_at_destruct>this_t;

		template<class,bool>
		friend class base_function_t;

		template<class U>
		using func_data_t=function_n::func_data_t<U,Ret_t(Args_t...)>;

		typedef Ret_t(*func_ptr_t)(Args_t...)noexcept(nothrow);

		using base_t::ptr_t;
		using base_t::_m;

		template<class T>
		static constexpr bool base_on_this_t_or_more_stringent_restrictions=(
			type_info<T>.base_on<this_t>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept(bool(nothrow+1)),	promise_nothrow_at_destruct			>>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept(nothrow),			bool(promise_nothrow_at_destruct+1)	>>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept(bool(nothrow+1)),	bool(promise_nothrow_at_destruct+1)	>>
		);

		template<class T>
		static constexpr bool get_data_able_helper()noexcept{
			if constexpr(base_on_this_t_or_more_stringent_restrictions<T>)
				return true;
			elseif constexpr(is_function_t<T>)
				return false;
			elseif constexpr(::std::is_function_v<T>)
				return get_data_able_helper<decltype(&declvalue(T))>();
			elseif constexpr(invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				return get<func_data_t<remove_cvref<T>>>.able<T>;
			else
				return false;
		}
		template<class T>
		static constexpr bool get_data_able=get_data_able_helper<T>();
		template<class T>
		static constexpr bool get_data_nothrow_helper()noexcept{
			if constexpr(base_on_this_t_or_more_stringent_restrictions<T>)
				return true;
			elseif constexpr(is_function_t<T>)
				return false;
			elseif constexpr(::std::is_function_v<T>)
				return get_data_nothrow_helper<decltype(&declvalue(T))>();
			elseif constexpr(invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				return get<func_data_t<remove_cvref<T>>>.nothrow<T>;
			else
				return false;
		}
		template<class T>
		static constexpr bool get_data_nothrow=get_data_nothrow_helper<T>();

		template<class T> requires get_data_able<T>
		static auto get_data_from(T&&a)noexcept(get_data_nothrow<T>){
			if constexpr(::std::is_function_v<T>)
				return get_data_from(&a);
			elseif constexpr(is_function_t<T>)
				return a._m;
			else{
				//BLOCK:constexpr checks
				if constexpr(promise_nothrow_at_destruct and not destruct.nothrow<T>)
					template_error("unexpected assign.");
				if constexpr(nothrow)
					if constexpr(!invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>)
						template_warning("the call of T was not noexcept,this may cause terminate.");
				//BLOCK_END
				return get<func_data_t<remove_cvref<T>>>(a);
			}
		}
		explicit base_function_t(base_t::ptr_t a)noexcept{_m=a;}
	public:
		void swap_with(this_t&a)noexcept{//不与base_t::swap_with重复：与更加严格（或宽松）的this_t进行swap是错误的
			base_t::swap_with(a);
		}

		base_function_t()noexcept=default;
		template<class T> requires base_on_this_t_or_more_stringent_restrictions<T>
		base_function_t(const T&a)noexcept:base_t(a){}
		base_function_t(const this_t&a)noexcept:base_t(a){}
		base_function_t(this_t&&a)noexcept:base_function_t(){
			swap_with(a);
		}
		base_function_t(null_ptr_t)noexcept:base_function_t(){}
		base_function_t(nullptr_t)noexcept:base_function_t(null_ptr){}
		template<class T> requires(get_data_able<T>)
		base_function_t(T&&a)noexcept(get_data_nothrow<T>){
			_m=get_data_from(forward<T>(a));
		}
		base_function_t(func_ptr_t a)noexcept{//当nothrow==0时，noexcept(true)的参数可自动转为noexcept(false)的，不用再次考虑
			_m=get<func_data_t<func_ptr_t>>(a);
		}
		~base_function_t()noexcept(promise_nothrow_at_destruct)=default;

		this_t&operator=(const this_t&a)&noexcept(promise_nothrow_at_destruct)=default;
		this_t&operator=(this_t&&a)&noexcept(promise_nothrow_at_destruct)=default;
		this_t&operator=(null_ptr_t)&noexcept(promise_nothrow_at_destruct){_m=null_ptr;return *this;}
		this_t&operator=(nullptr_t)&noexcept(promise_nothrow_at_destruct){return *this=null_ptr;}
		template<class T> requires base_on_this_t_or_more_stringent_restrictions<T>
		this_t&operator=(const T&a)&noexcept(promise_nothrow_at_destruct){
			base_t::operator=(a);
			return*this;
		}
		template<class T> requires(get_data_able<T>)
		this_t&operator=(T&&a)noexcept(get_data_nothrow<T> && promise_nothrow_at_destruct){
			_m=get_data_from(forward<T>(a));
			return*this;
		}

		this_t deep_copy(){return this_t{copy_get(_m.get())};}

		[[nodiscard]]explicit operator bool()const noexcept{
			return bool(_m);
		}

		Ret_t operator()(Args_t...args)const noexcept(nothrow){
			suppress_msvc_warning(26447)
			return base_t::call(forward<Args_t>(args)...);
		}

	private:
		//以下是突然想加的功能(没什么用<迷惑行为大赏>).
		static thread_local inline base_t::base_t_w* _func_ptr_data_local=nullptr;
		static inline ::std::atomic<decltype(_func_ptr_data_local)> _func_ptr_data_gobal=nullptr;
		static Ret_t _func_ptr_value(Args_t...args)noexcept{
			if(!_func_ptr_data_local)
				_func_ptr_data_local=_func_ptr_data_gobal.load(::std::memory_order_relaxed);
			return _func_ptr_data_local->call(forward<Args_t>(args)...);
		}
	public:
		//自当前function对象生成一个函数指针，具有与当前function对象相同的行为
		//注意：该函数指针的有效性保留到当前线程下一个同类型的函数指针生成时或当前function对象析构时
		//若自该函数指针创建一个新的线程，该函数指针在新线程中的行为与调用时以前所有线程中最后一个生成的同类型的函数指针行为相同
		[[nodiscard]]explicit operator func_ptr_t()const noexcept(promise_nothrow_at_destruct){
			func_ptr_t a=(func_ptr_t)_m->get_func_ptr();
			if(a)return a;
			_func_ptr_data_local=base_t::_m.get();
			_func_ptr_data_gobal.store(_func_ptr_data_local,::std::memory_order_relaxed);
			return _func_ptr_value;
		}
	};
	#else
	//MSVC，我滴垃圾堆
	template<class Ret_t,class...Args_t,bool promise_nothrow_at_destruct>
	struct base_function_t<Ret_t(Args_t...),promise_nothrow_at_destruct>:function_data_saver_t<Ret_t(Args_t...)>{
	protected:
		typedef function_data_saver_t<Ret_t(Args_t...)>base_t;
		typedef base_function_t<Ret_t(Args_t...),promise_nothrow_at_destruct>this_t;

		template<class,bool>
		friend class base_function_t;

		template<class U>
		using func_data_t=function_n::func_data_t<U,Ret_t(Args_t...)>;

		typedef Ret_t(*func_ptr_t)(Args_t...);

		using base_t::ptr_t;
		using base_t::_m;

		template<class T>
		static constexpr bool base_on_this_t_or_more_stringent_restrictions=(
			type_info<T>.base_on<this_t>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept,	promise_nothrow_at_destruct			>>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...),			bool(promise_nothrow_at_destruct+1)	>>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept,	bool(promise_nothrow_at_destruct+1)	>>
		);

		template<class T>
		static constexpr bool get_data_able_helper()noexcept{
			if constexpr(base_on_this_t_or_more_stringent_restrictions<T>)
				return true;
			elseif constexpr(is_function_t<T>)
				return false;
			elseif constexpr(::std::is_function_v<T>)
				return get_data_able_helper<decltype(&declvalue(T))>();
			elseif constexpr(invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				return get<func_data_t<remove_cvref<T>>>.able<T>;
			else
				return false;
		}
		template<class T>
		static constexpr bool get_data_able=get_data_able_helper<T>();
		template<class T>
		static constexpr bool get_data_nothrow_helper()noexcept{
			if constexpr(base_on_this_t_or_more_stringent_restrictions<T>)
				return true;
			elseif constexpr(is_function_t<T>)
				return false;
			elseif constexpr(::std::is_function_v<T>)
				return get_data_nothrow_helper<decltype(&declvalue(T))>();
			elseif constexpr(invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				return get<func_data_t<remove_cvref<T>>>.nothrow<T>;
			else
				return false;
		}
		template<class T>
		static constexpr bool get_data_nothrow=get_data_nothrow_helper<T>();

		template<class T> requires get_data_able<T>
		static auto get_data_from(T&&a)noexcept(get_data_nothrow<T>){
			if constexpr(::std::is_function_v<T>)
				return get_data_from(&a);
			elseif constexpr(is_function_t<T>)
				return a._m;
			else{
				//BLOCK:constexpr checks
				if constexpr(promise_nothrow_at_destruct and not destruct.nothrow<T>)
					template_error("unexpected assign.");
				//BLOCK_END
				return get<func_data_t<remove_cvref<T>>>(a);
			}
		}
		explicit base_function_t(base_t::ptr_t a)noexcept{_m=a;}
	public:
		void swap_with(this_t&a)noexcept{//不与base_t::swap_with重复：与更加严格（或宽松）的this_t进行swap是错误的
			base_t::swap_with(a);
		}

		base_function_t()noexcept=default;
		template<class T> requires base_on_this_t_or_more_stringent_restrictions<T>
		base_function_t(const T&a)noexcept:base_t(a){}
		base_function_t(const this_t&a)noexcept:base_t(a){}
		base_function_t(this_t&&a)noexcept:base_function_t(){
			swap_with(a);
		}
		base_function_t(null_ptr_t)noexcept:base_function_t(){}
		base_function_t(nullptr_t)noexcept:base_function_t(null_ptr){}
		template<class T> requires(get_data_able<T>)
		base_function_t(T&&a)noexcept(get_data_nothrow<T>){
			_m=get_data_from(forward<T>(a));
		}
		base_function_t(func_ptr_t a)noexcept{//当nothrow==0时，noexcept(true)的参数可自动转为noexcept(false)的，不用再次考虑
			_m=get<func_data_t<func_ptr_t>>(a);
		}
		~base_function_t()noexcept(promise_nothrow_at_destruct)=default;

		this_t&operator=(const this_t&a)noexcept(promise_nothrow_at_destruct)=default;
		this_t&operator=(this_t&&a)noexcept(promise_nothrow_at_destruct)=default;
		this_t&operator=(null_ptr_t)noexcept(promise_nothrow_at_destruct){_m=null_ptr;return *this;}
		this_t&operator=(nullptr_t)noexcept(promise_nothrow_at_destruct){return *this=null_ptr;}
		template<class T> requires base_on_this_t_or_more_stringent_restrictions<T>
		this_t&operator=(const T&a)&noexcept(promise_nothrow_at_destruct){
			base_t::operator=(a);
			return*this;
		}
		template<class T> requires(get_data_able<T>)
		this_t&operator=(T&&a)noexcept(get_data_nothrow<T> && promise_nothrow_at_destruct){
			_m=get_data_from(forward<T>(a));
			return*this;
		}

		this_t deep_copy(){return this_t{copy_get(_m.get())};}

		[[nodiscard]]explicit operator bool()const noexcept{
			return bool(_m);
		}

		Ret_t operator()(Args_t...args){
			return base_t::call(forward<Args_t>(args)...);
		}
		Ret_t operator()(Args_t...args)const{
			return base_t::call(forward<Args_t>(args)...);
		}

	private:
		//以下是突然想加的功能(没什么用<迷惑行为大赏>).
		static thread_local inline base_t::base_t_w* _func_ptr_data_local=nullptr;
		static inline ::std::atomic<decltype(_func_ptr_data_local)> _func_ptr_data_gobal=nullptr;
		static Ret_t _func_ptr_value(Args_t...args)noexcept{
			if(!_func_ptr_data_local)
				_func_ptr_data_local=_func_ptr_data_gobal.load(::std::memory_order_relaxed);
			return _func_ptr_data_local->call(forward<Args_t>(args)...);
		}
	public:
		//自当前function对象生成一个函数指针，具有与当前function对象相同的行为
		//注意：该函数指针的有效性保留到当前线程下一个同类型的函数指针生成时或当前function对象析构时
		//若自该函数指针创建一个新的线程，该函数指针在新线程中的行为与调用时以前所有线程中最后一个生成的同类型的函数指针行为相同
		[[nodiscard]]explicit operator func_ptr_t()const noexcept(promise_nothrow_at_destruct){
			func_ptr_t a=(func_ptr_t)_m->get_func_ptr();
			if(a)return a;
			_func_ptr_data_local=base_t::_m.get();
			_func_ptr_data_gobal.store(_func_ptr_data_local,::std::memory_order_relaxed);
			return _func_ptr_value;
		}
	};
	template<class Ret_t,class...Args_t,bool promise_nothrow_at_destruct>
	struct base_function_t<Ret_t(Args_t...)noexcept,promise_nothrow_at_destruct>:function_data_saver_t<Ret_t(Args_t...)>{
	protected:
		typedef function_data_saver_t<Ret_t(Args_t...)>base_t;
		typedef base_function_t<Ret_t(Args_t...)noexcept,promise_nothrow_at_destruct>this_t;

		template<class,bool>
		friend class base_function_t;

		template<class U>
		using func_data_t=function_n::func_data_t<U,Ret_t(Args_t...)>;

		typedef Ret_t(*func_ptr_t)(Args_t...)noexcept;

		using base_t::ptr_t;
		using base_t::_m;

		template<class T>
		static constexpr bool base_on_this_t_or_more_stringent_restrictions=(
			type_info<T>.base_on<this_t>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept,	promise_nothrow_at_destruct			>>||
			type_info<T>.base_on<base_function_t<Ret_t(Args_t...)noexcept,	bool(promise_nothrow_at_destruct+1)	>>
		);

		template<class T>
		static constexpr bool get_data_able_helper()noexcept{
			if constexpr(base_on_this_t_or_more_stringent_restrictions<T>)
				return true;
			elseif constexpr(is_function_t<T>)
				return false;
			elseif constexpr(::std::is_function_v<T>)
				return get_data_able_helper<decltype(&declvalue(T))>();
			elseif constexpr(invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				return get<func_data_t<remove_cvref<T>>>.able<T>;
			else
				return false;
		}
		template<class T>
		static constexpr bool get_data_able=get_data_able_helper<T>();
		template<class T>
		static constexpr bool get_data_nothrow_helper()noexcept{
			if constexpr(base_on_this_t_or_more_stringent_restrictions<T>)
				return true;
			elseif constexpr(is_function_t<T>)
				return false;
			elseif constexpr(::std::is_function_v<T>)
				return get_data_nothrow_helper<decltype(&declvalue(T))>();
			elseif constexpr(invoke<T>.with_return_type<Ret_t>.able<Args_t...>)
				return get<func_data_t<remove_cvref<T>>>.nothrow<T>;
			else
				return false;
		}
		template<class T>
		static constexpr bool get_data_nothrow=get_data_nothrow_helper<T>();

		template<class T> requires get_data_able<T>
		static auto get_data_from(T&&a)noexcept(get_data_nothrow<T>){
			if constexpr(::std::is_function_v<T>)
				return get_data_from(&a);
			elseif constexpr(is_function_t<T>)
				return a._m;
			else{
				//BLOCK:constexpr checks
				if constexpr(promise_nothrow_at_destruct and not destruct.nothrow<T>)
					template_error("unexpected assign.");
				if constexpr(1)
					if constexpr(!invoke<T>.with_return_type<Ret_t>.nothrow<Args_t...>)
						template_warning("the call of T was not noexcept,this may cause terminate.");
				//BLOCK_END
				return get<func_data_t<remove_cvref<T>>>(a);
			}
		}
		explicit base_function_t(base_t::ptr_t a)noexcept{_m=a;}
	public:
		void swap_with(this_t&a)noexcept{//不与base_t::swap_with重复：与更加严格（或宽松）的this_t进行swap是错误的
			base_t::swap_with(a);
		}

		base_function_t()noexcept=default;
		template<class T> requires base_on_this_t_or_more_stringent_restrictions<T>
		base_function_t(const T&a)noexcept:base_t(a){}
		base_function_t(const this_t&a)noexcept:base_t(a){}
		base_function_t(this_t&&a)noexcept:base_function_t(){
			swap_with(a);
		}
		base_function_t(null_ptr_t)noexcept:base_function_t(){}
		base_function_t(nullptr_t)noexcept:base_function_t(null_ptr){}
		template<class T> requires(get_data_able<T>)
		base_function_t(T&&a)noexcept(get_data_nothrow<T>){
			_m=get_data_from(forward<T>(a));
		}
		base_function_t(func_ptr_t a)noexcept{//当nothrow==0时，noexcept(true)的参数可自动转为noexcept(false)的，不用再次考虑
			_m=get<func_data_t<func_ptr_t>>(a);
		}
		~base_function_t()noexcept(promise_nothrow_at_destruct)=default;

		this_t&operator=(const this_t&a)&noexcept(promise_nothrow_at_destruct)=default;
		this_t&operator=(this_t&&a)&noexcept(promise_nothrow_at_destruct)=default;
		this_t&operator=(null_ptr_t)&noexcept(promise_nothrow_at_destruct){_m=null_ptr;return *this;}
		this_t&operator=(nullptr_t)&noexcept(promise_nothrow_at_destruct){return *this=null_ptr;}
		template<class T> requires base_on_this_t_or_more_stringent_restrictions<T>
		this_t&operator=(const T&a)&noexcept(promise_nothrow_at_destruct){
			base_t::operator=(a);
			return*this;
		}
		template<class T> requires(get_data_able<T>)
		this_t&operator=(T&&a)noexcept(get_data_nothrow<T> && promise_nothrow_at_destruct){
			_m=get_data_from(forward<T>(a));
			return*this;
		}

		this_t deep_copy(){return this_t{copy_get(_m.get())};}

		[[nodiscard]]explicit operator bool()const noexcept{
			return bool(_m);
		}

		Ret_t operator()(Args_t...args)noexcept{
			suppress_msvc_warning(26447)
			return base_t::call(forward<Args_t>(args)...);
		}
		Ret_t operator()(Args_t...args)const noexcept{
			suppress_msvc_warning(26447)
			return base_t::call(forward<Args_t>(args)...);
		}

	private:
		//以下是突然想加的功能(没什么用<迷惑行为大赏>).
		static thread_local inline base_t::base_t_w* _func_ptr_data_local=nullptr;
		static inline ::std::atomic<decltype(_func_ptr_data_local)> _func_ptr_data_gobal=nullptr;
		static Ret_t _func_ptr_value(Args_t...args)noexcept{
			if(!_func_ptr_data_local)
				_func_ptr_data_local=_func_ptr_data_gobal.load(::std::memory_order_relaxed);
			return _func_ptr_data_local->call(forward<Args_t>(args)...);
		}
	public:
		//自当前function对象生成一个函数指针，具有与当前function对象相同的行为
		//注意：该函数指针的有效性保留到当前线程下一个同类型的函数指针生成时或当前function对象析构时
		//若自该函数指针创建一个新的线程，该函数指针在新线程中的行为与调用时以前所有线程中最后一个生成的同类型的函数指针行为相同
		[[nodiscard]]explicit operator func_ptr_t()const noexcept(promise_nothrow_at_destruct){
			func_ptr_t a=(func_ptr_t)_m->get_func_ptr();
			if(a)return a;
			_func_ptr_data_local=base_t::_m.get();
			_func_ptr_data_gobal.store(_func_ptr_data_local,::std::memory_order_relaxed);
			return _func_ptr_value;
		}
	};
	#endif
	template<class T,bool promise_nothrow_at_destruct>
	void swap(base_function_t<T,promise_nothrow_at_destruct>&a,base_function_t<T,promise_nothrow_at_destruct>&b)noexcept{
		a.swap_with(b);
	}
}

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/defs.hpp"
//defs.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace function_n{
	template<class T>
	using function_t=base_function_t<T,true>;

	//[[deprecated("not safe")]]//用这么长名字的人大概知道自己在干啥
	template<class T>
	using may_throw_in_destruct_function_t=base_function_t<T,false>;
}

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/deduction_guides.hpp"
//deduction_guides.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace function_n{
	template<typename T,typename Func_t=get_function_type<T>,bool promise_nothrow_at_destruct>
	base_function_t(T)->base_function_t<Func_t,promise_nothrow_at_destruct>;
}

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_export.hpp"
//_export.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using function_n::
export function_t;
//export may_throw_in_destruct_function_t;
#undef export

//file_end

#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_test.hpp"
//_test.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace function_n{
	//BLOCK:for debug
	inline void test(){
		ELC_TEST_EVENTNAME("function部分测试");
		{
			int tester=0;
			#if !defined(_MSC_VER)
				function_t
			#else
				function_t<void()noexcept>
			#endif
			a(lambda_with_catch (&tester)()noexcept{ tester=1; });
			static_assert(type_info<decltype(a)> == type_info<function_t<void()noexcept>>);
			stest_accert(tester==0);
			a();
			stest_accert(tester==1);
			#if !defined(_MSC_VER)
				function_t
			#else
				function_t<void()>
			#endif
			b=test;
			static_assert(type_info<decltype(b)> == type_info<function_t<void()>>);
			b=a;
			a=null_ptr;
			tester=0;
			a();
			stest_accert(tester==0);
			b();
			stest_accert(tester==1);
			swap(a,a);
			stest_accert(a!=b);
			b=a;
			stest_accert(a==b);
		}
		check_memory_lack();
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
	//BLOCK_END
}

//file_end

	#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/function/_body.hpp"
#endif

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_body.hpp"
//_body.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace stack_n{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/base_stack.hpp"
//defs.hpp
//at namespace elc::defs::container::stack_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename T>
class base_stack_t:non_copyable{//基础容器，可用于hashtable
	typedef base_stack_t<T>this_t;
protected:
	struct data_t{
		T _data;
		data_t*_next;

		constexpr_as(construct<T>(declvalue(const T&)))data_t(const T&a,data_t*b)noexcept(construct<T>.nothrow<const T&>):_data(a),_next(b){}
		constexpr_as(construct<T>(declvalue(const T&)))data_t(const data_t&a)noexcept(construct<T>.nothrow<const T&>):_data(a._data),_next(null_ptr){}
	}*_m;
	size_t _size;
private:
	this_t copy()const noexcept(copy_get.nothrow<data_t>){
		this_t tmp;
		const data_t*p=_m;
		data_t**p_=&tmp._m;
		while(p!=null_ptr){
			*p_=copy_get(p);
			p_=&(**p_)._next;
			p=p->_next;
		}
		tmp._size=size();
		return tmp;
	}
public:
	constexpr base_stack_t()noexcept:_m(null_ptr),_size(0){}
	void swap_with(this_t&a)noexcept{
		swap(_m,a._m);
		swap(_size,a._size);
	}
	this_t&operator=(this_t&&a)&noexcept{
		swap_with(a);
		return*this;
	}
	base_stack_t(this_t&&a)noexcept:base_stack_t(){
		operator=(move(a));
	}
	this_t&operator=(const this_t&a)&noexcept_as(declvalue(this_t).copy()){
		return operator=(a.copy());
	}
	base_stack_t(const this_t&a)noexcept_as(declvalue(this_t).copy()):base_stack_t(a.copy()){}
	~base_stack_t()noexcept(unget.nothrow<data_t>){
		suppress_msvc_warning(26494)//未初始化警告diss
		data_t*tmp;
		while(_m!=null_ptr){
			tmp=_m;
			_m=_m->_next;
			unget(tmp);
		}
	}
	void clear()noexcept(re_construct.nothrow<this_t>){
		re_construct(this);
	}
	[[nodiscard]]bool empty()const noexcept{
		return _m==null_ptr;
	}
	template<typename U>
	[[nodiscard]]maybe_fail_reference<T>find(U&&a)noexcept_as(declvalue(T&)==a){
		data_t*tmp=_m;
		while(tmp!=null_ptr){
			if(tmp->_data==a)
				return tmp->_data;
			tmp=tmp->_next;
		}
		return note::fail;
	}
	[[nodiscard]]bool in_stack(const T&a)const noexcept_as(declvalue(this_t).find(a).not_fail()){
		return remove_const(this)->find(a).not_fail();
	}
	[[nodiscard]]bool not_in_stack(const T&a)const noexcept_as(declvalue(this_t).in_stack(a)){
		return not in_stack(a);
	}
	[[nodiscard]]size_t size()const noexcept{
		return _size;
	}

	static constexpr bool add_nothrow=noexcept(get<data_t>(declvalue(const T&),declvalue(data_t*)));
	void add(const T&a)noexcept(add_nothrow){
		_m=get<data_t>(a,_m);
		_size++;
	}

	static constexpr bool remove_nothrow=unget.nothrow<data_t>;
	template<typename T_>
	bool remove(const T_&a)noexcept(remove_nothrow && equal.nothrow<T_,T>){//返回值：是否成功移除（容器里是否有此T）
		data_t*tmp=_m,**tmp_=&_m;
		while(tmp!=null_ptr){
			if(a==tmp->_data){
				_size--;
				*tmp_=tmp->_next;
				unget(tmp);
				return true;
			}
			tmp_=&tmp->_next;
			tmp=*tmp_;
		}
		return false;
	}
	#define expr declvalue(func_t)(declvalue(T&))
	template<typename func_t> requires was_not_an_ill_form(expr)
	void for_each(func_t&&func)noexcept_as(expr){
		data_t*tmp=_m;
		while(tmp!=null_ptr){
			func(tmp->_data);
			tmp=tmp->_next;
		}
	}
	#undef expr

	#define expr declvalue(func_t)(declvalue(const T&))
	template<typename func_t> requires was_not_an_ill_form(expr)
	void for_each(func_t&&func)const noexcept_as(expr){
		const data_t*tmp=_m;
		while(tmp!=null_ptr){
			func(tmp->_data);
			tmp=tmp->_next;
		}
	}
	#undef expr
protected:
	void add(data_t*a)noexcept{
		a->_next=_m;
		_m=a;
		_size++;
	}
public:
	[[nodiscard]]hash_t get_top_hash()noexcept_as(hash(declvalue(T&))){
		if(_m)
			return hash(_m->_data);
		else
			return hash(_m);
	}
	void move_top_to(this_t&a)noexcept{
		_size--;
		auto tmp=_m;
		_m=_m->_next;
		a.add(tmp);
	}
};

//file_end

	#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/auto_stack.hpp"
//defs.hpp
//at namespace elc::defs::container::stack_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename T>
struct auto_stack_t:base_stack_t<T>{//提头优化容器，可用于hashtable
private:
	typedef base_stack_t<T>base_t;
	typedef auto_stack_t<T>this_t;

	using base_t::data_t;
	using base_t::_m;
public:
	using base_t::base_t;
	auto_stack_t(const base_t&a)noexcept_as(base_t(a)):base_t(a){}
	auto_stack_t(base_t&&a)noexcept_as(base_t(a)):base_t(a){}

	this_t&operator=(this_t&&a)&noexcept{base_t::operator=(move(a));return*this;}
	template<typename U>
	[[nodiscard]]maybe_fail_reference<T>find(U&&a)noexcept_as(declvalue(T&)==a){
		data_t*tmp=_m,**tmp_=&_m;
		while(tmp!=null_ptr){
			if(tmp->_data==a){
				*tmp_=tmp->_next;
				tmp->_next=_m;//提头
				_m=tmp;
				return tmp->_data;
			}
			tmp_=&tmp->_next;
			tmp=*tmp_;
		}
		return note::fail;
	}
	[[nodiscard]]bool in_stack(const T&a)const noexcept_as(declvalue(this_t).find(a).not_fail()){
		return remove_const(this)->find(a).not_fail();
	}
	[[nodiscard]]bool not_in_stack(const T&a)const noexcept_as(declvalue(this_t).in_stack(a)){
		return not in_stack(a);
	}
};

//file_end

	#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_body.hpp"

	#if defined(ELC_TEST_ON)
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_test.hpp"
//_test.hpp
//at namespace elc::defs::container::stack_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline void test(){
	ELC_TEST_EVENTNAME("stack部分测试");
	{
		base_stack_t<int>a;
		stest_accert(a.size()==0);
		a.add(1);
		a.add(2);
		a.add(3);
		stest_accert(a.size()==3);
		a.remove(2);
		stest_accert(a.size()==2);
		int add_num=0;
		a.for_each(lambda_with_catch(&add_num)(int a){add_num+=a;});
		stest_accert(add_num==4);
		auto_stack_t<int>b=a;
		stest_accert(b.not_in_stack(2));
		b.remove(3);
		stest_accert(a.in_stack(3));
		a.clear();
		b=a;
		a=b;
		stest_accert(b.size()==0);
	}
	check_memory_lack();
}
inline void test_log_out(){
}
inline void test_end(){
}

//file_end

		#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_body.hpp"
	#endif
}
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_export.hpp"
//_export.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using stack_n::
export auto_stack_t;
export base_stack_t;
#undef export

//file_end

#line 17 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/stacks/_body.hpp"

//file_end

#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_body.hpp"
//_body.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/defs.hpp"
//defs.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace hash_table_n{
	template<typename T,template<typename>class stack_t=auto_stack_t,size_t bucket_max_size=256>
	class hash_table_t{
		typedef hash_table_t<T,stack_t,bucket_max_size>this_t;
		typedef stack_t<T>bucket_t;
	public:
		typedef array_t<bucket_t>base_t_w;
	private:
		base_t_w _m;
	public:
		void swap(base_t_w&a)noexcept{_m.swap_with(a);}
	private:
		[[nodiscard]]bucket_t&find_bucket(hash_t a)noexcept{
			return _m[a%_m.size()];
		}
		void bucket_count_grow()noexcept{
			this_t tmp(special_init,get_next_gold_size_to_resize_for_hash(_m.size()));
			for(bucket_t&a:_m){
				while(!a.empty())
					a.move_top_to(tmp.find_bucket(a.get_top_hash()));
			}
			swap(tmp);
		}
		hash_table_t(const base_t_w&a)noexcept:_m(a){}
		this_t copy()noexcept(copy_construct.nothrow<base_t_w>){
			return{_m};
		}
	public:
		hash_table_t()noexcept:_m(5){}
		hash_table_t(special_init_t,size_t bucket_size)noexcept:_m(bucket_size){}
		~hash_table_t()noexcept(destruct.nothrow<base_t_w>)=default;

		operator base_t_w&()noexcept{return _m;}
		operator const base_t_w&()const noexcept{return _m;}

		hash_table_t(const this_t&a)noexcept:_m(a._m){}
		hash_table_t(this_t&&a)noexcept:_m(a._m){}

		this_t&operator=(base_t_w&&a)&noexcept{
			swap(_m,a);
			return*this;
		}
		this_t&operator=(const base_t_w&a)&noexcept{
			_m=a;
			return*this;
		}

		template<typename U>
		static constexpr bool hash_nothrow=noexcept(hash(declvalue(U)));
		template<typename U>
		static constexpr bool find_nothrow=hash_nothrow<U>&&noexcept(declvalue(bucket_t).find(declvalue(U)));

		void add(const T&a)noexcept(hash_nothrow<const T&>&&bucket_t::add_nothrow){
			auto&bucket=find_bucket(hash(a));
			bucket.add(a);
			if(bucket.size() > bucket_max_size)
				bucket_count_grow();
		}
		bool remove(const T&a)noexcept(bucket_t::remove_nothrow){
			auto&bucket=find_bucket(hash(a));
			bool remove_success=bucket.remove(a);
			if constexpr(is_unstable_hash<T>)
				if(not remove_success){
					for(auto&i:_m){
						if(is_eq(i,bucket))
							continue;
						remove_success=i.remove(a);
						if(remove_success)
							break;
					}
				}
			return remove_success;
		}
		template<typename U>
		[[nodiscard]]maybe_fail_reference<T>find(U&&a)noexcept(find_nothrow<U>){
			auto&bucket=find_bucket(hash(a));
			suppress_msvc_warning(26496)//?
			auto reference=bucket.find(a);
			if constexpr(is_unstable_hash<T>)
				if(reference.fail()){
					for(auto&i:_m){
						if(is_eq(i,bucket))
							continue;
						re_construct[&reference](i.find(a));
						if(reference.not_fail())
							break;
					}
				}
			return reference;
		}
		[[nodiscard]]bool in_table(const T&a)noexcept_as(declvalue(this_t).find(a).not_fail()){
			return find(a).not_fail();
		}
		[[nodiscard]]bool not_in_table(const T&a)noexcept_as(declvalue(this_t).in_table(a)){
			return not in_table(a);
		}

		size_t size()noexcept{
			size_t aret=0;
			for(const bucket_t&a:_m){
				aret+=a.size();
			}
			return aret;
		}

		void clear()noexcept(re_construct.nothrow<this_t>){
			re_construct(this);
		}

		#define expr declvalue(func_t)(declvalue(T&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each(func_t&&func)noexcept_as(expr){
			for(bucket_t&a:_m){
				a.for_each(func);
			}
		}
		#undef expr

		#define expr declvalue(func_t)(declvalue(const T&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each(func_t&&func)const noexcept_as(expr){
			for(bucket_t&a:_m){
				a.for_each(func);
			}
		}
		#undef expr

		#define expr declvalue(func_t)(declvalue(bucket_t&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each_bucket(func_t&&func)noexcept_as(expr){
			_m.for_each(func);
		}
		#undef expr

		#define expr declvalue(func_t)(declvalue(const bucket_t&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each_bucket(func_t&&func)const noexcept_as(expr){
			_m.for_each(func);
		}
		#undef expr
	};
	template<typename T,template<typename>class stack_t,size_t _,size_t __>
	inline void swap(hash_table_t<T,stack_t,_>&a,hash_table_t<T,stack_t,__>&b)noexcept{a.swap(b);}
	template<typename T,template<typename>class stack_t,size_t _>
	inline void swap(hash_table_t<T,stack_t,_>&a,typename hash_table_t<T,stack_t,_>::base_t_w&b)noexcept{a.swap(b);}
	template<typename T,template<typename>class stack_t,size_t _>
	inline void swap(typename hash_table_t<T,stack_t,_>::base_t_w&b,hash_table_t<T,stack_t,_>&a)noexcept{a.swap(b);}
}

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_export.hpp"
//_export.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using hash_table_n::
export hash_table_t;
#undef export

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_test.hpp"
//_test.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace hash_table_n{
	//BLOCK:for debug
	inline void test(){
		ELC_TEST_EVENTNAME("hash_table部分测试");
		{

		}
		check_memory_lack();
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
	//BLOCK_END
}

//file_end

	#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/hash_table/_body.hpp"
#endif

//file_end

#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_body.hpp"
//_body.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/defs.hpp"
//defs.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace map_n{
	template<typename T,typename key_t,template<typename>class stack_t=auto_stack_t,size_t bucket_max_size=256>
	class map_t{
		typedef map_t<T,key_t,stack_t,bucket_max_size>this_t;

		struct data_t{
			key_t _key;
			T _value;

			data_t(const data_t&) = default;
			data_t(const key_t&a,const T&b)noexcept(copy_construct.nothrow<key_t> && copy_construct.nothrow<T>):_key(a),_value(b){}

			struct seek_value_t{
				const T*_m;
				constexpr seek_value_t(const T&a)noexcept:_m(addressof(a)){};
				[[nodiscard]]bool operator==(const data_t&a)const noexcept_as(a._value==*_m){
					return bool(a._value==*_m);
				}
			};

			[[nodiscard]]bool operator==(const key_t&a)noexcept_as(_key==a){
				return bool(_key==a);
			}
			[[nodiscard]]constexpr_as(hash(_key))operator decltype(hash(_key))()const noexcept_as(hash(_key)){
				return hash(_key);
			}
			/* operator T&()noexcept{
				return _value;
			} */
			[[nodiscard]]bool empty(){
				return _value==const_default_value_of<T>;
			}
		};
		typedef hash_table_t<data_t,stack_t,bucket_max_size>base_t_w;

		mutable base_t_w _m;//mutable cause shrink.

		map_t(const base_t_w&a)noexcept:_m(a){}
		this_t copy()noexcept(copy_construct.nothrow<base_t_w>){
			return{_m};//不用疑惑，这是deep copy
		}
	public:
		map_t()noexcept=default;
		~map_t()noexcept(destruct.nothrow<base_t_w>)=default;
		map_t(const this_t&a)noexcept=default;
		map_t(this_t&&a)noexcept=default;

		this_t&operator=(this_t&&a)noexcept{
			swap(_m,a._m);
			return*this;
		}
		this_t&operator=(const this_t&a)noexcept{
			return operator=(a.copy());
		}

		template<size_t _>
		void swap(map_t<T,key_t,stack_t,_>&a)noexcept{swap(_m,a._m);}

		[[nodiscard]]T&operator[](const key_t&a)noexcept_as(_m.add({a,T()})){
			auto tmp=_m.find(a);
			if(tmp.fail()){
				_m.add({a,T()});
				tmp=_m.find(a);
			}
			return tmp.get_ref()._value;
		}
		[[nodiscard]]const T&operator[](const key_t&a)const noexcept{
			auto tmp=_m.find(a);
			return tmp.fail()?const_default_value_of<T>:tmp.get_ref()._value;
		}
		void clear()noexcept(re_construct.nothrow<this_t>){
			re_construct(this);
		}

		#define expr declvalue(func_t)(declvalue(T&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each(func_t&&func)noexcept_as(expr){
			_m.for_each(lambda(data_t&a)noexcept_as(expr){
				func(a._value);
			});
		}
		#undef expr

		#define expr declvalue(func_t)(declvalue(const T&))
		template<typename func_t> requires was_not_an_ill_form(expr)
		void for_each(func_t&&func)const noexcept_as(expr){
			_m.for_each(lambda(data_t&a)noexcept_as(expr){
				func(add_const<T&>(a._value));
			});
		}
		#undef expr

		static constexpr bool shrink_nothow=stack_t<data_t>::remove_nothrow;
		void shrink()const noexcept(shrink_nothow){
			_m.for_each_bucket(lambda(stack_t<data_t>&a)noexcept(shrink_nothow && equal.nothrow<T>){
				while(a.remove(data_t::seek_value_t(const_default_value_of<T>)));
			});
		}

		using_method_from_value(size,_m,const);

		bool operator==(const this_t&a)const noexcept(shrink_nothow && equal.nothrow<T>){
			shrink();
			a.shrink();
			if(size()!=a.size())
				return 0;
			try{
				_m.for_each(lambda_with_catch(&a)(data_t&b){
					if(a[b._key]!=b._value)
						throw (this_t*)(nullptr);
				});
			}
			catch(this_t*){
				return 0;
			}
			return 1;
		}
	};
	template<typename T,typename key_t,template<typename>class stack_t,size_t _,size_t __>
	inline void swap(map_t<T,key_t,stack_t,_>&a,map_t<T,key_t,stack_t,__>&b)noexcept{a.swap(b);}
}

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_export.hpp"
//_export.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using map_n::
export map_t;
#undef export

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_body.hpp"
#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_test.hpp"
//_test.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace map_n{
	//BLOCK:for debug
	inline void test(){
		ELC_TEST_EVENTNAME("map部分测试");
		{

		}
		check_memory_lack();
	}
	inline void test_log_out(){
	}
	inline void test_end(){
	}
	//BLOCK_END
}

//file_end

	#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/map/_body.hpp"
#endif

//file_end

#line 15 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"

#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_test.hpp"
//_test.hpp
//at namespace elc::defs::container
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline void test(){
	ELC_TEST_EVENTNAME("container部分测试");
	array_n::test();
	function_n::test();
	stack_n::test();
}
inline void test_log_out(){
	array_n::test_log_out();
	function_n::test_log_out();
	stack_n::test_log_out();
}
inline void test_end(){
	array_n::test_end();
	function_n::test_end();
	stack_n::test_end();
}

//file_end

	#line 18 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/container/_body.hpp"
#endif

//file_end

		#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
	}
	using namespace container;

	namespace memory::gc_n{//gc定义，依赖container（但container依赖memory的其他部分）
		//依赖container
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/roots/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
struct have_root{};

template<typename T>
class root_of;

template<typename T>
class roots_t{
	typedef roots_t<T>this_t;
	typedef root_of<T>root_t;
	typedef root_of<T>*value_t;

	base_stack_t<value_t>_roots;
public:
	constexpr roots_t()noexcept=default;
	~roots_t()noexcept=default;

	using_method_from_value(map,_roots);
	using_method_from_value(add,_roots);
	using_method_from_value(remove,_roots);
	using_method_from_value(for_each,_roots);

	void map_and_mark()noexcept_as(declvalue(value_t)->map_and_mark()){
		_roots.for_each(
			lambda(value_t&a)noexcept_as(a->map_and_mark())
			{
				a->map_and_mark();
			}
		);
	}
};
template<typename T>
distinctive inline roots_t<T>roots_of{};

template<typename T>
class root_of{
	typedef root_of<T>this_t;
public:
	root_of()noexcept_as(roots_of<T>.add(declvalue(this_t*))){
		roots_of<T>.add(this);
	}
	virtual T& get()noexcept=0;
	virtual void map_and_mark()noexcept=0;
};
template<typename T>
inline T& root_of<T>::get()noexcept{return const_default_value_of<T>;}
template<typename T>
inline void root_of<T>::map_and_mark()noexcept{}

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/mark_able_for_gc/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename T>
struct mark_able_for_gc:mark_able<T>{
	mark_able_for_gc()noexcept:mark_able<T>(not_mark){}
	mark_able_for_gc(const mark_able_for_gc&)noexcept{}
};

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/others/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
def_common_attribute_with_nothing(can_shrink);
def_common_attribute_with_nothing(can_map_all);

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_flags/_body.hpp"

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/default_method/decl.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<class T,enable_flag>
inline void gc_method_of()noexcept;
template<class T,enable_flag>
[[nodiscard]]inline bool gc_success_identifier_of()noexcept;

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/_body.hpp"
//
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
class gc_t{
	typedef gc_t this_t;
	typedef function_t<void()noexcept>gc_method_t;
	typedef function_t<bool()noexcept>success_identifier_t;

	base_stack_t<gc_method_t>_gc_methods;
	base_stack_t<success_identifier_t>_gc_success_identifiers;
	mutable flag _gc_running=flag(not_set);
public:
	inline void operator()()const noexcept{
		if(_gc_running)
			die_with(locale::str::gc_fail);
		_gc_running.set();
		if(_gc_methods.empty())
			die_with(locale::str::empty_gc_method);
		_gc_methods.for_each(invoke<const gc_method_t>._as(nothing));
		_gc_running.unset();
	}
	[[nodiscard]]inline bool success()const noexcept{
		bool success=_gc_success_identifiers.empty();
		_gc_success_identifiers.for_each(
			lambda_with_catch(&success)(const success_identifier_t&a)noexcept{
				if(not success)
					success=a();
			}
		);
		return success;
	}

	inline void add_gc_method(gc_method_t a)noexcept{
		_gc_methods.add(a);
	}
	inline void remove_gc_method(gc_method_t a){
		_gc_methods.remove(a);
	}

	inline void add_gc_success_identifier(success_identifier_t a)noexcept{
		_gc_success_identifiers.add(a);
	}
	inline void remove_gc_success_identifier(success_identifier_t a){
		_gc_success_identifiers.remove(a);
	}

	template<class T>
	inline void add_gc_method(type_info_t<T>)noexcept{
		add_gc_method((void(*)()noexcept)gc_method_of<T>);
		add_gc_success_identifier(gc_success_identifier_of<T>);
	}
	template<class T>
	inline void remove_gc_method(type_info_t<T>)noexcept{
		remove_gc_method(gc_method_of<T>);
		remove_gc_success_identifier(gc_success_identifier_of<T>);
	}
};

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/_body.hpp"
//
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/default_method/defs.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace default_gc_for_type{
	template<class T,enable_if(type_info<T>.has_attribute(count_able))>
	distinctive inline size_t count_for_success_identify;

	template<class T>
	constexpr bool use_default_gc_able =
	(
		type_info<T>.has_attribute(mark_able_for_gc) &&
		type_info<T>.has_attribute(have_root)
	)&&(
			type_info<T>.has_attribute(can_map_all)
		&&(
				type_info<T>.has_attribute(can_shrink)
			||(
				type_info<T>.has_attribute(mark_able_for_gc) &&
				type_info<T>.has_attribute(have_root)
			)
		)
	);

	enable_adl(destory_by_gc);
	template<class T>
	void destory_by_gc(T*){
		template_error("this function should not be instantiated,please overload the function destory_by_gc in the namespace where this type is defined.");
	}

	template<class T> requires use_default_gc_able<T>
	inline void default_gc_method()noexcept{
		constexpr auto&info=type_info<T>;
		//
		if constexpr(info.has_attribute(count_able))
			count_for_success_identify<T> = the_number_of(info);
		//
		if constexpr(info.has_attribute(can_map_all)){
			if constexpr(info.has_attribute(mark_able_for_gc)&&info.has_attribute(have_root))
				roots_of<T>.map_and_mark();
			if constexpr(info.has_attribute(can_shrink) || (info.has_attribute(mark_able_for_gc)&&info.has_attribute(have_root)))
				map_all<T>(
					lambda(T*a)noexcept{
						if constexpr(info.has_attribute(can_shrink))
							a->shrink();
						if constexpr(info.has_attribute(mark_able_for_gc)&&info.has_attribute(have_root)){
							auto& b=attribute_cast<mark_able_for_gc>(*a);
							if(b.was_marked())
								b.unmark();
							else
								destory_by_gc(a);
						}
					}
				);
		}
	}
	//
	template<class T>
	constexpr bool use_default_gc_success_identifier_able = type_info<T>.has_attribute(count_able);

	template<class T> requires use_default_gc_success_identifier_able<T>
	[[nodiscard]]inline bool default_gc_success_identifier()noexcept{
		constexpr auto&info=type_info<T>;
		if constexpr(info.has_attribute(count_able)){//重复判定，勿删，方便日后扩展
			return count_for_success_identify<T> _big_than_ the_number_of(info);
		}
	}
}
template<class T,enable_if(default_gc_for_type::use_default_gc_able<T>)>
inline void gc_method_of()noexcept{
	default_gc_for_type::default_gc_method<T>();
}
template<class T,enable_if(default_gc_for_type::use_default_gc_success_identifier_able<T>)>
[[nodiscard]]inline bool gc_success_identifier_of()noexcept{
	return default_gc_for_type::default_gc_success_identifier<T>();
}

//file_end

#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_t/_body.hpp"

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory::gc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
distinctive inline gc_t gc;

//file_end

#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"

//for alloc (def in "../alloc/defs.hpp#L10" )
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/gc_for_alloc/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline void gc_for_alloc()noexcept{
	gc();
}

//file_end

#line 15 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/_body.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
BREAK_NAMESPACE//in namespace elc::defs
INTER_NAMESPACE(memory::ptr_n)

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/defs.hpp"
//defs.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
enable_adl(map_and_mark_for_gc);
template<typename T>
void map_and_mark_for_gc(T*)noexcept{
	template_error("this function should not be instantiated,please overload the function map_and_mark_for_gc in the namespace where this type is defined");
}
using ::elc::defs::memory::gc_n::root_of;
template<class T,enable_if(
								was_ref_able<T> &&
								comn_ptr_t<T>::replace_check_nothrow &&
								type_info<T>.has_attribute(gc_n::have_root)
							)>
struct root_ptr_t:comn_ptr_t<T>,root_of<T>{
	typedef comn_ptr_t<T>base_t;
	typedef root_ptr_t<T>this_t;
public:
	using base_t::base_t;
	template<class assign_t> requires was_not_an_ill_form(declvalue(base_t)=declvalue(assign_t))
	this_t&operator=(assign_t&&a)noexcept_as(base_t::operator=(forward<assign_t>(a))){
		base_t::operator=(forward<assign_t>(a));
		return*this;
	}
	virtual T& get()noexcept override{
		return base_t::operator*();
	}
	virtual void map_and_mark()noexcept override{
		map_and_mark_for_gc(&**this);
	}
};

//file_end

#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/deduction_guides.hpp"
//deduction_guides.hpp
//at namespace elc::defs::memory::ptr_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<class T>
root_ptr_t(T*) -> root_ptr_t<T>;

//file_end

#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/_body.hpp"

BREAK_NAMESPACE//in namespace elc::defs

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/_export.hpp"
//_export.hpp
//at namespace elc::defs
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
INTER_NAMESPACE(memory)
#define export using memory::ptr_n::
export root_ptr_t;
#undef export
BREAK_NAMESPACE

//file_end

#line 17 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/root_ptr/_body.hpp"

INTER_NAMESPACE(memory::gc_n)

//file_end

#line 16 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_export.hpp"
//_export.hpp
//at namespace elc::defs::memory::gc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
BREAK_NAMESPACE//in namespace elc::defs
INTER_NAMESPACE(memory)
#define export using gc_n::
export gc;
export have_root;
export root_of;
export mark_able_for_gc;
export can_shrink;
#undef export
BREAK_NAMESPACE//in namespace elc::defs
INTER_NAMESPACE(memory::gc_n)

//file_end

#line 18 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"

#if defined(ELC_TEST_ON)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_test.hpp"
//_body.hpp
//at namespace elc::defs::memory::gc_n
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if!defined(_MSC_VER)//貌似msvc在这里有bug
struct gc_tester:type_info_t<gc_tester>::template_name
	with_common_attribute<can_map_all,can_shrink,count_able,mark_able_for_gc,never_in_array,ref_able>,
	have_root,build_by_get_only,force_use_default_null_ptr{
	distinctive static inline int shrink_time=0;
	distinctive static inline int destroy_time=0;
	~gc_tester()noexcept{destroy_time++;}
	void shrink(){
		shrink_time++;
	}
	static void reset_times(){
		shrink_time=destroy_time=0;
	}
};
static_assert(type_info<gc_tester>.base_on<can_map_all<gc_tester>>);
void map_and_mark_for_gc(gc_tester*a){
	attribute_ptr_cast<mark_able_for_gc>(a)->mark();
}
void destory_by_gc(gc_tester*a){
	a->~gc_tester();
}
#endif
inline void test(){
	#if!defined(_MSC_VER)
	ELC_TEST_EVENTNAME("gc部分测试");
	rand_seed.set_by_time();
	gc.add_gc_method(type_info<gc_tester>);
	for(int t=rand<int>()%7;t--;)
	{
		int i;
		root_ptr_t<gc_tester> name=get<gc_tester>();
		for(i=rand<int>()%72;i--;){
			#pragma warning(suppress: 4189)
			auto p=get<gc_tester>();
		}
		gc();
		stest_accert(gc_tester::shrink_time==i+1);
		stest_accert(gc_tester::destroy_time==i);
		stest_accert(get_size_of_get(&*name)==1);
	}
	check_memory_lack();
	#endif
}
inline void test_log_out(){

}
inline void test_end(){

}

//file_end

	#line 21 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/memory/gc/_body.hpp"
#endif

//file_end

		#line 40 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
	}
	using namespace memory;//只是强迫症

	#if defined(ELC_TEST_ON)
	namespace base_part_test{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_test.hpp"
//_test.hpp
//at namespace elc::defs::base_part_test
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline void test(){
	ELC_TEST_EVENTNAME("base部分测试");
	memory::test();
	container::test();
	gc_n::test();
}
inline void test_log_out(){
	memory::test_log_out();
	container::test_log_out();
}
inline void test_end(){
	memory::test_end();
	container::test_end();
}

//file_end

		#line 46 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
	}
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 50 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
}
namespace elc{
	//导出base承诺于名称空间elc中提供的内容
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_export.hpp"
//_export.hpp
//at namespace elc
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using defs::base::
#undef export

//file_end

	#line 53 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base/_body.hpp"
}

//file_end

	#line 18 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
#endif

//file_end

	#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/core"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
//base_exception
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
#if !defined(ELC_BASE_EXCEPTION)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"
//using.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*
locale说明
elc使用的字符串.
调整这些,实现快速本地化.
*/
#line 26 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/locale/using.hpp"

//file_end

	#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
	#define ELC_BASE_EXCEPTION
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
//_body.hpp
//at namespace ::
/*
未完成的elc解释器base_exception文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if defined(ELC_TEST)
	#error "this part cannot be tested."
#endif
//char_t
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
//default_data_type.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace elc{
	/*ELC内部string统一采用char_t宽字符，使用setlocale(LC_ALL,"en_US.utf8")下的UTF编码。*/
	typedef char32_t char_t;
	/*c_string表示*/
	typedef char_t* string_ptr_t;
	/*c_string表示*/
	typedef const char_t* const_string_ptr_t;
	/*ELC内部钦定int_t类型*/
	typedef int64_t int_t;
	/*ELC内部钦定uint_t类型*/
	typedef uint64_t uint_t;
	/*ELC内部钦定float_t类型*/
	typedef double float_t;
	/*ELC内部钦定float_size_t类型，用以描述内存大小的浮点状况*/
	typedef long double float_size_t;
}

//file_end

#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"

	namespace exception_n{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/exception/_body.hpp"
//_body.hpp
//at namespace elc::defs::exception_n
/*
未完成的elc解释器base_exception文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/exception/exception.hpp"
//_body.hpp
//at namespace elc::defs::exception_n
/*
未完成的elc解释器base_exception文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
no_vtable_class exception{
	const_string_ptr_t _constexpr_str=locale::str::exception::unknow_error;
public:
	constexpr exception()noexcept=default;
	constexpr exception(const constexpr_str_t<char_t>&str)noexcept:_constexpr_str(str){}
	virtual constexpr ~exception()noexcept=0;
	virtual constexpr const_string_ptr_t what()noexcept{return _constexpr_str;}
};
inline constexpr exception::~exception()noexcept{}

struct runtime_exception:exception{
	using exception::exception;
};

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/exception/_body.hpp"

//file_end

		#line 17 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
	}
	namespace exceptions=exception_n;

	#if defined(ELC_TEST_ON)
	namespace base_exception_part_test{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_test.hpp"
//_test.hpp
/*
未完成的elc解释器base_exception文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline void test(){
	ELC_TEST_EVENTNAME("base_exception部分测试");
}
inline void test_log_out(){
}
inline void test_end(){
}

//file_end

		#line 23 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
	}
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 27 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
}
namespace elc{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_export.hpp"
//_export.hpp
//at namespace elc
/*
未完成的elc解释器base_exception文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using defs::exception_n::
export exception;
export runtime_exception;
#undef export

//file_end

	#line 30 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_exception/_body.hpp"
}

//file_end

	#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_exception"
#endif

//file_end

	#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/core"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
//base_stream
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
#if !defined(ELC_BASE_STREAM)
	//abstract_base
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
//base
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
#line 19 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"

//file_end

	#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
	#include <istream>//std::istream for wrap
	#include <ostream>//std::ostream for wrap
	//do not include <iostream> as it will import some gobal objects like std::cin and std::cout that we may not want to use
	#define ELC_BASE_STREAM
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
//_body.hpp
//at namespace ::
/*
未完成的elc解释器base_stream文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if defined(ELC_TEST)
	#error "this part cannot be tested."
#endif
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"

	namespace stream_n{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/base_streams/_body.hpp"
//_body.hpp
//at namespace elc::defs::stream_n
/*
未完成的elc解释器base_stream文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
push_and_disable_msvc_warning(4250);
enum class seek_type{beg,end,cur};
using enum seek_type;
no_vtable_struct base_stream:abstract_base<base_stream>{
	virtual ~base_stream()=default;
	virtual int_t seek(seek_type,int_t)=0;
	virtual int_t tell(){return this->seek(cur,0);}
	virtual void seek_to(int_t)=0;
	virtual void sync()=0;
	virtual void flush()=0;
	virtual void close()=0;
};
no_vtable_struct base_istream:abstract_base<base_istream>,virtual base_stream{};
no_vtable_struct base_ostream:abstract_base<base_ostream>,virtual base_stream{};
no_vtable_struct base_iostream:abstract_base<base_iostream>,virtual base_ostream,virtual base_istream{};


no_vtable_struct noexcept_stream:abstract_base<noexcept_stream>,virtual base_stream{
	virtual int_t seek(seek_type,int_t)noexcept override=0;
	virtual int_t tell()noexcept override{return this->seek(cur,0);}
	virtual void seek_to(int_t)noexcept override=0;
	virtual void sync()noexcept override=0;
	virtual void flush()noexcept override=0;
	virtual void close()noexcept override=0;
};
no_vtable_struct noexcept_istream:abstract_base<noexcept_istream>,virtual base_istream,virtual noexcept_stream{};
no_vtable_struct noexcept_ostream:abstract_base<noexcept_ostream>,virtual base_ostream,virtual noexcept_stream{};
no_vtable_struct noexcept_iostream:abstract_base<noexcept_iostream>,virtual base_iostream,virtual noexcept_ostream,virtual noexcept_istream{};
static_assert(noexcept(((noexcept_iostream*)(nullptr))->~noexcept_iostream()));
static_assert(noexcept(((noexcept_iostream*)(nullptr))->sync()));

//text streams
template<class char_T>
no_vtable_struct text_stream:abstract_base<text_stream<char_T>>,virtual base_stream{
	typedef char_T char_type;
};
template<class char_T>
no_vtable_struct text_istream:abstract_base<text_istream<char_T>>,virtual base_istream,virtual text_stream<char_T>{
	virtual size_t read(char_T*buf,size_t size)=0;
};
template<class char_T>
no_vtable_struct text_ostream:abstract_base<text_ostream<char_T>>,virtual base_ostream,virtual text_stream<char_T>{
	virtual void write(const char_T*buf,size_t size)=0;
};
template<class char_T>
no_vtable_struct text_iostream:abstract_base<text_iostream<char_T>>,virtual base_iostream,virtual text_istream<char_T>,virtual text_ostream<char_T>{};
//noexcept_
template<class char_T>
no_vtable_struct noexcept_text_istream:abstract_base<noexcept_text_istream<char_T>>,virtual noexcept_istream,virtual text_istream<char_T>{
	virtual size_t read(char_T*buf,size_t size)noexcept override=0;
};
template<class char_T>
no_vtable_struct noexcept_text_ostream:abstract_base<noexcept_text_ostream<char_T>>,virtual noexcept_ostream,virtual text_ostream<char_T>{
	virtual void write(const char_T*buf,size_t size)noexcept override=0;
};
template<class char_T>
no_vtable_struct noexcept_text_iostream:abstract_base<noexcept_text_iostream<char_T>>,
	virtual noexcept_iostream,virtual text_iostream<char_T>,
	virtual noexcept_text_istream<char_T>,virtual noexcept_text_ostream<char_T>{};


//data streams
no_vtable_struct data_istream:abstract_base<data_istream>,virtual base_istream{
	virtual size_t read(byte*buf,size_t size)=0;
	template<class T> requires ::std::is_trivially_copyable_v<T>
	size_t read(T*v,size_t size=1){
		return this->read(cast_to_data(v),size*sizeof(T))/sizeof(T);
	}
};
no_vtable_struct data_ostream:abstract_base<data_ostream>,virtual base_ostream{
	virtual void write(const byte*buf,size_t size)=0;
	template<class T> requires ::std::is_trivially_copyable_v<T>
	void write(const T*v,size_t size=1){
		this->write(cast_to_data(v),size*sizeof(T));
	}
};
no_vtable_struct data_iostream:abstract_base<data_iostream>,virtual base_iostream,virtual data_istream,virtual data_ostream{};
//noexcept_
no_vtable_struct noexcept_data_istream:abstract_base<noexcept_data_istream>,virtual noexcept_istream,virtual data_istream{
	virtual size_t read(byte*buf,size_t size)noexcept override=0;
	template<class T> requires ::std::is_trivially_copyable_v<T>
	size_t read(T*v,size_t size=1)noexcept{
		return this->read(cast_to_data(v),size*sizeof(T))/sizeof(T);
	}
};
no_vtable_struct noexcept_data_ostream:abstract_base<noexcept_data_ostream>,virtual noexcept_ostream,virtual data_ostream{
	virtual void write(const byte*buf,size_t size)noexcept override=0;
	template<class T> requires ::std::is_trivially_copyable_v<T>
	void write(const T*v,size_t size=1)noexcept{
		this->write(cast_to_data(v),size*sizeof(T));
	}
};
no_vtable_struct noexcept_data_iostream:abstract_base<noexcept_data_iostream>,
	virtual noexcept_iostream,virtual data_iostream,
	virtual noexcept_data_istream,virtual noexcept_data_ostream{};

pop_msvc_warning();
//special streams
template<class char_T>
struct null_text_stream:noexcept_text_iostream<char_T>,instance_struct<null_text_stream<char_T>>{
	virtual int_t seek(seek_type,int_t)noexcept override{return 0;}
	virtual int_t tell()noexcept override{return 0;}
	virtual void seek_to(int_t)noexcept override{}
	virtual void sync()noexcept override{}
	virtual void flush()noexcept override{}
	virtual void close()noexcept override{}
	virtual void write(const char_T*,size_t)noexcept override{}
	virtual size_t read(char_T*,size_t)noexcept override{return 0;}
};
struct null_data_stream:noexcept_data_iostream,instance_struct<null_data_stream>{
	virtual int_t seek(seek_type,int_t)noexcept override{return 0;}
	virtual int_t tell()noexcept override{return 0;}
	virtual void seek_to(int_t)noexcept override{}
	virtual void sync()noexcept override{}
	virtual void flush()noexcept override{}
	virtual void close()noexcept override{}
	virtual void write(const byte*,size_t)noexcept override{}
	virtual size_t read(byte*,size_t)noexcept override{return 0;}
};

//file_end

		#line 16 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/operators/_body.hpp"
//_body.hpp
//at namespace elc::defs::stream_n
/*
未完成的elc解释器base_stream文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//text_stream

//operator<< of template<class char_T>struct text_ostream
template<class text_ostream_T,class char_T=typename text_ostream_T::char_type> requires(type_info<text_ostream_T>.base_on<text_ostream<char_T>>)
decltype(auto)operator<<(text_ostream_T&&stream,const char_T ch)noexcept(type_info<text_ostream_T>.base_on<noexcept_text_ostream<char_T>>){
	stream.write(&ch,1);
	return stream;
}
template<class text_ostream_T,class char_T=typename text_ostream_T::char_type> requires(type_info<text_ostream_T>.base_on<text_ostream<char_T>>)
decltype(auto)operator<<(text_ostream_T&&stream,array_like_view_t<const char_T>str)noexcept(type_info<text_ostream_T>.base_on<noexcept_text_ostream<char_T>>){
	stream.write(str.data(),str.size());
	return stream;
}
template<class text_ostream_T,class char_T=typename text_ostream_T::char_type> requires(type_info<text_ostream_T>.base_on<text_ostream<char_T>>)
decltype(auto)operator<<(text_ostream_T&&stream,const char_T*str)noexcept(type_info<text_ostream_T>.base_on<noexcept_text_ostream<char_T>>){
	return stream << array_end_by_zero_t<const char_T>{str};
}
//operator>> of template<class char_T>struct text_istream
template<class text_istream_T,class char_T=typename text_istream_T::char_type> requires(type_info<text_istream_T>.base_on<text_istream<char_T>>)
decltype(auto)operator>>(text_istream_T&stream,char_T&ch)noexcept(type_info<text_istream_T>.base_on<noexcept_text_istream<char_T>>){
	stream.read(&ch,1);
	return stream;
}

//data_stream of any is_trivially_copyable

//operator<< of template<class T>struct data_ostream
template<class data_ostream_T,class T> requires(type_info<data_ostream_T>.base_on<data_ostream> && ::std::is_trivially_copyable_v<T>)
decltype(auto)operator<<(data_ostream_T&&stream,const T&data)noexcept(type_info<data_ostream_T>.base_on<noexcept_data_ostream>){
	stream.write(&data,1);
	return stream;
}
template<class data_ostream_T,class T,size_t N> requires(type_info<data_ostream_T>.base_on<data_ostream> && ::std::is_trivially_copyable_v<T>)
decltype(auto)operator<<(data_ostream_T&&stream,const T(&data)[N])noexcept(type_info<data_ostream_T>.base_on<noexcept_data_ostream>){
	stream.write(data,N);
	return stream;
}
//operator>> of template<class T>struct data_istream
template<class data_istream_T,class T> requires(type_info<data_istream_T>.base_on<data_istream> && ::std::is_trivially_copyable_v<T>)
decltype(auto)operator>>(data_istream_T&&stream,T&data)noexcept(type_info<data_istream_T>.base_on<noexcept_data_istream>){
	stream.read(&data,1);
	return stream;
}
template<class data_istream_T,class T,size_t N> requires(type_info<data_istream_T>.base_on<data_istream> && ::std::is_trivially_copyable_v<T>)
decltype(auto)operator>>(data_istream_T&&stream,T(&data)[N])noexcept(type_info<data_istream_T>.base_on<noexcept_data_istream>){
	stream.read(data,N);
	return stream;
}

//flush
inline constexpr struct flush_t{
	template<class ostream_T>requires(type_info<ostream_T>.base_on<base_ostream>)
	constexpr decltype(auto)operator()(ostream_T&stream)const noexcept(type_info<ostream_T>.base_on<noexcept_ostream>){
		stream.flush();
		return stream;
	}
}flush{};

//endline
inline constexpr struct endline_t{
	template<class text_ostream_T,class char_T=typename text_ostream_T::char_type> requires(type_info<text_ostream_T>.base_on<text_ostream<char_T>>)
	constexpr decltype(auto)operator()(text_ostream_T& stream)const noexcept(type_info<text_ostream_T>.base_on<noexcept_text_ostream<char_T>>){
		stream << char_T{'\n'};
		stream.flush();
		return stream;
	}
}endline{};

//operator<< of functions
template<class callable_T,class stream_T> requires(type_info<stream_T>.base_on<base_ostream> && invoke<callable_T>.able<stream_T>)
decltype(auto)operator<<(stream_T&&stream,callable_T&&callable)noexcept(invoke<callable_T>.nothrow<stream_T>){
	return callable(stream);
}

//file_end

		#line 17 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/std_wrap/_body.hpp"
//_body.hpp
//at namespace elc::defs::stream_n
/*
未完成的elc解释器base_stream文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
push_and_disable_msvc_warning(26447);//noexcept警告diss
//wrap std::istream to elc::noexcept_text_istream
template<class char_T,class traits=::std::char_traits<char_T>>
struct std_istream_wrap:noexcept_text_istream<char_T>,instance_struct<std_istream_wrap<char_T,traits>>{
	typedef ::std::basic_istream<char_T,traits> stream_t;
	stream_t& _stream;
	std_istream_wrap(stream_t&stream)noexcept:_stream(stream){}
private:
	void clear_badbit()noexcept{
		_stream.clear(_stream.rdstate()&~::std::ios_base::badbit);
	}
public:
	virtual ~std_istream_wrap()noexcept override=default;
	virtual int_t seek(seek_type dir,int_t off)noexcept override{
		typename stream_t::iostate state = stream_t::goodbit;
		const typename stream_t::sentry isok(_stream);

		if(!isok)
			state |= stream_t::badbit;
		else{
			try{
				switch(dir){
					case beg:
						_stream.seekg(off);
						break;
					case cur:
						_stream.seekg(off,_stream.cur);
						break;
					case end:
						_stream.seekg(off,_stream.end);
						break;
				}
				return tell();
			}catch(...){
				state |= stream_t::badbit;
			}
		}
		_stream.setstate(state);
		return -1;
	}
	virtual int_t tell()noexcept override{
		typename stream_t::iostate state = stream_t::goodbit;
		const typename stream_t::sentry isok(_stream);

		if(!isok)
			state |= stream_t::badbit;
		else{
			try{
				const typename stream_t::pos_type base_p;
				return int_t(_stream.tellg()-base_p);
			}catch(...){
				state |= stream_t::badbit;
			}
		}
		_stream.setstate(state);
		return -1;
	}
	virtual void seek_to(int_t pos)noexcept override{
		const typename stream_t::pos_type base_p;
		_stream.seekg(base_p+pos);
	}
	virtual void sync()noexcept override{
		_stream.sync();
	}
	virtual void flush()noexcept override{
		_stream.sync();
	}
	virtual void close()noexcept override{
		_stream.sync();
	}
	virtual size_t read(char_T*buf,size_t size)noexcept override{
		typename stream_t::iostate state = stream_t::goodbit;
		const typename stream_t::sentry isok(_stream);

		if(!isok)
			state |= stream_t::badbit;
		else{
			try{
				_stream.read(buf,size);
				return size_t(_stream.gcount());
			}catch(...){
				state |= stream_t::badbit;
			}
		}
		_stream.setstate(state);
		return 0;
	}
};
//wrap std::ostream to elc::noexcept_text_ostream
template<class char_T,class traits=::std::char_traits<char_T>>
struct std_ostream_wrap:noexcept_text_ostream<char_T>,instance_struct<std_ostream_wrap<char_T,traits>>{
	typedef ::std::basic_ostream<char_T,traits> stream_t;
	stream_t& _stream;
	std_ostream_wrap(stream_t&stream)noexcept:_stream(stream){}
private:
	void clear_badbit()noexcept{
		_stream.clear(_stream.rdstate()&~::std::ios_base::badbit);
	}
public:
	virtual ~std_ostream_wrap()noexcept override=default;
	virtual int_t seek(seek_type dir,int_t off)noexcept override{
		typename stream_t::iostate state = stream_t::goodbit;
		const typename stream_t::sentry isok(_stream);

		if(!isok)
			state |= stream_t::badbit;
		else{
			try{
				switch(dir){
					case beg:
						_stream.seekp(off);
						break;
					case cur:
						_stream.seekp(off,_stream.cur);
						break;
					case end:
						_stream.seekp(off,_stream.end);
						break;
				}
				return tell();
			}catch(...){
				state |= stream_t::badbit;
			}
		}
		_stream.setstate(state);
		return -1;
	}
	virtual int_t tell()noexcept override{
		const typename stream_t::pos_type base_p;
		return int_t(_stream.tellp()-base_p);
	}
	virtual void seek_to(int_t pos)noexcept override{
		const typename stream_t::pos_type base_p;
		_stream.seekp(base_p+pos);
	}
	virtual void sync()noexcept override{
		_stream.flush();
	}
	virtual void flush()noexcept override{
		_stream.flush();
	}
	virtual void close()noexcept override{
		_stream.flush();
	}
	virtual void write(const char_T*buf,size_t size)noexcept override{
		typename stream_t::iostate state = stream_t::goodbit;
		const typename stream_t::sentry isok(_stream);

		if(!isok)
			state |= stream_t::badbit;
		else{
			try{
				_stream.write(buf,size);
			}catch(...){
				state |= stream_t::badbit;
			}
		}
		_stream.setstate(state);
	}
};
pop_msvc_warning();

//inject operator<< of elc::array_like_view_t to std::ostream
BREAK_NAMESPACE//elc::defs
INTER_NAMESPACE(base::array_like_n)//elc::defs::base::array_like_n

template<class char_T,class traits>
auto&operator<<(
	::std::basic_ostream<remove_cvref<char_T>,traits>&stream,
	const array_like_view_t<char_T>&view
)noexcept{
	stream_n::std_ostream_wrap wrap(stream);
	wrap << view;
	return stream;
}

BREAK_NAMESPACE//elc::defs
INTER_NAMESPACE(stream_n)//elc::defs::stream_n

//file_end

		#line 19 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
	}
	using namespace stream_n;

	#if defined(ELC_TEST_ON)
	namespace base_stream_part_test{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_test.hpp"
//_test.hpp
/*
未完成的elc解释器base_stream文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline void test(){
	ELC_TEST_EVENTNAME("base_stream部分测试");
}
inline void test_log_out(){
}
inline void test_end(){
}

//file_end

		#line 25 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
	}
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 29 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
}
namespace elc{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_export.hpp"
//_export.hpp
//at namespace elc
/*
未完成的elc解释器base_stream文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using defs::
export base_stream;
export base_ostream;
export base_istream;
export base_iostream;
export noexcept_stream;
export noexcept_ostream;
export noexcept_istream;
export noexcept_iostream;
export text_istream;
export text_ostream;
export text_iostream;
export noexcept_text_istream;
export noexcept_text_ostream;
export noexcept_text_iostream;
export data_istream;
export data_ostream;
export data_iostream;
export noexcept_data_istream;
export noexcept_data_ostream;
export noexcept_data_iostream;
export null_text_stream;
export null_data_stream;
export endline;
export flush;
#undef export

//file_end

	#line 32 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
}
#if defined(ELC_STRING)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"
//type_name_test_output.hpp
//at namespace ::
//multi when ELC_STRING & ELC_BASE_STREAM
/*
未完成的elc解释器base_stream文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if !defined(ELC_multi_type_name_test_output)//pls skip define check as this part is muti
#define ELC_multi_type_name_test_output
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"

	namespace stream_n{
		//typename output only for text_ostream<char_t>
		template<class stream_T> requires(type_info<stream_T>.base_on<text_ostream<char_t>>)
		decltype(auto)operator<<(stream_T&&stream,const type_name_t&name)noexcept(type_info<stream_T>.base_on<noexcept_text_ostream<char_t>>){
			return stream << to_char_t_str(name);
		}
		//output type_info
		template<class stream_T> requires(type_info<stream_T>.base_on<text_ostream<char_t>>)
		decltype(auto)operator<<(stream_T&&stream,const base_type_info_t&info)noexcept(type_info<stream_T>.base_on<noexcept_text_ostream<char_t>>){
			return stream << info.get_name();
		}
		//output ::std::type_info
		template<class stream_T> requires(type_info<stream_T>.base_on<text_ostream<char_t>>)
		decltype(auto)operator<<(stream_T&&stream,const ::std::type_info&info)noexcept(type_info<stream_T>.base_on<noexcept_text_ostream<char_t>>){
			return stream << type_name_t{info.name()};
		}
	}

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"
}
#endif

//file_end

	#line 35 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
#endif
#if defined(ELC_NUMERICAL_REPRESENTATION)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/arithmetic_text_io.hpp"
//arithmetic_text_io.hpp
//at namespace ::
//multi when ELC_NUMERICAL_REPRESENTATION & ELC_BASE_STREAM
/*
未完成的elc解释器base_stream文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if !defined(ELC_multi_arithmetic_text_io)//pls skip define check as this part is muti
#define ELC_multi_arithmetic_text_io
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/arithmetic_text_io.hpp"

	namespace stream_n{
		//arithmetic output only for text_ostream<char_t>
		template<typename T,class stream_T> requires(::std::is_arithmetic_v<remove_cvref<T>> &&
													 type_info<stream_T>.base_on<text_ostream<char_t>> &&
													 type_info<remove_cvref<T>> != type_info<char_t> &&
													 type_info<remove_cvref<T>> != type_info<bool>)
		decltype(auto)operator<<(stream_T&&stream,T&&data)noexcept(type_info<stream_T>.base_on<noexcept_text_ostream<char_t>>){
			return stream << to_string(forward<T>(data));
		}

		template<typename T,class stream_T> requires(!::std::is_arithmetic_v<remove_cvref<T>> &&
													 to_arithmetic.able<remove_cvref<T>> &&
													 type_info<stream_T>.base_on<text_ostream<char_t>>) decltype(auto)
		operator<<(stream_T&& stream, T&& data)noexcept(type_info<stream_T>.base_on<noexcept_text_ostream<char_t>> && to_arithmetic.nothrow<T>) {
			return stream << to_arithmetic(forward<T>(data));
		}

		template<typename T,class stream_T> requires(type_info<stream_T>.base_on<text_ostream<char_t>> &&
													 type_info<remove_cvref<T>> == type_info<bool>)
		decltype(auto)operator<<(stream_T&&stream,T&&data)noexcept(type_info<stream_T>.base_on<noexcept_text_ostream<char_t>>){
			if(data==true)
				stream << es"true"_constexpr_str;
			elseif(data==false)
				stream << es"false"_constexpr_str;
			else
				stream << es"others("_constexpr_str << union_cast<unsigned_specific_size_t<sizeof(bool)>>(data) << ec(')');
			return stream;
		}

		//T* output only for text_ostream<char_t>
		template<typename T,class stream_T> requires(type_info<stream_T>.base_on<text_ostream<char_t>>)
		decltype(auto)operator<<(stream_T&&stream,T*data)noexcept(type_info<stream_T>.base_on<noexcept_text_ostream<char_t>>){
			//output name of type at first
			stream << type_info<T>.get_name();
			if constexpr(::std::is_polymorphic_v<T> && !::std::is_final_v<T>){//RTTI
				const auto typeinfo = type_info_of(*data);
				if(typeinfo != type_info<T>)
					stream << ec("(") << typeinfo.get_name() << ec(")");
			}
			//output address
			stream << ec("@") << to_string((size_t)data,numerical_representation_n::hexadecimal);
			return stream;
		}
	}

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 60 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/arithmetic_text_io.hpp"
}
#endif

//file_end

	#line 38 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/base_stream/_body.hpp"
#endif

//file_end

	#line 16 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
#endif

//file_end

	#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/core"
	#define ELC_CORE
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
//_body.hpp
//at namespace ::
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if defined(ELC_TEST)
	#error "this part cannot be tested."
#endif
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"

	namespace core{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/_body.hpp"
//_body.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/decl.hpp"
//decl.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
struct node_like;
typedef comn_ptr_t<node_like>ptr;
typedef weak_ptr_t<node_like>weak_ptr;
typedef comn_ptr_t<const node_like>const_ptr;
typedef weak_ptr_t<const node_like>const_weak_ptr;
struct value;

BREAK_NAMESPACE
namespace string_n{
	template<typename char_T>
	struct string_t;
	typedef string_t<char_t> string;
	template<constexpr_str_n::constexpr_str_t_literal_helper str_helper>
	inline constexpr string operator""_elc_string()noexcept;
}
using string_n::string_t;
using string_n::string;
INTER_NAMESPACE(core)

template<typename T>
[[nodiscard]]inline ptr make_long_term_binary_node_from(T a)noexcept;

template<typename T>
constexpr bool as_ptr_nothrow_helper()noexcept{
	if constexpr(was_not_an_ill_form(ptr(&declvalue(T))))
		return noexcept(ptr(&declvalue(T)));
	elseif constexpr(was_not_an_ill_form(const_ptr(&declvalue(T))))
		return noexcept(const_ptr(&declvalue(T)));
	elseif constexpr(was_not_an_ill_form(static_cast<node_like&>(declvalue(T))))
		return noexcept(&static_cast<node_like&>(declvalue(T)));
	elseif constexpr(was_not_an_ill_form(static_cast<const node_like&>(declvalue(T))))
		return noexcept(&static_cast<const node_like&>(declvalue(T)));
	elseif constexpr(was_not_an_ill_form(static_cast<value&>(declvalue(T))))
		return noexcept(ptr(static_cast<value&>(declvalue(T))));
	elseif constexpr(was_not_an_ill_form(static_cast<const value&>(declvalue(T))))
		return noexcept(const_ptr(static_cast<value&>(declvalue(T))));
	elseif constexpr(was_not_an_ill_form(ptr(declvalue(T))))
		return noexcept(ptr(declvalue(T)));
	elseif constexpr(was_not_an_ill_form(const_ptr(declvalue(T))))
		return noexcept(const_ptr(declvalue(T)));
	elseif constexpr(type_info<remove_cvref<T>> == type_info<char_t>)
		return noexcept(make_long_term_binary_node_from<char_t>(declvalue(T)));
	elseif constexpr(::std::is_integral_v<remove_cvref<T>>){
		if constexpr(::std::is_signed_v<remove_cvref<T>>)
			return noexcept(make_long_term_binary_node_from<int_t>(declvalue(T)));
		else
			return noexcept(make_long_term_binary_node_from<uint_t>(declvalue(T)));
	}
	elseif constexpr(::std::is_floating_point_v<remove_cvref<T>>)
		return noexcept(make_long_term_binary_node_from<float_t>(declvalue(T)));
	elseif constexpr(construct<string>.able<T>){
		return noexcept(make_long_term_binary_node_from<string>(declvalue(T)));
	}
}
template<typename T>
decltype(auto) as_ptr(T&&a)noexcept(as_ptr_nothrow_helper<T>()){
	ELC_TEST_EVENTNAME("as_ptr转换");
	if constexpr(was_not_an_ill_form(ptr(&a)))
		return ptr(&a);
	elseif constexpr(was_not_an_ill_form(const_ptr(&a)))
		return const_ptr(&a);
	elseif constexpr(was_not_an_ill_form(static_cast<node_like&>(a)))
		return &static_cast<node_like&>(a);
	elseif constexpr(was_not_an_ill_form(static_cast<const node_like&>(a)))
		return &static_cast<const node_like&>(a);
	elseif constexpr(was_not_an_ill_form(static_cast<value&>(a)))
		return ptr(static_cast<value&>(a));
	elseif constexpr(was_not_an_ill_form(static_cast<const value&>(a)))
		return const_ptr(static_cast<value&>(a));
	elseif constexpr(was_not_an_ill_form(ptr(a)))
		return ptr(a);
	elseif constexpr(was_not_an_ill_form(const_ptr(a)))
		return const_ptr(a);
	elseif constexpr(type_info<remove_cvref<T>> == type_info<char_t>)
		return make_long_term_binary_node_from<char_t>(a);
	elseif constexpr(::std::is_integral_v<remove_cvref<T>>){
		if constexpr(::std::is_signed_v<remove_cvref<T>>)
			return make_long_term_binary_node_from<int_t>(a);
		else
			return make_long_term_binary_node_from<uint_t>(a);
	}
	elseif constexpr(::std::is_floating_point_v<remove_cvref<T>>)
		return make_long_term_binary_node_from<float_t>(a);
	elseif constexpr(construct<string>.able<T>){
		return make_long_term_binary_node_from<string>(a);
	}
}

template<typename T>
constexpr bool as_value_nothrow_helper()noexcept{
	if constexpr(was_not_an_ill_form(static_cast<value&>(declvalue(T))))
		return noexcept(static_cast<value&>(declvalue(T)));
	elseif constexpr(was_not_an_ill_form(static_cast<const value&>(declvalue(T))))
		return noexcept(static_cast<const value&>(declvalue(T)));
	elseif constexpr(was_not_an_ill_form(as_ptr(declvalue(T)))){
		if constexpr(type_info<decltype(as_ptr(declvalue(T)))> == type_info<ptr>)
			return noexcept(value(as_ptr(declvalue(T))));
		elseif constexpr(type_info<decltype(as_ptr(declvalue(T)))> == type_info<const_ptr>)
			return noexcept((const value)remove_const((const node_like*)as_ptr(declvalue(T))));
	}
}
template<typename T>
decltype(auto) as_value(T&& a)noexcept(as_value_nothrow_helper<T>()){
	ELC_TEST_EVENTNAME("as_value转换");
	if constexpr(was_not_an_ill_form(static_cast<value&>(a)))
		return static_cast<value&>(a);
	elseif constexpr(was_not_an_ill_form(static_cast<const value&>(a)))
		return static_cast<const value&>(a);
	elseif constexpr(was_not_an_ill_form(as_ptr(declvalue(T)))){
		if constexpr(type_info<decltype(as_ptr(declvalue(T)))> == type_info<ptr>)
			return value(as_ptr(forward<T>(a)));
		elseif constexpr(type_info<decltype(as_ptr(declvalue(T)))> == type_info<const_ptr>)
			return (const value)remove_const((const node_like*)as_ptr(forward<T>(a)));
	}
}

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/node_like.hpp"
//defs.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
[[nodiscard]]inline ptr make_list()noexcept;
template<typename T,typename...Args>
[[nodiscard]]inline ptr make_list(T&&first,Args&&...rest);

no_vtable_struct node_like:type_info_t<node_like>::template_name
	with_common_attribute<abstract_base,weak_ref_able,replace_able,ref_able>{
public:
	typedef node_like this_t;

	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept=0;

	[[nodiscard]]virtual value be_eval();
	[[nodiscard]]virtual value be_call(ptr);
protected:
	[[nodiscard]]virtual logical_bool equal_with(const_ptr)const noexcept=0;
	[[nodiscard]]virtual logical_bool eq_with(const_ptr a)const noexcept{return a.get()==this;}//不是a==this：ptr的opertaor==将调用在下方定义的pointer_equal，这会通过eq间接调用eq_with
	[[nodiscard]]virtual constexpr size_t equal_level()const noexcept{return 36;}
	[[nodiscard]]virtual constexpr size_t eq_level()const noexcept{return 36;}
public:
	node_like()noexcept=default;
	node_like(never_ref_num_zero_t)noexcept{ attribute_ptr_cast<ref_able>(this)->init_never_ref_num_zero(); }
	virtual ~node_like()=default;

	[[nodiscard]]virtual value arec(const value)=0;

	[[nodiscard]]value operator[](const value index);
	[[nodiscard]]value operator[](auto&&index){
		return operator[](as_value(index));
	}

	virtual void clear()noexcept=0;

	[[nodiscard]]virtual explicit operator hash_t()const noexcept{return hash((void*)this);}
	void destroy()noexcept{
		this->be_replace_as(null_ptr);
	}
	virtual void be_replace_as(ptr a)noexcept{
		this->clear();
		replace_able<this_t>::be_replace_as(a.get());
	}

	[[nodiscard]]virtual explicit operator logical_bool()const noexcept{return true;}
	[[nodiscard]]explicit operator bool()const noexcept{return(bool)this->operator logical_bool();}

	template<typename...Args>
	inline value operator()(Args&&...rest){return this->be_call(make_list(forward<Args>(rest)...));}

	[[nodiscard]]logical_bool eq(const_ptr a)const noexcept{
		const auto this_eqlv = this->eq_level();
		const auto arg_eqlv	 = a->eq_level();
		if(this_eqlv _small_than_ arg_eqlv)
			return a->eq_with(this);
		elseif(this_eqlv _big_than_ arg_eqlv)
			return this->eq_with(a);
		else
			return this->eq_with(a)&&a->eq_with(this);
	}
	[[nodiscard]]logical_bool equal(const_ptr a)const noexcept{
		const auto this_equlv = this->equal_level();
		const auto arg_equlv  = a->equal_level();
		if(this_equlv _small_than_ arg_equlv)
			return a->equal_with(this);
		elseif(this_equlv _big_than_ arg_equlv)
			return this->equal_with(a);
		else
			return this->equal_with(a)&&a->equal_with(this);
	}

	[[nodiscard]]ptr operator&()noexcept{return this;}
	[[nodiscard]]const_ptr operator&()const noexcept{return this;}
	[[nodiscard]]logical_bool operator==(const this_t&a)const noexcept{
		return a.equal(this);
	}
protected:
	friend void the_waiting_for_destroy(node_like* a)noexcept;
	virtual void waiting_for_destroy()noexcept{clear();}
};

//base中的类型功能适应器
[[nodiscard]]inline constexpr node_like*the_get_null_ptr(const node_like*)noexcept;//{return&void;}
[[nodiscard]]inline logical_bool the_pointer_to_bool(const node_like*a)noexcept{
	return a->operator logical_bool();
}
[[nodiscard]]inline logical_bool the_pointer_equal(const node_like*a,const node_like*b)noexcept{
	return a->eq(b);
}
[[nodiscard]]inline hash_t the_pointer_hash(const node_like*a)noexcept{
	return a->operator hash_t();
}
//ptr中的类型功能适应器
inline void the_waiting_for_destroy(node_like*a)noexcept{
	a->waiting_for_destroy();
}
inline void the_destroy_and_free(node_like*a)noexcept{
	unget(a);
}

//gc中的类型功能适应器
inline void the_destroy(node_like*a)noexcept{
	a->destroy();
}

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/ptr.hpp"
//def.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
typedef comn_ptr_t<node_like>ptr;
typedef weak_ptr_t<node_like>weak_ptr;
typedef comn_ptr_t<const node_like>const_ptr;
typedef weak_ptr_t<const node_like>const_weak_ptr;

//file_end

#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/value.hpp"
//value.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
struct value:non_copy_assign_able{
	typedef value this_t;
	no_vtable_struct base_data_t:type_info_t<base_data_t>::template_name
		with_common_attribute<abstract_base,ref_able,never_in_array,replace_able>,
		build_by_get_only{
		/*//COMMIT:
		是否应当支持value data的引用计数？
		否的原因：
			这将导致应当对value的data加入gc机制（否则容易出现闭环value垃圾！）
			而这将严重增加elc的运行时时空负担
			有人可能得到递归引用的value
		是的原因：
			防御式编程
			更佳多样的value实现
			引用计数以降低value的复制开销
		对否定想法的驳回：
			严重增加elc的运行时时空负担？：value的复制开销可能更大
			有人可能得到递归引用的value？这将导致应当对value的data加入gc机制？：
				没见哪个语言不允许写while(true)
				自定义value的应该都是聪明人，如果真的会出现循环引用那他们自己解决就好
		总结：
			加引用计数，但不加gc
			elc的设计理念包括“不应禁止用户做什么”，所以应当提供高自由度的value定制可能
			但出于性能考虑，不加gc
			如果真的有需要gc解决的value data那么让那聪明的设计者自己给自己的data类加gc解决这种问题就好
		*/
		base_data_t()noexcept=default;
		base_data_t(never_ref_num_zero_t)noexcept{ attribute_ptr_cast<ref_able>(this)->init_never_ref_num_zero(); }
		virtual ~base_data_t()noexcept=default;

		virtual void be_set(ptr)=0;
		[[nodiscard]]virtual ptr get_value()=0;
		[[nodiscard]]virtual base_data_t*copy()const noexcept=0;
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept=0;//为什么要加这个？我不知道，万一将来有人用上了呢？
	};

	distinctive static inline struct null_data_t final:instance_struct<null_data_t>
	,value::base_data_t{
		null_data_t()noexcept:value::base_data_t(never_ref_num_zero){}
		virtual ~null_data_t()noexcept override final=default;

		virtual void be_set(ptr a)noexcept override final{}
		[[nodiscard]]virtual ptr get_value()noexcept override final{return null_ptr;}
		[[nodiscard]]virtual base_data_t*copy()const noexcept override final{return remove_const(this);}
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<null_data_t>;}
	}null_data{};

	struct constexpr_data_t final:instance_struct<constexpr_data_t>
	,base_data_t{
		ptr _m;
		constexpr_data_t(ptr a)noexcept:_m(a){}
		constexpr_data_t(const constexpr_data_t&)noexcept=default;
		virtual ~constexpr_data_t()noexcept override final=default;

		virtual void be_set(ptr)noexcept override final{}
		[[nodiscard]]virtual ptr get_value()noexcept override final{return _m;}
		[[nodiscard]]virtual base_data_t*copy()const noexcept override final{return get<constexpr_data_t>(_m);}
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<constexpr_data_t>;}
	};

	struct variable_data_t final:instance_struct<variable_data_t>
	,base_data_t{
		ptr _m;
		variable_data_t(ptr a)noexcept:_m(a){}
		variable_data_t(const variable_data_t&)noexcept=default;
		virtual ~variable_data_t()noexcept override final=default;

		virtual void be_set(ptr a)noexcept override final{_m=a;}
		[[nodiscard]]virtual ptr get_value()noexcept override final{return _m;}
		[[nodiscard]]virtual base_data_t*copy()const noexcept override final{return get<variable_data_t>(_m);}
		[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<variable_data_t>;}
	};
private:
	mutable comn_ptr_t<base_data_t> _m;
public:
	explicit value()noexcept:_m(get<variable_data_t>(null_ptr)){}
	constexpr explicit value(special_init_t)noexcept:_m(null_ptr){}
	explicit value(ptr a)noexcept:_m(get<constexpr_data_t>(a)){}
	explicit value(node_like* a)noexcept:value(ptr(a)){}
	value(base_data_t*a)noexcept:_m(a){}

	value(const this_t&a)noexcept=default;
	value(this_t&&a)noexcept=default;
	~value()noexcept=default;

	this_t&operator=(ptr a){
		_m->be_set(a);
		return *this;
	}
	this_t&operator=(auto&&a){
		return operator=(as_ptr(a));
	}

	[[nodiscard]]operator ptr(){
		return _m->get_value();
	}
	[[nodiscard]]operator const_ptr()const{
		return _m->get_value();
	}
	[[nodiscard]]ptr operator&(){
		return operator ptr();
	}
	[[nodiscard]]const_ptr operator&()const{
		return operator const_ptr();
	}
	[[nodiscard]]explicit operator bool()const{return bool(_m->get_value());}

	void ref_to(this_t a)noexcept{
		_m.do_replace(a._m);
	}
	void un_ref()noexcept{
		_m=_m->copy();
	}
	void re_ref_to(this_t a)noexcept{
		_m=a._m;
	}
	this_t& operator>>(this_t a)noexcept{
		a.ref_to(*this);
		return*this;
	}

	template<typename T>
	[[nodiscard]]auto operator[](T&&index){
		return (*operator&())[forward<T>(index)];
	}
	template<typename...Args> requires(invoke<node_like>.able<Args...>)
	inline auto operator()(Args&&... rest)noexcept(invoke<node_like>.nothrow<Args...>){return(*operator&())(forward<Args>(rest)...);}
	[[nodiscard]]auto operator==(auto&&a)const noexcept{
		try{
			return const_ptr(*this) == const_ptr(as_value(a));
		}
		catch(...){
			return unknown;
		}
	}
	[[nodiscard]]auto operator!=(auto&&a)const{
		return !operator==(a);
	}
	[[nodiscard]]operator ptr::for_delete_t*(){
		return _m->get_value();
	}
};

static value::base_data_t*the_get_null_ptr(const value::base_data_t*)noexcept{
	return&value::null_data;
}

BREAK_NAMESPACE

INTER_NAMESPACE(base)
template<>
distinctive inline core::value const_default_value_of<core::value>{special_init};
BREAK_NAMESPACE

INTER_NAMESPACE(core)

//file_end

#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/_body.hpp"

#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/node_like_using_value_func_defs.hpp"
//defs.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
push_and_disable_msvc_warning(26440);//nothrow警告diss
[[nodiscard]]inline value node_like::be_eval(){
	return value(this);
}
[[nodiscard]]inline value node_like::be_call(ptr){
	return value(this);
}
pop_msvc_warning();

[[nodiscard]]inline value node_like::operator[](const value index){
	return arec(index);
}

//file_end

#line 15 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/base_def/_body.hpp"

//file_end

		#line 16 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/runtime_exception/_body.hpp"
//_body.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/runtime_exception/base_runtime_exception.hpp"
//base_runtime_exception.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
struct base_runtime_exception:runtime_exception{
	using runtime_exception::runtime_exception;
};

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/runtime_exception/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/runtime_exception/core_runtime_internal_helper.hpp"
//_body.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace core_runtime_internal_helper_n{
	struct base_t:base_runtime_exception{
		using base_runtime_exception::base_runtime_exception;
		constexpr base_t()noexcept:
			base_runtime_exception(locale::str::exception::core_runtime_internal_helper_leak){}
	};
	//
	struct goto_t:base_t{
		ptr to;
	};
	struct return_t:base_t{};
}
//#include ".hpp"

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/runtime_exception/_body.hpp"

//file_end

		#line 17 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/_body.hpp"
//_body.hpp
//at namespace elc::defs::base
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/base_constexpr.hpp"
//base_constexpr.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
struct base_constexpr_t:node_like,instance_struct<base_constexpr_t>{
	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<base_constexpr_t>;}
protected:
	[[nodiscard]]virtual constexpr size_t equal_level()const noexcept override{return magic_number::god;}
	[[nodiscard]]virtual constexpr size_t eq_level()const noexcept override{return magic_number::god;}
public:
	base_constexpr_t()noexcept:node_like(never_ref_num_zero){}
	constexpr virtual ~base_constexpr_t()noexcept override=default;

	[[nodiscard]]virtual value arec(const value)noexcept override{return value(this);}

	virtual void clear()noexcept override final{nothing}

	virtual void be_replace_as(ptr)noexcept override{nothing}
};

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/void.hpp"
//void.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*
使用elc::the_void来访问此值
或者通过包含<elc/void_name>来使用elc::void访问此值，并使用::void来访问c艹的原生void
*/
distinctive inline struct void_t final:base_constexpr_t{
	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<void_t>;}
protected:
	[[nodiscard]]virtual constexpr size_t equal_level()const noexcept override{return max(type_info<size_t>);}
	[[nodiscard]]virtual constexpr size_t eq_level()const noexcept override{return max(type_info<size_t>);}
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{
		if(this==a)
			return either;//当void是void时，void不是void
		else
			return neither;//当a不是void时，void是a
	}
	//我不知道为什么这么写，反正很有趣
public:
	[[nodiscard]]virtual constexpr explicit operator hash_t()const noexcept override{return hash(nothing);}
	[[nodiscard]]virtual constexpr explicit operator logical_bool()const noexcept override{return neither;}//void 应当不真不假
}the_void{};

[[nodiscard]]constexpr node_like*the_get_null_ptr(const node_like*)noexcept{return addressof((node_like&)the_void);}

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/nil.hpp"
//nil.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
distinctive inline struct nil_t final:base_constexpr_t{
	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<nil_t>;}
protected:
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{return !logical_bool(a);}
public:
	[[nodiscard]]virtual constexpr explicit operator hash_t()const noexcept override{return hash(false);}
	[[nodiscard]]virtual constexpr explicit operator logical_bool()const noexcept override{return false;}
}nil{};

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/t.hpp"
//t.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器base文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
distinctive inline struct t_t final:base_constexpr_t{
	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<t_t>;}
protected:
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{return logical_bool(a);}
public:
	[[nodiscard]]virtual constexpr explicit operator hash_t()const noexcept override{return hash(true);}
	[[nodiscard]]virtual constexpr explicit operator logical_bool()const noexcept override{return true;}

	//nothing is true,everything is permitted.
	[[noreturn]]virtual void be_replace_as(ptr)noexcept override{::std::exit(0);}
}t{};

//file_end

#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/special_values/_body.hpp"

//file_end

		#line 18 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"
//_body.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/common_node.hpp"
//common_node.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
struct common_node:node_like,instance_struct<common_node>{
	typedef common_node this_t;

	map_t<value,const_weak_ptr> _m;

	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<this_t>;}
protected:
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{
		if(a->get_type_info() != this->get_type_info())
			return false;
		const this_t*p=down_cast<const this_t*>(a.get());
		return _m==p->_m;
	}
public:
	[[nodiscard]]virtual value arec(const value index)override{return _m[&index];}

	virtual void clear()noexcept override{_m.clear();}
};

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/cons.hpp"
//common_node.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline value car_of(ptr p){
	return (*p)[t];
}
inline value cdr_of(ptr p){
	return (*p)[nil];
}
inline value car_of(auto&&node){
	return car_of(as_ptr(node));
}
inline value cdr_of(auto&&node){
	return cdr_of(as_ptr(node));
}

struct cons:node_like,instance_struct<cons>{
	typedef cons this_t;

	value _car;
	value _cdr;

	cons(ptr car,ptr cdr){
		_car = car;
		_cdr = cdr;
	}

	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<cons>;}
protected:
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{
		if(a->get_type_info() != this->get_type_info())
			return false;
		const this_t*p=down_cast<const this_t*>(a.get());
		return _car==p->_car&&_cdr==p->_cdr;
	}
public:
	[[nodiscard]]virtual value arec(const value index)override{
		const_ptr v=index;
		if(v==&nil)
			return _cdr;
		elseif(v==&t)
			return _car;
		else{
			ptr to=get<common_node>();
			_car >> car_of(to);
			_cdr >> cdr_of(to);
			be_replace_as(to);
			return (*to)[v];
		}
	}

	virtual void clear()noexcept override{as_value(&the_void)>>_car>>_cdr;}
};

[[nodiscard]]inline ptr make_list()noexcept{return &nil;}
template<typename T,typename...Args>
[[nodiscard]]inline ptr make_list(T&&first,Args&&...rest){
	ELC_TEST_EVENTNAME("make_list调用");
	return get<cons>(as_ptr(first),make_list(forward<Args>(rest)...));
}

//file_end

#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/expr.hpp"
//expr.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
struct expr:cons,instance_struct<expr>{
	typedef expr this_t;
	override_instance_struct;
public:
	using cons::_car;
	using cons::_cdr;
	using cons::cons;

	[[nodiscard]]virtual value be_eval()override{
		return as_ptr(_car)->be_call(_cdr);
	}
	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<expr>;}
};

//file_end

#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/base_binary_function_node.hpp"
//base_binary_function_node.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
struct base_binary_function_node:node_like,instance_struct<base_binary_function_node>{
	typedef base_binary_function_node this_t;

	function_t<value(ptr)> _func;

	base_binary_function_node(function_t<value(ptr)> func)noexcept:_func(func){}
	base_binary_function_node(function_t<void(ptr)> func)noexcept{
		_func = lambda_with_catch(func)(ptr p)mutable{
			func(p);
			return as_value(the_void);
		};
	}
	base_binary_function_node(function_t<void()> func)noexcept{
		_func = lambda_with_catch(func)(ptr)mutable{
			func();
			return as_value(the_void);
		};
	}

	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<this_t>;}
	[[nodiscard]]virtual value be_call(ptr arg_list)override{return _func(arg_list);}
protected:
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{
		if(a->get_type_info() != this->get_type_info())
			return false;
		const this_t*p=down_cast<const this_t*>(a.get());
		try{
			return _func==p->_func;
		}
		catch(...){
			return unknown;
		}
	}
public:
	[[nodiscard]]virtual value arec(const value index)override{return the_void[index];}

	virtual void clear()noexcept override{_func=nullptr;}
};

//file_end

#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/binary_node_t.hpp"
//binary_node_t.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
no_vtable_struct binary_node_base_t:node_like{
	typedef binary_node_base_t this_t;

	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<this_t>;}
	[[nodiscard]]virtual base_type_info_t get_additional_type_info()const noexcept=0;
protected:
	[[noreturn]] virtual void throw_self_ptr()const=0;
	[[noreturn]] virtual void throw_self_ptr()=0;
	template<typename T>
	friend[[nodiscard]]inline maybe_fail_reference<T> maybe_fail_use_by_ref_as(ptr p)noexcept;
	template<typename T>
	friend[[nodiscard]]inline maybe_fail_reference<T> maybe_fail_use_by_ref_as(ptr p)noexcept;
	template<typename T>
	friend[[nodiscard]]inline const T& const_use_by_ref_as(const_ptr p)noexcept;
};
template<typename T>
struct binary_node_t:binary_node_base_t,instance_struct<binary_node_t<T>>{
	typedef binary_node_t<T> this_t;
	typedef binary_node_base_t base_t;

	T _m;

	binary_node_t(const T&a)noexcept:_m(a){}
	binary_node_t(T&&a)noexcept:_m(a){}

	[[nodiscard]]virtual base_type_info_t get_additional_type_info()const noexcept override{return type_info<this_t>;}
private:
	static constexpr bool hash_nothrow_helper=hash.able<T>?
											  hash.nothrow<T>:1;
public:
	[[nodiscard]]virtual explicit operator hash_t()const noexcept(hash_nothrow_helper)override{
		if constexpr(hash.able<T>)
			return hash(_m);
		else
			#if defined(_MSC_VER)
				[[gsl::suppress(f.6)]]
			#endif
			return node_like::operator hash_t();
	}
protected:
	[[noreturn]] virtual void throw_self_ptr()const override{throw&_m;}
	[[noreturn]] virtual void throw_self_ptr()override{throw&_m;}
	[[nodiscard]]virtual logical_bool eq_with(const_ptr a)const noexcept override{
		using defs::equal;//貌似msvc在这里有bug
		if constexpr(equal.able<T>){
			if(a->get_type_info() != this->get_type_info())
				return false;
			const base_t*base_p=down_cast<const base_t*>(a.get());
			if(base_p->get_type_info() != this->get_type_info())
				return false;
			const this_t*p=down_cast<const this_t*>(base_p);
			return _m==p->_m;
		}
		else
			return node_like::eq_with(a);
	}
	[[nodiscard]]virtual logical_bool equal_with(const_ptr a)const noexcept override{
		return eq_with(a);
	}
private:
	static constexpr bool arec_nothrow_helper=was_not_an_ill_form(arec_as_value(_m,declvalue(const value&)))?
											  was_not_an_ill_form_and_noexcept(arec_as_value(_m,declvalue(const value&))):1;
public:
	[[nodiscard]]virtual value arec(const value index)noexcept(arec_nothrow_helper)override{
		if constexpr(was_not_an_ill_form(arec_as_value(_m,index)))
			return arec_as_value(_m,index);
		else
			return as_value(this);
	}
private:
	static constexpr bool clear_nothrow_helper= was_not_an_ill_form(declvalue(T).clear())?
												was_not_an_ill_form_and_noexcept(declvalue(T).clear()):
												re_construct.nothrow<T>;
public:
	virtual void clear()noexcept(clear_nothrow_helper)override{
		if constexpr(was_not_an_ill_form(declvalue(T).clear()))
			_m.clear();
		else
			re_construct(&_m);
	}
};

template<typename T>
[[nodiscard]]inline bool was_an(const_ptr p)noexcept{
	typedef binary_node_t<T> target_node_t;
	if(p->get_type_info() == type_info<binary_node_base_t>){
		auto base_p = down_cast<const binary_node_base_t*>(p.get());
		if(base_p->get_additional_type_info() == type_info<target_node_t>)
			return true;
		elseif constexpr(::std::is_class_v<T> && !::std::is_final_v<T>){
			try{
				base_p->throw_self_ptr();
			}
			catch(const T*){
				return true;
			}
			catch(const void*){}
		}
	}
	return false;
}
template<typename T>
[[nodiscard]]inline maybe_fail_reference<T> maybe_fail_use_by_ref_as(ptr p)noexcept{
	typedef binary_node_t<T> target_node_t;
	if(p->get_type_info() == type_info<binary_node_base_t>){
		auto base_p = down_cast<binary_node_base_t*>(p.get());
		if(base_p->get_additional_type_info() == type_info<target_node_t>)
			return down_cast<target_node_t*>(base_p)->_m;
		elseif constexpr(::std::is_class_v<T> && !::std::is_final_v<T>){
			try{
				base_p->throw_self_ptr();
			}
			catch(T*aret){
				return*aret;
			}
			catch(void*){}
		}
	}
	return note::fail;
}
template<typename T>
[[nodiscard]]inline T& use_by_ref_as(ptr p)noexcept{
	return maybe_fail_use_by_ref_as<T>(p).get_ref();
}
template<typename T>
[[nodiscard]]inline const T& const_use_by_ref_as(const_ptr p)noexcept{
	typedef binary_node_t<T> target_node_t;
	if(p->get_type_info() == type_info<binary_node_base_t>){
		auto base_p = down_cast<const binary_node_base_t*>(p.get());
		if(base_p->get_additional_type_info() == type_info<target_node_t>)
			return down_cast<const target_node_t*>(base_p)->_m;
		elseif constexpr(::std::is_class_v<T> && !::std::is_final_v<T>){
			try{
				base_p->throw_self_ptr();
			}
			catch(const T*aret){
				return*aret;
			}
			catch(const void*){}
		}
	}
	return const_default_value_of<T>;
}
template<typename T>
[[nodiscard]]inline T use_as(const_ptr p)noexcept{
	return const_use_by_ref_as<T>(p);
}
template<typename T>
[[nodiscard]]inline const T& use_by_ref_as(const_ptr p)noexcept{
	return const_use_by_ref_as<T>(p);
}
template<typename T>
[[nodiscard]]inline const T& use_by_ref_as(auto&&a)noexcept{
	return use_by_ref_as<T>(as_ptr(a));
}
template<typename T>
[[nodiscard]]inline ptr make_binary_node_from(T a)noexcept{
	return get<binary_node_t<T>>(move(a));
}
template<typename T>
distinctive inline map_t<ptr,T> long_term_binary_node_storager{};
template<typename T>
[[nodiscard]]inline ptr make_long_term_binary_node_from(T a)noexcept{
	ptr& to = long_term_binary_node_storager<T>[a];
	if(!bool(to) || const_use_by_ref_as<T>(to)!=a)
		to = make_binary_node_from<T>(move(a));
	return to;
}

//file_end

#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/code_list.hpp"
//code_list.hpp
//at namespace elc::defs::core
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline value eval(ptr p){
	return p->be_eval();
}
inline value eval(auto&&node){
	return eval(as_ptr(node));
}
struct code_list:cons,instance_struct<code_list>{
	typedef code_list this_t;
	override_instance_struct;
public:
	using cons::cons;

	[[nodiscard]]virtual value be_eval()override{
		ptr self = this;
		value aret{special_init};
	from_goto:
		try{
			do{
				eval(car_of(self)) >> aret;
				self=cdr_of(self);
			}while(self);
		}
		catch(core_runtime_internal_helper_n::goto_t&info){
			self=info.to;
			goto from_goto;
		}
		catch(core_runtime_internal_helper_n::return_t&){
		}
		return aret;
	}
	[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override{return type_info<code_list>;}
};

//file_end

#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/nodes/_body.hpp"

//file_end

		#line 19 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
	}

	#if defined(ELC_TEST_ON)
	namespace core_part_test{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_test.hpp"
//_test.hpp
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline void test(){
	ELC_TEST_EVENTNAME("core部分测试");
}
inline void test_log_out(){
}
inline void test_end(){
}

//file_end

		#line 24 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
	}
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 28 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
}
namespace elc{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_export.hpp"
//_export.hpp
//at namespace elc
/*
未完成的elc解释器core文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using defs::core::
export node_like;
export ptr;
export const_ptr;
export weak_ptr;
export const_weak_ptr;
export value;

export nil;
export t;
export the_void;

export as_value;
export as_ptr;
export common_node;
#undef export

//file_end

	#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
}
#if defined(ELC_STRING)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"
//string_arec_as_value.hpp
//at namespace ::
//multi when ELC_STRING & ELC_CORE
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if !defined(ELC_multi_string_arec_as_value)//pls skip define check as this part is muti
#define ELC_multi_string_arec_as_value
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"

	namespace string_n{
		template<class char_T>
		value arec_as_value(string_t<char_T>&str,const value index){
			size_t i=size_t(use_as<int_t>(index));
			if(!i)
				i=size_t(use_as<uint_t>(index));
			struct arec_data_t final:instance_struct<arec_data_t>
			,value::base_data_t{
				typename string_t<char_T>::arec_t _m;
				arec_data_t(string_t<char_T>&str,size_t index)noexcept:_m(&str,index){};
				arec_data_t(const arec_data_t&ref)noexcept:_m(special_init,ref._m){}
				virtual ~arec_data_t()noexcept override final=default;

				virtual void be_set(ptr a)noexcept override final{move(_m)=use_as<char_T>(a);}
				[[nodiscard]]virtual ptr get_value()noexcept override final{return core::make_binary_node_from<char_T>(move(_m));}
				[[nodiscard]]virtual base_data_t*copy()const noexcept override final{return get<arec_data_t>(*this);}
				[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<arec_data_t>;}
			};
			return get<arec_data_t>(str,i);
		}
	}

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"
}
#endif

//file_end

	#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/core/_body.hpp"
#endif

//file_end

	#line 15 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/core"
#endif

//file_end

	#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/namespace"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
//string
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
#if !defined(ELC_STRING)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
//base
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"
#line 19 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base"

//file_end

	#line 11 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
	//operator<< & operator>>
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
//base_stream
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"
#line 17 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/base_stream"

//file_end

	#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
	#define ELC_STRING
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
//_body.hpp
//at namespace ::
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if defined(ELC_TEST)
	#error "this part cannot be tested."
#endif
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/defs.hpp"
//defs.hpp
//at namespace elc::defs
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace string_n{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"
//_body.hpp
//at namespace elc::defs::string_n
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline namespace string_data_n{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_decl.hpp"
//_decl.hpp
//at namespace elc::defs::string_n::string_data_n
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename char_T>
struct base_string_data_t;

template<typename char_T>
struct null_string_data_t;
template<typename char_T>
struct constexpr_string_data_t;

template<typename char_T>
struct comn_string_data_t;

template<typename char_T>
struct substr_string_data_t;

template<typename char_T>
struct head_apply_string_data_t;
template<typename char_T>
struct end_apply_string_data_t;

template<typename char_T>
struct sum_string_data_t;

template<typename char_T>
struct erased_string_data_t;
template<typename char_T>
struct inserted_string_data_t;

//template<typename char_T>
//struct replaced_string_data_t;

template<typename char_T>
struct same_value_compress_string_data_t;

//file_end

	#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/base_string_data_t.hpp"
//base_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename char_T>
no_vtable_struct base_string_data_t:type_info_t<base_string_data_t<char_T>>::template_name
	with_common_attribute<abstract_base,never_in_array,replace_able,ref_able>,build_by_get_only{
	typedef base_string_data_t<char_T> this_t;
	typedef comn_ptr_t<this_t> ptr_t;
	typedef string_view_t<char_T> string_view_t;
	typedef char_T*string_ptr_t;
	typedef const char_T*const_string_ptr_t;

	static_assert(noexcept(declvalue(ptr_t).operator*()));//貌似msvc在这里有bug

	static constexpr bool copy_assign_nothrow=copy_assign.nothrow<char_T>;
	static constexpr bool copy_construct_nothrow=copy_construct.nothrow<char_T>;
	static constexpr bool move_construct_nothrow=move_construct.nothrow<char_T>;
	static constexpr bool construct_nothrow=construct<char_T>.nothrow<>;
	static constexpr bool destruct_nothrow=destruct.nothrow<char_T>;
	static constexpr bool clear_nothrow=destruct_nothrow;
	static constexpr bool ptr_reset_nothrow=destruct_nothrow;
	static constexpr bool hash_nothrow=hash.nothrow<char_T>;
	static constexpr bool get_data_nothrow=copy_construct_nothrow&&destruct_nothrow;
	static constexpr bool apply_data_nothrow=construct_nothrow&&copy_assign_nothrow;

	friend class null_string_data_t<char_T>;
	friend class constexpr_string_data_t<char_T>;
	friend class comn_string_data_t<char_T>;
	friend class substr_string_data_t<char_T>;
	friend class head_apply_string_data_t<char_T>;
	friend class end_apply_string_data_t<char_T>;
	friend class sum_string_data_t<char_T>;
	friend class erased_string_data_t<char_T>;
	friend class inserted_string_data_t<char_T>;
	//friend class replaced_string_data_t<char_T>;
	friend class same_value_compress_string_data_t<char_T>;

	base_string_data_t()noexcept=default;
	base_string_data_t(never_ref_num_zero_t)noexcept{ attribute_ptr_cast<ref_able>(this)->init_never_ref_num_zero(); }

	[[nodiscard]]bool is_unique()noexcept{ return get_ref_num(this)==1; }
	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)=0;

	virtual ~base_string_data_t()noexcept(destruct_nothrow)=default;

	[[nodiscard]]virtual string_ptr_t get_c_str(ptr_t&)noexcept(get_data_nothrow);
	[[nodiscard]]virtual const_string_ptr_t get_const_c_str(ptr_t&p)noexcept(get_data_nothrow){return get_c_str(p);}
	[[nodiscard]]virtual const char_T* get_data(ptr_t&p)noexcept(get_data_nothrow){return get_c_str(p);}//不要求以0结尾
	[[nodiscard]]virtual string_ptr_t get_unique_c_str(ptr_t&)noexcept(get_data_nothrow);
	[[nodiscard]]virtual size_t get_size()noexcept=0;
	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept;
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow);
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow);
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow);
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow);

	[[nodiscard]]virtual ptr_t do_insert(size_t pos,string_view_t str)noexcept(copy_construct_nothrow);
	[[nodiscard]]virtual ptr_t do_insert(size_t pos,ptr_t str)noexcept;
	[[nodiscard]]virtual ptr_t do_erase(size_t pos,size_t size)noexcept;

	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow){
		if(size==0)return this;
		const auto pos	  = this->get_size()-size;
		const auto before = get_substr_data(0,pos);
		return before;
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow){
		if(size==0)return this;
		const auto pos	  = size;
		const auto after  = get_substr_data(pos,this->get_size()-size);
		return after;
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow){
		if(size==0)return null_ptr;
		const auto pos	  = this->get_size()-size;
		const auto before = get_substr_data(0,pos);
		const auto after  = get_substr_data(pos,size);
		self			  = before;
		return after;
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow){
		if(size==0)return null_ptr;
		const auto pos	  = size;
		const auto before = get_substr_data(0,pos);
		const auto after  = get_substr_data(pos,this->get_size()-size);
		self			  = after;
		return before;
	}
	/*
	TODO:

	find
	rfind
	find_first_of
	find_first_not_of
	find_last_of
	find_last_not_of

	starts_with
	ends_with
	contains
	replace
	*/
	typedef compare_t::type<char_T> compare_type;
protected:
	bool same_type(ptr_t a)noexcept{return typeid(*this)==typeid(*a);}
	[[nodiscard]]virtual bool same_struct(ptr_t)noexcept=0;
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)=0;
	[[nodiscard]]virtual compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)=0;
protected:
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept=0;
private:
	[[nodiscard]]bool base_equal_with(ptr_t with)noexcept(equal.nothrow<char_T>){
		suppress_msvc_warning(26494)//未初始化警告diss
		bool aret;
		{
			//同结构比较优化比较方式
			if(same_type(with)&&same_struct(with))
				aret=same_struct_equal(with);
			//否则默认比较
			else
				aret=default_equal_method(with);
		}
		//如果equal，则eq处理
		if(aret)
			equivalent_optimization(this,with);
		return aret;
	}
public:
	[[nodiscard]]bool equal_with(ptr_t with)noexcept(equal.nothrow<char_T>){
		//eq->equal优化
		if(this==with)
			return true;
		//hash_diff->not_equal优化
		if(this->has_hash_cache()&&with->has_hash_cache())
			if(this->get_hash_cache()!=with->get_hash_cache())
				return false;
		//size比较优化
		if(this->get_size()!=with->get_size())
			return false;
		//快速比较结束，实际比较段
		return base_equal_with(with);
	}
	[[nodiscard]]bool equal_with_same_size(ptr_t with)noexcept(equal.nothrow<char_T>){
		//eq->equal优化
		if(this==with)
			return true;
		//hash_diff->not_equal优化
		if(this->has_hash_cache()&&with->has_hash_cache())
			if(this->get_hash_cache()!=with->get_hash_cache())
				return false;
		//size比较优化被移除
		//快速比较结束，实际比较段
		return base_equal_with(with);
	}
protected:
	[[nodiscard]]bool default_equal_method(ptr_t with)noexcept(equal.nothrow<char_T>){
		const size_t self_size=get_size();
		return equal_with(with,0,self_size);
	}
public:
	[[nodiscard]]bool equal_with(ptr_t with,size_t pos,size_t size)noexcept(equal.nothrow<char_T>){
		//eq->equal优化
		if(this==with)
			return true;
		size_t index=pos;
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		auto b=with->get_the_largest_complete_data_block_begin_form(index);
		while(size){
			const size_t step=min({a.size(),b.size(),size});
			if(a.begin()!=b.begin())//起始地址不同时才需要真的比较
				if(!equal(a.begin(),b.begin(),step))
					return false;
			index+=step;
			size-=step;
			if(a.size()==step)
				a=this->get_the_largest_complete_data_block_begin_form(index);
			else
				a={a.begin()+step,note::size(a.size()-step)};
			if(b.size()==step)
				b=with->get_the_largest_complete_data_block_begin_form(index);
			else
				b={b.begin()+step,note::size(b.size()-step)};
			if(!a.size()&&!b.size())
				return a.size()==b.size();
		}
		return true;
	}
	[[nodiscard]]bool equal_with(string_view_t with)noexcept(equal.nothrow<char_T>){
		size_t size=with.size();
		size_t index=0;
		if(this->get_size()!=with.size())
			return false;
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		if(a.begin()==with.begin() && a.size()==with.size())
			return true;
		floop{
			auto b=with.begin()+index;
			const size_t step=min({a.size(),with.size()-index,size});
			if(!equal(a.begin(),b,step))
				return false;
			index+=step;
			size-=step;
			if(a.size()==step)
				a=this->get_the_largest_complete_data_block_begin_form(index);
			else
				a={a.begin()+step,note::size(a.size()-step)};
			if(!a.size()||!size)
				return a.size()==size;
		}
	}
	[[nodiscard]]bool equal_with(const_string_ptr_t with)noexcept(equal.nothrow<char_T>){
		size_t size=get_size();
		size_t index=0;
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		if(a.begin()==with && with[a.size()]==char_T{})
			return true;
		floop{
			auto b=with+index;
			if(!*b)
				return false;
			size_t step=min({a.size(),size});
			if(!equal(a.begin(),step,just_an_part,b,end_by_zero))
				return false;
			index+=step;
			size-=step;
			if(a.size()==step)
				a=this->get_the_largest_complete_data_block_begin_form(index);
			else
				a={a.begin()+step,note::size(a.size()-step)};
			if(!*(b+step))
				return !a.size();
			if(!a.size())
				return !*(b+step);
		}
	}
private:
	[[nodiscard]]compare_type base_compare_with(ptr_t with)noexcept(compare.nothrow<char_T>){
		suppress_msvc_warning(26494)//未初始化警告diss
		compare_type aret;
		{
			//同结构比较优化比较方式
			if(same_type(with)&&same_struct(with))
				aret=same_struct_compare(with);
			//否则默认比较
			else
				aret=default_compare_method(with);
		}
		//如果equal，则eq处理
		if(aret==0)
			equivalent_optimization(this,with);
		return aret;
	}
public:
	[[nodiscard]]compare_type compare_with(ptr_t with)noexcept(compare.nothrow<char_T>){
		//eq->equal优化
		if(this==with)
			return strong_ordering::equivalent;
		//size比较优化
		{
			auto scom=compare(this->get_size(),with->get_size());
			if(scom!=0)
				return scom;
		}
		//快速比较结束，实际比较段
		return base_compare_with(with);
	}
	[[nodiscard]]compare_type compare_with_same_size(ptr_t with)noexcept(compare.nothrow<char_T>){
		//eq->equal优化
		if(this==with)
			return strong_ordering::equivalent;
		//size比较优化被移除
		//快速比较结束，实际比较段
		return base_compare_with(with);
	}
protected:
	[[nodiscard]]compare_type default_compare_method(ptr_t with)noexcept(compare.nothrow<char_T>){
		const size_t self_size=get_size();
		return compare_with(with,0,self_size);
	}
public:
	[[nodiscard]]compare_type compare_with(ptr_t with,size_t pos,size_t size)noexcept(compare.nothrow<char_T>){
		//eq->equal优化
		if(this==with)
			return strong_ordering::equivalent;
		size_t index=pos;
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		auto b=with->get_the_largest_complete_data_block_begin_form(index);
		while(size){
			const size_t step=min({a.size(),b.size(),size});
			if(a.begin()!=b.begin())//起始地址不同时才需要真的比较
				if(auto tmp=compare(a.begin(),b.begin(),step); tmp!=0)
					return tmp;
			index+=step;
			size-=step;
			if(a.size()==step)
				a=this->get_the_largest_complete_data_block_begin_form(index);
			else
				a={a.begin()+step,note::size(a.size()-step)};
			if(b.size()==step)
				b=with->get_the_largest_complete_data_block_begin_form(index);
			else
				b={b.begin()+step,note::size(b.size()-step)};
			if(!a.size()||!b.size())
				return a.size()<=>b.size();
		}
		return strong_ordering::equivalent;
	}
	[[nodiscard]]compare_type compare_with(string_view_t with)noexcept(compare.nothrow<char_T>){
		size_t size=with.size();
		size_t index=0;
		{
			auto scom=compare(this->get_size(),size);
			if(scom!=0)
				return scom;
		}
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		if(a.begin()==with.begin() && a.size()==with.size())
			return strong_ordering::equivalent;
		floop{
			auto b=with.begin()+index;
			size_t step=min({a.size(),with.size()-index,size});
			if(auto tmp=compare(a.begin(),b,step); tmp!=0)
				return tmp;
			index+=step;
			size-=step;
			if(a.size()==step)
				a=this->get_the_largest_complete_data_block_begin_form(index);
			else
				a={a.begin()+step,note::size(a.size()-step)};
			if(!a.size()||!size)
				return a.size()<=>size;
		}
	}
	[[nodiscard]]compare_type compare_with(const_string_ptr_t with)noexcept(compare.nothrow<char_T>){
		size_t size=get_size();
		size_t index=0;
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		if(a.begin()==with && with[a.size()]==char_T{})
			return strong_ordering::equivalent;
		floop{
			auto b=with+index;
			if(!*b)
				return strong_ordering::greater;
			size_t step=min({a.size(),size});
			if(auto tmp=compare(a.begin(),step,just_an_part,b,end_by_zero); tmp!=0)
				return tmp;
			index+=step;
			size-=step;
			if(a.size()==step)
				a=this->get_the_largest_complete_data_block_begin_form(index);
			else
				a={a.begin()+step,note::size(a.size()-step)};
			if(!a.size())
				return *(with+index)==char_T{}? strong_ordering::equivalent:
												strong_ordering::less;
			if(!*(with+index))
				return strong_ordering::greater;
		}
	}
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)=0;
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)=0;
	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)=0;
protected:
	hash_t _hash_cache{};
	bool _has_hash_cache=false;
	bool has_hash_cache()noexcept{return _has_hash_cache;}
	void reset_hash_cache()noexcept{_has_hash_cache=false;}
	hash_t get_hash_cache()noexcept{return _hash_cache;}
	hash_t set_hash_cache(hash_t value)noexcept{_has_hash_cache=true;return _hash_cache=value;}
public:
	hash_t get_hash(ptr_t&p)noexcept(hash_nothrow){
		if(has_hash_cache())
			return get_hash_cache();
		else{
			const auto tmp=this->get_hash_detail(p);
			return p->set_hash_cache(tmp);
		}
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&p)noexcept(hash_nothrow){
		const auto size=get_size();
		const auto data=get_data(p);
		return hash(data,size);
	}
public:
	hash_t get_others_hash_with_calculated_before(hash_t before,size_t before_size,ptr_t&p,size_t pos,size_t size)noexcept(hash_nothrow){
		if(pos==0&&size==get_size())
			return hash.merge_array_hash_results(before,before_size,get_hash(p),size);
		return this->get_others_hash_with_calculated_before_detail(before,before_size,p,pos,size);
	}
protected:
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&p,size_t pos,size_t size)noexcept(hash_nothrow){
		return hash.with_calculated_before(before,before_size,get_data(p)+pos,size);
	}
protected:
	void self_changed()noexcept{
		reset_hash_cache();
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept=0;
public:
	[[nodiscard]]float_size_t get_memory_cost()noexcept{
		return get_base_memory_cost()/get_ref_num(this);
	}
	[[nodiscard]]float_size_t get_memory_cost_after_gc()noexcept;
	[[nodiscard]]float_size_t get_gc_profit()noexcept{return get_memory_cost()-get_memory_cost_after_gc();}
	[[nodiscard]]bool positive_gc_profit()noexcept{return get_gc_profit() > 0;}
	//for gc:
	/*
	[[nodiscard]]virtual bool gc()=0{
		bool need_be_replace=get_gc_profit()>=0
		if(need_be_replace)
			this->be_replace_as(get<comn_string_data_t>(this));
		return need_be_replace;
	}
	*/

	[[nodiscard]]virtual const range_n::match_pattern<const char_T>& get_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow);
	[[nodiscard]]virtual const range_n::reverse_match_pattern<const char_T>& get_reverse_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow);

protected:
	static inline void be_replace(this_t* a,ptr_t b)noexcept(ptr_reset_nothrow){
		a->be_replace_as(b);
	}
	static inline void be_replace(ptr_t& a,ptr_t b)noexcept(ptr_reset_nothrow){
		a.do_replace(b);
	}
	static inline void equivalent_optimization(auto&& a,auto&& b)noexcept(ptr_reset_nothrow){
		if(a->get_memory_cost() >= b->get_memory_cost())
			be_replace(a,b);
		else
			be_replace(b,a);
	}
public:
	//Pre-alloc before begin memory
	[[nodiscard]]virtual ptr_t pre_alloc_before_begin(size_t size)noexcept;
	//Pre-alloc after end memory
	[[nodiscard]]virtual ptr_t pre_alloc_after_end(size_t size)noexcept;

	//io
	virtual void do_output(text_ostream<char_T>& os){
		size_t index=0;
		auto a=this->get_the_largest_complete_data_block_begin_form(index);
		while(a.size()){
			os.write(a.begin(),a.size());
			index+=a.size();
			a=this->get_the_largest_complete_data_block_begin_form(index);
		}
	}
};
template<typename char_T>
void base_string_data_t<char_T>::be_replace_as(ptr_t a)noexcept(clear_nothrow){
	replace_able<this_t>::be_replace_as(a.get());
}

//file_end

	#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/null_string_data_t.hpp"
//null_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename char_T>
struct null_string_data_t final:base_string_data_t<char_T>,instance_struct<null_string_data_t<char_T>>{
	typedef null_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	null_string_data_t()noexcept:base_t(never_ref_num_zero){}

	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{nothing;}
	[[nodiscard]]virtual string_ptr_t get_c_str(ptr_t&)noexcept override final{
		static char_T data[1]{};
		return data;
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return 0; }
	[[nodiscard]]virtual ptr_t get_substr_data([[maybe_unused]]size_t begin,[[maybe_unused]]size_t size)noexcept override final{ return this; }
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{ return get<comn_string_data_t<char_T>>(str); }
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{ return str; }
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{ return get<comn_string_data_t<char_T>>(str); }
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept override final{ return str; }

	[[nodiscard]]virtual ptr_t do_insert([[maybe_unused]]size_t pos,[[maybe_unused]]string_view_t str)noexcept(construct_nothrow&&copy_assign_nothrow)override final{ return get<comn_string_data_t<char_T>>(str); }
	[[nodiscard]]virtual ptr_t do_insert([[maybe_unused]]size_t pos,[[maybe_unused]]ptr_t str)noexcept override final{ return str; }
	[[nodiscard]]virtual ptr_t do_erase([[maybe_unused]]size_t pos,[[maybe_unused]]size_t size)noexcept override final{ return this; }
protected:
	virtual void copy_part_data_to([[maybe_unused]]char_T* to,[[maybe_unused]]size_t pos,[[maybe_unused]]size_t size)noexcept override final{ return; }
public:
	[[nodiscard]]virtual char_T arec([[maybe_unused]]size_t index)noexcept override final{ return char_T{}; }
	virtual void arec_set([[maybe_unused]]size_t index,[[maybe_unused]]char_T a,[[maybe_unused]]ptr_t& p)noexcept override final{ nothing; }
	[[nodiscard]]virtual ptr_t do_remove_front([[maybe_unused]]size_t size)noexcept override final{ return this; }
	[[nodiscard]]virtual ptr_t do_remove_back([[maybe_unused]]size_t size)noexcept override final{ return this; }
	[[nodiscard]]virtual ptr_t do_pop_back([[maybe_unused]]size_t size,[[maybe_unused]]ptr_t& self)noexcept override final{ return this; }
	[[nodiscard]]virtual ptr_t do_pop_front([[maybe_unused]]size_t size,[[maybe_unused]]ptr_t& self)noexcept override final{ return this; }
protected:
	virtual hash_t get_hash_detail([[maybe_unused]]ptr_t&p)noexcept override final{ return hash(nothing); }
	virtual hash_t get_others_hash_with_calculated_before_detail([[maybe_unused]]hash_t before,[[maybe_unused]]size_t before_size,[[maybe_unused]]ptr_t&p,[[maybe_unused]]size_t pos,[[maybe_unused]]size_t size)noexcept override final{ return before; }
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t)noexcept override final{return false;}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form([[maybe_unused]]size_t begin)noexcept override final{return{0,0};}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept override final{return false;}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept override final{return strong_ordering::equivalent;}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{return 0;}
};
template<typename char_T>
distinctive inline null_string_data_t<char_T> null_string_data{};
template<typename char_T>
base_string_data_t<char_T>* the_get_null_ptr(const base_string_data_t<char_T>*)noexcept{ return&null_string_data<char_T>; }

//file_end

	#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/constexpr_string_data_t.hpp"
//constexpr_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename char_T>
struct constexpr_string_data_t final:base_string_data_t<char_T>,instance_struct<constexpr_string_data_t<char_T>>{
	typedef constexpr_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	const char_T* _m;
	size_t _size;

	const range_n::match_pattern<const char_T>*			_p_match_pattern		 = nullptr;
	const range_n::reverse_match_pattern<const char_T>* _p_reverse_match_pattern = nullptr;
	bool												match_pattern_by_get	 = 0;

	void clear_match_pattern()noexcept{
		if(match_pattern_by_get){
			unget(remove_const(_p_match_pattern));
			unget(remove_const(_p_reverse_match_pattern));
			_p_match_pattern = nullptr;
			_p_reverse_match_pattern = nullptr;
		}
	}

	constexpr_string_data_t(const constexpr_str_t<char_T>&str)noexcept{
		_m=str.begin();
		_size=str.size();
		set_hash_cache(hash(str));
		_p_match_pattern=&str.match_pattern;
		_p_reverse_match_pattern=&str.reverse_match_pattern;
		match_pattern_by_get=0;
	}
	constexpr_string_data_t(string_view_t str)noexcept{
		_m=str.begin();
		_size=str.size();
		if(!_size)
			be_replace_as(null_ptr);
	}
	virtual ~constexpr_string_data_t()noexcept(destruct_nothrow)override final{
		clear_match_pattern();
	}

	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{
		return get<this_t>(string_view_t{_m+begin,size});
	}
	[[nodiscard]]virtual const char_T* get_data(ptr_t&)noexcept(get_data_nothrow)override final{return _m;}
	[[nodiscard]]virtual const_string_ptr_t get_const_c_str(ptr_t&p)noexcept(get_data_nothrow)override final{
		if(!_m[_size])
			return _m;
		else
			return base_t::get_const_c_str(p);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _size; }
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{ copy_assign[size](note::from(_m+pos),note::to(to)); }
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{ return _m[index]; }

	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{base_t::be_replace_as(a);}
	virtual void arec_set(size_t index,char_T a,ptr_t&p)noexcept override final{base_t::arec_set(index,a,p);}

	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		return true;//总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{return{&_m[begin],note::size(_size-begin)};}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		if(_m==wp->_m)
			return true;
		return equal(_m,wp->_m,_size);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		if(_m==wp->_m)
			return strong_ordering::equivalent;
		return compare(_m,wp->_m,_size);
	}
protected:
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this);
	}
public:
	[[nodiscard]]virtual const range_n::match_pattern<const char_T>& get_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(!_p_match_pattern){
			_p_match_pattern=get<range_n::match_pattern<const char_T>>(array_like_view_t{this->get_data(self),this->get_size()});
			match_pattern_by_get = 1;
		}
		return *_p_match_pattern;
	}
	[[nodiscard]]virtual const range_n::reverse_match_pattern<const char_T>&get_reverse_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(!_p_reverse_match_pattern){
			_p_reverse_match_pattern=get<range_n::reverse_match_pattern<const char_T>>(array_like_view_t{this->get_data(self),this->get_size()});
			match_pattern_by_get = 1;
		}
		return *_p_reverse_match_pattern;
	}
};

//file_end

	#line 15 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/comn_string_data_t.hpp"
//comn_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename char_T>
struct comn_string_data_t final:base_string_data_t<char_T>,instance_struct<comn_string_data_t<char_T>>{
	typedef comn_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	array_t<char_T> _m;
	range_n::match_pattern<const char_T>*		  _p_match_pattern		   = nullptr;
	range_n::reverse_match_pattern<const char_T>* _p_reverse_match_pattern = nullptr;
	void clear_match_pattern()noexcept{
		unget(_p_match_pattern);
		unget(_p_reverse_match_pattern);
		base_t::self_changed();
	}
	void self_changed()noexcept{
		clear_match_pattern();
		base_t::self_changed();
	}

	comn_string_data_t(string_view_t str)noexcept(construct_nothrow&&copy_assign_nothrow):_m(note::size(str.size()+1)){
		copy_assign[str.size()](note::from(str.begin()),note::to((char_T*)_m));
		_m[str.size()]=zero;
	}
	comn_string_data_t(ptr_t str)noexcept(construct_nothrow&&copy_assign_nothrow):_m(note::size(str->get_size()+1)){
		const auto size=this->get_size();
		str->copy_part_data_to((char_T*)_m,0,size);
		_m[size]=zero;
	}
	comn_string_data_t(ptr_t str,size_t pos,size_t size)noexcept(construct_nothrow&&copy_assign_nothrow):_m(note::size(size+1)){
		str->copy_part_data_to((char_T*)_m,pos,size);
		_m[size]=zero;
	}
	comn_string_data_t(size_t size,char_T ch)noexcept(construct_nothrow&&copy_assign_nothrow):_m(note::size(size+1),ch){
		_m[size]=zero;
	}
	comn_string_data_t(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow):_m(note::size(size+1)){
		_m[size]=zero;
	}

	virtual ~comn_string_data_t()noexcept(destruct_nothrow)override final{
		clear_match_pattern();
	}

	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		_m.clear();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual string_ptr_t get_c_str(ptr_t&)noexcept override final{ return (char_T*)_m; }
	[[nodiscard]]virtual string_ptr_t get_unique_c_str(ptr_t&p)noexcept(get_data_nothrow)override final{
		if(this->is_unique())
			return (char_T*)_m;
		else
			return base_t::get_unique_c_str(p);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _m.size()-1; }
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{ copy_assign[size](note::from((const char_T*)_m+pos),note::to(to)); }
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{ return _m[index]; }
	virtual void arec_set(size_t index,char_T a,ptr_t&p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			copy_assign(_m[index],a);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}

	[[nodiscard]]virtual bool same_struct(ptr_t)noexcept override final{
		return true;//总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{return{&_m[begin],note::size(get_size()-begin)};}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return equal(_m, wp->_m);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return compare(_m, wp->_m);
	}
protected:
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this) + _m.size_in_byte();
	}
public:
	[[nodiscard]]virtual const range_n::match_pattern<const char_T>& get_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(!_p_match_pattern)
			_p_match_pattern=get<range_n::match_pattern<const char_T>>(array_like_view_t{this->get_data(self),this->get_size()});
		return *_p_match_pattern;
	}
	[[nodiscard]]virtual const range_n::reverse_match_pattern<const char_T>&get_reverse_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(!_p_reverse_match_pattern)
			_p_reverse_match_pattern=get<range_n::reverse_match_pattern<const char_T>>(array_like_view_t{this->get_data(self),this->get_size()});
		return *_p_reverse_match_pattern;
	}
};
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::string_ptr_t base_string_data_t<char_T>::get_c_str(ptr_t&a)noexcept(get_data_nothrow){
	auto comn_data=get<comn_string_data_t<char_T>>(this);
	if(positive_gc_profit())
		a.do_replace(comn_data);
	else
		a=comn_data;
	return comn_data->get_c_str(a);
}
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::string_ptr_t base_string_data_t<char_T>::get_unique_c_str(ptr_t&a)noexcept(get_data_nothrow){
	auto comn_data=get<comn_string_data_t<char_T>>(this);
	a=comn_data;
	return comn_data->get_c_str(a);
}
template<typename char_T>
void base_string_data_t<char_T>::arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow){
	copy_assign(this->get_unique_c_str(p)[index],a);
}
template<typename char_T>
[[nodiscard]]float_size_t base_string_data_t<char_T>::get_memory_cost_after_gc()noexcept{
	const auto size_of_base_array=this->get_size()*sizeof(char_T);
	const auto size=float_size_of(comn_string_data_t<char_T>)+size_of_base_array;
	return size/get_ref_num(this);
}
template<typename char_T>
[[nodiscard]]const range_n::match_pattern<const char_T>& base_string_data_t<char_T>::get_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow){
	auto comn_data=get<comn_string_data_t<char_T>>(this);
	self=comn_data;
	return comn_data->get_match_pattern_from_self(self);
}
template<typename char_T>
[[nodiscard]]const range_n::reverse_match_pattern<const char_T>& base_string_data_t<char_T>::get_reverse_match_pattern_from_self(ptr_t&self)noexcept(copy_assign_nothrow&&move_construct_nothrow){
	auto comn_data=get<comn_string_data_t<char_T>>(this);
	self=comn_data;
	return comn_data->get_reverse_match_pattern_from_self(self);
}

//file_end

	#line 17 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/substr_string_data_t.hpp"
//substr_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename char_T>
struct substr_string_data_t final:base_string_data_t<char_T>,instance_struct<substr_string_data_t<char_T>>{
	typedef substr_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	ptr_t _to;
	size_t _sub_begin;
	size_t _sub_size;

	void null_equivalent_check()noexcept{
		if(!_sub_size)
			be_replace_as(null_ptr);
	}

	substr_string_data_t(ptr_t str,size_t sub_begin,size_t sub_size)noexcept:_to(str),_sub_begin(sub_begin),_sub_size(sub_size){
		null_equivalent_check();
	}

	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		_to.reset();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{ return get<substr_string_data_t<char_T>>(_to,begin+_sub_begin,size); }
	[[nodiscard]]virtual const_string_ptr_t get_const_c_str(ptr_t&p)noexcept(get_data_nothrow)override final{
		if(_sub_begin+_sub_size==_to->get_size())
			return _to->get_const_c_str(_to)+_sub_begin;
		else
			return base_t::get_const_c_str(p);
	}
	[[nodiscard]]virtual const char_T* get_data(ptr_t&)noexcept(get_data_nothrow)override final{ return _to->get_data(_to)+_sub_begin; }
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _sub_size; }
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{ _to->copy_part_data_to(to,pos+_sub_begin,size); }
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{ return _to->arec(index+_sub_begin); }
	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			_to->arec_set(index+_sub_begin,a,_to);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique() && _sub_begin==0){
			_to=_to->apply_str_to_begin(str);
			_sub_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique() && _sub_begin==0){
			_to=_to->apply_str_to_begin(str);
			_sub_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique() && _sub_begin+_sub_size==_to->get_size()){
			_to=_to->apply_str_to_end(str);
			_sub_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique() && _sub_begin+_sub_size==_to->get_size()){
			_to=_to->apply_str_to_end(str);
			_sub_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _sub_begin==0){
			auto aret=_to->do_pop_front(size,_to);
			_sub_size-=size;
			null_equivalent_check();
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_front(size,self);
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _sub_begin+_sub_size==_to->get_size()){
			auto aret=_to->do_pop_back(size,_to);
			_sub_size-=size;
			null_equivalent_check();
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_back(size,self);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			if(_sub_begin==0){
				_to=_to->do_remove_front(size);
				_sub_size-=size;
			}
			else{
				_sub_begin+=size;
				_sub_size-=size;
			}
			null_equivalent_check();
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_front(size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			if(_sub_begin+_sub_size==_to->get_size())
				_to=_to->do_remove_back(size);
			_sub_size-=size;
			null_equivalent_check();
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_back(size);
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		auto result=hash(nothing);
		result=_to->get_others_hash_with_calculated_before(result,0,_to,_sub_begin,_sub_size);
		return result;
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,size_t pos,size_t size)noexcept(hash_nothrow)override final{
		return _to->get_others_hash_with_calculated_before(before,before_size,_to,pos+_sub_begin,size);
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp = down_cast<this_t*>(with.get());
		return _sub_begin == wp->_sub_begin;//总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{
		auto result = _to->get_the_largest_complete_data_block_begin_form(_sub_begin+begin);
		auto size	= min(result.size(),_sub_size-begin);
		return{result.begin(), note::size(size)};
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return _to->equal_with(wp->_to,_sub_begin,_sub_size);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return _to->compare_with(wp->_to,_sub_begin,_sub_size);
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this)+_to->get_memory_cost();
	}
};
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::get_substr_data(size_t begin,size_t size)noexcept{
	if(begin==0&&size==get_size())
		return this;
	else
		return get<substr_string_data_t<char_T>>(this,begin,size);
}

//file_end

	#line 19 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/head_apply_string_data_t.hpp"
//end_apply_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename char_T>
struct head_apply_string_data_t final:base_string_data_t<char_T>,instance_struct<head_apply_string_data_t<char_T>>{
	typedef head_apply_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	array_t<char_T> _m;//意义为向前延续的数组：当需要向前附加内容时向前拓展以避免重新分配内存
	ptr_t _to;
	size_t _to_size;
	size_t _used_size;

	head_apply_string_data_t(ptr_t str,string_view_t head)noexcept(construct_nothrow&&copy_assign_nothrow):
		_to_size(str->get_size()),
		_used_size(head.size()),
		_to(str)
	{
		_m.resize(get_next_gold_size_to_resize_for_array(_to_size+_used_size));
		copy_assign[_used_size](note::from<const char_T*>(head.begin()),note::to<char_T*>(_m.end()-_used_size));
	}
	head_apply_string_data_t(ptr_t str,pre_alloc_t,size_t head_size)noexcept(construct_nothrow):
		_to_size(str->get_size()),
		_used_size(0),
		_to(str)
	{
		_m.resize(head_size);
	}

	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{
		if(begin>=_used_size)
			return _to->get_substr_data(begin-_used_size,size);
		else
			return base_t::get_substr_data(begin,size);
	}
	[[nodiscard]]virtual string_ptr_t get_c_str(ptr_t&p)noexcept(get_data_nothrow)override final{
		if(!_used_size)
			return _to->get_c_str(_to);
		else
			return base_t::get_c_str(p);
	}
	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		if(type_info<this_t> == typeid(*a)){
			const auto p = down_cast<this_t*>(a.get());
			if(_used_size==p->_used_size && _to!=p->_to)
				base_t::equivalent_optimization(_to, p->_to);
		}
		_m.clear();
		_to.reset();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _used_size+_to_size; }
	[[nodiscard]]virtual ptr_t do_insert(size_t pos,string_view_t str)noexcept(copy_construct_nothrow)override final{
		if(pos==0)
			return this->apply_str_to_begin(str);
		elseif(pos==get_size())
			return this->apply_str_to_end(str);
		elseif(this->is_unique()){
			if(pos<_used_size){
				if(_m.size()-_used_size>=str.size()){
					char_T* orogin_head_begin=_m.end()-_used_size;
					char_T* head_begin=orogin_head_begin-str.size();
					copy_assign[pos](note::from<const char_T*>(orogin_head_begin),note::to<char_T*>(head_begin));
					copy_assign[str.size()](note::from<const char_T*>(str.begin()),note::to<char_T*>(head_begin+pos));
				}
				else{
					const auto size_now=this->get_size()+str.size();
					const auto size_new=get_next_gold_size_to_resize_for_array(size_now);
					_m.insert_with_forward_resize(pos,str.size(),str.begin(),size_new);
				}
				_used_size+=str.size();
			}else{
				_to=_to->do_insert(pos-_used_size,str);
				_to_size=_to->get_size();
			}
			self_changed();
			return this;
		}
		else
			return base_t::do_insert(pos,str);
	}
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{
		if(pos<_used_size){
			const char_T* head_begin=_m.end()-_used_size;
			const char_T* head_end=_m.end();
			const char_T* copy_begin=pos+head_begin;
			size_t size_of_copy_from_head=min(size_t(head_end-copy_begin),size);

			copy_assign[size_of_copy_from_head](note::from(copy_begin),note::to(to));
			if(size!=size_of_copy_from_head){
				const size_t size_left=size-size_of_copy_from_head;
				char_T* next_copy_begin_pos=to+size_of_copy_from_head;
				_to->copy_part_data_to(next_copy_begin_pos,0,size_left);
			}
		}
		else
			_to->copy_part_data_to(to,pos-_used_size,size);
	}
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{
		if(index<_used_size){
			const char_T* head_begin=_m.end()-_used_size;
			return head_begin[index];
		}
		else
			return _to->arec(index-_used_size);
	}
	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			if(index<_used_size){
				char_T* head_begin=_m.end()-_used_size;
				copy_assign(head_begin[index],a);
			}
			else
				_to->arec_set(index-_used_size,a,_to);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			if(_m.size()-_used_size>=str.size())
				copy_assign[str.size()](note::from<const char_T*>(str.begin()),note::to<char_T*>(_m.end()-_used_size-str.size()));
			else{
				const auto size_now=this->get_size()+str.size();
				const auto size_new=get_next_gold_size_to_resize_for_array(size_now);
				_m.insert_with_forward_resize(0,str.size(),str.begin(),size_new);
			}
			_used_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{
		this->shrink();
		return base_t::apply_str_to_begin(str);
	}
	void shrink()noexcept(_m.forward_resize_nothrow){
		_m.forward_resize(_used_size);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_end(str);
			_to_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_end(str);
			_to_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(size>=_used_size)
			return _to->do_remove_front(size-_used_size);
		if(this->is_unique()){//&& size<_used_size
			_used_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_front(size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		/*
		if(size>=_to_size){
			const auto size_left=_used_size+_to_size-size;
			return get<comn_string_data_t<char_T>>(string_view_t{(char_T*)_m.end()-_used_size,size_left});
		}
		*/
		if(this->is_unique() && size<_to_size){
			_to=_to->do_remove_back(size);
			_to_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_back(size);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _used_size>=size){
			_used_size-=size;
			self_changed();
			return get<comn_string_data_t<char_T>>(string_view_t{(char_T*)_m.end()-_used_size-size,size});
		}
		else
			return base_t::do_pop_front(size,self);
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			auto aret=_to->do_pop_back(size,_to);
			_to_size-=size;
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_back(size,self);
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		suppress_msvc_warning(26494)//未初始化警告diss
		hash_t result;
		if(_used_size){
			const char_T* head_begin=_m.end()-_used_size;
			result=hash(head_begin,_used_size);
			if(_to_size)
				result=hash.merge_array_hash_results(result,_used_size,_to->get_hash(_to),_to_size);
		}
		else
			result=_to->get_hash(_to);
		return result;
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,size_t pos,size_t size)noexcept(hash_nothrow)override final{
		if(pos<_used_size){
			const char_T* head_begin=_m.end()-_used_size;
			const char_T* head_end=_m.end();
			const char_T* calculate_begin=pos+head_begin;
			const size_t size_of_calculate_from_head=min(size_t(head_end-calculate_begin),size);

			before=hash.with_calculated_before(before,before_size,calculate_begin,size_of_calculate_from_head);
			if(size!=size_of_calculate_from_head){
				const size_t size_left=size-size_of_calculate_from_head;
				before_size+=size_of_calculate_from_head;
				before=_to->get_others_hash_with_calculated_before(before,before_size,_to,0,size_left);
			}
		}
		else
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos-_used_size,size);
		return before;
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp=down_cast<this_t*>(with.get());
		return _used_size==wp->_used_size;// && _to_size==wp->_to_size; //总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{
		if(begin >= _used_size)
			return _to->get_the_largest_complete_data_block_begin_form(begin-_used_size);
		else {
			const char_T* head_begin = _m.end() - _used_size;
			const char_T* head_end	 = _m.end();
			const char_T* ret_begin	 = begin+head_begin;
			return{ret_begin, head_end};
		}
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		const char_T* head_begin = _m.end() - _used_size;
		const char_T* wp_head_begin = wp->_m.end() - _used_size;
		return equal(head_begin,wp_head_begin,_used_size) && _to->equal_with_same_size(wp->_to);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		const char_T* head_begin = _m.end() - _used_size;
		const char_T* wp_head_begin = wp->_m.end() - _used_size;
		if(auto tmp=compare(head_begin,wp_head_begin,_used_size); tmp!=0)
			return tmp;
		return _to->compare_with_same_size(wp->_to);
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return _to->get_memory_cost()+float_size_of(*this)+_m.size_in_byte();
	}
public:
	[[nodiscard]]virtual ptr_t pre_alloc_before_begin(size_t size)noexcept override final{
		if(this->is_unique()){
			const auto size_new=_used_size+size;
			if(size_new>_m.size())
				_m.forward_resize(size_new);
			return this;
		}
		return base_t::pre_alloc_before_begin(size);
	}
};
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow){
	if(str.size())
		return get<head_apply_string_data_t<char_T>>(this,str);
	else
		return this;
}
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::pre_alloc_before_begin(size_t size)noexcept{
	if(size)
		return get<head_apply_string_data_t<char_T>>(this,pre_alloc,size);
	else
		return this;
}

//file_end

	#line 21 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/end_apply_string_data_t.hpp"
//end_apply_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename char_T>
struct end_apply_string_data_t final:base_string_data_t<char_T>,instance_struct<end_apply_string_data_t<char_T>>{
	typedef end_apply_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	array_t<char_T> _m;
	ptr_t _to;
	size_t _to_size;
	size_t _used_size;

	end_apply_string_data_t(ptr_t str,string_view_t end)noexcept(construct_nothrow&&copy_assign_nothrow):
		_to_size(str->get_size()),
		_used_size(end.size()),
		_to(str)
	{
		_m.resize(get_next_gold_size_to_resize_for_array(_to_size+_used_size));
		copy_assign[_used_size](note::from(end.begin()),note::to((char_T*)_m));
	}
	end_apply_string_data_t(ptr_t str,size_t count,char_T ch)noexcept:
		_to_size(str->get_size()),
		_used_size(count),
		_to(str)
	{
		_m.resize(get_next_gold_size_to_resize_for_array(_to_size+_used_size));
		copy_assign[_used_size](ch,note::to((char_T*)_m));
	}
	end_apply_string_data_t(ptr_t str,size_t count)noexcept:
		_to_size(str->get_size()),
		_used_size(count),
		_to(str)
	{
		_m.resize(get_next_gold_size_to_resize_for_array(_to_size+_used_size));
	}
	end_apply_string_data_t(ptr_t str,pre_alloc_t,size_t end_count)noexcept(construct_nothrow):
		_to_size(str->get_size()),
		_used_size(0),
		_to(str)
	{
		_m.resize(end_count);
	}

	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{
		if(begin+size<=_to_size)
			return _to->get_substr_data(begin,size);
		else
			return base_t::get_substr_data(begin,size);
	}
	[[nodiscard]]virtual string_ptr_t get_c_str(ptr_t&p)noexcept(get_data_nothrow)override final{
		if(!_used_size)
			return _to->get_c_str(_to);
		else
			return base_t::get_c_str(p);
	}
	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		if(type_info<this_t> == typeid(*a)){
			const auto p = down_cast<this_t*>(a.get());
			if(_used_size==p->_used_size && _to!=p->_to)
				base_t::equivalent_optimization(_to, p->_to);
		}
		_m.clear();
		_to.reset();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _used_size+_to_size; }
	[[nodiscard]]virtual ptr_t do_insert(size_t pos,string_view_t str)noexcept(copy_construct_nothrow)override final{
		if(pos==0)
			return this->apply_str_to_begin(str);
		elseif(pos==get_size())
			return this->apply_str_to_end(str);
		elseif(this->is_unique()){
			if(pos<_to_size){
				_to=_to->do_insert(pos-_used_size,str);
				_to_size=_to->get_size();
			}
			else{
				pos-=_to_size;
				if(_m.size()-_used_size>=str.size()){
					copy_assign[_used_size-pos](note::from<const char_T*>(&_m[pos]),note::to((char_T*)&_m[pos+str.size()]));
					copy_assign[str.size()](note::from<const char_T*>(str.begin()),note::to<char_T*>(&_m[pos]));
				}
				else{
					const auto size_now=this->get_size()+str.size();
					const auto size_new=get_next_gold_size_to_resize_for_array(size_now);
					_m.insert_with_resize(pos,str.size(),str.begin(),size_new);
				}
				_used_size+=str.size();
			}
			self_changed();
			return this;
		}
		else
			return base_t::do_insert(pos,str);
	}
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{
		if(pos+size<=_to_size)
			_to->copy_part_data_to(to,pos,size);
		else{
			if(pos<_to_size){
				_to->copy_part_data_to(to,pos,_to_size-pos);
				auto copied_size=_to_size-pos;
				pos=0;
				size-=copied_size;
				to+=copied_size;
			}
			else
				pos-=_to_size;
			copy_assign[size](note::from((const char_T*)_m+pos),note::to(to));
		}
	}
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{
		if(index<_to_size)
			return _to->arec(index);
		else
			return _m[index-_to_size];
	}
	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			if(index<_to_size)
				_to->arec_set(index,a,_to);
			else
				copy_assign(_m[index - _to_size],a);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}

	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			if(_m.size()-_used_size>=str.size())
				copy_assign[str.size()](note::from(str.begin()),note::to((char_T*)_m+_used_size));
			else{
				const auto size_now=this->get_size()+str.size();
				const auto size_new=get_next_gold_size_to_resize_for_array(size_now);
				_m.insert_with_resize(_used_size,str.size(),str.begin(),size_new);
			}
			_used_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow)override final{
		this->shrink();
		return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_begin(str);
			_to_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_begin(str);
			_to_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		/*
		if(size>=_to_size)
			return get<comn_string_data_t<char_T>>(string_view_t{_m.begin(),_used_size+_to_size-size});
		*/
		if(this->is_unique() && size<_to_size){
			_to=_to->do_remove_front(size);
			_to_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_front(size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(size>=_used_size)
			return _to->do_remove_back(size-_used_size);
		if(this->is_unique()){//&& size<_used_size
			_used_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_back(size);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && size<_to_size){
			auto aret=_to->do_pop_front(size,_to);
			_to_size-=size;
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_front(size,self);
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _used_size>=size){
			_used_size-=size;
			self_changed();
			return get<comn_string_data_t<char_T>>(string_view_t{(char_T*)_m+_used_size,size});
		}
		else
			return base_t::do_pop_back(size,self);
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		return hash.with_calculated_before(_to->get_hash(_to),_to_size,string_view_t(_m.begin(),_used_size));
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,size_t pos,size_t size)noexcept(hash_nothrow)override final{
		if(pos+size<=_to_size)
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos,size);
		else{
			if(pos<_to_size){
				before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos,_to_size-pos);
				const auto calculated_size=_to_size-pos;
				pos=0;
				size-=calculated_size;
				before_size+=calculated_size;
			}
			else
				pos-=_to_size;
			before=hash.with_calculated_before(before,before_size,(const char_T*)_m+pos,size);
		}
		return before;
	}
	void shrink()noexcept(_m.resize_nothrow){
		_m.resize(_used_size);
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp = down_cast<this_t*>(with.get());
		return _used_size==wp->_used_size;// && _to_size==wp->_to_size; //总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{
		if(begin < _to_size)
			return _to->get_the_largest_complete_data_block_begin_form(begin);
		else {
			begin-=_to_size;
			return{_m.begin()+begin,note::size(_used_size-begin)};
		}
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return _to->equal_with_same_size(wp->_to) && equal((char_T*)_m.begin(),(char_T*)wp->_m.begin(),_used_size);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		if(auto tmp=_to->compare_with_same_size(wp->_to); tmp!=0)
			return tmp;
		return compare((char_T*)_m.begin(),(char_T*)wp->_m.begin(),_used_size);
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return _to->get_memory_cost()+float_size_of(*this)+_m.size_in_byte();
	}
public:
	[[nodiscard]]virtual ptr_t pre_alloc_after_end(size_t size)noexcept override final{
		if(this->is_unique()){
			const auto size_new=_used_size+size;
			if(size_new>_m.size())
				_m.resize(size_new);
			return this;
		}
		return base_t::pre_alloc_after_end(size);
	}
};
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow){
	if(str.size())
		return get<end_apply_string_data_t<char_T>>(this,str);
	else
		return this;
}
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::pre_alloc_after_end(size_t size)noexcept{
	if(size)
		return get<end_apply_string_data_t<char_T>>(this,pre_alloc,size);
	else
		return this;
}

//file_end

	#line 22 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/sum_string_data_t.hpp"
//sum_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename char_T>
struct sum_string_data_t final:base_string_data_t<char_T>,instance_struct<sum_string_data_t<char_T>>{
	typedef sum_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	ptr_t  _before;
	ptr_t  _after;
	size_t _before_size;
	size_t _after_size;

	sum_string_data_t(ptr_t before,ptr_t after)noexcept:_before(before),_after(after),_before_size(_before->get_size()),_after_size(_after->get_size()){
		if(!_before_size)
			be_replace_as(_after);
		elseif(!_after_size)
			be_replace_as(_before);
	}

	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{
		if(begin+size<=_before_size)
			return _before->get_substr_data(begin,size);
		elseif(begin>=_before_size)
			return _after->get_substr_data(begin-_before_size,size);
		else
			return base_t::get_substr_data(begin,size);
	}
	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		if(type_info<this_t> == typeid(*a)){
			const auto p = down_cast<this_t*>(a.get());
			if(_before_size==p->_before_size){
				if(_before!=p->_before)
					base_t::equivalent_optimization(_before, p->_before);
				if(_after!=p->_after)
					base_t::equivalent_optimization(_after, p->_after);
			}
		}
		_before.reset();
		_after.reset();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _before_size+_after_size; }
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{
		if(pos<_before_size){
			const auto copy_before_begin=pos;
			const auto copy_before_end=min(pos+size,_before_size);
			const auto copy_before_size=copy_before_end-copy_before_begin;
			_before->copy_part_data_to(to,copy_before_begin,copy_before_size);
			if(size!=copy_before_size){
				const auto copy_after_size=size-copy_before_size;
				to+=copy_before_size;
				_after->copy_part_data_to(to,0,copy_after_size);
			}
		}
		else
			_after->copy_part_data_to(to,pos-_before_size,size);
	}
public:
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{
		if(index<_before_size)
			return _before->arec(index);
		else
			return _after->arec(index-_before_size);
	}
	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			if(index<_before_size)
				_before->arec_set(index,a,_before);
			else
				_after->arec_set(index-_before_size,a,_after);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			_before=_before->apply_str_to_begin(str);
			_before_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			_before=_before->apply_str_to_begin(str);
			_before_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			_after=_after->apply_str_to_end(str);
			_after_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			_after=_after->apply_str_to_end(str);
			_after_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(_before_size==size)
			return _after;
		if(_before_size<size)
			return _after->do_remove_front(size-_before_size);
		if(this->is_unique()){
			_before=_before->do_remove_front(size);
			_before_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_front(size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(_after_size==size)
			return _before;
		if(_after_size<size)
			return _before->do_remove_back(size-_after_size);
		if(this->is_unique()){
			_after=_after->do_remove_back(size);
			_after_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_back(size);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _before_size>=size){
			ptr_t aret;
			if(_before_size==size)
				swap(aret,_before);
			else
				aret=_before->do_pop_front(size,_before);
			_before_size-=size;
			if(!_before_size)
				be_replace_as(_after);
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_front(size,self);
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _after_size>=size){
			ptr_t aret;
			if(_before_size==size)
				swap(aret,_after);
			else
				aret=_after->do_pop_back(size,_after);
			_after_size-=size;
			if(!_after_size)
				be_replace_as(_before);
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_back(size,self);
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		suppress_msvc_warning(26494)//未初始化警告diss
		hash_t result;
		if(_before_size){
			result=_before->get_hash(_before);
			if(_after_size)
				result=hash.merge_array_hash_results(result,_before_size,_after->get_hash(_after),_after_size);
		}
		else
			result=_after->get_hash(_after);
		return result;
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,size_t pos,size_t size)noexcept(hash_nothrow)override final{
		if(pos<_before_size){
			const auto calculate_before_begin=pos;
			const auto calculate_before_end=min(pos+size,_before_size);
			const auto calculate_before_size=calculate_before_end-calculate_before_begin;
			before=_before->get_others_hash_with_calculated_before(before,before_size,_before,calculate_before_begin,calculate_before_size);
			if(size!=calculate_before_size){
				const auto calculate_after_size=size-calculate_before_size;
				before_size+=calculate_before_size;
				before=_after->get_others_hash_with_calculated_before(before,before_size,_after,0,calculate_after_size);
			}
		}
		else
			before=_after->get_others_hash_with_calculated_before(before,before_size,_after,pos-_before_size,size);
		return before;
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp=down_cast<this_t*>(with.get());
		return _before_size==wp->_before_size;//总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{
		if(begin < _before_size)
			return _before->get_the_largest_complete_data_block_begin_form(begin);
		else
			return _after->get_the_largest_complete_data_block_begin_form(begin - _before_size);
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return this->_before->equal_with_same_size(wp->_before) && this->_after->equal_with_same_size(wp->_after);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		if(auto tmp=this->_before->compare_with_same_size(wp->_before); tmp!=0)
			return tmp;
		return this->_after->compare_with_same_size(wp->_after);
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this)+_before->get_memory_cost()+_after->get_memory_cost();
	}
};
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow){
	return get<sum_string_data_t<char_T>>(this,str);
}
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow){
	return get<sum_string_data_t<char_T>>(str,this);
}

//file_end

	#line 24 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/erased_string_data_t.hpp"
//erased_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename char_T>
struct erased_string_data_t final:base_string_data_t<char_T>,instance_struct<erased_string_data_t<char_T>>{
	typedef erased_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	ptr_t  _to;
	size_t _to_size;
	size_t _erase_pos;
	size_t _erase_size;

	void null_equivalent_check()noexcept{
		if(_to_size==_erase_size || !_to_size)
			be_replace_as(null_ptr);
	}

	erased_string_data_t(ptr_t str,size_t erase_pos,size_t erase_size)noexcept:_to(str),_to_size(_to->get_size()),_erase_pos(erase_pos),_erase_size(erase_size){
		null_equivalent_check();
	}

	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{
		if(begin+size<_erase_pos)
			return _to->get_substr_data(begin,size);
		elseif(begin>=_erase_pos)
			return _to->get_substr_data(begin+_erase_size,size);
		else
			return base_t::get_substr_data(begin,size);
	}
	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final {
		if(type_info<this_t> == typeid(*a)){
			const auto p = down_cast<this_t*>(a.get());
			if(_erase_pos==p->_erase_pos && _erase_size==p->_erase_size && _to!=p->_to)
				base_t::equivalent_optimization(_to, p->_to);
		}
		_to.reset();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _to_size-_erase_size; }
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{
		if(pos+size<_erase_pos)
			_to->copy_part_data_to(to,pos,size);
		elseif(pos>=_erase_pos)
			_to->copy_part_data_to(to,pos+_erase_size,size);
		else{
			const auto size_before_erase_pos=_erase_pos-pos;
			const auto size_after_erase_pos=size-size_before_erase_pos;
			_to->copy_part_data_to(to,pos,size_before_erase_pos);
			_to->copy_part_data_to(to+size_before_erase_pos,_erase_pos+_erase_size,size_after_erase_pos);
		}
	}
public:
	[[nodiscard]]virtual ptr_t do_erase(size_t pos,size_t size)noexcept override final{
		if(this->is_unique()){
			if(pos<=_erase_pos && pos+size>=_erase_pos+_erase_size){
				_erase_pos=pos;
				_erase_size+=size;
				self_changed();
				return this;
			}
		}
		return base_t::do_erase(pos,size);
	}
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{
		if(index>=_erase_pos)
			return _to->arec(index+_erase_size);
		else
			return _to->arec(index);
	}

	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			if(index>=_erase_pos)
				_to->arec_set(index+_erase_size,a,_to);
			else
				_to->arec_set(index,a,_to);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_begin(str);
			const auto strsize=str.size();
			_to_size+=strsize;
			_erase_pos+=strsize;
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_begin(str);
			const auto strsize=str->get_size();
			_to_size+=strsize;
			_erase_pos+=strsize;
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_end(str);
			_to_size+=str.size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			_to=_to->apply_str_to_end(str);
			_to_size+=str->get_size();
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(size>=_erase_pos)
			return _to->do_remove_front(size+_erase_size);
		if(this->is_unique()){//&& size<_erase_pos
			_to=_to->do_remove_front(size);
			_to_size-=size;
			_erase_pos-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_front(size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(size>=_to_size-_erase_pos-_erase_size)
			return _to->do_remove_back(size+_erase_size);
		if(this->is_unique()){//&& size<_to_size-_erase_pos-_erase_size
			_to=_to->do_remove_back(size);
			_to_size-=size;
			self_changed();
			return this;
		}
		else
			return base_t::do_remove_back(size);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _erase_pos > size){
			auto aret=_to->do_pop_front(size,_to);
			_to_size-=size;
			_erase_pos-=size;
			null_equivalent_check();
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_front(size,self);
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique() && _erase_pos+_erase_size <= _to_size-size){
			auto aret=_to->do_pop_back(size,_to);
			_to_size-=size;
			null_equivalent_check();
			self_changed();
			return aret;
		}
		else
			return base_t::do_pop_back(size,self);
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		auto result=hash(nothing);
		const auto size=get_size();
		const auto size_before_erase_pos=_erase_pos;
		const auto size_after_erase_pos=size-size_before_erase_pos;
		result=_to->get_others_hash_with_calculated_before(result,0,_to,0,size_before_erase_pos);
		result=_to->get_others_hash_with_calculated_before(result,size_before_erase_pos,_to,_erase_pos+_erase_size,size_after_erase_pos);
		return result;
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,size_t pos,size_t size)noexcept(hash_nothrow)override final{
		if(pos+size<_erase_pos)
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos,size);
		elseif(pos>=_erase_pos)
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos+_erase_size,size);
		else{
			const auto size_before_erase_pos=_erase_pos-pos;
			const auto size_after_erase_pos=size-size_before_erase_pos;
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos,size_before_erase_pos);
			before=_to->get_others_hash_with_calculated_before(before,before_size+size_before_erase_pos,_to,_erase_pos+_erase_size,size_after_erase_pos);
		}
		return before;
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp = down_cast<this_t*>(with.get());
		return _erase_pos == wp->_erase_pos && _erase_size == wp->_erase_size;
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t begin)noexcept override final{
		if(begin < _erase_pos){
			auto aret=_to->get_the_largest_complete_data_block_begin_form(begin);
			if(aret.size() > _erase_pos)
				aret = {aret.begin(),_erase_pos};
			return aret;
		}
		else
			return _to->get_the_largest_complete_data_block_begin_form(begin + _erase_size);
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return _to->equal_with(wp->_to,0,_erase_pos) && _to->equal_with(wp->_to,_erase_pos+_erase_size,_to_size);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		if(auto tmp=_to->compare_with(wp->_to,0,_erase_pos); tmp!=0)
			return tmp;
		return _to->compare_with(wp->_to,_erase_pos+_erase_size,_to_size);
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this)+_to->get_memory_cost();
	}
};
template<typename char_T>
[[nodiscard]]base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::do_erase(size_t pos,size_t size)noexcept{
	if(size==get_size())
		return null_ptr;
	else
		return get<erased_string_data_t<char_T>>(this,pos,size);
}

//file_end

	#line 26 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/inserted_string_data_t.hpp"
//inserted_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename char_T>
struct inserted_string_data_t final: base_string_data_t<char_T>,instance_struct<inserted_string_data_t<char_T>>{
	typedef inserted_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	ptr_t  _to;
	ptr_t  _insert_data;
	size_t _to_size;
	size_t _insert_pos;
	size_t _insert_size;

	inserted_string_data_t(ptr_t to,ptr_t insert_data,size_t insert_pos)noexcept:_to(to),_insert_data(insert_data),_insert_pos(insert_pos),_to_size(to->get_size()),_insert_size(insert_data->get_size()){}

	[[nodiscard]]virtual ptr_t get_substr_data(size_t begin,size_t size)noexcept override final{
		if(begin+size<_insert_pos)
			return _to->get_substr_data(begin,size);
		elseif(begin>_insert_pos+_insert_size)
			return _to->get_substr_data(begin-_insert_size,size);
		elseif(begin>=_insert_pos && begin+size<=_insert_pos+_insert_size)
			return _insert_data->get_substr_data(begin-_insert_pos,size);
		else
			return base_t::get_substr_data(begin,size);
	}
	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		if(type_info<this_t> == typeid(*a)){
			const auto p = down_cast<this_t*>(a.get());
			if(_insert_pos==p->_insert_pos && _insert_size==p->_insert_size){
				if(_to!=p->_to)
					base_t::equivalent_optimization(_to, p->_to);
				if(_insert_data!=p->_insert_data)
					base_t::equivalent_optimization(_insert_data, p->_insert_data);
			}
		}
		_to.reset();
		_insert_data.reset();
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _to_size+_insert_size; }
protected:
	virtual void copy_part_data_to(char_T* to,size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{
		if(pos+size<_insert_pos)
			_to->copy_part_data_to(to,pos,size);
		elseif(pos>_insert_pos+_insert_size)
			_to->copy_part_data_to(to,pos-_insert_size,size);
		else{
			if(_insert_pos>pos){
				auto size_before_insert_pos=_insert_pos-pos;
				_to->copy_part_data_to(to,pos,size_before_insert_pos);
				to+=size_before_insert_pos;
				size-=size_before_insert_pos;
			}
			auto size_before_insert_end=min(size,_insert_size);
			_insert_data->copy_part_data_to(to,0,size_before_insert_end);
			to+=size_before_insert_end;
			size-=size_before_insert_end;
			if(size)
				_to->copy_part_data_to(to,_insert_pos,size);
		}
	}
public:
	[[nodiscard]]virtual ptr_t do_insert(size_t pos,string_view_t str)noexcept(copy_construct_nothrow)override final{
		if(this->is_unique()){
			if(pos>=_insert_pos && pos<=_insert_pos+_insert_size){
				_insert_data=_insert_data->do_insert(pos-_insert_pos,str);
				_insert_size+=str.size();
			}
			elseif(pos<_insert_pos){
				_to=_to->do_insert(pos,str);
				_to_size+=str.size();
				_insert_pos+=str.size();
			}
			elseif(pos>_insert_pos+_insert_size){
				_to=_to->do_insert(pos-_insert_size,str);
				_to_size+=str.size();
			}
			self_changed();
			return this;
		}
		return base_t::do_insert(pos,str);
	}
	[[nodiscard]]virtual ptr_t do_erase(size_t pos,size_t size)noexcept override final{
		if(this->is_unique()){
			if(pos>=_insert_pos && pos+size<=_insert_pos+_insert_size){
				_insert_data=_insert_data->do_erase(pos-_insert_pos,size);
				_insert_size-=size;
				self_changed();
				return this;
			}
			elseif(pos+size<_insert_pos){
				_to=_to->do_erase(pos,size);
				_to_size-=size;
				_insert_pos-=size;
				self_changed();
				return this;
			}
			elseif(pos>_insert_pos+_insert_size){
				_to=_to->do_erase(pos-_insert_size,size);
				_to_size-=size;
				self_changed();
				return this;
			}
		}
		return base_t::do_erase(pos,size);
	}
	[[nodiscard]]virtual char_T arec(size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{
		if(index>=_insert_pos && index<_insert_pos+_insert_size)
			return _insert_data->arec(index-_insert_pos);
		elseif(index>=_insert_pos+_insert_size)
			return _to->arec(index-_insert_size);
		else
			return _to->arec(index);
	}

	virtual void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		if(this->is_unique()){
			if(index>=_insert_pos && index<_insert_pos+_insert_size)
				_insert_data->arec_set(index-_insert_pos,a,p);
			elseif(index>=_insert_pos+_insert_size)
				_to->arec_set(index-_insert_size,a,p);
			else
				_to->arec_set(index,a,p);
			self_changed();
		}
		else
			base_t::arec_set(index,a,p);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			const auto size=str.size();
			if(_insert_pos==0){
				_insert_data=_insert_data->apply_str_to_begin(str);
				_insert_size+=size;
			}
			else{
				_to=_to->apply_str_to_begin(str);
				_to_size+=str.size();
				_insert_pos+=size;
			}
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_begin(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			const auto size=str->get_size();
			if(_insert_pos==0){
				_insert_data=_insert_data->apply_str_to_begin(str);
				_insert_size+=size;
			}
			else{
				_to=_to->apply_str_to_begin(str);
				_to_size+=str->get_size();
				_insert_pos+=size;
			}
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_begin(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(string_view_t str)noexcept(copy_construct_nothrow&&apply_data_nothrow)override final{
		if(this->is_unique()){
			if(_insert_pos==_to_size){
				_insert_data=_insert_data->apply_str_to_end(str);
				_insert_size+=str.size();
			}
			else{
				_to=_to->apply_str_to_end(str);
				_to_size+=str.size();
			}
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t apply_str_to_end(ptr_t str)noexcept(apply_data_nothrow)override final{
		if(this->is_unique()){
			if(_insert_pos==_to_size){
				_insert_data=_insert_data->apply_str_to_end(str);
				_insert_size+=str->get_size();
			}
			else{
				_to=_to->apply_str_to_end(str);
				_to_size+=str->get_size();
			}
			self_changed();
			return this;
		}
		else
			return base_t::apply_str_to_end(str);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(size>=_insert_pos+_insert_size)
			return _to->do_remove_front(size-_insert_size);
		if(this->is_unique()){
			if(_insert_pos > size){
				_to=_to->do_remove_front(size);
				_to_size-=size;
				_insert_pos-=size;
				self_changed();
				return this;
			}
			elseif(_insert_pos==0 && _insert_size>=size){
				_insert_data=_insert_data->do_remove_front(size);
				_insert_size-=size;
				self_changed();
				return this;
			}
		}
		return base_t::do_remove_front(size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(size>=_to_size-_insert_pos)
			return _to->do_remove_back(size-_insert_pos);
		if(this->is_unique()){
			if(_insert_pos+_insert_size <= _to_size-size){
				_to=_to->do_remove_back(size);
				_to_size-=size;
				self_changed();
				return this;
			}
			elseif(_insert_pos==_to_size && _insert_size>=size){
				_insert_data=_insert_data->do_remove_front(size);
				_insert_size-=size;
				self_changed();
				return this;
			}
		}
		return base_t::do_remove_back(size);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			if(_insert_pos > size){
				auto aret=_to->do_pop_front(size,_to);
				_to_size-=size;
				_insert_pos-=size;
				self_changed();
				return aret;
			}
			elseif(_insert_pos==0 && _insert_size>=size){
				auto aret=_insert_data->do_pop_front(size,_insert_data);
				_insert_size-=size;
				self_changed();
				return aret;
			}
		}
		return base_t::do_pop_front(size,self);
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t& self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			if(_insert_pos+_insert_size <= _to_size-size){
				auto aret=_to->do_pop_back(size,_to);
				_to_size-=size;
				self_changed();
				return aret;
			}
			elseif(_insert_pos==_to_size && _insert_size>=size){
				auto aret=_insert_data->do_pop_front(size,_insert_data);
				_insert_size-=size;
				self_changed();
				return aret;
			}
		}
		return base_t::do_pop_back(size,self);
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		auto result=hash(nothing);
		if(_insert_pos)
			result=_to->get_others_hash_with_calculated_before(result,0,_to,0,_insert_pos);
		result=hash.merge_array_hash_results(result,_insert_pos,_insert_data->get_hash(_insert_data),_insert_size);
		const auto size=_to_size-_insert_pos;
		if(size)
			result=_to->get_others_hash_with_calculated_before(result,_insert_pos+_insert_size,_to,_insert_pos,size);
		return result;
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,size_t pos,size_t size)noexcept(hash_nothrow)override final{
		if(pos+size<_insert_pos)
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos,size);
		elseif(pos>_insert_pos+_insert_size)
			before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos-_insert_size,size);
		else{
			if(_insert_pos>pos){
				const auto size_before_insert_pos=_insert_pos-pos;
				before=_to->get_others_hash_with_calculated_before(before,before_size,_to,pos,size_before_insert_pos);
				size-=size_before_insert_pos;
				before_size+=size_before_insert_pos;
			}
			auto size_before_insert_end=min(size,_insert_size);
			before=_insert_data->get_others_hash_with_calculated_before(before,before_size,_insert_data,0,size_before_insert_end);
			size-=size_before_insert_end;
			before_size+=size_before_insert_end;
			if(size)
				before=_to->get_others_hash_with_calculated_before(before,before_size,_to,_insert_pos,size);
		}
		return before;
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp=down_cast<this_t*>(with.get());
		return _insert_pos==wp->_insert_pos && _insert_size==wp->_insert_size;//总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form(size_t index)noexcept override final{
		if(index>=_insert_pos && index<_insert_pos+_insert_size)
			return _insert_data->get_the_largest_complete_data_block_begin_form(index-_insert_pos);
		elseif(index>=_insert_pos+_insert_size)
			return _to->get_the_largest_complete_data_block_begin_form(index-_insert_size);
		else {
			auto aret=_to->get_the_largest_complete_data_block_begin_form(index);
			if(aret.size()+index > _insert_pos)
				aret = {aret.begin(), note::size(_insert_pos-index)};
			return aret;
		}
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return _insert_data->equal_with_same_size(wp->_insert_data) && _to->equal_with_same_size(wp->_to);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		if(auto tmp=_to->compare_with(wp->_to,0,_insert_pos); tmp!=0)
			return tmp;
		if(auto tmp=_insert_data->compare_with_same_size(wp->_insert_data); tmp!=0)
			return tmp;
		return _to->compare_with(wp->_to,_insert_pos,_to_size-(_insert_pos+_insert_size));
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this)+_insert_data->get_memory_cost()+_to->get_memory_cost();
	}
};
template<typename char_T>
base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::do_insert(size_t pos,ptr_t str)noexcept{
	return get<inserted_string_data_t<char_T>>(this,str,pos);
}
template<typename char_T>
base_string_data_t<char_T>::ptr_t base_string_data_t<char_T>::do_insert(size_t pos,string_view_t str)noexcept(copy_construct_nothrow){
	if(pos==0)
		return this->apply_str_to_begin(str);
	elseif(pos==get_size())
		return this->apply_str_to_end(str);
	else
		return this->do_insert(pos,get<comn_string_data_t<char_T>>(str));
}

//file_end

	#line 27 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"

	//#include "replaced_string_data_t.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/same_value_compress_string_data_t.hpp"
//sum_string_data_t.hpp
//at namespace elc::defs::string_n::string_data_n
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
template<typename char_T>
struct same_value_compress_string_data_t final:base_string_data_t<char_T>,instance_struct<same_value_compress_string_data_t<char_T>>{
	typedef same_value_compress_string_data_t<char_T> this_t;
	typedef base_string_data_t<char_T> base_t;
	using base_t::ptr_t;
	using base_t::string_view_t;
	using base_t::string_ptr_t;
	using base_t::const_string_ptr_t;
	using base_t::self_changed;

	using base_t::copy_assign_nothrow;
	using base_t::copy_construct_nothrow;
	using base_t::move_construct_nothrow;
	using base_t::construct_nothrow;
	using base_t::destruct_nothrow;
	using base_t::clear_nothrow;
	using base_t::ptr_reset_nothrow;
	using base_t::hash_nothrow;
	using base_t::get_data_nothrow;
	using base_t::apply_data_nothrow;
	using base_t::set_hash_cache;

	size_t _size;
	char_T _value;
	ptr_t _static_data_p;//必要时创建一个较大的数组，用于向外提供数据
	static constexpr size_t max_static_data_size=size_t(pow(BIT_POSSIBILITY, 9));

	same_value_compress_string_data_t(size_t size,char_T value)noexcept:_size(size),_value(value){}
	same_value_compress_string_data_t(size_t size,char_T value,ptr_t static_data_p)noexcept:_size(size),_value(value),_static_data_p(static_data_p){}
	ptr_t get_clone_with_new_size(size_t new_size)noexcept{
		if(new_size==_size)return this;
		if(new_size==0)return nullptr;
		return get<same_value_compress_string_data_t<char_T>>(new_size,_value,_static_data_p);
	}

	virtual void be_replace_as(ptr_t a)noexcept(clear_nothrow)override final{
		base_t::be_replace_as(a);
	}
	[[nodiscard]]virtual ptr_t get_substr_data([[maybe_unused]]size_t begin,size_t size)noexcept override final{
		return get_clone_with_new_size(size);
	}
	[[nodiscard]]virtual size_t get_size()noexcept override final{ return _size; }
protected:
	virtual void copy_part_data_to(char_T* to,[[maybe_unused]]size_t pos,size_t size)noexcept(copy_assign_nothrow)override final{
		copy_assign[size](_value,note::to(to));
	}
public:
	[[nodiscard]]virtual char_T arec([[maybe_unused]]size_t index)noexcept(copy_construct_nothrow&&move_construct_nothrow)override final{
		return _value;
	}
	void arec_set(size_t index,char_T a,ptr_t& p)noexcept(copy_assign_nothrow&&move_construct_nothrow)override final{
		//小优化
		if(a==_value)return;
		if(_size==1){_value=a;_static_data_p.reset();return;}
		//若_size>max_static_data_size，将当前类型转换为sum_string_data_t
		if(_size>max_static_data_size){
			//中间一段为comn_string_data_t，大小为max_static_data_size
			ptr_t tmp=get<comn_string_data_t<char_T>>(max_static_data_size,_value);
			//尽量确保index在中间一段的中间
			const size_t index_in_tmp=min(index,max_static_data_size/2);
			//将中间一段的index处的值改为a
			tmp->arec_set(index_in_tmp,a,tmp);
			//判断是否需要附加其他段
			if(index>max_static_data_size/2){
				const size_t first_size=index-max_static_data_size/2;
				ptr_t first_p=get_clone_with_new_size(first_size);
				tmp=get<sum_string_data_t<char_T>>(first_p,tmp);
			}
			const size_t last_size=_size-tmp->get_size();
			if(last_size){
				ptr_t last_p=get_clone_with_new_size(last_size);
				tmp=get<sum_string_data_t<char_T>>(tmp,last_p);
			}
			p=tmp;
			return;
		}
		else
			base_t::arec_set(index,a,p);
	}
	[[nodiscard]]virtual ptr_t do_remove_front(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			_size-=size;
			self_changed();
			return this;
		}
		else
			return get_clone_with_new_size(_size-size);
	}
	[[nodiscard]]virtual ptr_t do_remove_back(size_t size)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			_size-=size;
			self_changed();
			return this;
		}
		else
			return get_clone_with_new_size(_size-size);
	}
	[[nodiscard]]virtual ptr_t do_pop_front(size_t size,ptr_t&self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			_size-=size;
			self_changed();
			return get_clone_with_new_size(size);
		}
		else{
			auto aret=get_clone_with_new_size(size);
			self=get_clone_with_new_size(_size-size);
			return aret;
		}
	}
	[[nodiscard]]virtual ptr_t do_pop_back(size_t size,ptr_t&self)noexcept(construct_nothrow&&copy_assign_nothrow)override final{
		if(this->is_unique()){
			_size-=size;
			self_changed();
			return get_clone_with_new_size(size);
		}
		else{
			auto aret=get_clone_with_new_size(size);
			self=get_clone_with_new_size(_size-size);
			return aret;
		}
	}
protected:
	virtual hash_t get_hash_detail(ptr_t&)noexcept(hash_nothrow)override final{
		return hash.repeat_times(_value,_size);
	}
	virtual hash_t get_others_hash_with_calculated_before_detail(hash_t before,size_t before_size,ptr_t&,[[maybe_unused]]size_t pos,size_t size)noexcept(hash_nothrow)override final{
		return hash.merge_array_hash_results(before,before_size,hash.repeat_times(_value,size),size);
	}
protected:
	[[nodiscard]]virtual bool same_struct(ptr_t with)noexcept override final{
		auto wp=down_cast<this_t*>(with.get());
		if(wp->_value==_value && wp->_static_data_p!=_static_data_p){
			if(_static_data_p)
				wp->_static_data_p.do_replace(_static_data_p);
			elseif(wp->_static_data_p)
				_static_data_p.do_replace(wp->_static_data_p);
		}
		return true;//总size被保证一样
	}
	[[nodiscard]]virtual range_t<const char_T*> get_the_largest_complete_data_block_begin_form([[maybe_unused]]size_t begin)noexcept override final{
		if constexpr(construct<char_T>.trivial<const char_T&> && destruct.trivial<char_T>){
			if(!_static_data_p)
				_static_data_p=get<comn_string_data_t<char_T>>(max_static_data_size,_value);
			return{_static_data_p->get_data(_static_data_p),note::size(min(_size-begin,max_static_data_size))};
		}
		else
			return{&_value,note::size<size_t>(1)};
	}
	[[nodiscard]]virtual bool same_struct_equal(ptr_t with)noexcept(equal.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return equal(_value,wp->_value);
	}
	[[nodiscard]]virtual base_t::compare_type same_struct_compare(ptr_t with)noexcept(compare.nothrow<char_T>)override final{
		auto wp=down_cast<this_t*>(with.get());
		return compare(_value,wp->_value);
	}
	[[nodiscard]]virtual float_size_t get_base_memory_cost()noexcept override final{
		return float_size_of(*this)+_static_data_p->get_memory_cost();
	}
};

//file_end

	#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/string_data_t/_body.hpp"
}

//file_end

	#line 10 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/defs.hpp"
	template<typename char_T>
	struct string_t{
		static_assert(type_info<char_T> != type_info<const char_T>);

		typedef base_string_data_t<char_T>			base_t_w;
		typedef base_t_w::ptr_t						ptr_t;
		typedef base_t_w::string_view_t				string_view_t;
		typedef base_t_w::string_ptr_t				string_ptr_t;
		typedef base_t_w::const_string_ptr_t		const_string_ptr_t;
		typedef const constexpr_str_t<char_T>		constexpr_str_t;
		typedef string_t<char_T>					this_t;
		typedef char_T								value_type;
		typedef value_type							char_type;
		typedef size_t								size_type;
		static constexpr size_t						npos = range_n::npos;

	private:
		//_cso_info用于存储不同cso情况下string所用到的数据
		mutable union _cso_info_t{
			ptr_t _mptr;
			const constexpr_str_t* _str;
			char_T _ch;

			push_and_disable_msvc_warning(26495);//未初始化警告diss
			force_inline constexpr _cso_info_t()noexcept{}
			constexpr _cso_info_t(const _cso_info_t&a)noexcept{
				copy_assign[sizeof(_cso_info_t)](cast_to_data(this),cast_to_data(&a));
			}
			pop_msvc_warning();
			force_inline constexpr void operator=(const _cso_info_t&a)noexcept{
				copy_assign[sizeof(_cso_info_t)](cast_to_data(this),cast_to_data(&a));
			}
			force_inline ~_cso_info_t()noexcept{}
		}_cso_info{};
		//_cso_flags用于标识不同的cso情况
		mutable struct _cso_flags_t{
			bool _cso_flag=0;
			bool _str_cso_flag=0;
		}_cso_flags;

		//非cso情况下的成员宏，表示一个指向string data的智能指针
		#define _m _cso_info._mptr

		//BLOCK: 对成员宏`_m`的生命周期手动管理的函数族

		//结束成员宏`_m`的生命周期
		force_inline constexpr void _ncso_destruct_mptr()const noexcept{destruct(&_m);}
		//开始成员宏`_m`的生命周期
		force_inline constexpr void _ncso_construct_mptr()const noexcept{construct<ptr_t>[&_m]();}
		//以特定初始值开始成员宏`_m`的生命周期
		force_inline constexpr void _ncso_construct_mptr(ptr_t p)const noexcept{construct<ptr_t>[&_m](p);}

		//END_BLOCK

		//BLOCK: cso情况判断函数族
		[[nodiscard]]force_inline bool _in_cso()const noexcept{return _cso_flags._cso_flag;}
		[[nodiscard]]force_inline bool _in_str_cso()const noexcept{return _in_cso() && _cso_flags._str_cso_flag;}
		[[nodiscard]]force_inline bool _in_chr_cso()const noexcept{return _in_cso() && !_cso_flags._str_cso_flag;}
		//END_BLOCK
		//BLOCK: cso情况设定函数族
		force_inline constexpr void _set_str_cso()const noexcept{_cso_flags._cso_flag=1;_cso_flags._str_cso_flag=1;}
		force_inline constexpr void _set_chr_cso()const noexcept{_cso_flags._cso_flag=1;_cso_flags._str_cso_flag=0;}
		force_inline constexpr void _set_not_cso()const noexcept{_cso_flags._cso_flag=0;}
		//END_BLOCK

		//BLOCK: cso情况下的信息获取函数族
		[[nodiscard]]force_inline const char_T* _get_cso_data()const noexcept{return _in_str_cso()?_cso_info._str->str():&_cso_info._ch;}
		[[nodiscard]]force_inline size_t _get_cso_size()const noexcept{return _in_str_cso()?_cso_info._str->size():1;}
		[[nodiscard]]force_inline hash_t _get_cso_hash()const noexcept{return _in_str_cso()?hash(_get_cso_constexpr_str()):hash(_cso_info._ch);}
		[[nodiscard]]force_inline constexpr_str_t& _get_cso_constexpr_str()const noexcept{return *_cso_info._str;}
		//END_BLOCK

		//BLOCK: cso情况管理函数族
		force_inline constexpr void _cso_init(constexpr_str_t&str)noexcept{_set_str_cso();_cso_info._str=&str;}
		force_inline constexpr void _cso_reinit(constexpr_str_t&str)noexcept{if(!_in_cso())_ncso_destruct_mptr();_cso_init(str);}
		force_inline constexpr void _cso_init(char_T ch)noexcept{_set_chr_cso();_cso_info._ch=ch;}
		force_inline constexpr void _cso_reinit(char_T ch)noexcept{if(!_in_cso())_ncso_destruct_mptr();_cso_init(ch);}
		force_inline void _cso_fin(bool need_write)const noexcept{
			if(_in_str_cso()&&!need_write)
				_ncso_construct_mptr(get<constexpr_string_data_t<char_T>>(*_cso_info._str));
			else{
				auto str=string_view_t{_get_cso_data(),_get_cso_size()};
				_ncso_construct_mptr(get<comn_string_data_t<char_T>>(str));
			}
			_set_not_cso();
		}
		force_inline void _cso_fin(ptr_t p)noexcept{
			_set_not_cso();
			_ncso_construct_mptr(p);
		}
		//END_BLOCK

		//BLOCK: 已知需要拷贝cso全部内容，判断是否值得结束cso的检查
		static force_inline constexpr bool the_size_worth_to_end_cso(size_t size)noexcept{
			constexpr auto max_size=max(sizeof(comn_string_data_t<char_T>)*2/sizeof(char_T),(size_t)1);
			return size>=max_size;
		}
		static force_inline void full_copy_cso_check(const string_t&str)noexcept{
			if(the_size_worth_to_end_cso(str.size()))
				str._cso_check();
		}
		//END_BLOCK

		//若cso，结束它
		force_inline void _cso_check(bool need_write=0)const noexcept{
			if(_in_cso())
				_cso_fin(need_write);
		}

		//便利用，内部使用的构造函数
		force_inline string_t(ptr_t str)noexcept{_ncso_construct_mptr(str);}
		//无论是否在cso中，都保证可以获得一个ptr
		[[nodiscard]]force_inline ptr_t ptr_copy()const noexcept{
			_cso_check();
			return _m;
		}
	public:
		//swap的内部实现
		void swap_with(this_t& a)noexcept{
			if(_in_cso()||a._in_cso()){
				swap(_cso_info,a._cso_info);
				swap(_cso_flags,a._cso_flags);
			}
			else
				swap(_m,a._m);
		}

		//BLOCK: 构造函数
		constexpr string_t()noexcept:string_t(empty_constexpr_str_of<char_T>){}
		constexpr string_t(constexpr_str_t&str)noexcept{_cso_init(str);}
		string_t(string_view_t str)noexcept{_ncso_construct_mptr(get<comn_string_data_t<char_T>>(str));}
		string_t(const_string_ptr_t str)noexcept:string_t(string_view_t(str)){}
		constexpr string_t(char_T ch)noexcept{_cso_init(ch);}
		string_t(const string_t& str)noexcept{
			if(str._in_cso()){
				_cso_info=str._cso_info;
				_cso_flags=str._cso_flags;
			}
			else
				_ncso_construct_mptr(str._m);
		}
		string_t(string_t&& str)noexcept:string_t(){
			swap_with(str);
		}
		string_t(size_t size,char_T ch)noexcept{_ncso_construct_mptr(get<same_value_compress_string_data_t<char_T>>(size,ch));}
		string_t(char_T ch,size_t size)noexcept requires(type_info<size_t>!=type_info<char_T>):string_t(size,ch){}

		string_t(size_t size)noexcept{_ncso_construct_mptr(get<comn_string_data_t<char_T>>(size));}
		//END_BLOCK
		//析构函数
		~string_t()noexcept{if(!_in_cso())_ncso_destruct_mptr();}

		//BLOCK: 赋值操作符
		string_t& operator=(const string_t& str)&noexcept{re_construct[this](str);return*this;}
		string_t& operator=(string_t&& str)&noexcept{swap_with(str);return*this;}
		constexpr string_t& operator=(constexpr_str_t&str)&noexcept{_cso_reinit(str);return*this;}
		constexpr string_t& operator=(char_T ch)&noexcept{_cso_reinit(ch);return*this;}
		//END_BLOCK

		//BLOCK: 字符串相加操作符
		[[nodiscard]]string_t operator+(const string_t& str)const noexcept{
			full_copy_cso_check(str);
			if(str._in_cso())
				return operator+(str.to_string_view_t());
			else
				return ptr_copy()->apply_str_to_end(str._m);
		}
		[[nodiscard]]string_t operator+(string_view_t str)const noexcept{
			return ptr_copy()->apply_str_to_end(str);
		}
		[[nodiscard]]string_t operator+(const_string_ptr_t str)const noexcept{
			return *this+string_view_t(str);
		}
		friend [[nodiscard]]string_t operator+(string_view_t str1,const string_t& str2)noexcept{
			return str2.ptr_copy()->apply_str_to_begin(str1);
		}
		friend [[nodiscard]]string_t operator+(const_string_ptr_t str1,const string_t& str2)noexcept{
			return string_view_t(str1)+str2;
		}
		friend [[nodiscard]]string_t operator+(char_T ch,const string_t& str)noexcept{
			return string_view_t{&ch,1}+str;
		}

		string_t& operator+=(const string_t&str)&noexcept{
			push_back(str);
			return *this;
		}
		string_t& operator+=(string_view_t str)&noexcept{
			push_back(str);
			return *this;
		}
		string_t& operator+=(const_string_ptr_t str)&noexcept{
			return *this+=string_view_t(str);
		}
		string_t& operator+=(char_T ch)&noexcept{
			return *this += string_view_t{&ch,1};
		}
		template<typename U>
		[[nodiscard]]string_t&& operator+(U&& b)&&noexcept_as(*this+=b) requires was_not_an_ill_form(*this+=b){		  //对右值的operator+优化为operator+=
			*this+=b;
			return move(*this);
		}
		//END_BLOCK

		//获取string占用的内存大小
		float_size_t memory_cost()const noexcept{
			if(_in_cso())
				return 0;
			else
				return _m->get_memory_cost();
		}
	public:
		//BLOCK: 比较运算符
		[[nodiscard]]constexpr auto operator<=>(const string_t& a)const noexcept(compare.nothrow<char_T>){
			if(a._in_str_cso())
				return operator<=>(a._get_cso_constexpr_str());
			elseif(a._in_cso())
				return operator<=>(a.to_string_view_t());
			if(!_in_cso())
				return _m->compare_with(a._m);
			elseif(_in_str_cso())
				return compare.reverse(a<=>_get_cso_constexpr_str());
			else
				return compare.reverse(a<=>to_string_view_t());
		}
		[[nodiscard]]constexpr auto operator==(const string_t& a)const noexcept(equal.nothrow<char_T>){
			if(a._in_str_cso())
				return operator==(a._get_cso_constexpr_str());
			elseif(a._in_cso())
				return operator==(a.to_string_view_t());
			if(!_in_cso())
				return _m->equal_with(a._m);
			elseif(_in_str_cso())
				return a==_get_cso_constexpr_str();
			else
				return a==to_string_view_t();
		}
		[[nodiscard]]constexpr auto operator<=>(string_view_t a)const noexcept(compare.nothrow<char_T>){
			if(_in_cso())
				return compare(data(),a.begin(),size());
			else
				return _m->compare_with(a);
		}
		[[nodiscard]]constexpr auto operator==(string_view_t a)const noexcept(equal.nothrow<char_T>){
			if(_in_cso())
				return equal(data(),a.begin(),size());
			else
				return _m->equal_with(a);
		}
		[[nodiscard]]constexpr auto operator<=>(constexpr_str_t&a)const noexcept(compare.nothrow<char_T>){
			if(_in_cso() && data()==a.str())//同起始优化
				return strong_ordering::equivalent;
			auto tmp=operator<=>((string_view_t&)a);
			if(tmp==0)
				remove_const(this)->_cso_reinit(a);
			return tmp;
		}
		[[nodiscard]]constexpr auto operator==(constexpr_str_t&a)const noexcept(equal.nothrow<char_T>){
			if(_in_cso() && data()==a.str())//同起始优化
				return true;
			const auto tmp=operator==((string_view_t&)a);
			if(tmp)
				remove_const(this)->_cso_reinit(a);
			return tmp;
		}
		[[nodiscard]]constexpr auto operator<=>(const_string_ptr_t a)const noexcept(compare.nothrow<char_T>){
			if(_in_cso())
				return compare(data(),size(),a,end_by_zero);
			else
				return _m->compare_with(a);
		}
		[[nodiscard]]constexpr auto operator==(const_string_ptr_t a)const noexcept(equal.nothrow<char_T>){
			if(_in_cso())
				return equal(data(),size(),a,end_by_zero);
			else
				return _m->equal_with(a);
		}
		//END_BLOCK
	private:
		[[nodiscard]]string_ptr_t unique_c_str()noexcept{ _cso_check(1);return _m->get_unique_c_str(_m); }
	public:
		[[nodiscard]]char_T	arec(size_t index)noexcept{
			if(_in_cso())
				return _get_cso_data()[index];
			else
				return _m->arec(index);
		}
		void	arec_set(size_t index,char_T a)noexcept{ _cso_check(1);return _m->arec_set(index,a,_m); }

		class arec_t: non_copyable,non_moveable{
			string_t* _to;
			size_t	  _index;

			friend class string_t;
		public:
			arec_t(string_t* to,size_t index)noexcept:_to(to),_index(index){}
			arec_t(special_init_t,const arec_t&ref)noexcept:_to(ref._to),_index(ref._index){}
			[[nodiscard]]operator char_T()const&&noexcept{ return _to->arec(_index); }
			arec_t&&	 operator=(char_T a)&&noexcept{
				_to->arec_set(_index,a);
				return move(*this);
			}
			arec_t&&	 operator=(const arec_t&&ch)&&noexcept{ return move(*this).operator=(move(ch).operator char_T()); }
		private:
			[[nodiscard]]char_T*		get_address()noexcept{ return _to->unique_c_str()+_index; }
			[[nodiscard]]const char_T*	get_address()const noexcept{ return (add_const(_to))->c_str()+_index; }
		public:
			[[nodiscard]]char_T*		operator&()&&noexcept{ return get_address(); }
			[[nodiscard]]const char_T*	operator&()const&&noexcept{ return get_address(); }
			/*
			[[nodiscard]]explicit operator char_T&()&&noexcept{ return *get_address(); }
			[[nodiscard]]explicit operator const char_T&()const&&noexcept{ return *get_address(); }
			*/
			template<class text_ostream_T> requires(type_info<text_ostream_T>.base_on<text_ostream<char_T>>)
			friend auto& operator<<(text_ostream_T& os,arec_t&& ch)noexcept(type_info<text_ostream_T>.base_on<noexcept_text_ostream<char_T>>){
				return os << move(ch).operator char_T();
			}
			template<class text_istream_T> requires(type_info<text_istream_T>.base_on<text_istream<char_T>>)
			friend auto& operator>>(text_istream_T& is,arec_t&& ch)noexcept(type_info<text_istream_T>.base_on<noexcept_text_istream<char_T>>){
				char_T ach;is >> ach;
				move(ch)=ach;
				return is;
			}
		};

		[[nodiscard]]arec_t		  operator[](size_t index)noexcept{ return{this,index}; }
		[[nodiscard]]const arec_t operator[](size_t index)const noexcept{ return{remove_const(this),index}; }

		//front
		[[nodiscard]]arec_t		  front()noexcept{ return{this,0}; }
		[[nodiscard]]const arec_t front()const noexcept{ return{remove_const(this),0}; }
		//back
		[[nodiscard]]arec_t		  back()noexcept{ return{this,size()-1}; }
		[[nodiscard]]const arec_t back()const noexcept{ return{remove_const(this),size()-1}; }


		[[nodiscard]]string_t operator+(const arec_t&& ch)const noexcept{
			return *this+move(ch).operator char_T();
		}
		string_t& operator+=(const arec_t&& ch)&noexcept{
			return *this+=move(ch).operator char_T();
		}

		//floating arec.
	private:
		static constexpr bool floating_arec_result_able=was_not_an_ill_form(
			magic_number::linear_interpolation::get_result(declvalue(size_t),
				 magic_number::linear_interpolation::get_k(declvalue(char_T),declvalue(char_T)),
														   declvalue(float_t))
		);
		static auto floating_arec_result_type_helper()noexcept{
			if constexpr(floating_arec_result_able)
				return magic_number::linear_interpolation::get_result(size_t{},
					 magic_number::linear_interpolation::get_k(char_T{},char_T{}),
															   float_t{});
		}
		typedef decltype(floating_arec_result_type_helper()) floating_arec_result_type;
		static constexpr bool floating_arec_set_able=was_not_an_ill_form(
			magic_number::linear_interpolation::get_reverse_result(
				 magic_number::linear_interpolation::get_k(declvalue(char_T),declvalue(char_T)),
														   declvalue(float_t),declvalue(char_T))
		);
	public:
		static constexpr bool floating_arec_able=floating_arec_result_able||floating_arec_set_able;
		class floating_arec_t: non_copyable,non_moveable{
			string_t* _to;
			float_t	  _index;
			size_t	  _index_x1;
			size_t	  _index_x2;

			friend class string_t;
		public:
			static constexpr bool result_able=floating_arec_result_able;
			static constexpr bool set_able=floating_arec_set_able;

			floating_arec_t(string_t* to,float_t index)noexcept:_to(to),_index(index){
				_index_x1=static_cast<size_t>(index);
				_index_x2=_index_x1+1;
			}
			floating_arec_t(special_init_t,const floating_arec_t&ref)noexcept:_to(ref._to),_index(ref._index){}
			[[nodiscard]]operator floating_arec_result_type()const&&noexcept requires result_able{
				char_T y1=_to->arec(_index_x1);
				char_T y2=_to->arec(_index_x2);
				auto δx=_index-_index_x1;
				return magic_number::linear_interpolation::get_result(y1,
							magic_number::linear_interpolation::get_k(y1,y2),
														   			  δx);
			}
			floating_arec_t&& operator=(floating_arec_result_type a)&&noexcept requires set_able{
				char_T y1=_to->arec(_index_x1);
				char_T y2=_to->arec(_index_x2);
				auto k=magic_number::linear_interpolation::get_k(y1,y2);
				auto δx1=_index-_index_x1;
				auto δx2=_index-_index_x2;
				y1=(char_T)magic_number::linear_interpolation::get_reverse_result(k,δx1,a);
				y2=(char_T)magic_number::linear_interpolation::get_reverse_result(k,δx2,a);
				_to->arec_set(_index_x1,y1);
				_to->arec_set(_index_x2,y2);
				return move(*this);
			}
		};
		[[nodiscard]]floating_arec_t operator[](float_t index)noexcept requires(floating_arec_able){ return{this,index}; }
		[[nodiscard]]const floating_arec_t operator[](float_t index)const noexcept requires(floating_arec_able){ return{remove_const(this),index}; }

		//泛型arec.
		template<typename T> requires ::std::is_arithmetic_v<T>
		[[nodiscard]]auto operator[](T index)noexcept{
			if constexpr(::std::is_floating_point_v<T>)
				return operator[](static_cast<float_t>(index));
			else
				return operator[](static_cast<size_t>(index));
		}
		template<typename T> requires ::std::is_arithmetic_v<T>
		[[nodiscard]]const auto operator[](T index)const noexcept{
			if constexpr(::std::is_floating_point_v<T>)
				return operator[](static_cast<float_t>(index));
			else
				return operator[](static_cast<size_t>(index));
		}

		[[nodiscard]]string_t substr(size_t begin,size_t size=npos)const noexcept{
			size=min(size,this->size()-begin);
			if(size){
				_cso_check();
				return _m->get_substr_data(begin,size);
			}
			else
				return{};
		}
		[[nodiscard]]const char_T*	data()const noexcept{ if(_in_cso())return _get_cso_data();else return _m->get_data(_m); }
		[[nodiscard]]char_T* writeable_data()noexcept{ return unique_c_str(); }
		[[nodiscard]]const_string_ptr_t 	c_str()const noexcept{ if(_in_cso())return _get_cso_data();else return _m->get_const_c_str(_m); }
		[[nodiscard]]string_ptr_t writeable_c_str()noexcept{ return unique_c_str(); }
		[[nodiscard]]size_t			size()const noexcept{ if(_in_cso())return _get_cso_size();else return _m->get_size(); }
		[[nodiscard]]explicit operator bool()const noexcept{ return size(); }
		[[nodiscard]]bool			empty()const noexcept{ return !size(); }
		[[nodiscard]]size_t			length()const noexcept{ return size(); }
		void resize(size_t nsize,char_T ch)noexcept{
			const auto size=this->size();
			if(size > nsize)
				*this=substr(0,nsize);
			elseif(size == nsize)
				return;
			elseif(size){
				_cso_check();
				_m=get<end_apply_string_data_t<char_T>>(_m,nsize-size,ch);
			}
			else
				*this=string_t{nsize,ch};
		}
		void resize(size_t nsize)noexcept{
			const auto size=this->size();
			if(size > nsize)
				*this=substr(0,nsize);
			elseif(size == nsize)
				return;
			elseif(size){
				_cso_check();
				_m=get<end_apply_string_data_t<char_T>>(_m,nsize-size);
			}
			else
				*this=string_t{nsize};
		}
		void clear()noexcept{ re_construct(this); }
	private:
		struct iterator_base_t{
			string_t* _to;
			ptrdiff_t _index;		//rend: -1，使用size_t也不是不可以（标准允许无符号整数溢出），但是operator<=>会出问题

			[[nodiscard]]constexpr iterator_base_t	get_before()const noexcept{ return{_to,_index-1}; }
			[[nodiscard]]constexpr iterator_base_t	get_next()const noexcept{ return{_to,_index+1}; }
			[[nodiscard]]arec_t						get_value()noexcept{ return (*_to)[_index]; }
			[[nodiscard]]const arec_t				get_value()const noexcept{ return (*add_const(_to))[_index]; }
			[[nodiscard]]char_T*					get_handle()noexcept{ return &get_value(); }
			[[nodiscard]]const char_T*				get_handle()const noexcept{ return &get_value(); }
			[[nodiscard]]constexpr bool operator==(const iterator_base_t& a)const noexcept{ return _to==a._to && _index==a._index; }
			[[nodiscard]]constexpr auto operator<=>(const iterator_base_t& a)const noexcept{ return _to==a._to ? _index<=>a._index : partial_ordering::unordered; }
		};
		[[nodiscard]]iterator_base_t get_iterator_data_at(ptrdiff_t index)const noexcept{ return iterator_base_t{(string_t*)this,index}; }
	public:
		typedef iterator_t<char_T,iterator_base_t>				iterator;
		typedef const_iterator_t<char_T,const iterator_base_t>	const_iterator;

		[[nodiscard]]iterator		get_iterator_at(ptrdiff_t index)noexcept{ return get_iterator_data_at(index); }
		[[nodiscard]]const_iterator get_iterator_at(ptrdiff_t index)const noexcept{ return get_iterator_data_at(index); }
		[[nodiscard]]iterator		begin()noexcept{ return get_iterator_at(0); }
		[[nodiscard]]const_iterator begin()const noexcept{ return get_iterator_at(0); }
		[[nodiscard]]const_iterator cbegin()const noexcept{ return begin(); }
		[[nodiscard]]iterator		end()noexcept{ return get_iterator_at(size()); }
		[[nodiscard]]const_iterator end()const noexcept{ return get_iterator_at(size()); }
		[[nodiscard]]const_iterator cend()const noexcept{ return end(); }

		typedef reverse_iterator_t<char_T,iterator_base_t>				reverse_iterator;
		typedef reverse_const_iterator_t<char_T,const iterator_base_t>	reverse_const_iterator;

		[[nodiscard]]reverse_iterator		get_reverse_iterator_at(ptrdiff_t index)noexcept{ return get_iterator_data_at(index); }
		[[nodiscard]]reverse_const_iterator get_reverse_iterator_at(ptrdiff_t index)const noexcept{ return get_iterator_data_at(index); }
		[[nodiscard]]reverse_iterator		rbegin()noexcept{ return get_reverse_iterator_at(size()-1); }
		[[nodiscard]]reverse_const_iterator rbegin()const noexcept{ return get_reverse_iterator_at(size()-1); }
		[[nodiscard]]reverse_const_iterator rcbegin()const noexcept{ return rbegin(); }
		[[nodiscard]]reverse_iterator		rend()noexcept{ return get_reverse_iterator_at(-1); }
		[[nodiscard]]reverse_const_iterator rend()const noexcept{ return get_reverse_iterator_at(-1); }
		[[nodiscard]]reverse_const_iterator rcend()const noexcept{ return rend(); }

		//

		void push_back(const string_t& str)&noexcept{
			full_copy_cso_check(*this);
			full_copy_cso_check(str);
			if(_in_cso()&&!str._in_cso())
				_cso_fin(str._m->apply_str_to_begin(to_string_view_t()));
			elseif(str._in_cso())
				push_back(str.to_string_view_t());
			else{
				_cso_check();
				_m=_m->apply_str_to_end(str._m);
			}
		}
		void push_back(string_view_t str)&noexcept{ _cso_check();_m=_m->apply_str_to_end(str); }
		void push_back(char_T ch)&noexcept{ push_back(string_view_t{&ch,1}); }
		void push_back(const arec_t&& ch)&noexcept{ push_back(move(ch).operator char_T()); }
		void push_back(const_string_ptr_t str)&noexcept{ push_back(string_view_t(str)); }

		void push_front(const string_t& str)&noexcept{
			full_copy_cso_check(*this);
			full_copy_cso_check(str);
			if(_in_cso()&&!str._in_cso())
				_cso_fin(str._m->apply_str_to_end(to_string_view_t()));
			elseif(str._in_cso())
				push_front(str.to_string_view_t());
			else{
				_cso_check();
				_m=_m->apply_str_to_begin(str._m);
			}
		}
		void push_front(string_view_t str)&noexcept{ _cso_check();_m=_m->apply_str_to_begin(str); }
		void push_front(char_T ch)&noexcept{ push_front(string_view_t{&ch,1}); }
		void push_front(const arec_t&& ch)&noexcept{ push_front(move(ch).operator char_T()); }
		void push_front(const_string_ptr_t str)&noexcept{ push_front(string_view_t(str)); }

		void remove_back(size_t size=1)noexcept{ _cso_check();_m=_m->do_remove_back(size); }
		void remove_front(size_t size=1)noexcept{ _cso_check();_m=_m->do_remove_front(size); }
		#define pop_function_nodiscard nodiscard("if you don't want to use the return value, use remove_back() or remove_front() instead to avoid unnecessary cost")
		[[pop_function_nodiscard]]string_t pop_back(size_t size)noexcept{ _cso_check();return _m->do_pop_back(size,_m); }
		[[pop_function_nodiscard]]string_t pop_front(size_t size)noexcept{ _cso_check();return _m->do_pop_front(size,_m); }
		[[pop_function_nodiscard]]char_T pop_back()noexcept{ return pop_back(1)[0]; }
		[[pop_function_nodiscard]]char_T pop_front()noexcept{ return pop_front(1)[0]; }
		#undef pop_function_nodiscard

		//

		[[nodiscard]]operator string_view_t()const&noexcept{ return string_view_t{data(),size()}; }
		[[nodiscard]]auto to_string_view_t()const&noexcept{ return operator string_view_t(); }
		[[nodiscard]]auto view()&noexcept{ return array_like_view_t<char_T>{writeable_data(),size()}; }
		[[nodiscard]]auto view()const&noexcept{ return array_like_view_t<const char_T>{data(),size()}; }
		[[nodiscard]]explicit operator hash_t()const noexcept{ return _in_cso()?_get_cso_hash():_m->get_hash(_m); }

		//
		static constexpr bool find_nothrow=equal.nothrow<char_T>;
		[[nodiscard]]size_t find(const char_T ch)const noexcept(find_nothrow){
			if(_in_cso()){
				if(_in_str_cso())
					return in_range_size_t(ch,_get_cso_constexpr_str());
				else//if(_in_cso())
					return _cso_info._ch==ch?0:npos;
			}
			return in_range_size_t(ch, to_string_view_t());
		}
		[[nodiscard]]size_t find(const char_T ch,size_t begin)const noexcept(find_nothrow){
			return in_range_size_t(ch, to_string_view_t().substr(begin));
		}
		[[nodiscard]]size_t reverse_find(const char_T ch)const noexcept(find_nothrow){
			if(_in_cso()){
				if(_in_str_cso())
					return in_range_but_reverse_size_t(ch,_get_cso_constexpr_str());
				else//if(_in_cso())
					return _cso_info._ch==ch?0:npos;
			}
			return in_range_but_reverse_size_t(ch, to_string_view_t());
		}
		[[nodiscard]]size_t find(string_view_t str,size_t begin=0)const noexcept(find_nothrow){
			return in_range_size_t(str, to_string_view_t().substr(begin));
		}
		[[nodiscard]]size_t reverse_find(string_view_t str)const noexcept(find_nothrow){
			return in_range_but_reverse_size_t(str, to_string_view_t());
		}
		[[nodiscard]]size_t find(constexpr_str_t&str,size_t begin=0)const noexcept(find_nothrow){
			return in_range_size_t(str, to_string_view_t().substr(begin));
		}
		[[nodiscard]]size_t reverse_find(constexpr_str_t&str)const noexcept(find_nothrow){
			return in_range_but_reverse_size_t(str, to_string_view_t());
		}
		[[nodiscard]]size_t find(const string_t&str,size_t begin=0)const noexcept(find_nothrow){
			if(str._in_cso()){
				if(str._in_str_cso())
					return find(str._get_cso_constexpr_str(),begin);
				else//if(str._in_cso())
					return find(str._cso_info._ch,begin);
			}
			auto result = str._m->get_match_pattern_from_self(str._m).match(to_string_view_t().substr(begin));
			if(result)
				return result - data();
			else
				return npos;
		}
		[[nodiscard]]size_t reverse_find(const string_t&str)const noexcept(find_nothrow){
			if(str._in_cso()){
				if(str._in_str_cso())
					return reverse_find(str._get_cso_constexpr_str());
				elseif(str._in_cso())
					return reverse_find(str._cso_info._ch);
			}
			auto result = str._m->get_reverse_match_pattern_from_self(str._m).match(to_string_view_t());
			if(result)
				return result - data();
			else
				return npos;
		}
		//
		[[nodiscard]]size_t find_first_of(string_view_t str)const noexcept(find_nothrow){
			return range_n::find_first_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_first_of(constexpr_str_t&str)const noexcept(find_nothrow){
			return range_n::find_first_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_first_of(const string_t&str)const noexcept(find_nothrow){
			if(str._in_cso()){
				if(str._in_str_cso())
					return find_first_of(str._get_cso_constexpr_str());
				elseif(str._in_cso())
					return find(str._cso_info._ch);
			}
			return find_first_of(str.to_string_view_t());
		}
		[[nodiscard]]size_t find_first_of(const_string_ptr_t str)const noexcept(find_nothrow){
			return find_first_of(string_view_t(str));
		}
		[[nodiscard]]size_t find_first_of(char_T ch)const noexcept(find_nothrow){
			return find(ch);
		}
		[[nodiscard]]size_t find_first_of(const arec_t&&ch)const noexcept(find_nothrow){
			return find(move(ch).operator char_T());
		}
		[[nodiscard]]size_t find_first_not_of(string_view_t str)const noexcept(find_nothrow){
			return range_n::find_first_not_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_first_not_of(constexpr_str_t&str)const noexcept(find_nothrow){
			return range_n::find_first_not_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_first_not_of(const string_t&str)const noexcept(find_nothrow){
			if(str._in_cso()){
				if(str._in_str_cso())
					return find_first_not_of(str._get_cso_constexpr_str());
				elseif(str._in_cso())
					return find_first_not_of(str.to_string_view_t());
			}
			return find_first_not_of(str.to_string_view_t());
		}
		[[nodiscard]]size_t find_first_not_of(const_string_ptr_t str)const noexcept(find_nothrow){
			return find_first_not_of(string_view_t(str));
		}
		[[nodiscard]]size_t find_first_not_of(char_T ch)const noexcept(find_nothrow){
			return find_first_not_of(string_view_t(ch));
		}
		[[nodiscard]]size_t find_first_not_of(const arec_t&&ch)const noexcept(find_nothrow){
			return find_first_not_of(string_view_t(move(ch).operator char_T()));
		}
		[[nodiscard]]size_t find_last_of(string_view_t str)const noexcept(find_nothrow){
			return range_n::find_last_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_last_of(constexpr_str_t&str)const noexcept(find_nothrow){
			return range_n::find_last_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_last_of(const string_t&str)const noexcept(find_nothrow){
			if(str._in_cso()){
				if(str._in_str_cso())
					return find_last_of(str._get_cso_constexpr_str());
				elseif(str._in_cso())
					return reverse_find(str._cso_info._ch);
			}
			return find_last_of(str.to_string_view_t());
		}
		[[nodiscard]]size_t find_last_of(const_string_ptr_t str)const noexcept(find_nothrow){
			return find_last_of(string_view_t(str));
		}
		[[nodiscard]]size_t find_last_of(char_T ch)const noexcept(find_nothrow){
			return reverse_find(ch);
		}
		[[nodiscard]]size_t find_last_of(const arec_t&&ch)const noexcept(find_nothrow){
			return reverse_find(move(ch).operator char_T());
		}
		[[nodiscard]]size_t find_last_not_of(string_view_t str)const noexcept(find_nothrow){
			return range_n::find_last_not_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_last_not_of(constexpr_str_t&str)const noexcept(find_nothrow){
			return range_n::find_last_not_of_size_t(str,to_string_view_t());
		}
		[[nodiscard]]size_t find_last_not_of(const string_t&str)const noexcept(find_nothrow){
			if(str._in_cso()){
				if(str._in_str_cso())
					return find_last_not_of(str._get_cso_constexpr_str());
				elseif(str._in_cso())
					return find_last_not_of(str.to_string_view_t());
			}
			return find_last_not_of(str.to_string_view_t());
		}
		[[nodiscard]]size_t find_last_not_of(const_string_ptr_t str)const noexcept(find_nothrow){
			return find_last_not_of(string_view_t(str));
		}
		[[nodiscard]]size_t find_last_not_of(char_T ch)const noexcept(find_nothrow){
			return find_last_not_of(string_view_t{&ch,1});
		}
		[[nodiscard]]size_t find_last_not_of(const arec_t&&ch)const noexcept(find_nothrow){
			return find_last_not_of(move(ch).operator char_T());
		}

		//

		[[nodiscard]]string_t arec(size_t index,char_T delimiter)const{
			auto pos=find(delimiter);
			auto end=find(delimiter,pos);
			while(index--){
				pos=end;
				end=find(delimiter,pos);
			}
			return substr(pos,end-pos);
		}
		[[nodiscard]]string_t arec(size_t index,string_view_t delimiter_str)const{
			auto pos=find(delimiter_str);
			auto end=find(delimiter_str,pos);
			while(index--){
				pos=end;
				end=find(delimiter_str,pos);
			}
			return substr(pos,end-pos);
		}
		[[nodiscard]]string_t arec(size_t index,const string_t&delimiter_str)const{
			auto pos=find(delimiter_str);
			auto end=find(delimiter_str,pos);
			while(index--){
				pos=end;
				end=find(delimiter_str,pos);
			}
			return substr(pos,end-pos);
		}
		[[nodiscard]]string_t arec(size_t index,constexpr_str_t&delimiter_str)const{
			auto pos=find(delimiter_str);
			auto end=find(delimiter_str,pos);
			while(index--){
				pos=end;
				end=find(delimiter_str,pos);
			}
			return substr(pos,end-pos);
		}

		//

		void erase(size_t pos,size_t size=1)&noexcept{
			_cso_check();_m=_m->do_erase(pos,size);
		}
		void insert(size_t pos,const string_t& str)&noexcept{
			_cso_check();
			full_copy_cso_check(str);
			if(str._in_cso())
				_m=_m->do_insert(pos,str.to_string_view_t());
			else
				_m=_m->do_insert(pos,str);
		}
		void insert(size_t pos,string_view_t str)&noexcept{
			_cso_check();_m=_m->do_insert(pos,str);
		}
		void insert(size_t pos,const_string_ptr_t str)&noexcept{
			insert(pos,string_view_t(str));
		}
		void insert(size_t pos,char_T ch)&noexcept{
			insert(pos,string_view_t{&ch,1});
		}

		//

		//contains
		constexpr bool contains(string_view_t str)const noexcept{
			return find(str) != npos;
		}
		constexpr bool contains(constexpr_str_t&str)const noexcept{
			return find(str) != npos;
		}
		constexpr bool contains(const string_t&str)const noexcept{
			return find(str) != npos;
		}
		constexpr bool contains(char_T ch)const noexcept{
			return find(ch) != npos;
		}
		constexpr bool contains(const_string_ptr_t str)const noexcept{
			return find(str) != npos;
		}

		//starts_with
		constexpr bool starts_with(string_view_t str)const noexcept{
			if(size()<str.size())
				return false;
			return substr(0,str.size()) == str;
		}
		constexpr bool starts_with(constexpr_str_t&str)const noexcept{
			if(size()<str.size())
				return false;
			return substr(0,str.size()) == str;
		}
		constexpr bool starts_with(const string_t&str)const noexcept{
			if(size()<str.size())
				return false;
			if(str._in_chr_cso())
				return starts_with(str._cso_info._ch);
			else
				return substr(0,str.size()) == str;
		}
		constexpr bool starts_with(char_T ch)const noexcept{
			if(size()<1)
				return false;
			return operator[](0) == ch;
		}
		constexpr bool starts_with(const_string_ptr_t str)const noexcept{
			return starts_with(string_view_t{str});
		}

		//ends_with
		constexpr bool ends_with(string_view_t str)const noexcept{
			if(size()<str.size())
				return false;
			return substr(size()-str.size()) == str;
		}
		constexpr bool ends_with(constexpr_str_t&str)const noexcept{
			if(size()<str.size())
				return false;
			return substr(size()-str.size()) == str;
		}
		constexpr bool ends_with(const string_t&str)const noexcept{
			if(size()<str.size())
				return false;
			if(str._in_chr_cso())
				return ends_with(str._cso_info._ch);
			else
				return substr(size()-str.size()) == str;
		}
		constexpr bool ends_with(char_T ch)const noexcept{
			if(size()<1)
				return false;
			return operator[](size()-1) == ch;
		}
		constexpr bool ends_with(char_T ch,size_t count)const noexcept{
			if(size() < count)
				return false;
			return find_last_not_of(ch) <= size()-count;
		}
		constexpr bool ends_with(const_string_ptr_t str)const noexcept{
			return ends_with(string_view_t{str});
		}

		this_t& append(size_t size,char_T ch)noexcept{
			return *this+=string_t{size,ch};
		}

		//pre_allocate
		void pre_alloc_before_begin(size_t size)noexcept{
			_cso_check();
			_m=_m->pre_alloc_before_begin(size);
		}
		void pre_alloc_after_end(size_t size)noexcept{
			_cso_check();
			_m=_m->pre_alloc_after_end(size);
		}

		/*
		compare
		replace
		*/

		//iostream
		template<class text_ostream_T> requires(type_info<text_ostream_T>.base_on<text_ostream<char_T>>)
		friend auto& operator<<(text_ostream_T& os,const string_t& str)noexcept(type_info<text_ostream_T>.base_on<noexcept_text_ostream<char_T>>){
			if(str._in_cso())
				os<<str.to_string_view_t();
			else{
				push_and_disable_msvc_warning(26447);//nothrow警告diss
				str._m->do_output(os);
				pop_msvc_warning();
			}
			return os;
		}
		template<class text_istream_T> requires(type_info<text_istream_T>.base_on<text_istream<char_T>>)
		friend auto& operator>>(text_istream_T& is,string_t& str)noexcept(type_info<text_istream_T>.base_on<noexcept_text_istream<char_T>>){
			str.clear();
			using namespace locale::char_n;
			while(isspace(is.peek()))
				is.get();
			while(!is.eof()&&!isspace(is.peek()))
				str+=is.get();
		}
		#undef _m
	};

	//推导指引
	template<class char_T>
	string_t(const char_T*) -> string_t<char_T>;
	template<class char_T>
	string_t(char_T*) -> string_t<char_T>;

	//string的swap特化
	template<typename T>
	inline void swap(string_t<T>& a,string_t<T>& b)noexcept{ a.swap_with(b); }

	//other iostream
	template<typename char_T,typename traits>
	inline auto& operator<<(::std::basic_ostream<char_T,traits>& os,const string_t<char_T>& str)noexcept{
		typedef ::std::basic_ostream<char_T,traits> stream_t;
		typedef stream_t::traits_type	 traits_t;
		typename stream_t::iostate		 state = stream_t::goodbit;

		size_t size = str.size();
		suppress_msvc_warning(26494);//未初始化警告diss
		size_t pad;
		if(os.width() <= 0 || static_cast<size_t>(os.width()) <= size)
			pad = 0;
		else
			pad = static_cast<size_t>(os.width()) - size;

		const typename stream_t::sentry isok(os);

		if(!isok)
			state |= stream_t::badbit;
		else {
			try {
				if((os.flags() & stream_t::adjustfield) != stream_t::left){
					for(; 0 < pad; --pad){// pad on left
						if(traits_t::eq_int_type(traits_t::eof(), os.rdbuf()->sputc(os.fill()))){
							state |= stream_t::badbit;// insertion failed, quit
							break;
						}
					}
				}
				if(state == stream_t::goodbit){
					stream_n::std_ostream_wrap wrap(os);
					wrap<<str;
				}
				if(os.fail())
					state |= stream_t::badbit;
				else{
					for(; 0 < pad; --pad){// pad on right
						if(traits_t::eq_int_type(traits_t::eof(), os.rdbuf()->sputc(os.fill()))){
							state |= stream_t::badbit;// insertion failed, quit
							break;
						}
					}
				}
				os.width(0);
			}
			catch(...){
				os.setstate(stream_t::badbit, true);
				return os;
			}
		}
		os.setstate(state);
		return os;
	}
	template<typename char_T,typename traits>
	inline auto& operator>>(::std::basic_istream<char_T,traits>& is,string_t<char_T>& str)noexcept{
		stream_n::std_istream_wrap wrap{is};
		wrap>>str;
		return is;
	}

	//array like支持
	template<class T>
	[[nodiscard]]inline auto size_of_array_like(const string_t<remove_cv<T>>& a)noexcept{ return a.size(); }
	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(string_t<remove_cv<T>>& a)noexcept{ return a.c_str(); }
	template<class T>
	[[nodiscard]]inline auto begin_of_array_like(const string_t<remove_cv<T>>& a)noexcept{ return a.c_str(); }

	//typedef
	typedef string_t<char_t>string;
}
using string_n::string_t;
using string_n::string;

//file_end

	#line 15 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 17 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
}
//strings
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/str_code_convert.hpp"
//str_code_convert.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
/*
APIs说明
elc依赖的基础函数.
调整这些,实现快速移植,快速优化与行为自定义.
*/
#if !defined(ELC_APIS_str_code_convert)
	#define ELC_APIS_str_code_convert
	#include <cuchar>
	#include <clocale>
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/default_data_type.hpp"
//default_data_type.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace elc{
	/*ELC内部string统一采用char_t宽字符，使用setlocale(LC_ALL,"en_US.utf8")下的UTF编码。*/
	typedef char32_t char_t;
	/*c_string表示*/
	typedef char_t* string_ptr_t;
	/*c_string表示*/
	typedef const char_t* const_string_ptr_t;
	/*ELC内部钦定int_t类型*/
	typedef int64_t int_t;
	/*ELC内部钦定uint_t类型*/
	typedef uint64_t uint_t;
	/*ELC内部钦定float_t类型*/
	typedef double float_t;
	/*ELC内部钦定float_size_t类型，用以描述内存大小的浮点状况*/
	typedef long double float_size_t;
}

//file_end

	#line 17 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/str_code_convert.hpp"
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
//string
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/pre_checks.hpp"
//pre_checks.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
//__cplusplus needs 20+
#if !defined(__cplusplus)||__cplusplus<202002L
	//if msvc, check _MSVC_LANG
	#if defined(_MSVC_LANG) && _MSVC_LANG>=202002L
		//ok
	#else
		#error "elc files needs c++20 or higher"
	#endif
#endif

//check if the compiler is msvc
#if defined(_MSC_VER)
	//check if _CPPRTTI
	#if !defined(_CPPRTTI)
		#error "elc files needs rtti"
	#endif
	//check _MSC_VER at last 1932
	#if _MSC_VER<1932
		#error "elc files needs at last msvc 19.32 or higher, keep moving!"
	#endif
#endif

//file_end

#line 9 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
#line 15 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"

//file_end

	#line 18 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/str_code_convert.hpp"
	namespace elc::APIs::str_code_convert{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

		#line 20 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/str_code_convert.hpp"

		using namespace ::elc::defs;//get def

		[[nodiscard]]inline string_t<char> to_char_str(string_view_t<char_t> a)noexcept{
			string_t<char>aret;
			::std::mbstate_t stat{};
			push_and_disable_msvc_warning(26494)//未初始化警告diss
			char r[MB_LEN_MAX];
			ptrdiff_t s;
			pop_msvc_warning();
			for(auto c:a){
				s=::std::c32rtomb(r,c,&stat);
				if(s < 0)//-1
					die_with(locale::str::code_convert_error);
				aret+=string_view_t<char>{(char*)r,note::size((size_t)s)};
			}
			return aret;
		}
		[[nodiscard]]inline string_t<char_t> to_char_t_str(string_view_t<char> a)noexcept{
			string_t<char_t>aret;
			::std::mbstate_t stat{};
			push_and_disable_msvc_warning(26494);//未初始化警告diss
			char_t c;
			ptrdiff_t s;
			pop_msvc_warning();
			auto i=a.cbegin(),e=a.cend();
			while(i!=e){
				s=::std::mbrtoc32(&c,i,MB_LEN_MAX,&stat);
				if(s < 0)//-3 或 -1
					die_with(locale::str::code_convert_error);
				i+=s;
				aret+=c;
			}
			return aret;
		}

		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

		#line 57 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/APIs/str_code_convert.hpp"
	}
	namespace elc::defs{
		using namespace elc::APIs::str_code_convert;
	}
#endif

//file_end

#line 19 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 21 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/literal.hpp"
//literal.hpp
//at namespace elc::defs
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace string_n{
	template<constexpr_str_n::constexpr_str_t_literal_helper str_helper>
	inline constexpr string operator""_elc_string()noexcept{
		return string(constexpr_str_n::operator""_constexpr_str<str_helper>());
	}
}
using string_n::operator""_elc_string;

//file_end

	#line 23 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"

	#if defined(ELC_TEST_ON)
	namespace string_part_test{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_test.hpp"
//_test.hpp
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline void test(){
	ELC_TEST_EVENTNAME("string部分测试");
	{
		{
			string_t a=es"";
			stest_accert(a.size()==0);
			a=es"asd";
			stest_accert(a.size()==3);
			a=es"asd"+a;
			stest_accert(a.size()==6);
			a+=es"asd";
			stest_accert(es"asd"+a==es"asdasdasdasd");
			a[1]=ec('e');
			stest_accert(a.substr(0,3)==es"aed");
			stest_accert(a.substr(3).size()==6);
			stest_accert(a[2]==ec('d'));
			a.clear();
			stest_accert(a.size()==0);
			a.resize(3,ec('d'));
			stest_accert(a==es"ddd");
			for(const char_t&c:a)
				stest_accert(c==ec('d'));
			a=es"abc";
			stest_accert(a.begin()==a.cbegin());
			stest_accert(*a.begin()==ec('a'));
			stest_accert(a.begin()<=a.cend());
			stest_accert(*a.rbegin()==ec('c'));
			stest_accert(a.rbegin()<=a.rend());
			stest_accert(a.rbegin()==a.end()-1);
			a.push_back(es"as");
			a.push_front(ec('p'));
			stest_accert(a == es"pabcas");
			a.erase(1,3);
			a.erase(1);
			stest_accert(a == es"ps");
			stest_accert(a.pop_front() == ec('p'));
			stest_accert(a.pop_back() == ec('s'));
			stest_accert(a.size() == 0);
			a=es"abc";
			stest_accert(a.pop_back(2) == es"bc");
			stest_accert(a.size() == 1);
			a.push_front(es"wqer");
			stest_accert(a==es"wqera");
			a.insert(2,es"123");
			a.insert(0,es"123");
			a.insert(a.size(),es"123");
			stest_accert(a[2] == ec('3'));
			a[5]=ec('6');
			a[6]=ec('6');
			a[7]=ec('6');
			a[8]=ec('6');
			stest_accert(a == es"123wq6666ra123");
			for(char_t& c: a.view())
				c ='7';
			stest_accert(a == es"77777777777777");
		}
		{
			using namespace elc;
			using elc::defs::hash;
			auto a = es"ab"_elc_string;//constexpr_string_data_t
			stest_accert(hash(a) == hash(string_view(es"ab")));
			string b = es"ab";//comn_string_data_t
			stest_accert(hash(b) == hash(string_view(es"ab")));
			stest_accert(b.memory_cost() > a.memory_cost());
			a += b;//sum_string_data_t -> constexpr_string_data_t
				   //				   -> comn_string_data_t
			stest_accert(hash(a) == hash(string_view(es"abab")));
			a.insert(1, 'c');//inserted_string_data_t -> sum_string_data_t
			stest_accert(hash(a) == hash(string_view(es"acbab")));
			a.erase(2, 3);//erased_string_data_t -> inserted_string_data_t
			stest_accert(hash(a) == hash(string_view(es"ac")));
			a.push_back(es"123");//end_apply_string_data_t -> erased_string_data_t
			stest_accert(hash(a) == hash(string_view(es"ac123")));
			a.push_front(es"123");//head_apply_string_data_t -> end_apply_string_data_t
			stest_accert(hash(a) == hash(string_view(es"123ac123")));
		}
	}
	check_memory_lack();
}
inline void test_log_out(){
}
inline void test_end(){
}

//file_end

		#line 27 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
	}
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 31 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
}
namespace elc{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_export.hpp"
//_export.hpp
//at namespace elc
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using defs::
export string_t;
export string;
export string_view_t;
export string_view;
export operator""_elc_string;
export operator""_constexpr_str;
#undef export

//file_end

	#line 34 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
}
#if defined(ELC_BASE_STREAM)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"
//type_name_test_output.hpp
//at namespace ::
//multi when ELC_STRING & ELC_BASE_STREAM
/*
未完成的elc解释器base_stream文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if !defined(ELC_multi_type_name_test_output)//pls skip define check as this part is muti
#define ELC_multi_type_name_test_output
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"

	namespace stream_n{
		//typename output only for text_ostream<char_t>
		template<class stream_T> requires(type_info<stream_T>.base_on<text_ostream<char_t>>)
		decltype(auto)operator<<(stream_T&&stream,const type_name_t&name)noexcept(type_info<stream_T>.base_on<noexcept_text_ostream<char_t>>){
			return stream << to_char_t_str(name);
		}
		//output type_info
		template<class stream_T> requires(type_info<stream_T>.base_on<text_ostream<char_t>>)
		decltype(auto)operator<<(stream_T&&stream,const base_type_info_t&info)noexcept(type_info<stream_T>.base_on<noexcept_text_ostream<char_t>>){
			return stream << info.get_name();
		}
		//output ::std::type_info
		template<class stream_T> requires(type_info<stream_T>.base_on<text_ostream<char_t>>)
		decltype(auto)operator<<(stream_T&&stream,const ::std::type_info&info)noexcept(type_info<stream_T>.base_on<noexcept_text_ostream<char_t>>){
			return stream << type_name_t{info.name()};
		}
	}

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 33 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/type_name_test_output.hpp"
}
#endif

//file_end

	#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
#endif
#if defined(ELC_CORE)
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"
//string_arec_as_value.hpp
//at namespace ::
//multi when ELC_STRING & ELC_CORE
/*
未完成的elc解释器string文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if !defined(ELC_multi_string_arec_as_value)//pls skip define check as this part is muti
#define ELC_multi_string_arec_as_value
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"

	namespace string_n{
		template<class char_T>
		value arec_as_value(string_t<char_T>&str,const value index){
			size_t i=size_t(use_as<int_t>(index));
			if(!i)
				i=size_t(use_as<uint_t>(index));
			struct arec_data_t final:instance_struct<arec_data_t>
			,value::base_data_t{
				typename string_t<char_T>::arec_t _m;
				arec_data_t(string_t<char_T>&str,size_t index)noexcept:_m(&str,index){};
				arec_data_t(const arec_data_t&ref)noexcept:_m(special_init,ref._m){}
				virtual ~arec_data_t()noexcept override final=default;

				virtual void be_set(ptr a)noexcept override final{move(_m)=use_as<char_T>(a);}
				[[nodiscard]]virtual ptr get_value()noexcept override final{return core::make_binary_node_from<char_T>(move(_m));}
				[[nodiscard]]virtual base_data_t*copy()const noexcept override final{return get<arec_data_t>(*this);}
				[[nodiscard]]virtual base_type_info_t get_type_info()const noexcept override final{return type_info<arec_data_t>;}
			};
			return get<arec_data_t>(str,i);
		}
	}

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 37 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_multi/string_arec_as_value.hpp"
}
#endif

//file_end

	#line 40 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/string/_body.hpp"
#endif

//file_end

	#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/string"
#endif

//file_end

	#line 12 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/namespace"
	#define ELC_NAMESPACE
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_body.hpp"
//_body.hpp
//at namespace ::
/*
未完成的elc解释器namespace文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if defined(ELC_TEST)
	#error "this part cannot be tested."
#endif
namespace elc::defs{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"
//_defs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//undefs at "_undefs.hpp"

//set ELC_WARNING_LEVEL default to 4(max)
#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(push,ELC_WARNING_LEVEL)
	#pragma warning(disable:4099)//class与struct混用警告diss
	#pragma warning(disable:4584)//重复子类警告diss
	#pragma warning(disable:4250)//域控制继承警告diss
	#pragma warning(disable:26432)//不完全默认方法警告diss
	#pragma warning(disable:26435)//virtual override方法警告diss
	#pragma warning(disable:26481)//容器安利diss
	#pragma warning(disable:26446)//gsl::at安利diss
	#pragma warning(disable:26434)//方法覆盖警告diss
	#pragma warning(disable:26429)//gsl::not_null安利diss
	#pragma warning(disable:26471)//对void*进行static_cast安利diss
	#pragma warning(disable:26474)//隐式指针转换显式cast警告diss
	#pragma warning(disable:26473)//相同指针显式cast警告diss
	#pragma warning(disable:26456)//隐藏非虚运算符警告diss
	#pragma warning(disable:26485)//数组作指针警告diss
	#pragma warning(disable:26490)//reinterpret_cast警告diss
	#pragma warning(disable:26472)//static_cast窄幅转换警告diss
	#pragma warning(disable:26482)//非常数数组索引警告diss
	#pragma warning(disable:26493)//c_cast转换警告diss：虽然有用但是太烦了，爬
#endif
#if defined(_MSC_VER)
	#define suppress_msvc_warning(...) __pragma(warning(suppress:__VA_ARGS__))
	#define disable_msvc_warning(...) __pragma(warning(disable:__VA_ARGS__))
	#define push_msvc_warning() __pragma(warning(push))
	#define pop_msvc_warning() __pragma(warning(pop))
	#define push_and_disable_msvc_warning(...) push_msvc_warning() disable_msvc_warning(__VA_ARGS__)
#else
	#define suppress_msvc_warning(...)
	#define disable_msvc_warning(...)
	#define push_msvc_warning()
	#define pop_msvc_warning()
	#define push_and_disable_msvc_warning(...)
#endif
#if defined(_MSC_VER)
	//push pack settings
	#pragma pack(push)
	#pragma pack()
#endif
#if defined(_MSC_VER)
	//push and undef common macros
	#pragma push_macro("new")
	#undef new
	#pragma push_macro("delete")
	#undef delete
	#pragma push_macro("min")
	#undef min
	#pragma push_macro("max")
	#undef max
	#pragma push_macro("abs")
	#undef abs
	#pragma push_macro("export")
	#undef export
	#pragma push_macro("rand")
	#undef rand
	#pragma push_macro("sqrt")
	#undef sqrt
	#pragma push_macro("elc")
	#undef elc
#endif
//
#if defined(ELC_VOID_NAME)
	#undef void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#undef rand
#endif

// #define often_noexcept
#define noexcept_as(...) noexcept(noexcept((__VA_ARGS__)))//dnmd C艹标准就是没有noexcept_as_auto
#define noexcept_as_auto MAGIC//哦现在有了
#define constexpr_as(...) MAGIC constexpr//( •̀ ω •́ )✌
#define constexpr_as_auto MAGIC MAGIC constexpr//✌( •̀ ω •́ )✌

#define using_method_from_base_t(name,...) \
template<class...Args> requires was_not_an_ill_form(declvalue(base_t).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(base_t::name(declvalue(Args)...))\
{\
	return base_t::name(forward<Args>(rest)...);\
}\

#define using_method_from_value(name,value_name,...) \
template<class...Args> requires was_not_an_ill_form(re_declvalue(value_name).name(declvalue(Args)...))\
auto name(Args&&...rest)__VA_ARGS__ noexcept_as(re_declvalue(value_name).name(declvalue(Args)...))\
{\
	return value_name.name(forward<Args>(rest)...);\
}\

#define floop while(__builtin_is_my_dick_still_there())
#if defined(_MSC_VER) && _MSC_VER==1935
	//https://developercommunity.visualstudio.com/t/10193638
	#define enable_adl(name) template<typename=void>void name()noexcept=delete
#else
	#define enable_adl(name) void name()noexcept=delete
#endif

#define re_declvalue(...) (declvalue(decltype(__VA_ARGS__)))
#define re_decltype(...) (decltype(declvalue(__VA_ARGS__)))

#define declvalue(...) (::std::declval<__VA_ARGS__>())

/*! 实例化到此将引发错误 */
#define template_error(reason) static_assert(template_error_helper<T>,reason)
/*! 实例化到此将引发警告 */
#define template_warning(reason) template_warning_helper<T>(reason)

//for type_info
#define type_info_of(...) base_type_info_t(typeid(__VA_ARGS__))
#define type_name_of(...) (type_info_of(__VA_ARGS__).get_name())

#define is_common_attribute(name) public attribute<T,name<T>>
#define is_special_attribute(name) public attribute<T,name>

#define has_attribute(...) template_name has_attribute_helper<__VA_ARGS__>()
#define not_has_attribute(...) template_name not_has_has_attribute_helper<__VA_ARGS__>()

//for float_size_t
#define float_size_of(...) (float_size_t{sizeof(__VA_ARGS__)})
//bitnum_of
#define bitnum_of(...) (sizeof(__VA_ARGS__)*CHAR_BIT)

//for attribute
#define def_common_attribute_with_nothing(name) \
template<typename T>\
class name{}\

#define def_special_attribute_with_nothing(name) \
class name{}\

#define common_attribute_t template<class>class
#define special_attribute_t class

/*!
若参数的布尔值为零，那么此模板不会实例化

为什么不用cpp20的constraints？
1.不能类内定义
2.不能作为模板参数
一句话总结：c艹标准会sb
*/
#define enable_if(...) class enable_state= ::std::enable_if_t<__VA_ARGS__>
/*! 默认参与模板候选 */
#define enabled_by_default class enable_state=void
/*! 默认不参与模板候选 */
#define disabled_by_default class enable_state= ::std::enable_if_t<false>
/*! 若参数为病式，那么此模板不会实例化 */
#define enable_if_not_ill_form(...) class enable_state= ::std::void_t<decltype(__VA_ARGS__)>
/*!用于模板声明 */
#define enable_flag class enable_state

#define was_an_ill_form(...) (!was_not_an_ill_form(__VA_ARGS__))
#define was_an_ill_form_with_parameter(...) (!was_not_an_ill_form_with_parameter(__VA_ARGS__))
#define was_not_an_ill_form(...) (bool(requires{__VA_ARGS__;}))
#define was_not_an_ill_form_and_noexcept(...) (bool(requires{__VA_ARGS__;{__VA_ARGS__}noexcept;}))
#define was_not_an_ill_form_with_parameter(...) (bool(requires __VA_ARGS__ ))

/*! 让lambda递归更加美观 */
#define recursive_lambda(...) lambda(auto&&lambda_RLSRRS,__VA_ARGS__)
/*! 让lambda递归更加美观 */
#define get_recursive_lambda_caller(name) \
lambda_with_catch(&)(auto&&...Args){\
	return name(name,Args...);\
}
/*! 让lambda定义更加美观 */
#define lambda []
/*! 让lambda定义更加美观 */
#define lambda_with_catch(...) [__VA_ARGS__]
/*! 让lambda定义更加美观 */
#define self_recursion(...) lambda_RLSRRS(lambda_RLSRRS,__VA_ARGS__)
//recursive_lambda_self_referential_reserved_symbolname
#define lambda_RLSRRS _my_jb_super_sb_name_

#define MAGIC//ahh,ko no tenno da!

/*! 装饰性语法糖 */
#define nothing

/*! aya风格语法糖 */
#define elseif else if
/*! aya风格语法糖 */
#define _big_than_ >
/*! aya风格语法糖 */
#define _small_than_ <

#if defined(_MSC_VER)
	#define not !
	#define and &&
	#define or ||
#endif

/*! 进入名称空间，并不是很美观 */
#define INTER_NAMESPACE(NAMESPACENAME) namespace NAMESPACENAME{
/*! 退出名称空间，并不是很美观 */
#define BREAK_NAMESPACE }

/*! template说明符 */
#define template_name template
/*! template说明符 */
#define type_name class

#if defined(DEBUG) || defined(_DEBUG)
	#define not_in_debug 0
#else
	#define not_in_debug 1
#endif

#define es U""
#define ec(ch) U ## ch

#if defined(ELC_TEST_ON)||defined(ELC_TEST_CHECK_MEMORY_LACK)
	#define ELC_TEST_EVENTNAME(name) stest_eventer _the_stest_eventer__(L""name)
#else
	#define ELC_TEST_EVENTNAME(name)
#endif

#define override_instance_struct \
protected:\
	virtual void abstract_method_unget_this()noexcept_as(instance_struct<this_t>::abstract_method_unget_this())override{instance_struct<this_t>::abstract_method_unget_this();}\
	virtual void* _abstract_method_copy_get_this()noexcept_as(instance_struct<this_t>::_abstract_method_copy_get_this())override{return instance_struct<this_t>::_abstract_method_copy_get_this();}\
	virtual void* _abstract_method_get_resize_this(size_t size)noexcept_as(instance_struct<this_t>::instance_struct<this_t>::_abstract_method_get_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_resize_this(size);}\
	virtual void* _abstract_method_get_forward_resize_this(size_t size)noexcept_as(instance_struct<this_t>::_abstract_method_get_forward_resize_this(size))override{return instance_struct<this_t>::_abstract_method_get_forward_resize_this(size);}\
	virtual size_t abstract_method_get_size_of_get_for_this()noexcept override{return instance_struct<this_t>::abstract_method_get_size_of_get_for_this();}

#if defined(_MSC_VER) && !defined(__clang__)
	#define distinctive __declspec(dllexport)
#else
	#define distinctive
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define force_inline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define force_inline __attribute__((always_inline)) inline
#else
	#define force_inline inline
#endif

#if defined(_MSC_VER) && !defined(__clang__)
	#define with_no_vtable __declspec(novtable)
#else
	#define with_no_vtable
#endif

#define in_consteval (::std::is_constant_evaluated())

#define no_vtable_struct struct with_no_vtable
#define no_vtable_class class with_no_vtable

//#define get_elc_defs using namespace ::elc::defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_defs.hpp"

//file_end

	#line 13 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_body.hpp"

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/defs.hpp"
//defs.hpp
/*
未完成的elc解释器namespace文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
namespace core{
	template<>
	distinctive inline map_t<ptr,string> long_term_binary_node_storager<string>{};
}
namespace namespace_n{
	distinctive inline struct namespace_t{
		ptr _namespace_root;
		weak_ptr _namespace_now;
		value get_symbol_type_map(ptr thenamespace){
			return (*thenamespace)[es".symbol_type_map"];
		}
		namespace_t()noexcept{
			_namespace_root = get<common_node>();
			auto&nmsp		= *_namespace_root;
			_namespace_now  = &nmsp;
			push_and_disable_msvc_warning(26447);//may throw警告diss
			nmsp[es".."]	 = the_void;
			nmsp[es"."]		 = nmsp;
			nmsp[es"t"]		 = t;
			nmsp[es"nil"]	 = nil;
			nmsp[es"void"]	 = the_void;
			value nmsptm	 = get_symbol_type_map(&nmsp);
			nmsptm			 = get<common_node>();
			nmsptm[es"void"] = es"void";
			pop_msvc_warning();
		}
		ptr get_symbol_namespace(const value index){
			ptr namespace_now_p = _namespace_now;
			while(namespace_now_p && !(*namespace_now_p)[index] && !get_symbol_type_map(namespace_now_p)[index])
				namespace_now_p = (*namespace_now_p)[es".."];
			return namespace_now_p;
		}
		ptr get_symbol_namespace(auto&& index){ return get_symbol_namespace(as_value(index)); }
		bool has_symbol(const value index){
			auto nmsp=get_symbol_namespace(index);
			if((*nmsp)[index] || get_symbol_type_map(nmsp)[index])
				return true;
			return false;
		}
		bool has_symbol(auto&& index){ return has_symbol(as_value(index)); }
		value get_symbol(const value index){
			return (*get_symbol_namespace(index))[index];
		}
		value get_symbol(auto&& index){ return get_symbol(as_value(index)); }
		value get_symbol_type(const value index){
			return get_symbol_type_map(get_symbol_namespace(index))[index];
		}
		value get_symbol_type(auto&& index){ return get_symbol_type(as_value(index)); }

		void inter_namespace(const value namespace_name){
			_namespace_now = get_symbol(namespace_name);
		}
		void inter_namespace(auto&& index){ inter_namespace(as_value(index)); }

		void leave_namespace(){ inter_namespace(es".."); }
	}names{};
}

//file_end

	#line 15 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_body.hpp"

	#if defined(ELC_TEST_ON)
	namespace namespace_part_test{
		#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_test.hpp"
//_test.hpp
/*
未完成的elc解释器namespace文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
inline void test(){
	ELC_TEST_EVENTNAME("namespace部分测试");
}
inline void test_log_out(){
}
inline void test_end{
}

//file_end

		#line 19 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_body.hpp"
	}
	#endif

	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器basic文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/../../../_share/_undefs.hpp"
//_undefs.hpp
/*
未完成的elc解释器_share文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/

//defs at "_defs.hpp"

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif
#undef suppress_msvc_warning
#undef disable_msvc_warning
#undef push_msvc_warning
#undef pop_msvc_warning
#undef push_and_disable_msvc_warning
#if defined(_MSC_VER)
	#pragma pack(pop)
#endif
#if defined(_MSC_VER)
	#pragma pop_macro("new")
	#pragma pop_macro("delete")
	#pragma pop_macro("min")
	#pragma pop_macro("max")
	#pragma pop_macro("abs")
	#pragma pop_macro("export")
	#pragma pop_macro("rand")
	#pragma pop_macro("sqrt")
	#pragma pop_macro("elc")
#endif

//
#if defined(ELC_VOID_NAME)
	#define void the_void
#endif
//
#if defined(ELC_RESOLVE_GLOBAL_NAME_CONFLICTS)
	#define rand the_rand
#endif

// #undef often_noexcept
#undef noexcept_as
#undef noexcept_as_auto
#undef constexpr_as
#undef constexpr_as_auto

#undef using_method_from_base_t
#undef using_method_from_value

#undef floop
#undef enable_adl

#undef re_declvalue
#undef re_decltype

#undef declvalue

#undef template_error
#undef template_warning

#undef type_info_of
#undef type_name_of

#undef is_common_attribute
#undef is_special_attribute

#undef has_attribute
#undef not_has_attribute

#undef float_size_of
#undef bitnum_of

#undef def_common_attribute_with_nothing
#undef def_special_attribute_with_nothing

#undef common_attribute_t
#undef special_attribute_t

#undef enable_if
#undef enabled_by_default
#undef disabled_by_default
#undef enable_if_not_ill_form
#undef enable_flag

#undef was_an_ill_form
#undef was_an_ill_form_with_parameter
#undef was_not_an_ill_form
#undef was_not_an_ill_form_and_noexcept
#undef was_not_an_ill_form_with_parameter

#undef recursive_lambda
#undef get_recursive_lambda_caller
#undef lambda
#undef lambda_with_catch
#undef self_recursion
#undef lambda_RLSRRS

#undef MAGIC

#undef nothing

#undef elseif
#undef _big_than_
#undef _small_than_

#if defined(_MSC_VER)
	#undef not
	#undef and
	#undef or
#endif

#undef INTER_NAMESPACE
#undef BREAK_NAMESPACE

#undef szie
#undef form

#undef template_name
#undef type_name

#undef not_in_debug

#undef es
#undef ec

#undef ELC_TEST_EVENTNAME

#undef override_instance_struct

#undef distinctive

#undef force_inline

#undef with_no_vtable

#undef in_consteval

#undef no_vtable_struct
#undef no_vtable_class

//#undef get_elc_defs

//file_end

#line 8 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/_share/_undefs.hpp"

//file_end

	#line 23 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_body.hpp"
}
namespace elc{
	#line 1 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_export.hpp"
//_export.hpp
//at namespace elc
/*
未完成的elc解释器namespace文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#define export using defs::
export namespace_n::names;
#undef export

//file_end

	#line 26 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/_files/namespace/_body.hpp"
}

//file_end

	#line 14 "https://github.com/ELC-lang/ELC/tree/master/parts/header_file/files/elc/namespace"
#endif

//file_end

